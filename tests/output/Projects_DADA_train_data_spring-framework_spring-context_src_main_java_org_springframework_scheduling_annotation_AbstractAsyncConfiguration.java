<METHOD_START> @ java.lang.Override public void void ( AnnotationMetadata org.springframework.scheduling.annotation.AnnotationMetadata ) { this . org.springframework.scheduling.annotation.AnnotationAttributes = AnnotationAttributes . fromMap ( org.springframework.scheduling.annotation.AnnotationMetadata . getAnnotationAttributes ( EnableAsync .class . java.lang.String ( ) , false ) ) ; if ( this . org.springframework.scheduling.annotation.AnnotationAttributes == null ) { throw new java.lang.IllegalArgumentException ( STRING + org.springframework.scheduling.annotation.AnnotationMetadata . getClassName ( ) ) ; } }  <METHOD_END>
<METHOD_START> @ Autowired ( required = false ) void void ( java.util.Collection<org.springframework.scheduling.annotation.AsyncConfigurer> < AsyncConfigurer > java.util.Collection<org.springframework.scheduling.annotation.AsyncConfigurer> ) { if ( CollectionUtils . isEmpty ( java.util.Collection<org.springframework.scheduling.annotation.AsyncConfigurer> ) ) { return; } if ( java.util.Collection<org.springframework.scheduling.annotation.AsyncConfigurer> . size ( ) > NUMBER ) { throw new java.lang.IllegalStateException ( STRING ) ; } AsyncConfigurer org.springframework.scheduling.annotation.AsyncConfigurer = java.util.Collection<org.springframework.scheduling.annotation.AsyncConfigurer> . iterator ( ) . next ( ) ; this . java.util.concurrent.Executor = org.springframework.scheduling.annotation.AsyncConfigurer . getAsyncExecutor ( ) ; this . org.springframework.scheduling.annotation.AsyncUncaughtExceptionHandler = org.springframework.scheduling.annotation.AsyncConfigurer . getAsyncUncaughtExceptionHandler ( ) ; }  <METHOD_END>
