<METHOD_START> public void ( MappingContext < ? extends PersistentEntity < ? , ? > , ? > org.springframework.data.convert.MappingContext<? extends org.springframework.data.convert.PersistentEntity<?,?>,?> ) { Assert . notNull ( org.springframework.data.convert.MappingContext<,> , STRING ) ; this . java.util.Map<org.springframework.data.convert.ClassTypeInformation<?>,org.springframework.data.convert.Alias> = new java.util.concurrent.ConcurrentHashMap <> ( ) ; this . org.springframework.data.convert.MappingContext<? extends org.springframework.data.convert.PersistentEntity<?,?>,?> = org.springframework.data.convert.MappingContext<,> ; for ( PersistentEntity < ? , ? > org.springframework.data.convert.PersistentEntity<?,?> : org.springframework.data.convert.MappingContext<,> . getPersistentEntities ( ) ) { org.springframework.data.convert.Alias ( org.springframework.data.convert.PersistentEntity<,> . getTypeInformation ( ) . getRawTypeInformation ( ) , org.springframework.data.convert.PersistentEntity<,> . getTypeAlias ( ) ) ; } }  <METHOD_END>
<METHOD_START> public org.springframework.data.convert.Alias org.springframework.data.convert.Alias ( TypeInformation < ? > org.springframework.data.convert.TypeInformation<?> ) { return java.util.Map<org.springframework.data.convert.ClassTypeInformation<?>,org.springframework.data.convert.Alias> . computeIfAbsent ( org.springframework.data.convert.TypeInformation<> . getRawTypeInformation ( ) , key -> verify ( key , mappingContext . getPersistentEntity ( key ) . map ( PersistentEntity :: getTypeAlias ) . orElse ( Alias . NONE ) ) ) ; }  <METHOD_END>
<METHOD_START> private org.springframework.data.convert.Alias org.springframework.data.convert.Alias ( ClassTypeInformation < ? > org.springframework.data.convert.ClassTypeInformation<?> , Alias org.springframework.data.convert.Alias ) { Alias org.springframework.data.convert.Alias = java.util.Map<org.springframework.data.convert.ClassTypeInformation<?>,org.springframework.data.convert.Alias> . getOrDefault ( org.springframework.data.convert.ClassTypeInformation<> , Alias . NONE ) ; if ( org.springframework.data.convert.Alias . isPresentButDifferent ( org.springframework.data.convert.Alias ) ) { throw new java.lang.IllegalArgumentException ( java.lang.String . java.lang.String ( STRING , org.springframework.data.convert.Alias , org.springframework.data.convert.Alias , org.springframework.data.convert.ClassTypeInformation<> ) ) ; } if ( java.util.Map<org.springframework.data.convert.ClassTypeInformation<?>,org.springframework.data.convert.Alias> . containsValue ( org.springframework.data.convert.Alias ) ) { java.util.Map<org.springframework.data.convert.ClassTypeInformation<?>,org.springframework.data.convert.Alias> . entrySet ( ) . stream ( ) . filter ( it -> it . getValue ( ) . hasSamePresentValueAs ( alias ) && ! it . getKey ( ) . equals ( key ) ) . findFirst ( ) . ifPresent ( it -> { throw new IllegalArgumentException ( String . format ( STRING , key , alias , it . getKey ( ) ) ) ; } ) ; } return org.springframework.data.convert.Alias ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.util.Optional<org.springframework.data.convert.TypeInformation<?>> < TypeInformation < ? > > java.util.Optional<org.springframework.data.convert.TypeInformation<?>> ( Alias org.springframework.data.convert.Alias ) { return org.springframework.data.convert.Alias . getValue ( ) . map ( it -> { for ( Entry < ClassTypeInformation < ? > , Alias > entry : typeMap . entrySet ( ) ) { if ( entry . getValue ( ) . hasValue ( it ) ) { return entry . getKey ( ) ; } } for ( PersistentEntity < ? , ? > entity : mappingContext . getPersistentEntities ( ) ) { if ( entity . getTypeAlias ( ) . hasValue ( it ) ) { return entity . getTypeInformation ( ) . getRawTypeInformation ( ) ; } } return null ; } ) ; }  <METHOD_END>
