<METHOD_START> @ Before public void void ( ) { org.springframework.integration.splitter.Message<?> = new GenericMessage < java.lang.String > ( STRING ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { int int = NUMBER ; MethodInvokingSplitter org.springframework.integration.splitter.MethodInvokingSplitter = new MethodInvokingSplitter ( new org.springframework.integration.splitter.StreamingSplitterTests.IteratorTestBean ( int ) ) ; QueueChannel org.springframework.integration.splitter.QueueChannel = new QueueChannel ( ) ; org.springframework.integration.splitter.MethodInvokingSplitter . setOutputChannel ( org.springframework.integration.splitter.QueueChannel ) ; org.springframework.integration.splitter.MethodInvokingSplitter . handleMessage ( org.springframework.integration.splitter.Message<> ) ; java.util.List<org.springframework.integration.splitter.Message<?>> < Message < ? > > java.util.List<org.springframework.integration.splitter.Message<?>> = org.springframework.integration.splitter.QueueChannel . clear ( ) ; java.util.Collections . void ( java.util.List<org.springframework.integration.splitter.Message<?>> , ( o1 , o2 ) -> o1 . getHeaders ( ) . get ( IntegrationMessageHeaderAccessor . SEQUENCE_NUMBER , Integer .class ) . compareTo ( o2 . getHeaders ( ) . get ( IntegrationMessageHeaderAccessor . SEQUENCE_NUMBER , Integer .class ) ) ) ; assertThat ( java.util.List<org.springframework.integration.splitter.Message<?>> . get ( NUMBER ) . getHeaders ( ) . get ( IntegrationMessageHeaderAccessor . SEQUENCE_NUMBER , java.lang.Integer .class ) , is ( int ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.lang.String java.lang.String = STRING ; java.lang.String java.lang.String = STRING ; org.springframework.integration.splitter.Message<?> = MessageBuilder . fromMessage ( org.springframework.integration.splitter.Message<> ) . setHeader ( java.lang.String , java.lang.String ) . build ( ) ; int int = NUMBER ; MethodInvokingSplitter org.springframework.integration.splitter.MethodInvokingSplitter = new MethodInvokingSplitter ( new org.springframework.integration.splitter.StreamingSplitterTests.IteratorTestBean ( int ) ) ; QueueChannel org.springframework.integration.splitter.QueueChannel = new QueueChannel ( ) ; org.springframework.integration.splitter.MethodInvokingSplitter . setOutputChannel ( org.springframework.integration.splitter.QueueChannel ) ; org.springframework.integration.splitter.MethodInvokingSplitter . handleMessage ( org.springframework.integration.splitter.Message<> ) ; java.util.List<org.springframework.integration.splitter.Message<?>> < Message < ? > > java.util.List<org.springframework.integration.splitter.Message<?>> = org.springframework.integration.splitter.QueueChannel . clear ( ) ; assertThat ( java.util.List<org.springframework.integration.splitter.Message<?>> . size ( ) , is ( int ) ) ; for ( Message < ? > org.springframework.integration.splitter.Message<?> : java.util.List<org.springframework.integration.splitter.Message<?>> ) { MessageHeaders org.springframework.integration.splitter.MessageHeaders = org.springframework.integration.splitter.Message<> . getHeaders ( ) ; assertTrue ( STRING + org.springframework.integration.splitter.MessageHeaders , org.springframework.integration.splitter.MessageHeaders . containsKey ( java.lang.String ) ) ; assertThat ( STRING + org.springframework.integration.splitter.MessageHeaders , org.springframework.integration.splitter.MessageHeaders . get ( java.lang.String , java.lang.String .class ) , is ( java.lang.String ) ) ; assertThat ( STRING + org.springframework.integration.splitter.MessageHeaders , org.springframework.integration.splitter.MessageHeaders . get ( IntegrationMessageHeaderAccessor . CORRELATION_ID , java.util.UUID .class ) , is ( org.springframework.integration.splitter.Message<> . getHeaders ( ) . getId ( ) ) ) ; } }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { int int = NUMBER ; MethodInvokingSplitter org.springframework.integration.splitter.MethodInvokingSplitter = new MethodInvokingSplitter ( new org.springframework.integration.splitter.StreamingSplitterTests.IteratorTestBean ( int ) ) ; QueueChannel org.springframework.integration.splitter.QueueChannel = new QueueChannel ( ) ; org.springframework.integration.splitter.MethodInvokingSplitter . setOutputChannel ( org.springframework.integration.splitter.QueueChannel ) ; org.springframework.integration.splitter.MethodInvokingSplitter . handleMessage ( org.springframework.integration.splitter.Message<> ) ; assertThat ( org.springframework.integration.splitter.QueueChannel . getQueueSize ( ) , is ( int ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { int int = NUMBER ; MethodInvokingSplitter org.springframework.integration.splitter.MethodInvokingSplitter = new MethodInvokingSplitter ( new org.springframework.integration.splitter.StreamingSplitterTests.IterableTestBean ( int ) ) ; QueueChannel org.springframework.integration.splitter.QueueChannel = new QueueChannel ( ) ; org.springframework.integration.splitter.MethodInvokingSplitter . setOutputChannel ( org.springframework.integration.splitter.QueueChannel ) ; org.springframework.integration.splitter.MethodInvokingSplitter . handleMessage ( org.springframework.integration.splitter.Message<> ) ; assertThat ( org.springframework.integration.splitter.QueueChannel . getQueueSize ( ) , is ( int ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final int int = NUMBER ; MethodInvokingSplitter org.springframework.integration.splitter.MethodInvokingSplitter = new MethodInvokingSplitter ( new org.springframework.integration.splitter.StreamingSplitterTests.IteratorTestBean ( int ) ) ; DirectChannel org.springframework.integration.splitter.DirectChannel = new DirectChannel ( ) ; org.springframework.integration.splitter.MethodInvokingSplitter . setOutputChannel ( org.springframework.integration.splitter.DirectChannel ) ; new EventDrivenConsumer ( org.springframework.integration.splitter.DirectChannel , message -> assertThat ( STRING + message , message . getHeaders ( ) . get ( IntegrationMessageHeaderAccessor . SEQUENCE_NUMBER , Integer .class ) , is ( Integer . valueOf ( ( String ) message . getPayload ( ) ) ) ) ) . start ( ) ; org.springframework.integration.splitter.MethodInvokingSplitter . handleMessage ( org.springframework.integration.splitter.Message<> ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final int int = NUMBER ; MethodInvokingSplitter org.springframework.integration.splitter.MethodInvokingSplitter = new MethodInvokingSplitter ( new org.springframework.integration.splitter.StreamingSplitterTests.IteratorTestBean ( int ) ) ; DirectChannel org.springframework.integration.splitter.DirectChannel = new DirectChannel ( ) ; org.springframework.integration.splitter.MethodInvokingSplitter . setOutputChannel ( org.springframework.integration.splitter.DirectChannel ) ; final java.util.concurrent.atomic.AtomicInteger java.util.concurrent.atomic.AtomicInteger = new java.util.concurrent.atomic.AtomicInteger ( NUMBER ) ; new EventDrivenConsumer ( org.springframework.integration.splitter.DirectChannel , message -> { assertThat ( STRING + message , message . getPayload ( ) , is ( notNullValue ( ) ) ) ; receivedMessageCounter . incrementAndGet ( ) ; } ) . start ( ) ; org.springframework.integration.splitter.MethodInvokingSplitter . handleMessage ( org.springframework.integration.splitter.Message<> ) ; assertThat ( java.util.concurrent.atomic.AtomicInteger . int ( ) , is ( int ) ) ; }  <METHOD_END>
<METHOD_START> void ( int int ) { this . int = int ; }  <METHOD_END>
<METHOD_START> @ Splitter public java.util.Iterator<java.lang.String> < java.lang.String > java.util.Iterator<java.lang.String> ( java.lang.String java.lang.String ) { return new java.util.Iterator<java.lang.String> < java.lang.String > ( ) { @ java.lang.Override public boolean boolean ( ) { return java.util.concurrent.atomic.AtomicInteger . int ( ) < int ; } @ java.lang.Override public java.lang.String java.lang.String ( ) { if ( ! boolean ( ) ) { throw new java.lang.IllegalStateException ( STRING ) ; } return java.lang.String . java.lang.String ( java.util.concurrent.atomic.AtomicInteger . int ( ) ) ; } @ java.lang.Override public void void ( ) { throw new java.lang.AssertionError ( STRING ) ; } } ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( ) { return java.util.concurrent.atomic.AtomicInteger . int ( ) < int ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.String java.lang.String ( ) { if ( ! boolean ( ) ) { throw new java.lang.IllegalStateException ( STRING ) ; } return java.lang.String . java.lang.String ( java.util.concurrent.atomic.AtomicInteger . int ( ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ) { throw new java.lang.AssertionError ( STRING ) ; }  <METHOD_END>
<METHOD_START> void ( int int ) { this . int = int ; }  <METHOD_END>
<METHOD_START> @ Splitter public java.lang.Iterable<java.lang.String> < java.lang.String > java.lang.Iterable<java.lang.String> ( java.lang.String java.lang.String ) { return new java.lang.Iterable<java.lang.String> < java.lang.String > ( ) { @ java.lang.Override public java.util.Iterator<java.lang.String> < java.lang.String > java.util.Iterator<java.lang.String> ( ) { return new java.util.Iterator<java.lang.String> < java.lang.String > ( ) { @ java.lang.Override public boolean boolean ( ) { return java.util.concurrent.atomic.AtomicInteger . int ( ) < int ; } @ java.lang.Override public java.lang.String java.lang.String ( ) { if ( ! boolean ( ) ) { throw new java.lang.IllegalStateException ( STRING ) ; } return java.lang.String . java.lang.String ( java.util.concurrent.atomic.AtomicInteger . int ( ) ) ; } @ java.lang.Override public void void ( ) { throw new java.lang.AssertionError ( STRING ) ; } } ; } } ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.util.Iterator<java.lang.String> < java.lang.String > java.util.Iterator<java.lang.String> ( ) { return new java.util.Iterator<java.lang.String> < java.lang.String > ( ) { @ java.lang.Override public boolean boolean ( ) { return java.util.concurrent.atomic.AtomicInteger . int ( ) < int ; } @ java.lang.Override public java.lang.String java.lang.String ( ) { if ( ! boolean ( ) ) { throw new java.lang.IllegalStateException ( STRING ) ; } return java.lang.String . java.lang.String ( java.util.concurrent.atomic.AtomicInteger . int ( ) ) ; } @ java.lang.Override public void void ( ) { throw new java.lang.AssertionError ( STRING ) ; } } ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( ) { return java.util.concurrent.atomic.AtomicInteger . int ( ) < int ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.String java.lang.String ( ) { if ( ! boolean ( ) ) { throw new java.lang.IllegalStateException ( STRING ) ; } return java.lang.String . java.lang.String ( java.util.concurrent.atomic.AtomicInteger . int ( ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ) { throw new java.lang.AssertionError ( STRING ) ; }  <METHOD_END>
