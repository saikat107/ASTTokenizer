<METHOD_START> @ java.lang.Override public void void ( StringValueResolver org.springframework.format.support.StringValueResolver ) { this . org.springframework.format.support.StringValueResolver = org.springframework.format.support.StringValueResolver ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( Formatter < ? > org.springframework.format.support.Formatter<?> ) { void ( java.lang.Class<?> ( org.springframework.format.support.Formatter<> ) , org.springframework.format.support.Formatter<> ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( java.lang.Class<?> < ? > java.lang.Class<?> , Formatter < ? > org.springframework.format.support.Formatter<?> ) { addConverter ( new org.springframework.format.support.FormattingConversionService.PrinterConverter ( java.lang.Class<> , org.springframework.format.support.Formatter<> , this ) ) ; addConverter ( new org.springframework.format.support.FormattingConversionService.ParserConverter ( java.lang.Class<> , org.springframework.format.support.Formatter<> , this ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( java.lang.Class<?> < ? > java.lang.Class<?> , Printer < ? > org.springframework.format.support.Printer<?> , Parser < ? > org.springframework.format.support.Parser<?> ) { addConverter ( new org.springframework.format.support.FormattingConversionService.PrinterConverter ( java.lang.Class<> , org.springframework.format.support.Printer<> , this ) ) ; addConverter ( new org.springframework.format.support.FormattingConversionService.ParserConverter ( java.lang.Class<> , org.springframework.format.support.Parser<> , this ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( AnnotationFormatterFactory < ? extends java.lang.annotation.Annotation > org.springframework.format.support.AnnotationFormatterFactory<? extends java.lang.annotation.Annotation> ) { java.lang.Class<? extends java.lang.annotation.Annotation> < ? extends java.lang.annotation.Annotation > java.lang.Class<? extends java.lang.annotation.Annotation> = java.lang.Class<? extends java.lang.annotation.Annotation> ( org.springframework.format.support.AnnotationFormatterFactory<> ) ; if ( this . org.springframework.format.support.StringValueResolver != null && org.springframework.format.support.AnnotationFormatterFactory<> instanceof EmbeddedValueResolverAware ) { ( ( EmbeddedValueResolverAware ) org.springframework.format.support.AnnotationFormatterFactory<> ) . setEmbeddedValueResolver ( this . org.springframework.format.support.StringValueResolver ) ; } java.util.Set<java.lang.Class<?>> < java.lang.Class<?> < ? > > java.util.Set<java.lang.Class<?>> = org.springframework.format.support.AnnotationFormatterFactory<> . getFieldTypes ( ) ; for ( java.lang.Class<?> < ? > java.lang.Class<?> : java.util.Set<java.lang.Class<?>> ) { addConverter ( new org.springframework.format.support.FormattingConversionService.AnnotationPrinterConverter ( java.lang.Class<> , org.springframework.format.support.AnnotationFormatterFactory<> , java.lang.Class<> ) ) ; addConverter ( new org.springframework.format.support.FormattingConversionService.AnnotationParserConverter ( java.lang.Class<> , org.springframework.format.support.AnnotationFormatterFactory<> , java.lang.Class<> ) ) ; } }  <METHOD_END>
<METHOD_START> static java.lang.Class<?> < ? > java.lang.Class<?> ( Formatter < ? > org.springframework.format.support.Formatter<?> ) { java.lang.Class<?> < ? > java.lang.Class<?> = GenericTypeResolver . resolveTypeArgument ( org.springframework.format.support.Formatter<> . getClass ( ) , Formatter .class ) ; if ( java.lang.Class<> == null && org.springframework.format.support.Formatter<> instanceof DecoratingProxy ) { java.lang.Class<?> = GenericTypeResolver . resolveTypeArgument ( ( ( DecoratingProxy ) org.springframework.format.support.Formatter<> ) . getDecoratedClass ( ) , Formatter .class ) ; } if ( java.lang.Class<> == null ) { throw new java.lang.IllegalArgumentException ( STRING + org.springframework.format.support.Formatter<> . getClass ( ) . getName ( ) + STRING ) ; } return java.lang.Class<> ; }  <METHOD_END>
<METHOD_START> @ java.lang.SuppressWarnings ( STRING ) static java.lang.Class<? extends java.lang.annotation.Annotation> < ? extends java.lang.annotation.Annotation > java.lang.Class<? extends java.lang.annotation.Annotation> ( AnnotationFormatterFactory < ? extends java.lang.annotation.Annotation > org.springframework.format.support.AnnotationFormatterFactory<? extends java.lang.annotation.Annotation> ) { java.lang.Class<? extends java.lang.annotation.Annotation> < ? extends java.lang.annotation.Annotation > java.lang.Class<? extends java.lang.annotation.Annotation> = ( java.lang.Class<? extends java.lang.annotation.Annotation> < ? extends java.lang.annotation.Annotation > ) GenericTypeResolver . resolveTypeArgument ( org.springframework.format.support.AnnotationFormatterFactory<> . getClass ( ) , AnnotationFormatterFactory .class ) ; if ( java.lang.Class<> == null ) { throw new java.lang.IllegalArgumentException ( STRING + STRING + org.springframework.format.support.AnnotationFormatterFactory<> . getClass ( ) . getName ( ) + STRING ) ; } return java.lang.Class<> ; }  <METHOD_END>
<METHOD_START> public void ( java.lang.Class<?> < ? > java.lang.Class<?> , Printer < ? > org.springframework.format.support.Printer<?> , ConversionService org.springframework.format.support.ConversionService ) { this . java.lang.Class<?> = java.lang.Class<> ; this . org.springframework.format.support.TypeDescriptor = TypeDescriptor . valueOf ( java.lang.Class<?> ( org.springframework.format.support.Printer<> ) ) ; this . org.springframework.format.support.Printer = org.springframework.format.support.Printer<> ; this . org.springframework.format.support.ConversionService = org.springframework.format.support.ConversionService ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.util.Set<org.springframework.format.support.ConvertiblePair> < ConvertiblePair > java.util.Set<org.springframework.format.support.ConvertiblePair> ( ) { return java.util.Collections . java.util.Set ( new ConvertiblePair ( this . java.lang.Class<> , java.lang.String .class ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override @ java.lang.SuppressWarnings ( STRING ) public java.lang.Object java.lang.Object ( java.lang.Object java.lang.Object , TypeDescriptor org.springframework.format.support.TypeDescriptor , TypeDescriptor org.springframework.format.support.TypeDescriptor ) { if ( java.lang.Object == null ) { return STRING ; } if ( ! org.springframework.format.support.TypeDescriptor . isAssignableTo ( this . org.springframework.format.support.TypeDescriptor ) ) { java.lang.Object = this . org.springframework.format.support.ConversionService . convert ( java.lang.Object , org.springframework.format.support.TypeDescriptor , this . org.springframework.format.support.TypeDescriptor ) ; } return this . org.springframework.format.support.Printer . print ( java.lang.Object , LocaleContextHolder . getLocale ( ) ) ; }  <METHOD_END>
<METHOD_START> private java.lang.Class<?> < ? > java.lang.Class<?> ( Printer < ? > org.springframework.format.support.Printer<?> ) { return GenericTypeResolver . resolveTypeArgument ( org.springframework.format.support.Printer<> . getClass ( ) , Printer .class ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.String java.lang.String ( ) { return ( this . java.lang.Class<> . java.lang.String ( ) + STRING + java.lang.String .class . java.lang.String ( ) + STRING + this . org.springframework.format.support.Printer ) ; }  <METHOD_END>
<METHOD_START> public void ( java.lang.Class<?> < ? > java.lang.Class<?> , Parser < ? > org.springframework.format.support.Parser<?> , ConversionService org.springframework.format.support.ConversionService ) { this . java.lang.Class<?> = java.lang.Class<> ; this . org.springframework.format.support.Parser<?> = org.springframework.format.support.Parser<> ; this . org.springframework.format.support.ConversionService = org.springframework.format.support.ConversionService ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.util.Set<org.springframework.format.support.ConvertiblePair> < ConvertiblePair > java.util.Set<org.springframework.format.support.ConvertiblePair> ( ) { return java.util.Collections . java.util.Set ( new ConvertiblePair ( java.lang.String .class , this . java.lang.Class<> ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.Object java.lang.Object ( java.lang.Object java.lang.Object , TypeDescriptor org.springframework.format.support.TypeDescriptor , TypeDescriptor org.springframework.format.support.TypeDescriptor ) { java.lang.String java.lang.String = ( java.lang.String ) java.lang.Object ; if ( ! StringUtils . hasText ( java.lang.String ) ) { return null ; } java.lang.Object java.lang.Object ; try { java.lang.Object = this . org.springframework.format.support.Parser<> . parse ( java.lang.String , LocaleContextHolder . getLocale ( ) ) ; } catch ( java.lang.IllegalArgumentException java.lang.IllegalArgumentException ) { throw java.lang.IllegalArgumentException ; } catch ( java.lang.Throwable java.lang.Throwable ) { throw new java.lang.IllegalArgumentException ( STRING + java.lang.String + STRING , java.lang.Throwable ) ; } if ( java.lang.Object == null ) { throw new java.lang.IllegalStateException ( STRING + this . org.springframework.format.support.Parser<> ) ; } TypeDescriptor org.springframework.format.support.TypeDescriptor = TypeDescriptor . valueOf ( java.lang.Object . java.lang.Class<? extends java.lang.Object> ( ) ) ; if ( ! org.springframework.format.support.TypeDescriptor . isAssignableTo ( org.springframework.format.support.TypeDescriptor ) ) { java.lang.Object = this . org.springframework.format.support.ConversionService . convert ( java.lang.Object , org.springframework.format.support.TypeDescriptor , org.springframework.format.support.TypeDescriptor ) ; } return java.lang.Object ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.String java.lang.String ( ) { return ( java.lang.String .class . java.lang.String ( ) + STRING + this . java.lang.Class<> . java.lang.String ( ) + STRING + this . org.springframework.format.support.Parser<> ) ; }  <METHOD_END>
<METHOD_START> public void ( java.lang.Class<? extends java.lang.annotation.Annotation> < ? extends java.lang.annotation.Annotation > java.lang.Class<? extends java.lang.annotation.Annotation> , AnnotationFormatterFactory < ? > org.springframework.format.support.AnnotationFormatterFactory<?> , java.lang.Class<?> < ? > java.lang.Class<?> ) { this . java.lang.Class<? extends java.lang.annotation.Annotation> = java.lang.Class<> ; this . org.springframework.format.support.AnnotationFormatterFactory = org.springframework.format.support.AnnotationFormatterFactory<> ; this . java.lang.Class<?> = java.lang.Class<> ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.util.Set<org.springframework.format.support.ConvertiblePair> < ConvertiblePair > java.util.Set<org.springframework.format.support.ConvertiblePair> ( ) { return java.util.Collections . java.util.Set ( new ConvertiblePair ( this . java.lang.Class<> , java.lang.String .class ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( TypeDescriptor org.springframework.format.support.TypeDescriptor , TypeDescriptor org.springframework.format.support.TypeDescriptor ) { return org.springframework.format.support.TypeDescriptor . hasAnnotation ( this . java.lang.Class<> ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override @ java.lang.SuppressWarnings ( STRING ) public java.lang.Object java.lang.Object ( java.lang.Object java.lang.Object , TypeDescriptor org.springframework.format.support.TypeDescriptor , TypeDescriptor org.springframework.format.support.TypeDescriptor ) { java.lang.annotation.Annotation java.lang.annotation.Annotation = org.springframework.format.support.TypeDescriptor . getAnnotation ( this . java.lang.Class<> ) ; if ( java.lang.annotation.Annotation == null ) { throw new java.lang.IllegalStateException ( STRING + this . java.lang.Class<> . java.lang.String ( ) + STRING + org.springframework.format.support.TypeDescriptor ) ; } org.springframework.format.support.FormattingConversionService.AnnotationConverterKey org.springframework.format.support.FormattingConversionService.AnnotationConverterKey = new org.springframework.format.support.FormattingConversionService.AnnotationConverterKey ( java.lang.annotation.Annotation , org.springframework.format.support.TypeDescriptor . getObjectType ( ) ) ; GenericConverter org.springframework.format.support.GenericConverter = java.util.Map<org.springframework.format.support.FormattingConversionService.AnnotationConverterKey,org.springframework.format.support.GenericConverter> . get ( org.springframework.format.support.FormattingConversionService.AnnotationConverterKey ) ; if ( org.springframework.format.support.GenericConverter == null ) { Printer < ? > org.springframework.format.support.Printer<?> = this . org.springframework.format.support.AnnotationFormatterFactory . getPrinter ( org.springframework.format.support.FormattingConversionService.AnnotationConverterKey . java.lang.annotation.Annotation ( ) , org.springframework.format.support.FormattingConversionService.AnnotationConverterKey . java.lang.Class<?> ( ) ) ; org.springframework.format.support.GenericConverter = new org.springframework.format.support.FormattingConversionService.PrinterConverter ( this . java.lang.Class<> , org.springframework.format.support.Printer<> , org.springframework.format.support.FormattingConversionService .this ) ; java.util.Map<org.springframework.format.support.FormattingConversionService.AnnotationConverterKey,org.springframework.format.support.GenericConverter> . put ( org.springframework.format.support.FormattingConversionService.AnnotationConverterKey , org.springframework.format.support.GenericConverter ) ; } return org.springframework.format.support.GenericConverter . convert ( java.lang.Object , org.springframework.format.support.TypeDescriptor , org.springframework.format.support.TypeDescriptor ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.String java.lang.String ( ) { return ( STRING + this . java.lang.Class<> . java.lang.String ( ) + STRING + this . java.lang.Class<> . java.lang.String ( ) + STRING + java.lang.String .class . java.lang.String ( ) + STRING + this . org.springframework.format.support.AnnotationFormatterFactory ) ; }  <METHOD_END>
<METHOD_START> public void ( java.lang.Class<? extends java.lang.annotation.Annotation> < ? extends java.lang.annotation.Annotation > java.lang.Class<? extends java.lang.annotation.Annotation> , AnnotationFormatterFactory < ? > org.springframework.format.support.AnnotationFormatterFactory<?> , java.lang.Class<?> < ? > java.lang.Class<?> ) { this . java.lang.Class<? extends java.lang.annotation.Annotation> = java.lang.Class<> ; this . org.springframework.format.support.AnnotationFormatterFactory = org.springframework.format.support.AnnotationFormatterFactory<> ; this . java.lang.Class<?> = java.lang.Class<> ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.util.Set<org.springframework.format.support.ConvertiblePair> < ConvertiblePair > java.util.Set<org.springframework.format.support.ConvertiblePair> ( ) { return java.util.Collections . java.util.Set ( new ConvertiblePair ( java.lang.String .class , java.lang.Class<> ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( TypeDescriptor org.springframework.format.support.TypeDescriptor , TypeDescriptor org.springframework.format.support.TypeDescriptor ) { return org.springframework.format.support.TypeDescriptor . hasAnnotation ( this . java.lang.Class<> ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override @ java.lang.SuppressWarnings ( STRING ) public java.lang.Object java.lang.Object ( java.lang.Object java.lang.Object , TypeDescriptor org.springframework.format.support.TypeDescriptor , TypeDescriptor org.springframework.format.support.TypeDescriptor ) { java.lang.annotation.Annotation java.lang.annotation.Annotation = org.springframework.format.support.TypeDescriptor . getAnnotation ( this . java.lang.Class<> ) ; if ( java.lang.annotation.Annotation == null ) { throw new java.lang.IllegalStateException ( STRING + this . java.lang.Class<> . java.lang.String ( ) + STRING + org.springframework.format.support.TypeDescriptor ) ; } org.springframework.format.support.FormattingConversionService.AnnotationConverterKey org.springframework.format.support.FormattingConversionService.AnnotationConverterKey = new org.springframework.format.support.FormattingConversionService.AnnotationConverterKey ( java.lang.annotation.Annotation , org.springframework.format.support.TypeDescriptor . getObjectType ( ) ) ; GenericConverter org.springframework.format.support.GenericConverter = java.util.Map<org.springframework.format.support.FormattingConversionService.AnnotationConverterKey,org.springframework.format.support.GenericConverter> . get ( org.springframework.format.support.FormattingConversionService.AnnotationConverterKey ) ; if ( org.springframework.format.support.GenericConverter == null ) { Parser < ? > org.springframework.format.support.Parser<?> = this . org.springframework.format.support.AnnotationFormatterFactory . getParser ( org.springframework.format.support.FormattingConversionService.AnnotationConverterKey . java.lang.annotation.Annotation ( ) , org.springframework.format.support.FormattingConversionService.AnnotationConverterKey . java.lang.Class<?> ( ) ) ; org.springframework.format.support.GenericConverter = new org.springframework.format.support.FormattingConversionService.ParserConverter ( this . java.lang.Class<> , org.springframework.format.support.Parser<> , org.springframework.format.support.FormattingConversionService .this ) ; java.util.Map<org.springframework.format.support.FormattingConversionService.AnnotationConverterKey,org.springframework.format.support.GenericConverter> . put ( org.springframework.format.support.FormattingConversionService.AnnotationConverterKey , org.springframework.format.support.GenericConverter ) ; } return org.springframework.format.support.GenericConverter . convert ( java.lang.Object , org.springframework.format.support.TypeDescriptor , org.springframework.format.support.TypeDescriptor ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.String java.lang.String ( ) { return ( java.lang.String .class . java.lang.String ( ) + STRING + this . java.lang.Class<> . java.lang.String ( ) + STRING + this . java.lang.Class<> . java.lang.String ( ) + STRING + this . org.springframework.format.support.AnnotationFormatterFactory ) ; }  <METHOD_END>
<METHOD_START> public void ( java.lang.annotation.Annotation java.lang.annotation.Annotation , java.lang.Class<?> < ? > java.lang.Class<?> ) { this . java.lang.annotation.Annotation = java.lang.annotation.Annotation ; this . java.lang.Class<?> = java.lang.Class<> ; }  <METHOD_END>
<METHOD_START> public java.lang.annotation.Annotation java.lang.annotation.Annotation ( ) { return this . java.lang.annotation.Annotation ; }  <METHOD_END>
<METHOD_START> public java.lang.Class<?> < ? > java.lang.Class<?> ( ) { return this . java.lang.Class<> ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( java.lang.Object java.lang.Object ) { if ( this == java.lang.Object ) { return true ; } org.springframework.format.support.FormattingConversionService.AnnotationConverterKey org.springframework.format.support.FormattingConversionService.AnnotationConverterKey = ( org.springframework.format.support.FormattingConversionService.AnnotationConverterKey ) java.lang.Object ; return ( this . java.lang.Class<> == org.springframework.format.support.FormattingConversionService.AnnotationConverterKey . java.lang.Class<> && this . java.lang.annotation.Annotation . boolean ( org.springframework.format.support.FormattingConversionService.AnnotationConverterKey . java.lang.annotation.Annotation ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public int int ( ) { return ( this . java.lang.Class<> . int ( ) * NUMBER + this . java.lang.annotation.Annotation . int ( ) ) ; }  <METHOD_END>
