<METHOD_START> @ Test public void void ( ) java.lang.Exception { QueueChannel org.springframework.integration.core.QueueChannel = new QueueChannel ( ) ; AsyncMessagingTemplate org.springframework.integration.core.AsyncMessagingTemplate = new AsyncMessagingTemplate ( ) ; org.springframework.integration.core.AsyncMessagingTemplate . setDefaultDestination ( org.springframework.integration.core.QueueChannel ) ; Message < ? > org.springframework.integration.core.Message<?> = MessageBuilder . withPayload ( STRING ) . build ( ) ; java.util.concurrent.Future<?> < ? > java.util.concurrent.Future<?> = org.springframework.integration.core.AsyncMessagingTemplate . asyncSend ( org.springframework.integration.core.Message<> ) ; assertNull ( java.util.concurrent.Future<> . get ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; Message < ? > org.springframework.integration.core.Message<?> = org.springframework.integration.core.QueueChannel . receive ( NUMBER ) ; assertEquals ( org.springframework.integration.core.Message<> , org.springframework.integration.core.Message<> ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { QueueChannel org.springframework.integration.core.QueueChannel = new QueueChannel ( ) ; AsyncMessagingTemplate org.springframework.integration.core.AsyncMessagingTemplate = new AsyncMessagingTemplate ( ) ; Message < ? > org.springframework.integration.core.Message<?> = MessageBuilder . withPayload ( STRING ) . build ( ) ; java.util.concurrent.Future<?> < ? > java.util.concurrent.Future<?> = org.springframework.integration.core.AsyncMessagingTemplate . asyncSend ( org.springframework.integration.core.QueueChannel , org.springframework.integration.core.Message<> ) ; assertNull ( java.util.concurrent.Future<> . get ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; Message < ? > org.springframework.integration.core.Message<?> = org.springframework.integration.core.QueueChannel . receive ( NUMBER ) ; assertEquals ( org.springframework.integration.core.Message<> , org.springframework.integration.core.Message<> ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { StaticApplicationContext org.springframework.integration.core.StaticApplicationContext = new StaticApplicationContext ( ) ; org.springframework.integration.core.StaticApplicationContext . registerSingleton ( STRING , QueueChannel .class ) ; org.springframework.integration.core.StaticApplicationContext . refresh ( ) ; QueueChannel org.springframework.integration.core.QueueChannel = org.springframework.integration.core.StaticApplicationContext . getBean ( STRING , QueueChannel .class ) ; AsyncMessagingTemplate org.springframework.integration.core.AsyncMessagingTemplate = new AsyncMessagingTemplate ( ) ; org.springframework.integration.core.AsyncMessagingTemplate . setBeanFactory ( org.springframework.integration.core.StaticApplicationContext ) ; Message < ? > org.springframework.integration.core.Message<?> = MessageBuilder . withPayload ( STRING ) . build ( ) ; java.util.concurrent.Future<?> < ? > java.util.concurrent.Future<?> = org.springframework.integration.core.AsyncMessagingTemplate . asyncSend ( STRING , org.springframework.integration.core.Message<> ) ; assertNull ( java.util.concurrent.Future<> . get ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; Message < ? > org.springframework.integration.core.Message<?> = org.springframework.integration.core.QueueChannel . receive ( NUMBER ) ; assertEquals ( org.springframework.integration.core.Message<> , org.springframework.integration.core.Message<> ) ; }  <METHOD_END>
<METHOD_START> @ Test ( expected = java.util.concurrent.TimeoutException .class ) public void void ( ) java.lang.Exception { QueueChannel org.springframework.integration.core.QueueChannel = new QueueChannel ( NUMBER ) ; org.springframework.integration.core.QueueChannel . send ( MessageBuilder . withPayload ( STRING ) . build ( ) ) ; AsyncMessagingTemplate org.springframework.integration.core.AsyncMessagingTemplate = new AsyncMessagingTemplate ( ) ; java.util.concurrent.Future<?> < ? > java.util.concurrent.Future<?> = org.springframework.integration.core.AsyncMessagingTemplate . asyncSend ( org.springframework.integration.core.QueueChannel , MessageBuilder . withPayload ( STRING ) . build ( ) ) ; java.util.concurrent.Future<> . get ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { QueueChannel org.springframework.integration.core.QueueChannel = new QueueChannel ( ) ; AsyncMessagingTemplate org.springframework.integration.core.AsyncMessagingTemplate = new AsyncMessagingTemplate ( ) ; org.springframework.integration.core.AsyncMessagingTemplate . setDefaultDestination ( org.springframework.integration.core.QueueChannel ) ; java.util.concurrent.Future<?> < ? > java.util.concurrent.Future<?> = org.springframework.integration.core.AsyncMessagingTemplate . asyncConvertAndSend ( STRING ) ; assertNull ( java.util.concurrent.Future<> . get ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; Message < ? > org.springframework.integration.core.Message<?> = org.springframework.integration.core.QueueChannel . receive ( NUMBER ) ; assertEquals ( STRING , org.springframework.integration.core.Message<> . getPayload ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { QueueChannel org.springframework.integration.core.QueueChannel = new QueueChannel ( ) ; AsyncMessagingTemplate org.springframework.integration.core.AsyncMessagingTemplate = new AsyncMessagingTemplate ( ) ; java.util.concurrent.Future<?> < ? > java.util.concurrent.Future<?> = org.springframework.integration.core.AsyncMessagingTemplate . asyncConvertAndSend ( org.springframework.integration.core.QueueChannel , STRING ) ; assertNull ( java.util.concurrent.Future<> . get ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; Message < ? > org.springframework.integration.core.Message<?> = org.springframework.integration.core.QueueChannel . receive ( NUMBER ) ; assertEquals ( STRING , org.springframework.integration.core.Message<> . getPayload ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { StaticApplicationContext org.springframework.integration.core.StaticApplicationContext = new StaticApplicationContext ( ) ; org.springframework.integration.core.StaticApplicationContext . registerSingleton ( STRING , QueueChannel .class ) ; org.springframework.integration.core.StaticApplicationContext . refresh ( ) ; QueueChannel org.springframework.integration.core.QueueChannel = org.springframework.integration.core.StaticApplicationContext . getBean ( STRING , QueueChannel .class ) ; AsyncMessagingTemplate org.springframework.integration.core.AsyncMessagingTemplate = new AsyncMessagingTemplate ( ) ; org.springframework.integration.core.AsyncMessagingTemplate . setBeanFactory ( org.springframework.integration.core.StaticApplicationContext ) ; java.util.concurrent.Future<?> < ? > java.util.concurrent.Future<?> = org.springframework.integration.core.AsyncMessagingTemplate . asyncConvertAndSend ( STRING , STRING ) ; assertNull ( java.util.concurrent.Future<> . get ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; Message < ? > org.springframework.integration.core.Message<?> = org.springframework.integration.core.QueueChannel . receive ( NUMBER ) ; assertEquals ( STRING , org.springframework.integration.core.Message<> . getPayload ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test ( expected = java.util.concurrent.TimeoutException .class ) public void void ( ) java.lang.Exception { QueueChannel org.springframework.integration.core.QueueChannel = new QueueChannel ( NUMBER ) ; org.springframework.integration.core.QueueChannel . send ( MessageBuilder . withPayload ( STRING ) . build ( ) ) ; AsyncMessagingTemplate org.springframework.integration.core.AsyncMessagingTemplate = new AsyncMessagingTemplate ( ) ; java.util.concurrent.Future<?> < ? > java.util.concurrent.Future<?> = org.springframework.integration.core.AsyncMessagingTemplate . asyncConvertAndSend ( org.springframework.integration.core.QueueChannel , STRING ) ; java.util.concurrent.Future<> . get ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { QueueChannel org.springframework.integration.core.QueueChannel = new QueueChannel ( ) ; AsyncMessagingTemplate org.springframework.integration.core.AsyncMessagingTemplate = new AsyncMessagingTemplate ( ) ; org.springframework.integration.core.AsyncMessagingTemplate . setDefaultDestination ( org.springframework.integration.core.QueueChannel ) ; java.util.concurrent.Future<org.springframework.integration.core.Message<?>> < Message < ? > > java.util.concurrent.Future<org.springframework.integration.core.Message<?>> = org.springframework.integration.core.AsyncMessagingTemplate . asyncReceive ( ) ; void ( org.springframework.integration.core.QueueChannel , new GenericMessage < java.lang.String > ( STRING ) , NUMBER ) ; long long = java.lang.System . long ( ) ; assertNotNull ( java.util.concurrent.Future<org.springframework.integration.core.Message<?>> . get ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; long long = java.lang.System . long ( ) - long ; assertEquals ( STRING , java.util.concurrent.Future<org.springframework.integration.core.Message<?>> . get ( ) . getPayload ( ) ) ; assertTrue ( long >= NUMBER - long ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { QueueChannel org.springframework.integration.core.QueueChannel = new QueueChannel ( ) ; AsyncMessagingTemplate org.springframework.integration.core.AsyncMessagingTemplate = new AsyncMessagingTemplate ( ) ; java.util.concurrent.Future<org.springframework.integration.core.Message<?>> < Message < ? > > java.util.concurrent.Future<org.springframework.integration.core.Message<?>> = org.springframework.integration.core.AsyncMessagingTemplate . asyncReceive ( org.springframework.integration.core.QueueChannel ) ; void ( org.springframework.integration.core.QueueChannel , new GenericMessage < java.lang.String > ( STRING ) , NUMBER ) ; long long = java.lang.System . long ( ) ; assertNotNull ( java.util.concurrent.Future<org.springframework.integration.core.Message<?>> . get ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; long long = java.lang.System . long ( ) - long ; assertEquals ( STRING , java.util.concurrent.Future<org.springframework.integration.core.Message<?>> . get ( ) . getPayload ( ) ) ; assertTrue ( long >= NUMBER - long ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { StaticApplicationContext org.springframework.integration.core.StaticApplicationContext = new StaticApplicationContext ( ) ; org.springframework.integration.core.StaticApplicationContext . registerSingleton ( STRING , QueueChannel .class ) ; org.springframework.integration.core.StaticApplicationContext . refresh ( ) ; QueueChannel org.springframework.integration.core.QueueChannel = org.springframework.integration.core.StaticApplicationContext . getBean ( STRING , QueueChannel .class ) ; AsyncMessagingTemplate org.springframework.integration.core.AsyncMessagingTemplate = new AsyncMessagingTemplate ( ) ; org.springframework.integration.core.AsyncMessagingTemplate . setBeanFactory ( org.springframework.integration.core.StaticApplicationContext ) ; java.util.concurrent.Future<org.springframework.integration.core.Message<?>> < Message < ? > > java.util.concurrent.Future<org.springframework.integration.core.Message<?>> = org.springframework.integration.core.AsyncMessagingTemplate . asyncReceive ( STRING ) ; void ( org.springframework.integration.core.QueueChannel , new GenericMessage < java.lang.String > ( STRING ) , NUMBER ) ; long long = java.lang.System . long ( ) ; assertNotNull ( java.util.concurrent.Future<org.springframework.integration.core.Message<?>> . get ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; long long = java.lang.System . long ( ) - long ; assertTrue ( long >= NUMBER - long ) ; assertEquals ( STRING , java.util.concurrent.Future<org.springframework.integration.core.Message<?>> . get ( ) . getPayload ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test ( expected = java.util.concurrent.TimeoutException .class ) public void void ( ) java.lang.Exception { AsyncMessagingTemplate org.springframework.integration.core.AsyncMessagingTemplate = new AsyncMessagingTemplate ( ) ; java.util.concurrent.Future<org.springframework.integration.core.Message<?>> < Message < ? > > java.util.concurrent.Future<org.springframework.integration.core.Message<?>> = org.springframework.integration.core.AsyncMessagingTemplate . asyncReceive ( new QueueChannel ( ) ) ; java.util.concurrent.Future<org.springframework.integration.core.Message<?>> . get ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { QueueChannel org.springframework.integration.core.QueueChannel = new QueueChannel ( ) ; AsyncMessagingTemplate org.springframework.integration.core.AsyncMessagingTemplate = new AsyncMessagingTemplate ( ) ; org.springframework.integration.core.AsyncMessagingTemplate . setDefaultDestination ( org.springframework.integration.core.QueueChannel ) ; java.util.concurrent.Future<?> < ? > java.util.concurrent.Future<?> = org.springframework.integration.core.AsyncMessagingTemplate . asyncReceiveAndConvert ( ) ; void ( org.springframework.integration.core.QueueChannel , new GenericMessage < java.lang.String > ( STRING ) , NUMBER ) ; long long = java.lang.System . long ( ) ; assertNotNull ( java.util.concurrent.Future<> . get ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; long long = java.lang.System . long ( ) - long ; assertEquals ( STRING , java.util.concurrent.Future<> . get ( ) ) ; assertTrue ( long >= NUMBER - long ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { QueueChannel org.springframework.integration.core.QueueChannel = new QueueChannel ( ) ; AsyncMessagingTemplate org.springframework.integration.core.AsyncMessagingTemplate = new AsyncMessagingTemplate ( ) ; java.util.concurrent.Future<?> < ? > java.util.concurrent.Future<?> = org.springframework.integration.core.AsyncMessagingTemplate . asyncReceiveAndConvert ( org.springframework.integration.core.QueueChannel ) ; void ( org.springframework.integration.core.QueueChannel , new GenericMessage < java.lang.String > ( STRING ) , NUMBER ) ; long long = java.lang.System . long ( ) ; assertNotNull ( java.util.concurrent.Future<> . get ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; long long = java.lang.System . long ( ) - long ; assertEquals ( STRING , java.util.concurrent.Future<> . get ( ) ) ; assertTrue ( long >= NUMBER - long ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { StaticApplicationContext org.springframework.integration.core.StaticApplicationContext = new StaticApplicationContext ( ) ; org.springframework.integration.core.StaticApplicationContext . registerSingleton ( STRING , QueueChannel .class ) ; org.springframework.integration.core.StaticApplicationContext . refresh ( ) ; QueueChannel org.springframework.integration.core.QueueChannel = org.springframework.integration.core.StaticApplicationContext . getBean ( STRING , QueueChannel .class ) ; AsyncMessagingTemplate org.springframework.integration.core.AsyncMessagingTemplate = new AsyncMessagingTemplate ( ) ; org.springframework.integration.core.AsyncMessagingTemplate . setBeanFactory ( org.springframework.integration.core.StaticApplicationContext ) ; java.util.concurrent.Future<?> < ? > java.util.concurrent.Future<?> = org.springframework.integration.core.AsyncMessagingTemplate . asyncReceiveAndConvert ( STRING ) ; void ( org.springframework.integration.core.QueueChannel , new GenericMessage < java.lang.String > ( STRING ) , NUMBER ) ; long long = java.lang.System . long ( ) ; assertNotNull ( java.util.concurrent.Future<> . get ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; long long = java.lang.System . long ( ) - long ; assertTrue ( long >= NUMBER - long ) ; assertEquals ( STRING , java.util.concurrent.Future<> . get ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test ( expected = java.util.concurrent.TimeoutException .class ) public void void ( ) java.lang.Exception { AsyncMessagingTemplate org.springframework.integration.core.AsyncMessagingTemplate = new AsyncMessagingTemplate ( ) ; java.util.concurrent.Future<?> < ? > java.util.concurrent.Future<?> = org.springframework.integration.core.AsyncMessagingTemplate . asyncReceiveAndConvert ( new QueueChannel ( ) ) ; java.util.concurrent.Future<> . get ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { DirectChannel org.springframework.integration.core.DirectChannel = new DirectChannel ( ) ; org.springframework.integration.core.DirectChannel . subscribe ( new org.springframework.integration.core.AsyncMessagingTemplateTests.EchoHandler ( NUMBER ) ) ; AsyncMessagingTemplate org.springframework.integration.core.AsyncMessagingTemplate = new AsyncMessagingTemplate ( ) ; org.springframework.integration.core.AsyncMessagingTemplate . setDefaultDestination ( org.springframework.integration.core.DirectChannel ) ; long long = java.lang.System . long ( ) ; java.util.concurrent.Future<org.springframework.integration.core.Message<?>> < Message < ? > > java.util.concurrent.Future<org.springframework.integration.core.Message<?>> = org.springframework.integration.core.AsyncMessagingTemplate . asyncSendAndReceive ( MessageBuilder . withPayload ( STRING ) . build ( ) ) ; assertNotNull ( java.util.concurrent.Future<org.springframework.integration.core.Message<?>> . get ( ) ) ; long long = java.lang.System . long ( ) - long ; assertTrue ( long >= NUMBER - long ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { DirectChannel org.springframework.integration.core.DirectChannel = new DirectChannel ( ) ; org.springframework.integration.core.DirectChannel . subscribe ( new org.springframework.integration.core.AsyncMessagingTemplateTests.EchoHandler ( NUMBER ) ) ; AsyncMessagingTemplate org.springframework.integration.core.AsyncMessagingTemplate = new AsyncMessagingTemplate ( ) ; long long = java.lang.System . long ( ) ; java.util.concurrent.Future<org.springframework.integration.core.Message<?>> < Message < ? > > java.util.concurrent.Future<org.springframework.integration.core.Message<?>> = org.springframework.integration.core.AsyncMessagingTemplate . asyncSendAndReceive ( org.springframework.integration.core.DirectChannel , MessageBuilder . withPayload ( STRING ) . build ( ) ) ; assertNotNull ( java.util.concurrent.Future<org.springframework.integration.core.Message<?>> . get ( ) ) ; long long = java.lang.System . long ( ) - long ; assertTrue ( long >= NUMBER - long ) ; assertEquals ( STRING , java.util.concurrent.Future<org.springframework.integration.core.Message<?>> . get ( ) . getPayload ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { StaticApplicationContext org.springframework.integration.core.StaticApplicationContext = new StaticApplicationContext ( ) ; org.springframework.integration.core.StaticApplicationContext . registerSingleton ( STRING , DirectChannel .class ) ; org.springframework.integration.core.StaticApplicationContext . refresh ( ) ; DirectChannel org.springframework.integration.core.DirectChannel = org.springframework.integration.core.StaticApplicationContext . getBean ( STRING , DirectChannel .class ) ; org.springframework.integration.core.DirectChannel . subscribe ( new org.springframework.integration.core.AsyncMessagingTemplateTests.EchoHandler ( NUMBER ) ) ; AsyncMessagingTemplate org.springframework.integration.core.AsyncMessagingTemplate = new AsyncMessagingTemplate ( ) ; org.springframework.integration.core.AsyncMessagingTemplate . setBeanFactory ( org.springframework.integration.core.StaticApplicationContext ) ; long long = java.lang.System . long ( ) ; java.util.concurrent.Future<org.springframework.integration.core.Message<?>> < Message < ? > > java.util.concurrent.Future<org.springframework.integration.core.Message<?>> = org.springframework.integration.core.AsyncMessagingTemplate . asyncSendAndReceive ( STRING , MessageBuilder . withPayload ( STRING ) . build ( ) ) ; assertNotNull ( java.util.concurrent.Future<org.springframework.integration.core.Message<?>> . get ( ) ) ; long long = java.lang.System . long ( ) - long ; assertTrue ( long >= NUMBER - long ) ; assertEquals ( STRING , java.util.concurrent.Future<org.springframework.integration.core.Message<?>> . get ( ) . getPayload ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { DirectChannel org.springframework.integration.core.DirectChannel = new DirectChannel ( ) ; org.springframework.integration.core.DirectChannel . subscribe ( new org.springframework.integration.core.AsyncMessagingTemplateTests.EchoHandler ( NUMBER ) ) ; AsyncMessagingTemplate org.springframework.integration.core.AsyncMessagingTemplate = new AsyncMessagingTemplate ( ) ; org.springframework.integration.core.AsyncMessagingTemplate . setDefaultDestination ( org.springframework.integration.core.DirectChannel ) ; long long = java.lang.System . long ( ) ; java.util.concurrent.Future<java.lang.String> < java.lang.String > java.util.concurrent.Future<java.lang.String> = org.springframework.integration.core.AsyncMessagingTemplate . asyncConvertSendAndReceive ( STRING ) ; assertNotNull ( java.util.concurrent.Future<java.lang.String> . java.lang.String ( ) ) ; long long = java.lang.System . long ( ) - long ; assertTrue ( long >= NUMBER - long ) ; assertEquals ( STRING , java.util.concurrent.Future<java.lang.String> . java.lang.String ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { DirectChannel org.springframework.integration.core.DirectChannel = new DirectChannel ( ) ; org.springframework.integration.core.DirectChannel . subscribe ( new org.springframework.integration.core.AsyncMessagingTemplateTests.EchoHandler ( NUMBER ) ) ; AsyncMessagingTemplate org.springframework.integration.core.AsyncMessagingTemplate = new AsyncMessagingTemplate ( ) ; long long = java.lang.System . long ( ) ; java.util.concurrent.Future<java.lang.String> < java.lang.String > java.util.concurrent.Future<java.lang.String> = org.springframework.integration.core.AsyncMessagingTemplate . asyncConvertSendAndReceive ( org.springframework.integration.core.DirectChannel , STRING ) ; assertNotNull ( java.util.concurrent.Future<java.lang.String> . java.lang.String ( ) ) ; long long = java.lang.System . long ( ) - long ; assertTrue ( long >= NUMBER - long ) ; assertEquals ( STRING , java.util.concurrent.Future<java.lang.String> . java.lang.String ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { StaticApplicationContext org.springframework.integration.core.StaticApplicationContext = new StaticApplicationContext ( ) ; org.springframework.integration.core.StaticApplicationContext . registerSingleton ( STRING , DirectChannel .class ) ; org.springframework.integration.core.StaticApplicationContext . refresh ( ) ; DirectChannel org.springframework.integration.core.DirectChannel = org.springframework.integration.core.StaticApplicationContext . getBean ( STRING , DirectChannel .class ) ; org.springframework.integration.core.DirectChannel . subscribe ( new org.springframework.integration.core.AsyncMessagingTemplateTests.EchoHandler ( NUMBER ) ) ; AsyncMessagingTemplate org.springframework.integration.core.AsyncMessagingTemplate = new AsyncMessagingTemplate ( ) ; org.springframework.integration.core.AsyncMessagingTemplate . setBeanFactory ( org.springframework.integration.core.StaticApplicationContext ) ; long long = java.lang.System . long ( ) ; java.util.concurrent.Future<java.lang.String> < java.lang.String > java.util.concurrent.Future<java.lang.String> = org.springframework.integration.core.AsyncMessagingTemplate . asyncConvertSendAndReceive ( STRING , STRING ) ; assertNotNull ( java.util.concurrent.Future<java.lang.String> . java.lang.String ( ) ) ; long long = java.lang.System . long ( ) - long ; assertTrue ( long >= NUMBER - long ) ; assertEquals ( STRING , java.util.concurrent.Future<java.lang.String> . java.lang.String ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { DirectChannel org.springframework.integration.core.DirectChannel = new DirectChannel ( ) ; org.springframework.integration.core.DirectChannel . subscribe ( new org.springframework.integration.core.AsyncMessagingTemplateTests.EchoHandler ( NUMBER ) ) ; AsyncMessagingTemplate org.springframework.integration.core.AsyncMessagingTemplate = new AsyncMessagingTemplate ( ) ; org.springframework.integration.core.AsyncMessagingTemplate . setDefaultDestination ( org.springframework.integration.core.DirectChannel ) ; long long = java.lang.System . long ( ) ; java.util.concurrent.Future<java.lang.String> < java.lang.String > java.util.concurrent.Future<java.lang.String> = org.springframework.integration.core.AsyncMessagingTemplate . asyncConvertSendAndReceive ( NUMBER , new org.springframework.integration.core.AsyncMessagingTemplateTests.TestMessagePostProcessor ( ) ) ; assertNotNull ( java.util.concurrent.Future<java.lang.String> . java.lang.String ( ) ) ; long long = java.lang.System . long ( ) - long ; assertTrue ( long >= NUMBER - long ) ; assertEquals ( STRING , java.util.concurrent.Future<java.lang.String> . java.lang.String ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { DirectChannel org.springframework.integration.core.DirectChannel = new DirectChannel ( ) ; org.springframework.integration.core.DirectChannel . subscribe ( new org.springframework.integration.core.AsyncMessagingTemplateTests.EchoHandler ( NUMBER ) ) ; AsyncMessagingTemplate org.springframework.integration.core.AsyncMessagingTemplate = new AsyncMessagingTemplate ( ) ; long long = java.lang.System . long ( ) ; java.util.concurrent.Future<java.lang.String> < java.lang.String > java.util.concurrent.Future<java.lang.String> = org.springframework.integration.core.AsyncMessagingTemplate . asyncConvertSendAndReceive ( org.springframework.integration.core.DirectChannel , STRING , new org.springframework.integration.core.AsyncMessagingTemplateTests.TestMessagePostProcessor ( ) ) ; assertNotNull ( java.util.concurrent.Future<java.lang.String> . java.lang.String ( ) ) ; long long = java.lang.System . long ( ) - long ; assertTrue ( long >= NUMBER - long ) ; assertEquals ( STRING , java.util.concurrent.Future<java.lang.String> . java.lang.String ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { StaticApplicationContext org.springframework.integration.core.StaticApplicationContext = new StaticApplicationContext ( ) ; org.springframework.integration.core.StaticApplicationContext . registerSingleton ( STRING , DirectChannel .class ) ; org.springframework.integration.core.StaticApplicationContext . refresh ( ) ; DirectChannel org.springframework.integration.core.DirectChannel = org.springframework.integration.core.StaticApplicationContext . getBean ( STRING , DirectChannel .class ) ; org.springframework.integration.core.DirectChannel . subscribe ( new org.springframework.integration.core.AsyncMessagingTemplateTests.EchoHandler ( NUMBER ) ) ; AsyncMessagingTemplate org.springframework.integration.core.AsyncMessagingTemplate = new AsyncMessagingTemplate ( ) ; org.springframework.integration.core.AsyncMessagingTemplate . setBeanFactory ( org.springframework.integration.core.StaticApplicationContext ) ; long long = java.lang.System . long ( ) ; java.util.concurrent.Future<java.lang.String> < java.lang.String > java.util.concurrent.Future<java.lang.String> = org.springframework.integration.core.AsyncMessagingTemplate . asyncConvertSendAndReceive ( STRING , STRING , new org.springframework.integration.core.AsyncMessagingTemplateTests.TestMessagePostProcessor ( ) ) ; assertNotNull ( java.util.concurrent.Future<java.lang.String> . java.lang.String ( ) ) ; long long = java.lang.System . long ( ) - long ; assertTrue ( long >= NUMBER - long ) ; assertEquals ( STRING , java.util.concurrent.Future<java.lang.String> . java.lang.String ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test ( expected = java.util.concurrent.TimeoutException .class ) public void void ( ) java.lang.Exception { DirectChannel org.springframework.integration.core.DirectChannel = new DirectChannel ( ) ; org.springframework.integration.core.DirectChannel . subscribe ( new org.springframework.integration.core.AsyncMessagingTemplateTests.EchoHandler ( NUMBER ) ) ; AsyncMessagingTemplate org.springframework.integration.core.AsyncMessagingTemplate = new AsyncMessagingTemplate ( ) ; org.springframework.integration.core.AsyncMessagingTemplate . setDefaultDestination ( org.springframework.integration.core.DirectChannel ) ; java.util.concurrent.Future<org.springframework.integration.core.Message<?>> < Message < ? > > java.util.concurrent.Future<org.springframework.integration.core.Message<?>> = org.springframework.integration.core.AsyncMessagingTemplate . asyncSendAndReceive ( MessageBuilder . withPayload ( STRING ) . build ( ) ) ; java.util.concurrent.Future<org.springframework.integration.core.Message<?>> . get ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ; }  <METHOD_END>
<METHOD_START> @ Test ( expected = MessagingException .class ) public void void ( ) java.lang.Throwable { DirectChannel org.springframework.integration.core.DirectChannel = new DirectChannel ( ) ; org.springframework.integration.core.DirectChannel . subscribe ( new org.springframework.integration.core.AsyncMessagingTemplateTests.EchoHandler ( - NUMBER ) ) ; AsyncMessagingTemplate org.springframework.integration.core.AsyncMessagingTemplate = new AsyncMessagingTemplate ( ) ; org.springframework.integration.core.AsyncMessagingTemplate . setDefaultDestination ( org.springframework.integration.core.DirectChannel ) ; java.util.concurrent.Future<org.springframework.integration.core.Message<?>> < Message < ? > > java.util.concurrent.Future<org.springframework.integration.core.Message<?>> = org.springframework.integration.core.AsyncMessagingTemplate . asyncSendAndReceive ( MessageBuilder . withPayload ( STRING ) . build ( ) ) ; try { java.util.concurrent.Future<org.springframework.integration.core.Message<?>> . get ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ; fail ( ) ; } catch ( java.util.concurrent.ExecutionException java.util.concurrent.ExecutionException ) { throw java.util.concurrent.ExecutionException . java.lang.Throwable ( ) ; } }  <METHOD_END>
<METHOD_START> @ Test ( expected = java.util.concurrent.CancellationException .class ) public void void ( ) java.lang.Throwable { DirectChannel org.springframework.integration.core.DirectChannel = new DirectChannel ( ) ; org.springframework.integration.core.AsyncMessagingTemplateTests.EchoHandler org.springframework.integration.core.AsyncMessagingTemplateTests.EchoHandler = new org.springframework.integration.core.AsyncMessagingTemplateTests.EchoHandler ( NUMBER ) ; org.springframework.integration.core.DirectChannel . subscribe ( org.springframework.integration.core.AsyncMessagingTemplateTests.EchoHandler ) ; AsyncMessagingTemplate org.springframework.integration.core.AsyncMessagingTemplate = new AsyncMessagingTemplate ( ) ; org.springframework.integration.core.AsyncMessagingTemplate . setDefaultDestination ( org.springframework.integration.core.DirectChannel ) ; java.util.concurrent.Future<org.springframework.integration.core.Message<?>> < Message < ? > > java.util.concurrent.Future<org.springframework.integration.core.Message<?>> = org.springframework.integration.core.AsyncMessagingTemplate . asyncSendAndReceive ( MessageBuilder . withPayload ( STRING ) . build ( ) ) ; try { java.lang.Thread . void ( NUMBER ) ; java.util.concurrent.Future<org.springframework.integration.core.Message<?>> . cancel ( true ) ; java.util.concurrent.Future<org.springframework.integration.core.Message<?>> . get ( ) ; fail ( ) ; } catch ( java.util.concurrent.ExecutionException java.util.concurrent.ExecutionException ) { Assert . isTrue ( org.springframework.integration.core.AsyncMessagingTemplateTests.EchoHandler . boolean , STRING ) ; throw java.util.concurrent.ExecutionException . java.lang.Throwable ( ) ; } }  <METHOD_END>
<METHOD_START> private static void void ( final MessageChannel org.springframework.integration.core.MessageChannel , final GenericMessage < java.lang.String > org.springframework.integration.core.GenericMessage<java.lang.String> , final int int ) { java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . void ( ( ) { try { java.lang.Thread . void ( int ) ; } catch ( java.lang.InterruptedException java.lang.InterruptedException ) { java.lang.Thread . java.lang.Thread ( ) . void ( ) ; return; } org.springframework.integration.core.MessageChannel . send ( org.springframework.integration.core.GenericMessage<java.lang.String> ) ; } ) ; }  <METHOD_END>
<METHOD_START> private void ( long long ) { this . long = long ; this . boolean = ( this . long < NUMBER ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected java.lang.Object java.lang.Object ( Message < ? > org.springframework.integration.core.Message<?> ) { if ( this . boolean ) { throw new MessagingException ( STRING + org.springframework.integration.core.AsyncMessagingTemplateTests .class . java.lang.String ( ) ) ; } try { java.lang.Thread . void ( this . long ) ; } catch ( java.lang.InterruptedException java.lang.InterruptedException ) { java.lang.Thread . java.lang.Thread ( ) . void ( ) ; this . boolean = true ; return null ; } java.lang.String java.lang.String = org.springframework.integration.core.Message<> . getPayload ( ) . toString ( ) . toUpperCase ( ) ; java.lang.String java.lang.String = org.springframework.integration.core.Message<> . getHeaders ( ) . get ( STRING , java.lang.String .class ) ; return ( java.lang.String != null ) ? java.lang.String + STRING + java.lang.String : java.lang.String ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.integration.core.Message<?> < ? > org.springframework.integration.core.Message<?> ( Message < ? > org.springframework.integration.core.Message<?> ) { return MessageBuilder . fromMessage ( org.springframework.integration.core.Message<> ) . setHeader ( STRING , STRING ) . build ( ) ; }  <METHOD_END>
