<METHOD_START> public void ( java.lang.String java.lang.String , int int , ReactorNettyCodec < P > org.springframework.messaging.tcp.reactor.ReactorNettyCodec<P> ) { this( opts -> opts . connect ( host , port ) , org.springframework.messaging.tcp.reactor.ReactorNettyCodec<P> ); }  <METHOD_END>
<METHOD_START> public void ( java.util.function.Consumer<org.springframework.messaging.tcp.reactor.ClientOptions> < ClientOptions > java.util.function.Consumer<org.springframework.messaging.tcp.reactor.ClientOptions> , ReactorNettyCodec < P > org.springframework.messaging.tcp.reactor.ReactorNettyCodec<P> ) { Assert . notNull ( java.util.function.Consumer<org.springframework.messaging.tcp.reactor.ClientOptions> , STRING ) ; Assert . notNull ( org.springframework.messaging.tcp.reactor.ReactorNettyCodec<P> , STRING ) ; this . org.springframework.messaging.tcp.reactor.ChannelGroup = new DefaultChannelGroup ( ImmediateEventExecutor . INSTANCE ) ; this . org.springframework.messaging.tcp.reactor.LoopResources = LoopResources . create ( STRING ) ; this . org.springframework.messaging.tcp.reactor.PoolResources = PoolResources . fixed ( STRING ) ; java.util.function.Consumer<org.springframework.messaging.tcp.reactor.ClientOptions> < ClientOptions > java.util.function.Consumer<org.springframework.messaging.tcp.reactor.ClientOptions> = org.springframework.messaging.tcp.reactor.ClientOptions -> org.springframework.messaging.tcp.reactor.ClientOptions . channelGroup ( this . org.springframework.messaging.tcp.reactor.ChannelGroup ) . loopResources ( this . org.springframework.messaging.tcp.reactor.LoopResources ) . poolResources ( this . org.springframework.messaging.tcp.reactor.PoolResources ) . preferNative ( false ) ; this . org.springframework.messaging.tcp.reactor.TcpClient = TcpClient . create ( java.util.function.Consumer<org.springframework.messaging.tcp.reactor.ClientOptions> . andThen ( java.util.function.Consumer<org.springframework.messaging.tcp.reactor.ClientOptions> ) ) ; this . org.springframework.messaging.tcp.reactor.ReactorNettyCodec<P> = org.springframework.messaging.tcp.reactor.ReactorNettyCodec<P> ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.messaging.tcp.reactor.ListenableFuture<java.lang.Void> < java.lang.Void > org.springframework.messaging.tcp.reactor.ListenableFuture<java.lang.Void> ( final TcpConnectionHandler < P > org.springframework.messaging.tcp.reactor.TcpConnectionHandler<P> ) { Assert . notNull ( org.springframework.messaging.tcp.reactor.TcpConnectionHandler<P> , STRING ) ; if ( this . boolean ) { return org.springframework.messaging.tcp.reactor.ListenableFuture<java.lang.Void> ( org.springframework.messaging.tcp.reactor.TcpConnectionHandler<P> ) ; } Mono < java.lang.Void > org.springframework.messaging.tcp.reactor.Mono<java.lang.Void> = this . org.springframework.messaging.tcp.reactor.TcpClient . newHandler ( new org.springframework.messaging.tcp.reactor.ReactorNettyTcpClient<P>.ReactorNettyHandler ( org.springframework.messaging.tcp.reactor.TcpConnectionHandler<P> ) ) . doOnError ( org.springframework.messaging.tcp.reactor.TcpConnectionHandler<P> :: afterConnectFailure ) . then ( ) ; return new MonoToListenableFutureAdapter <> ( org.springframework.messaging.tcp.reactor.Mono<java.lang.Void> ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.messaging.tcp.reactor.ListenableFuture<java.lang.Void> < java.lang.Void > org.springframework.messaging.tcp.reactor.ListenableFuture<java.lang.Void> ( TcpConnectionHandler < P > org.springframework.messaging.tcp.reactor.TcpConnectionHandler<P> , ReconnectStrategy org.springframework.messaging.tcp.reactor.ReconnectStrategy ) { Assert . notNull ( org.springframework.messaging.tcp.reactor.TcpConnectionHandler<P> , STRING ) ; Assert . notNull ( org.springframework.messaging.tcp.reactor.ReconnectStrategy , STRING ) ; if ( this . boolean ) { return org.springframework.messaging.tcp.reactor.ListenableFuture<java.lang.Void> ( org.springframework.messaging.tcp.reactor.TcpConnectionHandler<P> ) ; } MonoProcessor < java.lang.Void > org.springframework.messaging.tcp.reactor.MonoProcessor<java.lang.Void> = MonoProcessor . create ( ) ; this . org.springframework.messaging.tcp.reactor.TcpClient . newHandler ( new org.springframework.messaging.tcp.reactor.ReactorNettyTcpClient<P>.ReactorNettyHandler ( org.springframework.messaging.tcp.reactor.TcpConnectionHandler<P> ) ) . doOnNext ( java.util.function.Consumer ( org.springframework.messaging.tcp.reactor.MonoProcessor<java.lang.Void> ) ) . doOnError ( java.util.function.Consumer ( org.springframework.messaging.tcp.reactor.MonoProcessor<java.lang.Void> ) ) . doOnError ( org.springframework.messaging.tcp.reactor.TcpConnectionHandler<P> :: afterConnectFailure ) . then ( NettyContext :: onClose ) . retryWhen ( java.util.function.Function ( org.springframework.messaging.tcp.reactor.ReconnectStrategy ) ) . repeatWhen ( java.util.function.Function ( org.springframework.messaging.tcp.reactor.ReconnectStrategy ) ) . subscribe ( ) ; return new MonoToListenableFutureAdapter <> ( org.springframework.messaging.tcp.reactor.MonoProcessor<java.lang.Void> ) ; }  <METHOD_END>
<METHOD_START> private org.springframework.messaging.tcp.reactor.ListenableFuture<java.lang.Void> < java.lang.Void > org.springframework.messaging.tcp.reactor.ListenableFuture<java.lang.Void> ( TcpConnectionHandler < P > org.springframework.messaging.tcp.reactor.TcpConnectionHandler<P> ) { java.lang.IllegalStateException java.lang.IllegalStateException = new java.lang.IllegalStateException ( STRING ) ; org.springframework.messaging.tcp.reactor.TcpConnectionHandler<P> . afterConnectFailure ( java.lang.IllegalStateException ) ; return new MonoToListenableFutureAdapter <> ( Mono . error ( java.lang.IllegalStateException ) ) ; }  <METHOD_END>
<METHOD_START> private < T > java.util.function.Consumer<T> < T > java.util.function.Consumer<T> ( MonoProcessor < java.lang.Void > org.springframework.messaging.tcp.reactor.MonoProcessor<java.lang.Void> ) { return T -> { if ( ! org.springframework.messaging.tcp.reactor.MonoProcessor<java.lang.Void> . isTerminated ( ) ) { if ( T instanceof java.lang.Throwable ) { org.springframework.messaging.tcp.reactor.MonoProcessor<java.lang.Void> . onError ( ( java.lang.Throwable ) T ) ; } else { org.springframework.messaging.tcp.reactor.MonoProcessor<java.lang.Void> . onComplete ( ) ; } } } ; }  <METHOD_END>
<METHOD_START> private < T > java.util.function.Function<org.springframework.messaging.tcp.reactor.Flux<T>,org.springframework.messaging.tcp.reactor.Publisher<?>> < Flux < T > , Publisher < ? > > java.util.function.Function<org.springframework.messaging.tcp.reactor.Flux<T>,org.springframework.messaging.tcp.reactor.Publisher<?>> ( ReconnectStrategy org.springframework.messaging.tcp.reactor.ReconnectStrategy ) { return org.springframework.messaging.tcp.reactor.Flux<T> -> org.springframework.messaging.tcp.reactor.Flux<T> . scan ( NUMBER , ( count , element ) -> count ++ ) . flatMap ( attempt -> Mono . delay ( Duration . ofMillis ( reconnectStrategy . getTimeToNextAttempt ( attempt ) ) ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.messaging.tcp.reactor.ListenableFuture<java.lang.Void> < java.lang.Void > org.springframework.messaging.tcp.reactor.ListenableFuture<java.lang.Void> ( ) { if ( this . boolean ) { SettableListenableFuture < java.lang.Void > org.springframework.messaging.tcp.reactor.SettableListenableFuture<java.lang.Void> = new SettableListenableFuture <> ( ) ; org.springframework.messaging.tcp.reactor.SettableListenableFuture<java.lang.Void> . set ( null ) ; return org.springframework.messaging.tcp.reactor.SettableListenableFuture<java.lang.Void> ; } this . boolean = true ; ChannelGroupFuture org.springframework.messaging.tcp.reactor.ChannelGroupFuture = this . org.springframework.messaging.tcp.reactor.ChannelGroup . close ( ) ; Mono < java.lang.Void > org.springframework.messaging.tcp.reactor.Mono<java.lang.Void> = FutureMono . from ( org.springframework.messaging.tcp.reactor.ChannelGroupFuture ) . doAfterTerminate ( ( x , e ) -> { shutdownGlobalResources ( ) ; this . loopResources . dispose ( ) ; this . poolResources . dispose ( ) ; try { Thread . sleep ( NUMBER ) ; } catch ( InterruptedException ex ) { ex . printStackTrace ( ) ; } this . scheduler . dispose ( ) ; } ) ; return new MonoToListenableFutureAdapter <> ( org.springframework.messaging.tcp.reactor.Mono<java.lang.Void> ) ; }  <METHOD_END>
<METHOD_START> private void void ( ) { try { java.lang.reflect.Method java.lang.reflect.Method = TcpResources .class . java.lang.reflect.Method ( STRING ) ; ReflectionUtils . makeAccessible ( java.lang.reflect.Method ) ; ReflectionUtils . invokeMethod ( java.lang.reflect.Method , TcpResources . get ( ) ) ; } catch ( java.lang.NoSuchMethodException java.lang.NoSuchMethodException ) { } }  <METHOD_END>
<METHOD_START> void ( TcpConnectionHandler < P > org.springframework.messaging.tcp.reactor.TcpConnectionHandler<P> ) { this . org.springframework.messaging.tcp.reactor.TcpConnectionHandler<P> = org.springframework.messaging.tcp.reactor.TcpConnectionHandler<P> ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override @ java.lang.SuppressWarnings ( STRING ) public org.springframework.messaging.tcp.reactor.Publisher<java.lang.Void> < java.lang.Void > org.springframework.messaging.tcp.reactor.Publisher<java.lang.Void> ( NettyInbound org.springframework.messaging.tcp.reactor.NettyInbound , NettyOutbound org.springframework.messaging.tcp.reactor.NettyOutbound ) { DirectProcessor < java.lang.Void > org.springframework.messaging.tcp.reactor.DirectProcessor<java.lang.Void> = DirectProcessor . create ( ) ; TcpConnection < P > org.springframework.messaging.tcp.reactor.TcpConnection<P> = new ReactorNettyTcpConnection <> ( org.springframework.messaging.tcp.reactor.NettyInbound , org.springframework.messaging.tcp.reactor.NettyOutbound , org.springframework.messaging.tcp.reactor.ReactorNettyCodec<P> , org.springframework.messaging.tcp.reactor.DirectProcessor<java.lang.Void> ) ; org.springframework.messaging.tcp.reactor.Scheduler . schedule ( ( ) connectionHandler . afterConnected ( connection ) ) ; org.springframework.messaging.tcp.reactor.NettyInbound . context ( ) . addHandler ( new org.springframework.messaging.tcp.reactor.ReactorNettyTcpClient.StompMessageDecoder <> ( org.springframework.messaging.tcp.reactor.ReactorNettyCodec<P> ) ) ; org.springframework.messaging.tcp.reactor.NettyInbound . receiveObject ( ) . cast ( Message .class ) . publishOn ( org.springframework.messaging.tcp.reactor.Scheduler , QueueSupplier . SMALL_BUFFER_SIZE ) . subscribe ( org.springframework.messaging.tcp.reactor.TcpConnectionHandler<P> :: handleMessage , org.springframework.messaging.tcp.reactor.TcpConnectionHandler<P> :: handleFailure , org.springframework.messaging.tcp.reactor.TcpConnectionHandler<P> :: afterConnectionClosed ) ; return org.springframework.messaging.tcp.reactor.DirectProcessor<java.lang.Void> ; }  <METHOD_END>
<METHOD_START> public void ( ReactorNettyCodec < P > org.springframework.messaging.tcp.reactor.ReactorNettyCodec<P> ) { this . org.springframework.messaging.tcp.reactor.ReactorNettyCodec<P> = org.springframework.messaging.tcp.reactor.ReactorNettyCodec<P> ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( ChannelHandlerContext org.springframework.messaging.tcp.reactor.ChannelHandlerContext , ByteBuf org.springframework.messaging.tcp.reactor.ByteBuf , java.util.List<java.lang.Object> < java.lang.Object > java.util.List<java.lang.Object> ) throws java.lang.Exception { java.util.Collection<org.springframework.messaging.tcp.reactor.Message<P>> < Message < P > > java.util.Collection<org.springframework.messaging.tcp.reactor.Message<P>> = org.springframework.messaging.tcp.reactor.ReactorNettyCodec<P> . decode ( org.springframework.messaging.tcp.reactor.ByteBuf ) ; java.util.List<java.lang.Object> . boolean ( java.util.Collection<org.springframework.messaging.tcp.reactor.Message<P>> ) ; }  <METHOD_END>
