<METHOD_START> public void ( ) { super( MimeTypeUtils . ALL ); }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( ResolvableType org.springframework.core.codec.ResolvableType , MimeType org.springframework.core.codec.MimeType ) { java.lang.Class<?> < ? > java.lang.Class<?> = org.springframework.core.codec.ResolvableType . getRawClass ( ) ; return ( InputStreamResource .class . boolean ( java.lang.Class<> ) || java.lang.Class<> . boolean ( ByteArrayResource .class ) ) && super. canDecode ( org.springframework.core.codec.ResolvableType , org.springframework.core.codec.MimeType ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.core.codec.Flux<org.springframework.core.codec.Resource> < Resource > org.springframework.core.codec.Flux<org.springframework.core.codec.Resource> ( Publisher < DataBuffer > org.springframework.core.codec.Publisher<org.springframework.core.codec.DataBuffer> , ResolvableType org.springframework.core.codec.ResolvableType , MimeType org.springframework.core.codec.MimeType , java.util.Map<java.lang.String,java.lang.Object> < java.lang.String , java.lang.Object > java.util.Map<java.lang.String,java.lang.Object> ) { java.lang.Class<?> < ? > java.lang.Class<?> = org.springframework.core.codec.ResolvableType . getRawClass ( ) ; Mono < byte [] > org.springframework.core.codec.Mono<byte[]> = Flux . from ( org.springframework.core.codec.Publisher<org.springframework.core.codec.DataBuffer> ) . reduce ( DataBuffer :: write ) . map ( dataBuffer -> { byte [] bytes = new byte [ dataBuffer . readableByteCount ( ) ] ; dataBuffer . read ( bytes ) ; DataBufferUtils . release ( dataBuffer ) ; return bytes ; } ) ; if ( InputStreamResource .class . boolean ( java.lang.Class<> ) ) { return Flux . from ( org.springframework.core.codec.Mono<byte[]> . map ( java.io.ByteArrayInputStream ::new ) . map ( InputStreamResource ::new ) ) ; } else if ( java.lang.Class<> . boolean ( ByteArrayResource .class ) ) { return Flux . from ( org.springframework.core.codec.Mono<byte[]> . map ( ByteArrayResource ::new ) ) ; } else { return Flux . error ( new java.lang.IllegalStateException ( STRING + java.lang.Class<> ) ) ; } }  <METHOD_END>
