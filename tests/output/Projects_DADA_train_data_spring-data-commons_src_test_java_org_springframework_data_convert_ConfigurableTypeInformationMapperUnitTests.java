<METHOD_START> @ Before public void void ( ) { org.springframework.data.convert.ConfigurableTypeInformationMapper = new ConfigurableTypeInformationMapper ( java.util.Collections . java.util.Map<java.lang.Class<java.lang.String>,java.lang.String> ( java.lang.String .class , STRING ) ) ; }  <METHOD_END>
<METHOD_START> @ Test ( expected = java.lang.IllegalArgumentException .class ) public void void ( ) { new ConfigurableTypeInformationMapper ( null ) ; }  <METHOD_END>
<METHOD_START> @ Test ( expected = java.lang.IllegalArgumentException .class ) public void void ( ) { java.util.Map<java.lang.Class<?>,java.lang.String> < java.lang.Class<?> < ? > , java.lang.String > java.util.Map<java.lang.Class<?>,java.lang.String> = new java.util.HashMap<java.lang.Class<?>,java.lang.String> <> ( ) ; java.util.Map<java.lang.Class<?>,java.lang.String> . java.lang.String ( java.lang.String .class , STRING ) ; java.util.Map<java.lang.Class<?>,java.lang.String> . java.lang.String ( java.lang.Object .class , STRING ) ; new ConfigurableTypeInformationMapper ( java.util.Map<java.lang.Class<?>,java.lang.String> ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { assertThat ( org.springframework.data.convert.ConfigurableTypeInformationMapper . createAliasFor ( ClassTypeInformation . from ( java.lang.String .class ) ) ) . isEqualTo ( Alias . of ( STRING ) ) ; assertThat ( org.springframework.data.convert.ConfigurableTypeInformationMapper . createAliasFor ( ClassTypeInformation . from ( java.lang.Object .class ) ) ) . isEqualTo ( Alias . NONE ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { assertThat ( org.springframework.data.convert.ConfigurableTypeInformationMapper . resolveTypeFrom ( Alias . of ( STRING ) ) ) . hasValue ( ClassTypeInformation . from ( java.lang.String .class ) ) ; assertThat ( org.springframework.data.convert.ConfigurableTypeInformationMapper . resolveTypeFrom ( Alias . of ( STRING ) ) ) . isEmpty ( ) ; }  <METHOD_END>
