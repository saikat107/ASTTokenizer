<METHOD_START> @ java.lang.SuppressWarnings ( STRING ) public static < T > T T ( java.util.List<java.lang.annotation.Annotation> < java.lang.annotation.Annotation > java.util.List<java.lang.annotation.Annotation> , java.lang.String java.lang.String , java.lang.Class<T> < T > java.lang.Class<T> ) { for ( java.lang.annotation.Annotation java.lang.annotation.Annotation : java.util.List<java.lang.annotation.Annotation> ) { if ( java.lang.annotation.Annotation != null ) { java.lang.Object java.lang.Object = AnnotationUtils . getValue ( java.lang.annotation.Annotation , java.lang.String ) ; if ( java.lang.Object != null && java.lang.Object . java.lang.Class<? extends java.lang.Object> ( ) == java.lang.Class<T> && boolean ( java.lang.Object ) ) { return ( T ) java.lang.Object ; } } } return null ; }  <METHOD_END>
<METHOD_START> public static boolean boolean ( java.lang.Object java.lang.Object ) { return java.lang.Object != null && ( ! ( java.lang.Object instanceof java.lang.String ) || ( StringUtils . hasText ( ( java.lang.String ) java.lang.Object ) ) ) && ( ! java.lang.Object . java.lang.Class<? extends java.lang.Object> ( ) . boolean ( ) || ( ( java.lang.Object [] ) java.lang.Object ) . int > NUMBER ) ; }  <METHOD_END>
<METHOD_START> public static java.lang.reflect.Method java.lang.reflect.Method ( java.lang.Object java.lang.Object , final java.lang.Class<? extends java.lang.annotation.Annotation> < ? extends java.lang.annotation.Annotation > java.lang.Class<? extends java.lang.annotation.Annotation> ) { final java.util.concurrent.atomic.AtomicReference<java.lang.reflect.Method> < java.lang.reflect.Method > java.util.concurrent.atomic.AtomicReference<java.lang.reflect.Method> = new java.util.concurrent.atomic.AtomicReference<java.lang.reflect.Method> < java.lang.reflect.Method > ( ) ; ReflectionUtils . doWithMethods ( java.lang.Class<?> ( java.lang.Object ) , method -> reference . compareAndSet ( null , method ) , method -> ReflectionUtils . USER_DECLARED_METHODS . matches ( method ) && AnnotatedElementUtils . isAnnotated ( method , annotationType . getName ( ) ) ) ; return java.util.concurrent.atomic.AtomicReference<java.lang.reflect.Method> . java.lang.reflect.Method ( ) ; }  <METHOD_END>
<METHOD_START> public static java.lang.annotation.Annotation java.lang.annotation.Annotation ( java.lang.annotation.Annotation [] java.lang.annotation.Annotation[] , boolean boolean ) { if ( java.lang.annotation.Annotation[] == null || java.lang.annotation.Annotation[] . int == NUMBER ) { return null ; } java.lang.annotation.Annotation java.lang.annotation.Annotation = null ; for ( java.lang.annotation.Annotation java.lang.annotation.Annotation : java.lang.annotation.Annotation[] ) { java.lang.Class<? extends java.lang.annotation.Annotation> < ? extends java.lang.annotation.Annotation > java.lang.Class<? extends java.lang.annotation.Annotation> = java.lang.annotation.Annotation . java.lang.Class<? extends java.lang.annotation.Annotation> ( ) ; if ( java.lang.Class<> . boolean ( Payload .class ) || java.lang.Class<> . boolean ( Header .class ) || java.lang.Class<> . boolean ( Headers .class ) || ( boolean && java.lang.Class<> . boolean ( Payloads .class ) ) ) { if ( java.lang.annotation.Annotation != null ) { throw new MessagingException ( STRING + STRING + java.lang.annotation.Annotation . java.lang.Class<? extends java.lang.annotation.Annotation> ( ) . java.lang.String ( ) + STRING + java.lang.annotation.Annotation . java.lang.Class<? extends java.lang.annotation.Annotation> ( ) . java.lang.String ( ) + STRING ) ; } java.lang.annotation.Annotation = java.lang.annotation.Annotation ; } } return java.lang.annotation.Annotation ; }  <METHOD_END>
<METHOD_START> private static java.lang.Class<?> < ? > java.lang.Class<?> ( java.lang.Object java.lang.Object ) { java.lang.Class<?> < ? > java.lang.Class<?> = java.lang.Object . java.lang.Class<? extends java.lang.Object> ( ) ; if ( AopUtils . isAopProxy ( java.lang.Object ) ) { java.lang.Class<?> = AopUtils . getTargetClass ( java.lang.Object ) ; } else if ( ClassUtils . isCglibProxyClass ( java.lang.Class<> ) ) { java.lang.Class<?> < ? > java.lang.Class<?> = java.lang.Object . java.lang.Class<? extends java.lang.Object> ( ) . java.lang.Class<? super > ( ) ; if ( ! java.lang.Object .class . boolean ( java.lang.Class<> ) ) { java.lang.Class<?> = java.lang.Class<> ; } } return java.lang.Class<> ; }  <METHOD_END>
<METHOD_START> private void ( ) { }  <METHOD_END>
