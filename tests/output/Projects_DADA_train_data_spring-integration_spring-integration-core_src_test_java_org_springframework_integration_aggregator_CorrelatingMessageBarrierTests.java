<METHOD_START> @ Before public void void ( ) { org.springframework.integration.aggregator.CorrelatingMessageBarrier = new CorrelatingMessageBarrier ( ) ; org.springframework.integration.aggregator.CorrelatingMessageBarrier . setCorrelationStrategy ( org.springframework.integration.aggregator.CorrelationStrategy ) ; org.springframework.integration.aggregator.CorrelatingMessageBarrier . setReleaseStrategy ( org.springframework.integration.aggregator.ReleaseStrategy ) ; when ( org.springframework.integration.aggregator.CorrelationStrategy . getCorrelationKey ( isA ( Message .class ) ) ) . thenReturn ( STRING ) ; when ( org.springframework.integration.aggregator.ReleaseStrategy . canRelease ( isA ( MessageGroup .class ) ) ) . thenReturn ( true ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { Message < java.lang.Object > org.springframework.integration.aggregator.Message<java.lang.Object> = org.springframework.integration.aggregator.Message<java.lang.Object> ( ) ; org.springframework.integration.aggregator.CorrelatingMessageBarrier . handleMessage ( org.springframework.integration.aggregator.Message<java.lang.Object> ) ; assertThat ( org.springframework.integration.aggregator.CorrelatingMessageBarrier . receive ( ) , is ( org.springframework.integration.aggregator.Message<java.lang.Object> ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.InterruptedException { Message < java.lang.Object > org.springframework.integration.aggregator.Message<java.lang.Object> = org.springframework.integration.aggregator.Message<java.lang.Object> ( ) ; Message < java.lang.Object > org.springframework.integration.aggregator.Message<java.lang.Object> = org.springframework.integration.aggregator.Message<java.lang.Object> ( ) ; org.springframework.integration.aggregator.CorrelatingMessageBarrier . handleMessage ( org.springframework.integration.aggregator.Message<java.lang.Object> ) ; verify ( org.springframework.integration.aggregator.CorrelationStrategy ) . getCorrelationKey ( org.springframework.integration.aggregator.Message<java.lang.Object> ) ; assertThat ( org.springframework.integration.aggregator.CorrelatingMessageBarrier . receive ( ) , is ( notNullValue ( ) ) ) ; org.springframework.integration.aggregator.CorrelatingMessageBarrier . handleMessage ( org.springframework.integration.aggregator.Message<java.lang.Object> ) ; assertThat ( org.springframework.integration.aggregator.CorrelatingMessageBarrier . receive ( ) , is ( notNullValue ( ) ) ) ; assertThat ( org.springframework.integration.aggregator.CorrelatingMessageBarrier . receive ( ) , is ( nullValue ( ) ) ) ; }  <METHOD_END>
<METHOD_START> @ Test ( timeout = NUMBER ) public void void ( ) { org.springframework.integration.aggregator.CorrelatingMessageBarrierTests.OneMessagePerKeyReleaseStrategy org.springframework.integration.aggregator.CorrelatingMessageBarrierTests.OneMessagePerKeyReleaseStrategy = new org.springframework.integration.aggregator.CorrelatingMessageBarrierTests.OneMessagePerKeyReleaseStrategy ( ) ; org.springframework.integration.aggregator.CorrelatingMessageBarrier . setReleaseStrategy ( org.springframework.integration.aggregator.CorrelatingMessageBarrierTests.OneMessagePerKeyReleaseStrategy ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; for ( int int = NUMBER ; int < NUMBER ; int ++ ) { void ( org.springframework.integration.aggregator.CorrelatingMessageBarrier , org.springframework.integration.aggregator.Message<java.lang.Object> ( ) , java.util.concurrent.CountDownLatch , java.util.concurrent.CountDownLatch ) ; } java.util.concurrent.CountDownLatch . void ( ) ; try { java.util.concurrent.CountDownLatch . void ( ) ; } catch ( java.lang.InterruptedException java.lang.InterruptedException ) { java.lang.Thread . java.lang.Thread ( ) . void ( ) ; } assertThat ( ( org.springframework.integration.aggregator.CorrelatingMessageBarrier . receive ( ) ) , is ( notNullValue ( ) ) ) ; for ( int int = NUMBER ; int < NUMBER ; int ++ ) { org.springframework.integration.aggregator.CorrelatingMessageBarrierTests.OneMessagePerKeyReleaseStrategy . void ( STRING ) ; assertThat ( ( org.springframework.integration.aggregator.CorrelatingMessageBarrier . receive ( ) ) , is ( notNullValue ( ) ) ) ; } }  <METHOD_END>
<METHOD_START> private void void ( final MessageHandler org.springframework.integration.aggregator.MessageHandler , final Message < java.lang.Object > org.springframework.integration.aggregator.Message<java.lang.Object> , final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch , final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch ) { java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . void ( ( ) { try { java.util.concurrent.CountDownLatch . void ( ) ; } catch ( java.lang.InterruptedException java.lang.InterruptedException ) { java.lang.Thread . java.lang.Thread ( ) . void ( ) ; } org.springframework.integration.aggregator.MessageHandler . handleMessage ( org.springframework.integration.aggregator.Message<java.lang.Object> ) ; java.util.concurrent.CountDownLatch . void ( ) ; } ) ; }  <METHOD_END>
<METHOD_START> private org.springframework.integration.aggregator.Message<java.lang.Object> < java.lang.Object > org.springframework.integration.aggregator.Message<java.lang.Object> ( ) { return MessageBuilder . withPayload ( ( java.lang.Object ) STRING ) . build ( ) ; }  <METHOD_END>
<METHOD_START> void ( ) { super(); }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( MessageGroup org.springframework.integration.aggregator.MessageGroup ) { java.lang.Object java.lang.Object = org.springframework.integration.aggregator.MessageGroup . getGroupId ( ) ; java.util.concurrent.Semaphore java.util.concurrent.Semaphore = java.util.concurrent.Semaphore ( java.lang.Object ) ; return java.util.concurrent.Semaphore . boolean ( ) ; }  <METHOD_END>
<METHOD_START> private java.util.concurrent.Semaphore java.util.concurrent.Semaphore ( java.lang.Object java.lang.Object ) { java.util.concurrent.Semaphore java.util.concurrent.Semaphore = java.util.concurrent.ConcurrentMap<java.lang.Object,java.util.concurrent.Semaphore> . java.util.concurrent.Semaphore ( java.lang.Object ) ; if ( java.util.concurrent.Semaphore == null ) { java.util.concurrent.ConcurrentMap<java.lang.Object,java.util.concurrent.Semaphore> . java.util.concurrent.Semaphore ( java.lang.Object , new java.util.concurrent.Semaphore ( NUMBER ) ) ; java.util.concurrent.Semaphore = java.util.concurrent.ConcurrentMap<java.lang.Object,java.util.concurrent.Semaphore> . java.util.concurrent.Semaphore ( java.lang.Object ) ; } return java.util.concurrent.Semaphore ; }  <METHOD_END>
<METHOD_START> public void void ( java.lang.String java.lang.String ) { java.util.concurrent.Semaphore java.util.concurrent.Semaphore = java.util.concurrent.ConcurrentMap<java.lang.Object,java.util.concurrent.Semaphore> . java.util.concurrent.Semaphore ( java.lang.String ) ; if ( java.util.concurrent.Semaphore != null ) { java.util.concurrent.Semaphore . void ( ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.SuppressWarnings ( STRING ) public void void ( ) { for ( java.util.concurrent.Semaphore java.util.concurrent.Semaphore : java.util.concurrent.ConcurrentMap<java.lang.Object,java.util.concurrent.Semaphore> . java.util.Collection<java.util.concurrent.Semaphore> ( ) ) { java.util.concurrent.Semaphore . void ( ) ; } }  <METHOD_END>
