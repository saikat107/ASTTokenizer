<METHOD_START> @ After public void void ( ) { if ( org.springframework.scheduling.annotation.AnnotationConfigApplicationContext != null ) { org.springframework.scheduling.annotation.AnnotationConfigApplicationContext . close ( ) ; } }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.InterruptedException { Assume . group ( TestGroup . PERFORMANCE ) ; org.springframework.scheduling.annotation.AnnotationConfigApplicationContext = new AnnotationConfigApplicationContext ( org.springframework.scheduling.annotation.EnableSchedulingTests.FixedRateTaskConfig .class ) ; java.lang.Thread . void ( NUMBER ) ; assertThat ( org.springframework.scheduling.annotation.AnnotationConfigApplicationContext . getBean ( java.util.concurrent.atomic.AtomicInteger .class ) . get ( ) , greaterThanOrEqualTo ( NUMBER ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.InterruptedException { Assume . group ( TestGroup . PERFORMANCE ) ; org.springframework.scheduling.annotation.AnnotationConfigApplicationContext = new AnnotationConfigApplicationContext ( org.springframework.scheduling.annotation.EnableSchedulingTests.FixedRateTaskConfigSubclass .class ) ; java.lang.Thread . void ( NUMBER ) ; assertThat ( org.springframework.scheduling.annotation.AnnotationConfigApplicationContext . getBean ( java.util.concurrent.atomic.AtomicInteger .class ) . get ( ) , greaterThanOrEqualTo ( NUMBER ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.InterruptedException { Assume . group ( TestGroup . PERFORMANCE ) ; org.springframework.scheduling.annotation.AnnotationConfigApplicationContext = new AnnotationConfigApplicationContext ( org.springframework.scheduling.annotation.EnableSchedulingTests.ExplicitSchedulerConfig .class ) ; java.lang.Thread . void ( NUMBER ) ; assertThat ( org.springframework.scheduling.annotation.AnnotationConfigApplicationContext . getBean ( java.util.concurrent.atomic.AtomicInteger .class ) . get ( ) , greaterThanOrEqualTo ( NUMBER ) ) ; assertThat ( org.springframework.scheduling.annotation.AnnotationConfigApplicationContext . getBean ( org.springframework.scheduling.annotation.EnableSchedulingTests.ExplicitSchedulerConfig .class ) . threadName , startsWith ( STRING ) ) ; assertTrue ( java.util.Arrays . java.util.List ( org.springframework.scheduling.annotation.AnnotationConfigApplicationContext . getDefaultListableBeanFactory ( ) . getDependentBeans ( STRING ) ) . contains ( TaskManagementConfigUtils . SCHEDULED_ANNOTATION_PROCESSOR_BEAN_NAME ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { org.springframework.scheduling.annotation.AnnotationConfigApplicationContext = new AnnotationConfigApplicationContext ( org.springframework.scheduling.annotation.EnableSchedulingTests.AmbiguousExplicitSchedulerConfig .class ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.InterruptedException { Assume . group ( TestGroup . PERFORMANCE ) ; org.springframework.scheduling.annotation.AnnotationConfigApplicationContext = new AnnotationConfigApplicationContext ( org.springframework.scheduling.annotation.EnableSchedulingTests.ExplicitScheduledTaskRegistrarConfig .class ) ; java.lang.Thread . void ( NUMBER ) ; assertThat ( org.springframework.scheduling.annotation.AnnotationConfigApplicationContext . getBean ( java.util.concurrent.atomic.AtomicInteger .class ) . get ( ) , greaterThanOrEqualTo ( NUMBER ) ) ; assertThat ( org.springframework.scheduling.annotation.AnnotationConfigApplicationContext . getBean ( org.springframework.scheduling.annotation.EnableSchedulingTests.ExplicitScheduledTaskRegistrarConfig .class ) . threadName , startsWith ( STRING ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { org.springframework.scheduling.annotation.AnnotationConfigApplicationContext = new AnnotationConfigApplicationContext ( org.springframework.scheduling.annotation.EnableSchedulingTests.SchedulingEnabled_withAmbiguousTaskSchedulers_butNoActualTasks .class ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { org.springframework.scheduling.annotation.AnnotationConfigApplicationContext = new AnnotationConfigApplicationContext ( org.springframework.scheduling.annotation.EnableSchedulingTests.SchedulingEnabled_withAmbiguousTaskSchedulers_andSingleTask .class ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.InterruptedException { Assume . group ( TestGroup . PERFORMANCE ) ; org.springframework.scheduling.annotation.AnnotationConfigApplicationContext = new AnnotationConfigApplicationContext ( org.springframework.scheduling.annotation.EnableSchedulingTests.SchedulingEnabled_withAmbiguousTaskSchedulers_andSingleTask_disambiguatedByScheduledTaskRegistrar .class ) ; java.lang.Thread . void ( NUMBER ) ; assertThat ( org.springframework.scheduling.annotation.AnnotationConfigApplicationContext . getBean ( org.springframework.scheduling.annotation.EnableSchedulingTests.ThreadAwareWorker .class ) . executedByThread , startsWith ( STRING ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.InterruptedException { Assume . group ( TestGroup . PERFORMANCE ) ; org.springframework.scheduling.annotation.AnnotationConfigApplicationContext = new AnnotationConfigApplicationContext ( org.springframework.scheduling.annotation.EnableSchedulingTests.SchedulingEnabled_withAmbiguousTaskSchedulers_andSingleTask_disambiguatedBySchedulerNameAttribute .class ) ; java.lang.Thread . void ( NUMBER ) ; assertThat ( org.springframework.scheduling.annotation.AnnotationConfigApplicationContext . getBean ( org.springframework.scheduling.annotation.EnableSchedulingTests.ThreadAwareWorker .class ) . executedByThread , startsWith ( STRING ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.InterruptedException { Assume . group ( TestGroup . PERFORMANCE ) ; org.springframework.scheduling.annotation.AnnotationConfigApplicationContext = new AnnotationConfigApplicationContext ( org.springframework.scheduling.annotation.EnableSchedulingTests.SchedulingEnabled_withTaskAddedVia_configureTasks .class ) ; java.lang.Thread . void ( NUMBER ) ; assertThat ( org.springframework.scheduling.annotation.AnnotationConfigApplicationContext . getBean ( org.springframework.scheduling.annotation.EnableSchedulingTests.ThreadAwareWorker .class ) . executedByThread , startsWith ( STRING ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.InterruptedException { Assume . group ( TestGroup . PERFORMANCE ) ; org.springframework.scheduling.annotation.AnnotationConfigApplicationContext = new AnnotationConfigApplicationContext ( org.springframework.scheduling.annotation.EnableSchedulingTests.TriggerTaskConfig .class ) ; java.lang.Thread . void ( NUMBER ) ; assertThat ( org.springframework.scheduling.annotation.AnnotationConfigApplicationContext . getBean ( java.util.concurrent.atomic.AtomicInteger .class ) . get ( ) , greaterThan ( NUMBER ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.InterruptedException { Assume . group ( TestGroup . PERFORMANCE ) ; org.springframework.scheduling.annotation.AnnotationConfigApplicationContext = new AnnotationConfigApplicationContext ( org.springframework.scheduling.annotation.EnableSchedulingTests.FixedRateTaskConfig_withInitialDelay .class ) ; java.lang.Thread . void ( NUMBER ) ; java.util.concurrent.atomic.AtomicInteger java.util.concurrent.atomic.AtomicInteger = org.springframework.scheduling.annotation.AnnotationConfigApplicationContext . getBean ( java.util.concurrent.atomic.AtomicInteger .class ) ; assertThat ( java.util.concurrent.atomic.AtomicInteger . int ( ) , both ( greaterThan ( NUMBER ) ) . and ( lessThanOrEqualTo ( NUMBER ) ) ) ; }  <METHOD_END>
<METHOD_START> @ Bean public java.util.concurrent.atomic.AtomicInteger java.util.concurrent.atomic.AtomicInteger ( ) { return new java.util.concurrent.atomic.AtomicInteger ( ) ; }  <METHOD_END>
<METHOD_START> @ Scheduled ( fixedRate = NUMBER ) public void void ( ) { java.util.concurrent.atomic.AtomicInteger ( ) . int ( ) ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.scheduling.annotation.TaskScheduler org.springframework.scheduling.annotation.TaskScheduler ( ) { ThreadPoolTaskScheduler org.springframework.scheduling.annotation.ThreadPoolTaskScheduler = new ThreadPoolTaskScheduler ( ) ; org.springframework.scheduling.annotation.ThreadPoolTaskScheduler . setThreadNamePrefix ( STRING ) ; return org.springframework.scheduling.annotation.ThreadPoolTaskScheduler ; }  <METHOD_END>
<METHOD_START> @ Bean public java.util.concurrent.atomic.AtomicInteger java.util.concurrent.atomic.AtomicInteger ( ) { return new java.util.concurrent.atomic.AtomicInteger ( ) ; }  <METHOD_END>
<METHOD_START> @ Scheduled ( fixedRate = NUMBER ) public void void ( ) { java.lang.String = java.lang.Thread . java.lang.Thread ( ) . java.lang.String ( ) ; java.util.concurrent.atomic.AtomicInteger ( ) . int ( ) ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.scheduling.annotation.TaskScheduler org.springframework.scheduling.annotation.TaskScheduler ( ) { ThreadPoolTaskScheduler org.springframework.scheduling.annotation.ThreadPoolTaskScheduler = new ThreadPoolTaskScheduler ( ) ; org.springframework.scheduling.annotation.ThreadPoolTaskScheduler . setThreadNamePrefix ( STRING ) ; return org.springframework.scheduling.annotation.ThreadPoolTaskScheduler ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.scheduling.annotation.TaskScheduler org.springframework.scheduling.annotation.TaskScheduler ( ) { ThreadPoolTaskScheduler org.springframework.scheduling.annotation.ThreadPoolTaskScheduler = new ThreadPoolTaskScheduler ( ) ; org.springframework.scheduling.annotation.ThreadPoolTaskScheduler . setThreadNamePrefix ( STRING ) ; return org.springframework.scheduling.annotation.ThreadPoolTaskScheduler ; }  <METHOD_END>
<METHOD_START> @ Scheduled ( fixedRate = NUMBER ) public void void ( ) {		}  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.scheduling.annotation.TaskScheduler org.springframework.scheduling.annotation.TaskScheduler ( ) { ThreadPoolTaskScheduler org.springframework.scheduling.annotation.ThreadPoolTaskScheduler = new ThreadPoolTaskScheduler ( ) ; org.springframework.scheduling.annotation.ThreadPoolTaskScheduler . setThreadNamePrefix ( STRING ) ; return org.springframework.scheduling.annotation.ThreadPoolTaskScheduler ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.scheduling.annotation.TaskScheduler org.springframework.scheduling.annotation.TaskScheduler ( ) { ThreadPoolTaskScheduler org.springframework.scheduling.annotation.ThreadPoolTaskScheduler = new ThreadPoolTaskScheduler ( ) ; org.springframework.scheduling.annotation.ThreadPoolTaskScheduler . setThreadNamePrefix ( STRING ) ; return org.springframework.scheduling.annotation.ThreadPoolTaskScheduler ; }  <METHOD_END>
<METHOD_START> @ Bean public java.util.concurrent.atomic.AtomicInteger java.util.concurrent.atomic.AtomicInteger ( ) { return new java.util.concurrent.atomic.AtomicInteger ( ) ; }  <METHOD_END>
<METHOD_START> @ Scheduled ( fixedRate = NUMBER ) public void void ( ) { java.lang.String = java.lang.Thread . java.lang.Thread ( ) . java.lang.String ( ) ; java.util.concurrent.atomic.AtomicInteger ( ) . int ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ScheduledTaskRegistrar org.springframework.scheduling.annotation.ScheduledTaskRegistrar ) { org.springframework.scheduling.annotation.ScheduledTaskRegistrar . setScheduler ( org.springframework.scheduling.annotation.TaskScheduler ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.scheduling.annotation.TaskScheduler org.springframework.scheduling.annotation.TaskScheduler ( ) { ThreadPoolTaskScheduler org.springframework.scheduling.annotation.ThreadPoolTaskScheduler = new ThreadPoolTaskScheduler ( ) ; org.springframework.scheduling.annotation.ThreadPoolTaskScheduler . setThreadNamePrefix ( STRING ) ; return org.springframework.scheduling.annotation.ThreadPoolTaskScheduler ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.scheduling.annotation.TaskScheduler org.springframework.scheduling.annotation.TaskScheduler ( ) { ThreadPoolTaskScheduler org.springframework.scheduling.annotation.ThreadPoolTaskScheduler = new ThreadPoolTaskScheduler ( ) ; org.springframework.scheduling.annotation.ThreadPoolTaskScheduler . setThreadNamePrefix ( STRING ) ; return org.springframework.scheduling.annotation.ThreadPoolTaskScheduler ; }  <METHOD_END>
<METHOD_START> @ Scheduled ( fixedRate = NUMBER ) public void void ( ) {		}  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.scheduling.annotation.TaskScheduler org.springframework.scheduling.annotation.TaskScheduler ( ) { ThreadPoolTaskScheduler org.springframework.scheduling.annotation.ThreadPoolTaskScheduler = new ThreadPoolTaskScheduler ( ) ; org.springframework.scheduling.annotation.ThreadPoolTaskScheduler . setThreadNamePrefix ( STRING ) ; return org.springframework.scheduling.annotation.ThreadPoolTaskScheduler ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.scheduling.annotation.TaskScheduler org.springframework.scheduling.annotation.TaskScheduler ( ) { ThreadPoolTaskScheduler org.springframework.scheduling.annotation.ThreadPoolTaskScheduler = new ThreadPoolTaskScheduler ( ) ; org.springframework.scheduling.annotation.ThreadPoolTaskScheduler . setThreadNamePrefix ( STRING ) ; return org.springframework.scheduling.annotation.ThreadPoolTaskScheduler ; }  <METHOD_END>
<METHOD_START> @ Scheduled ( fixedRate = NUMBER ) public void void ( ) { org.springframework.scheduling.annotation.EnableSchedulingTests.ThreadAwareWorker ( ) . java.lang.String = java.lang.Thread . java.lang.Thread ( ) . java.lang.String ( ) ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.scheduling.annotation.EnableSchedulingTests.ThreadAwareWorker org.springframework.scheduling.annotation.EnableSchedulingTests.ThreadAwareWorker ( ) { return new org.springframework.scheduling.annotation.EnableSchedulingTests.ThreadAwareWorker ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ScheduledTaskRegistrar org.springframework.scheduling.annotation.ScheduledTaskRegistrar ) { org.springframework.scheduling.annotation.ScheduledTaskRegistrar . setScheduler ( org.springframework.scheduling.annotation.TaskScheduler ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.scheduling.annotation.TaskScheduler org.springframework.scheduling.annotation.TaskScheduler ( ) { ThreadPoolTaskScheduler org.springframework.scheduling.annotation.ThreadPoolTaskScheduler = new ThreadPoolTaskScheduler ( ) ; org.springframework.scheduling.annotation.ThreadPoolTaskScheduler . setThreadNamePrefix ( STRING ) ; return org.springframework.scheduling.annotation.ThreadPoolTaskScheduler ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.scheduling.annotation.TaskScheduler org.springframework.scheduling.annotation.TaskScheduler ( ) { ThreadPoolTaskScheduler org.springframework.scheduling.annotation.ThreadPoolTaskScheduler = new ThreadPoolTaskScheduler ( ) ; org.springframework.scheduling.annotation.ThreadPoolTaskScheduler . setThreadNamePrefix ( STRING ) ; return org.springframework.scheduling.annotation.ThreadPoolTaskScheduler ; }  <METHOD_END>
<METHOD_START> @ Scheduled ( fixedRate = NUMBER ) public void void ( ) { org.springframework.scheduling.annotation.EnableSchedulingTests.ThreadAwareWorker ( ) . java.lang.String = java.lang.Thread . java.lang.Thread ( ) . java.lang.String ( ) ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.scheduling.annotation.EnableSchedulingTests.ThreadAwareWorker org.springframework.scheduling.annotation.EnableSchedulingTests.ThreadAwareWorker ( ) { return new org.springframework.scheduling.annotation.EnableSchedulingTests.ThreadAwareWorker ( ) ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.scheduling.annotation.TaskScheduler org.springframework.scheduling.annotation.TaskScheduler ( ) { ThreadPoolTaskScheduler org.springframework.scheduling.annotation.ThreadPoolTaskScheduler = new ThreadPoolTaskScheduler ( ) ; org.springframework.scheduling.annotation.ThreadPoolTaskScheduler . setThreadNamePrefix ( STRING ) ; return org.springframework.scheduling.annotation.ThreadPoolTaskScheduler ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.scheduling.annotation.TaskScheduler org.springframework.scheduling.annotation.TaskScheduler ( ) { ThreadPoolTaskScheduler org.springframework.scheduling.annotation.ThreadPoolTaskScheduler = new ThreadPoolTaskScheduler ( ) ; org.springframework.scheduling.annotation.ThreadPoolTaskScheduler . setThreadNamePrefix ( STRING ) ; return org.springframework.scheduling.annotation.ThreadPoolTaskScheduler ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ScheduledTaskRegistrar org.springframework.scheduling.annotation.ScheduledTaskRegistrar ) { org.springframework.scheduling.annotation.ScheduledTaskRegistrar . setScheduler ( org.springframework.scheduling.annotation.TaskScheduler ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.scheduling.annotation.EnableSchedulingTests.ThreadAwareWorker org.springframework.scheduling.annotation.EnableSchedulingTests.ThreadAwareWorker ( ) { return new org.springframework.scheduling.annotation.EnableSchedulingTests.ThreadAwareWorker ( ) ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.scheduling.annotation.TaskScheduler org.springframework.scheduling.annotation.TaskScheduler ( ) { return new ThreadPoolTaskScheduler ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ScheduledTaskRegistrar org.springframework.scheduling.annotation.ScheduledTaskRegistrar ) { org.springframework.scheduling.annotation.ScheduledTaskRegistrar . setScheduler ( org.springframework.scheduling.annotation.TaskScheduler ( ) ) ; org.springframework.scheduling.annotation.ScheduledTaskRegistrar . addFixedRateTask ( new IntervalTask ( new java.lang.Runnable ( ) { @ java.lang.Override public void void ( ) { org.springframework.scheduling.annotation.EnableSchedulingTests.ThreadAwareWorker ( ) . java.lang.String = java.lang.Thread . java.lang.Thread ( ) . java.lang.String ( ) ; } } , NUMBER , NUMBER ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ) { org.springframework.scheduling.annotation.EnableSchedulingTests.ThreadAwareWorker ( ) . java.lang.String = java.lang.Thread . java.lang.Thread ( ) . java.lang.String ( ) ; }  <METHOD_END>
<METHOD_START> @ Bean public java.util.concurrent.atomic.AtomicInteger java.util.concurrent.atomic.AtomicInteger ( ) { return new java.util.concurrent.atomic.AtomicInteger ( ) ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.scheduling.annotation.TaskScheduler org.springframework.scheduling.annotation.TaskScheduler ( ) { ThreadPoolTaskScheduler org.springframework.scheduling.annotation.ThreadPoolTaskScheduler = new ThreadPoolTaskScheduler ( ) ; org.springframework.scheduling.annotation.ThreadPoolTaskScheduler . initialize ( ) ; org.springframework.scheduling.annotation.ThreadPoolTaskScheduler . schedule ( new java.lang.Runnable ( ) { @ java.lang.Override public void void ( ) { java.util.concurrent.atomic.AtomicInteger ( ) . int ( ) ; } } , new Trigger ( ) { @ java.lang.Override public java.util.Date java.util.Date ( TriggerContext org.springframework.scheduling.annotation.TriggerContext ) { return new java.util.Date ( new java.util.Date ( ) . long ( ) + NUMBER ) ; } } ) ; return org.springframework.scheduling.annotation.ThreadPoolTaskScheduler ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ) { java.util.concurrent.atomic.AtomicInteger ( ) . int ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.util.Date java.util.Date ( TriggerContext org.springframework.scheduling.annotation.TriggerContext ) { return new java.util.Date ( new java.util.Date ( ) . long ( ) + NUMBER ) ; }  <METHOD_END>
<METHOD_START> @ Bean public java.util.concurrent.atomic.AtomicInteger java.util.concurrent.atomic.AtomicInteger ( ) { return new java.util.concurrent.atomic.AtomicInteger ( ) ; }  <METHOD_END>
<METHOD_START> @ Scheduled ( initialDelay = NUMBER , fixedRate = NUMBER ) public void void ( ) { java.util.concurrent.atomic.AtomicInteger ( ) . int ( ) ; }  <METHOD_END>
