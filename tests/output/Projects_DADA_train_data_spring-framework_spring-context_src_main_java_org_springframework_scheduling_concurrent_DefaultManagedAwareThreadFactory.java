<METHOD_START> public void void ( JndiTemplate org.springframework.scheduling.concurrent.JndiTemplate ) { this . org.springframework.scheduling.concurrent.JndiLocatorDelegate . setJndiTemplate ( org.springframework.scheduling.concurrent.JndiTemplate ) ; }  <METHOD_END>
<METHOD_START> public void void ( java.util.Properties java.util.Properties ) { this . org.springframework.scheduling.concurrent.JndiLocatorDelegate . setJndiEnvironment ( java.util.Properties ) ; }  <METHOD_END>
<METHOD_START> public void void ( boolean boolean ) { this . org.springframework.scheduling.concurrent.JndiLocatorDelegate . setResourceRef ( boolean ) ; }  <METHOD_END>
<METHOD_START> public void void ( java.lang.String java.lang.String ) { this . java.lang.String = java.lang.String ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ) javax.naming.NamingException { if ( this . java.lang.String != null ) { try { this . java.util.concurrent.ThreadFactory = this . org.springframework.scheduling.concurrent.JndiLocatorDelegate . lookup ( this . java.lang.String , java.util.concurrent.ThreadFactory .class ) ; } catch ( javax.naming.NamingException javax.naming.NamingException ) { if ( org.springframework.scheduling.concurrent.Log . isDebugEnabled ( ) ) { org.springframework.scheduling.concurrent.Log . debug ( STRING + this . java.lang.String + STRING , javax.naming.NamingException ) ; } org.springframework.scheduling.concurrent.Log . info ( STRING + STRING ) ; } } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.Thread java.lang.Thread ( java.lang.Runnable java.lang.Runnable ) { if ( this . java.util.concurrent.ThreadFactory != null ) { return this . java.util.concurrent.ThreadFactory . java.lang.Thread ( java.lang.Runnable ) ; } else { return super. newThread ( java.lang.Runnable ) ; } }  <METHOD_END>
