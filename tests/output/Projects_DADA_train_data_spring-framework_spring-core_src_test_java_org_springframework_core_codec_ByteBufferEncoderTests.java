<METHOD_START> @ Before public void void ( ) { this . org.springframework.core.codec.ByteBufferEncoder = new ByteBufferEncoder ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { assertTrue ( this . org.springframework.core.codec.ByteBufferEncoder . canEncode ( ResolvableType . forClass ( java.nio.ByteBuffer .class ) , MimeTypeUtils . TEXT_PLAIN ) ) ; assertFalse ( this . org.springframework.core.codec.ByteBufferEncoder . canEncode ( ResolvableType . forClass ( java.lang.Integer .class ) , MimeTypeUtils . TEXT_PLAIN ) ) ; assertTrue ( this . org.springframework.core.codec.ByteBufferEncoder . canEncode ( ResolvableType . forClass ( java.nio.ByteBuffer .class ) , MimeTypeUtils . APPLICATION_JSON ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { byte [] byte[] = STRING . byte[] ( java.nio.charset.StandardCharsets . java.nio.charset.Charset ) ; byte [] byte[] = STRING . byte[] ( java.nio.charset.StandardCharsets . java.nio.charset.Charset ) ; Flux < java.nio.ByteBuffer > org.springframework.core.codec.Flux<java.nio.ByteBuffer> = Flux . just ( java.nio.ByteBuffer . java.nio.ByteBuffer ( byte[] ) , java.nio.ByteBuffer . java.nio.ByteBuffer ( byte[] ) ) ; Flux < DataBuffer > org.springframework.core.codec.Flux<org.springframework.core.codec.DataBuffer> = this . org.springframework.core.codec.ByteBufferEncoder . encode ( org.springframework.core.codec.Flux<java.nio.ByteBuffer> , this . bufferFactory , ResolvableType . forClassWithGenerics ( Publisher .class , java.nio.ByteBuffer .class ) , null , java.util.Collections . java.util.Map<java.lang.Object,java.lang.Object> ( ) ) ; StepVerifier . create ( org.springframework.core.codec.Flux<org.springframework.core.codec.DataBuffer> ) . consumeNextWith ( b -> { byte [] buf = new byte [ NUMBER ] ; b . read ( buf ) ; assertArrayEquals ( fooBytes , buf ) ; } ) . consumeNextWith ( b -> { byte [] buf = new byte [ NUMBER ] ; b . read ( buf ) ; assertArrayEquals ( barBytes , buf ) ; } ) . expectComplete ( ) . verify ( ) ; }  <METHOD_END>
