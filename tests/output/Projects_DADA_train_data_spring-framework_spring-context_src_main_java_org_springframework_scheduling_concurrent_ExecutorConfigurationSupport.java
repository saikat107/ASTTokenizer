<METHOD_START> public void void ( java.util.concurrent.ThreadFactory java.util.concurrent.ThreadFactory ) { this . java.util.concurrent.ThreadFactory = ( java.util.concurrent.ThreadFactory != null ? java.util.concurrent.ThreadFactory : this ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( java.lang.String java.lang.String ) { super. setThreadNamePrefix ( java.lang.String ) ; this . boolean = true ; }  <METHOD_END>
<METHOD_START> public void void ( java.util.concurrent.RejectedExecutionHandler java.util.concurrent.RejectedExecutionHandler ) { this . java.util.concurrent.RejectedExecutionHandler = ( java.util.concurrent.RejectedExecutionHandler != null ? java.util.concurrent.RejectedExecutionHandler : new java.util.concurrent.ThreadPoolExecutor . java.util.concurrent.ThreadPoolExecutor.AbortPolicy ( ) ) ; }  <METHOD_END>
<METHOD_START> public void void ( boolean boolean ) { this . boolean = boolean ; }  <METHOD_END>
<METHOD_START> public void void ( int int ) { this . int = int ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( java.lang.String java.lang.String ) { this . java.lang.String = java.lang.String ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ) { void ( ) ; }  <METHOD_END>
<METHOD_START> public void void ( ) { if ( org.springframework.scheduling.concurrent.Log . isInfoEnabled ( ) ) { org.springframework.scheduling.concurrent.Log . info ( STRING + ( this . java.lang.String != null ? STRING + this . java.lang.String + STRING : STRING ) ) ; } if ( ! this . boolean && this . java.lang.String != null ) { void ( this . java.lang.String + STRING ) ; } this . java.util.concurrent.ExecutorService = java.util.concurrent.ExecutorService ( this . java.util.concurrent.ThreadFactory , this . java.util.concurrent.RejectedExecutionHandler ) ; }  <METHOD_END>
<METHOD_START> protected abstract java.util.concurrent.ExecutorService java.util.concurrent.ExecutorService ( java.util.concurrent.ThreadFactory java.util.concurrent.ThreadFactory , java.util.concurrent.RejectedExecutionHandler java.util.concurrent.RejectedExecutionHandler );  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ) { void ( ) ; }  <METHOD_END>
<METHOD_START> public void void ( ) { if ( org.springframework.scheduling.concurrent.Log . isInfoEnabled ( ) ) { org.springframework.scheduling.concurrent.Log . info ( STRING + ( this . java.lang.String != null ? STRING + this . java.lang.String + STRING : STRING ) ) ; } if ( this . boolean ) { this . java.util.concurrent.ExecutorService . void ( ) ; } else { this . java.util.concurrent.ExecutorService . java.util.List<java.lang.Runnable> ( ) ; } void ( ) ; }  <METHOD_END>
<METHOD_START> private void void ( ) { if ( this . int > NUMBER ) { try { if ( ! this . java.util.concurrent.ExecutorService . boolean ( this . int , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) { if ( org.springframework.scheduling.concurrent.Log . isWarnEnabled ( ) ) { org.springframework.scheduling.concurrent.Log . warn ( STRING + ( this . java.lang.String != null ? STRING + this . java.lang.String + STRING : STRING ) + STRING ) ; } } } catch ( java.lang.InterruptedException java.lang.InterruptedException ) { if ( org.springframework.scheduling.concurrent.Log . isWarnEnabled ( ) ) { org.springframework.scheduling.concurrent.Log . warn ( STRING + ( this . java.lang.String != null ? STRING + this . java.lang.String + STRING : STRING ) + STRING ) ; } java.lang.Thread . java.lang.Thread ( ) . void ( ) ; } } }  <METHOD_END>
