<METHOD_START> public static java.lang.reflect.Type java.lang.reflect.Type ( java.lang.reflect.Field java.lang.reflect.Field ) { Assert . notNull ( java.lang.reflect.Field , STRING ) ; return java.lang.reflect.Type ( new org.springframework.core.SerializableTypeWrapper.FieldTypeProvider ( java.lang.reflect.Field ) ) ; }  <METHOD_END>
<METHOD_START> public static java.lang.reflect.Type java.lang.reflect.Type ( MethodParameter org.springframework.core.MethodParameter ) { return java.lang.reflect.Type ( new org.springframework.core.SerializableTypeWrapper.MethodParameterTypeProvider ( org.springframework.core.MethodParameter ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.SuppressWarnings ( STRING ) public static java.lang.reflect.Type java.lang.reflect.Type ( final java.lang.Class<?> < ? > java.lang.Class<?> ) { return java.lang.reflect.Type ( new org.springframework.core.SerializableTypeWrapper.DefaultTypeProvider ( ) { @ java.lang.Override public java.lang.reflect.Type java.lang.reflect.Type ( ) { return java.lang.Class<> . java.lang.reflect.Type ( ) ; } } ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.reflect.Type java.lang.reflect.Type ( ) { return java.lang.Class<> . java.lang.reflect.Type ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.SuppressWarnings ( STRING ) public static java.lang.reflect.Type [] java.lang.reflect.Type[] ( final java.lang.Class<?> < ? > java.lang.Class<?> ) { java.lang.reflect.Type [] java.lang.reflect.Type[] = new java.lang.reflect.Type [ java.lang.Class<> . java.lang.reflect.Type[] ( ) . int ] ; for ( int int = NUMBER ; int < java.lang.reflect.Type[] . int ; int ++ ) { final int int = int ; java.lang.reflect.Type[] [ int ] = java.lang.reflect.Type ( new org.springframework.core.SerializableTypeWrapper.DefaultTypeProvider ( ) { @ java.lang.Override public java.lang.reflect.Type java.lang.reflect.Type ( ) { return java.lang.Class<> . java.lang.reflect.Type[] ( ) [ int ] ; } } ) ; } return java.lang.reflect.Type[] ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.reflect.Type java.lang.reflect.Type ( ) { return java.lang.Class<> . java.lang.reflect.Type[] ( ) [ int ] ; }  <METHOD_END>
<METHOD_START> @ java.lang.SuppressWarnings ( STRING ) public static java.lang.reflect.Type [] java.lang.reflect.Type[] ( final java.lang.Class<?> < ? > java.lang.Class<?> ) { java.lang.reflect.Type [] java.lang.reflect.Type[] = new java.lang.reflect.Type [ java.lang.Class<> . java.lang.reflect.TypeVariable<java.lang.Class<>>[] ( ) . int ] ; for ( int int = NUMBER ; int < java.lang.reflect.Type[] . int ; int ++ ) { final int int = int ; java.lang.reflect.Type[] [ int ] = java.lang.reflect.Type ( new org.springframework.core.SerializableTypeWrapper.DefaultTypeProvider ( ) { @ java.lang.Override public java.lang.reflect.Type java.lang.reflect.Type ( ) { return java.lang.Class<> . java.lang.reflect.TypeVariable<java.lang.Class<>>[] ( ) [ int ] ; } } ) ; } return java.lang.reflect.Type[] ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.reflect.Type java.lang.reflect.Type ( ) { return java.lang.Class<> . java.lang.reflect.TypeVariable<java.lang.Class<>>[] ( ) [ int ] ; }  <METHOD_END>
<METHOD_START> @ java.lang.SuppressWarnings ( STRING ) public static < T extends java.lang.reflect.Type > T T ( T T ) { java.lang.reflect.Type java.lang.reflect.Type = T ; while ( java.lang.reflect.Type instanceof org.springframework.core.SerializableTypeWrapper.SerializableTypeProxy ) { java.lang.reflect.Type = ( ( org.springframework.core.SerializableTypeWrapper.SerializableTypeProxy ) T ) . org.springframework.core.SerializableTypeWrapper.TypeProvider ( ) . java.lang.reflect.Type ( ) ; } return ( T ) java.lang.reflect.Type ; }  <METHOD_END>
<METHOD_START> static java.lang.reflect.Type java.lang.reflect.Type ( final org.springframework.core.SerializableTypeWrapper.TypeProvider org.springframework.core.SerializableTypeWrapper.TypeProvider ) { Assert . notNull ( org.springframework.core.SerializableTypeWrapper.TypeProvider , STRING ) ; if ( org.springframework.core.SerializableTypeWrapper.TypeProvider . java.lang.reflect.Type ( ) instanceof java.io.Serializable || org.springframework.core.SerializableTypeWrapper.TypeProvider . java.lang.reflect.Type ( ) == null ) { return org.springframework.core.SerializableTypeWrapper.TypeProvider . java.lang.reflect.Type ( ) ; } java.lang.reflect.Type java.lang.reflect.Type = org.springframework.core.ConcurrentReferenceHashMap<java.lang.reflect.Type,java.lang.reflect.Type> . get ( org.springframework.core.SerializableTypeWrapper.TypeProvider . java.lang.reflect.Type ( ) ) ; if ( java.lang.reflect.Type != null ) { return java.lang.reflect.Type ; } for ( java.lang.Class<?> < ? > java.lang.Class<?> : java.lang.Class<?>[] ) { if ( java.lang.Class<> . boolean ( org.springframework.core.SerializableTypeWrapper.TypeProvider . java.lang.reflect.Type ( ) . java.lang.Class<? extends java.lang.reflect.Type> ( ) ) ) { java.lang.ClassLoader java.lang.ClassLoader = org.springframework.core.SerializableTypeWrapper.TypeProvider . java.lang.Class<? extends org.springframework.core.SerializableTypeWrapper.TypeProvider> ( ) . java.lang.ClassLoader ( ) ; java.lang.Class<?> < ? > [] java.lang.Class<?>[] = new java.lang.Class<?> < ? > [] { java.lang.Class<> , org.springframework.core.SerializableTypeWrapper.SerializableTypeProxy .class , java.io.Serializable .class } ; java.lang.reflect.InvocationHandler java.lang.reflect.InvocationHandler = new org.springframework.core.SerializableTypeWrapper.TypeProxyInvocationHandler ( org.springframework.core.SerializableTypeWrapper.TypeProvider ) ; java.lang.reflect.Type = ( java.lang.reflect.Type ) java.lang.reflect.Proxy . java.lang.Object ( java.lang.ClassLoader , java.lang.Class<?>[] , java.lang.reflect.InvocationHandler ) ; org.springframework.core.ConcurrentReferenceHashMap<java.lang.reflect.Type,java.lang.reflect.Type> . put ( org.springframework.core.SerializableTypeWrapper.TypeProvider . java.lang.reflect.Type ( ) , java.lang.reflect.Type ) ; return java.lang.reflect.Type ; } } throw new java.lang.IllegalArgumentException ( STRING + org.springframework.core.SerializableTypeWrapper.TypeProvider . java.lang.reflect.Type ( ) . java.lang.Class<? extends java.lang.reflect.Type> ( ) . java.lang.String ( ) ) ; }  <METHOD_END>
<METHOD_START> org.springframework.core.SerializableTypeWrapper.TypeProvider org.springframework.core.SerializableTypeWrapper.TypeProvider ( )  <METHOD_END>
<METHOD_START> java.lang.reflect.Type java.lang.reflect.Type ( )  <METHOD_END>
<METHOD_START> java.lang.Object java.lang.Object ( )  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.Object java.lang.Object ( ) { return null ; }  <METHOD_END>
<METHOD_START> public void ( org.springframework.core.SerializableTypeWrapper.TypeProvider org.springframework.core.SerializableTypeWrapper.TypeProvider ) { this . org.springframework.core.SerializableTypeWrapper.TypeProvider = org.springframework.core.SerializableTypeWrapper.TypeProvider ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.Object java.lang.Object ( java.lang.Object java.lang.Object , java.lang.reflect.Method java.lang.reflect.Method , java.lang.Object [] java.lang.Object[] ) throws java.lang.Throwable { if ( java.lang.reflect.Method . java.lang.String ( ) . boolean ( STRING ) ) { java.lang.Object java.lang.Object = java.lang.Object[] [ NUMBER ] ; if ( java.lang.Object instanceof java.lang.reflect.Type ) { java.lang.Object = java.lang.reflect.Type ( ( java.lang.reflect.Type ) java.lang.Object ) ; } return this . org.springframework.core.SerializableTypeWrapper.TypeProvider . java.lang.reflect.Type ( ) . boolean ( java.lang.Object ) ; } else if ( java.lang.reflect.Method . java.lang.String ( ) . boolean ( STRING ) ) { return this . org.springframework.core.SerializableTypeWrapper.TypeProvider . java.lang.reflect.Type ( ) . int ( ) ; } else if ( java.lang.reflect.Method . java.lang.String ( ) . boolean ( STRING ) ) { return this . org.springframework.core.SerializableTypeWrapper.TypeProvider ; } if ( java.lang.reflect.Type .class == java.lang.reflect.Method . java.lang.Class<?> ( ) && java.lang.Object[] == null ) { return java.lang.reflect.Type ( new org.springframework.core.SerializableTypeWrapper.MethodInvokeTypeProvider ( this . org.springframework.core.SerializableTypeWrapper.TypeProvider , java.lang.reflect.Method , - NUMBER ) ) ; } else if ( java.lang.reflect.Type [] .class == java.lang.reflect.Method . java.lang.Class<?> ( ) && java.lang.Object[] == null ) { java.lang.reflect.Type [] java.lang.reflect.Type[] = new java.lang.reflect.Type [ ( ( java.lang.reflect.Type [] ) java.lang.reflect.Method . java.lang.Object ( this . org.springframework.core.SerializableTypeWrapper.TypeProvider . java.lang.reflect.Type ( ) , java.lang.Object[] ) ) . int ] ; for ( int int = NUMBER ; int < java.lang.reflect.Type[] . int ; int ++ ) { java.lang.reflect.Type[] [ int ] = java.lang.reflect.Type ( new org.springframework.core.SerializableTypeWrapper.MethodInvokeTypeProvider ( this . org.springframework.core.SerializableTypeWrapper.TypeProvider , java.lang.reflect.Method , int ) ) ; } return java.lang.reflect.Type[] ; } try { return java.lang.reflect.Method . java.lang.Object ( this . org.springframework.core.SerializableTypeWrapper.TypeProvider . java.lang.reflect.Type ( ) , java.lang.Object[] ) ; } catch ( java.lang.reflect.InvocationTargetException java.lang.reflect.InvocationTargetException ) { throw java.lang.reflect.InvocationTargetException . java.lang.Throwable ( ) ; } }  <METHOD_END>
<METHOD_START> public void ( java.lang.reflect.Field java.lang.reflect.Field ) { this . java.lang.String = java.lang.reflect.Field . java.lang.String ( ) ; this . java.lang.Class<?> = java.lang.reflect.Field . java.lang.Class<?> ( ) ; this . java.lang.reflect.Field = java.lang.reflect.Field ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.reflect.Type java.lang.reflect.Type ( ) { return this . java.lang.reflect.Field . java.lang.reflect.Type ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.Object java.lang.Object ( ) { return this . java.lang.reflect.Field ; }  <METHOD_END>
<METHOD_START> private void void ( java.io.ObjectInputStream java.io.ObjectInputStream ) throws java.io.IOException , java.lang.ClassNotFoundException { java.io.ObjectInputStream . void ( ) ; try { this . java.lang.reflect.Field = this . java.lang.Class<> . java.lang.reflect.Field ( this . java.lang.String ) ; } catch ( java.lang.Throwable java.lang.Throwable ) { throw new java.lang.IllegalStateException ( STRING , java.lang.Throwable ) ; } }  <METHOD_END>
<METHOD_START> public void ( MethodParameter org.springframework.core.MethodParameter ) { if ( org.springframework.core.MethodParameter . getMethod ( ) != null ) { this . java.lang.String = org.springframework.core.MethodParameter . getMethod ( ) . getName ( ) ; this . java.lang.Class<?>[] = org.springframework.core.MethodParameter . getMethod ( ) . getParameterTypes ( ) ; } else { this . java.lang.String = null ; this . java.lang.Class<?>[] = org.springframework.core.MethodParameter . getConstructor ( ) . getParameterTypes ( ) ; } this . java.lang.Class<?> = org.springframework.core.MethodParameter . getDeclaringClass ( ) ; this . int = org.springframework.core.MethodParameter . getParameterIndex ( ) ; this . org.springframework.core.MethodParameter = org.springframework.core.MethodParameter ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.reflect.Type java.lang.reflect.Type ( ) { return this . org.springframework.core.MethodParameter . getGenericParameterType ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.Object java.lang.Object ( ) { return this . org.springframework.core.MethodParameter ; }  <METHOD_END>
<METHOD_START> private void void ( java.io.ObjectInputStream java.io.ObjectInputStream ) throws java.io.IOException , java.lang.ClassNotFoundException { java.io.ObjectInputStream . void ( ) ; try { if ( this . java.lang.String != null ) { this . org.springframework.core.MethodParameter = new MethodParameter ( this . java.lang.Class<> . java.lang.reflect.Method ( this . java.lang.String , this . java.lang.Class<?>[] ) , this . int ) ; } else { this . org.springframework.core.MethodParameter = new MethodParameter ( this . java.lang.Class<> . java.lang.reflect.Constructor<> ( this . java.lang.Class<?>[] ) , this . int ) ; } } catch ( java.lang.Throwable java.lang.Throwable ) { throw new java.lang.IllegalStateException ( STRING , java.lang.Throwable ) ; } }  <METHOD_END>
<METHOD_START> public void ( org.springframework.core.SerializableTypeWrapper.TypeProvider org.springframework.core.SerializableTypeWrapper.TypeProvider , java.lang.reflect.Method java.lang.reflect.Method , int int ) { this . org.springframework.core.SerializableTypeWrapper.TypeProvider = org.springframework.core.SerializableTypeWrapper.TypeProvider ; this . java.lang.String = java.lang.reflect.Method . java.lang.String ( ) ; this . java.lang.Class<?> = java.lang.reflect.Method . java.lang.Class<?> ( ) ; this . int = int ; this . java.lang.reflect.Method = java.lang.reflect.Method ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.reflect.Type java.lang.reflect.Type ( ) { java.lang.Object java.lang.Object = this . java.lang.Object ; if ( java.lang.Object == null ) { java.lang.Object = ReflectionUtils . invokeMethod ( this . java.lang.reflect.Method , this . org.springframework.core.SerializableTypeWrapper.TypeProvider . java.lang.reflect.Type ( ) ) ; this . java.lang.Object = java.lang.Object ; } return ( java.lang.Object instanceof java.lang.reflect.Type [] ? ( ( java.lang.reflect.Type [] ) java.lang.Object ) [ this . int ] : ( java.lang.reflect.Type ) java.lang.Object ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.Object java.lang.Object ( ) { return null ; }  <METHOD_END>
<METHOD_START> private void void ( java.io.ObjectInputStream java.io.ObjectInputStream ) throws java.io.IOException , java.lang.ClassNotFoundException { java.io.ObjectInputStream . void ( ) ; this . java.lang.reflect.Method = ReflectionUtils . findMethod ( this . java.lang.Class<> , this . java.lang.String ) ; if ( this . java.lang.reflect.Method . java.lang.Class<?> ( ) != java.lang.reflect.Type .class && this . java.lang.reflect.Method . java.lang.Class<?> ( ) != java.lang.reflect.Type [] .class ) { throw new java.lang.IllegalStateException ( STRING + this . java.lang.reflect.Method ) ; } }  <METHOD_END>
