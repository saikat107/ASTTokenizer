<METHOD_START> @ Test public void void ( ) { assertTrue ( this . org.springframework.core.codec.ByteArrayDecoder . canDecode ( ResolvableType . forClass ( byte [] .class ) , MimeTypeUtils . TEXT_PLAIN ) ) ; assertFalse ( this . org.springframework.core.codec.ByteArrayDecoder . canDecode ( ResolvableType . forClass ( java.lang.Integer .class ) , MimeTypeUtils . TEXT_PLAIN ) ) ; assertTrue ( this . org.springframework.core.codec.ByteArrayDecoder . canDecode ( ResolvableType . forClass ( byte [] .class ) , MimeTypeUtils . APPLICATION_JSON ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { DataBuffer org.springframework.core.codec.DataBuffer = stringBuffer ( STRING ) ; DataBuffer org.springframework.core.codec.DataBuffer = stringBuffer ( STRING ) ; Flux < DataBuffer > org.springframework.core.codec.Flux<org.springframework.core.codec.DataBuffer> = Flux . just ( org.springframework.core.codec.DataBuffer , org.springframework.core.codec.DataBuffer ) ; Flux < byte [] > org.springframework.core.codec.Flux<byte[]> = this . org.springframework.core.codec.ByteArrayDecoder . decode ( org.springframework.core.codec.Flux<org.springframework.core.codec.DataBuffer> , ResolvableType . forClassWithGenerics ( Publisher .class , byte [] .class ) , null , java.util.Collections . java.util.Map<java.lang.Object,java.lang.Object> ( ) ) ; StepVerifier . create ( org.springframework.core.codec.Flux<byte[]> ) . consumeNextWith ( bytes -> assertArrayEquals ( STRING . getBytes ( ) , bytes ) ) . consumeNextWith ( bytes -> assertArrayEquals ( STRING . getBytes ( ) , bytes ) ) . expectComplete ( ) . verify ( ) ; }  <METHOD_END>
