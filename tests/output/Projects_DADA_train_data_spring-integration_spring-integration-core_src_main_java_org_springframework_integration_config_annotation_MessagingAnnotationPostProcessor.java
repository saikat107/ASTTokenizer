<METHOD_START> @ java.lang.Override public void void ( BeanFactory org.springframework.integration.config.annotation.BeanFactory ) { Assert . isAssignable ( ConfigurableListableBeanFactory .class , org.springframework.integration.config.annotation.BeanFactory . getClass ( ) , STRING ) ; this . org.springframework.integration.config.annotation.ConfigurableListableBeanFactory = ( ConfigurableListableBeanFactory ) org.springframework.integration.config.annotation.BeanFactory ; }  <METHOD_END>
<METHOD_START> protected org.springframework.integration.config.annotation.ConfigurableListableBeanFactory org.springframework.integration.config.annotation.ConfigurableListableBeanFactory ( ) { return this . org.springframework.integration.config.annotation.ConfigurableListableBeanFactory ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ) { Assert . notNull ( this . org.springframework.integration.config.annotation.ConfigurableListableBeanFactory , STRING ) ; this . java.util.Map<java.lang.Class<? extends java.lang.annotation.Annotation>,org.springframework.integration.config.annotation.MethodAnnotationPostProcessor<?>> . put ( Filter .class , new FilterAnnotationPostProcessor ( this . org.springframework.integration.config.annotation.ConfigurableListableBeanFactory ) ) ; this . java.util.Map<java.lang.Class<? extends java.lang.annotation.Annotation>,org.springframework.integration.config.annotation.MethodAnnotationPostProcessor<?>> . put ( Router .class , new RouterAnnotationPostProcessor ( this . org.springframework.integration.config.annotation.ConfigurableListableBeanFactory ) ) ; this . java.util.Map<java.lang.Class<? extends java.lang.annotation.Annotation>,org.springframework.integration.config.annotation.MethodAnnotationPostProcessor<?>> . put ( Transformer .class , new TransformerAnnotationPostProcessor ( this . org.springframework.integration.config.annotation.ConfigurableListableBeanFactory ) ) ; this . java.util.Map<java.lang.Class<? extends java.lang.annotation.Annotation>,org.springframework.integration.config.annotation.MethodAnnotationPostProcessor<?>> . put ( ServiceActivator .class , new ServiceActivatorAnnotationPostProcessor ( this . org.springframework.integration.config.annotation.ConfigurableListableBeanFactory ) ) ; this . java.util.Map<java.lang.Class<? extends java.lang.annotation.Annotation>,org.springframework.integration.config.annotation.MethodAnnotationPostProcessor<?>> . put ( Splitter .class , new SplitterAnnotationPostProcessor ( this . org.springframework.integration.config.annotation.ConfigurableListableBeanFactory ) ) ; this . java.util.Map<java.lang.Class<? extends java.lang.annotation.Annotation>,org.springframework.integration.config.annotation.MethodAnnotationPostProcessor<?>> . put ( Aggregator .class , new AggregatorAnnotationPostProcessor ( this . org.springframework.integration.config.annotation.ConfigurableListableBeanFactory ) ) ; this . java.util.Map<java.lang.Class<? extends java.lang.annotation.Annotation>,org.springframework.integration.config.annotation.MethodAnnotationPostProcessor<?>> . put ( InboundChannelAdapter .class , new InboundChannelAdapterAnnotationPostProcessor ( this . org.springframework.integration.config.annotation.ConfigurableListableBeanFactory ) ) ; this . java.util.Map<java.lang.Class<? extends java.lang.annotation.Annotation>,org.springframework.integration.config.annotation.MethodAnnotationPostProcessor<?>> . put ( BridgeFrom .class , new BridgeFromAnnotationPostProcessor ( this . org.springframework.integration.config.annotation.ConfigurableListableBeanFactory ) ) ; this . java.util.Map<java.lang.Class<? extends java.lang.annotation.Annotation>,org.springframework.integration.config.annotation.MethodAnnotationPostProcessor<?>> . put ( BridgeTo .class , new BridgeToAnnotationPostProcessor ( this . org.springframework.integration.config.annotation.ConfigurableListableBeanFactory ) ) ; java.util.Map<java.lang.Class<? extends java.lang.annotation.Annotation>,org.springframework.integration.config.annotation.MethodAnnotationPostProcessor<?>> < java.lang.Class<? extends java.lang.annotation.Annotation> < ? extends java.lang.annotation.Annotation > , MethodAnnotationPostProcessor < ? > > java.util.Map<java.lang.Class<? extends java.lang.annotation.Annotation>,org.springframework.integration.config.annotation.MethodAnnotationPostProcessor<?>> = java.util.Map<java.lang.Class<? extends java.lang.annotation.Annotation>,org.springframework.integration.config.annotation.MethodAnnotationPostProcessor<?>> ( ) ; if ( ! CollectionUtils . isEmpty ( java.util.Map<java.lang.Class<? extends java.lang.annotation.Annotation>,org.springframework.integration.config.annotation.MethodAnnotationPostProcessor<?>> ) ) { this . java.util.Map<java.lang.Class<? extends java.lang.annotation.Annotation>,org.springframework.integration.config.annotation.MethodAnnotationPostProcessor<?>> . putAll ( java.util.Map<java.lang.Class<? extends java.lang.annotation.Annotation>,org.springframework.integration.config.annotation.MethodAnnotationPostProcessor<?>> ) ; } }  <METHOD_END>
<METHOD_START> protected java.util.Map<java.lang.Class<? extends java.lang.annotation.Annotation>,org.springframework.integration.config.annotation.MethodAnnotationPostProcessor<?>> < java.lang.Class<? extends java.lang.annotation.Annotation> < ? extends java.lang.annotation.Annotation > , MethodAnnotationPostProcessor < ? > > java.util.Map<java.lang.Class<? extends java.lang.annotation.Annotation>,org.springframework.integration.config.annotation.MethodAnnotationPostProcessor<?>> ( ) { return null ; }  <METHOD_END>
<METHOD_START> public < A extends java.lang.annotation.Annotation > void void ( java.lang.Class<A> < A > java.lang.Class<A> , MethodAnnotationPostProcessor < A > org.springframework.integration.config.annotation.MethodAnnotationPostProcessor<A> ) { this . java.util.Map<java.lang.Class<? extends java.lang.annotation.Annotation>,org.springframework.integration.config.annotation.MethodAnnotationPostProcessor<?>> . put ( java.lang.Class<A> , org.springframework.integration.config.annotation.MethodAnnotationPostProcessor<A> ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.Object java.lang.Object ( java.lang.Object java.lang.Object , java.lang.String java.lang.String ) throws org.springframework.integration.config.annotation.BeansException { return java.lang.Object ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ) { SmartLifecycleRoleController org.springframework.integration.config.annotation.SmartLifecycleRoleController ; try { org.springframework.integration.config.annotation.SmartLifecycleRoleController = this . org.springframework.integration.config.annotation.ConfigurableListableBeanFactory . getBean ( IntegrationContextUtils . INTEGRATION_LIFECYCLE_ROLE_CONTROLLER , SmartLifecycleRoleController .class ) ; for ( java.util.Map.Entry<java.lang.String,java.util.List<java.lang.String>> < java.lang.String , java.util.List<java.lang.String> < java.lang.String > > java.util.Map.Entry<java.lang.String,java.util.List<java.lang.String>> : this . org.springframework.integration.config.annotation.MultiValueMap<java.lang.String,java.lang.String> . entrySet ( ) ) { org.springframework.integration.config.annotation.SmartLifecycleRoleController . addLifecyclesToRole ( java.util.Map.Entry<java.lang.String,java.util.List<java.lang.String>> . java.lang.String ( ) , java.util.Map.Entry<java.lang.String,java.util.List<java.lang.String>> . java.util.List<java.lang.String> ( ) ) ; } } catch ( NoSuchBeanDefinitionException org.springframework.integration.config.annotation.NoSuchBeanDefinitionException ) { this . org.springframework.integration.config.annotation.Log . error ( STRING ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.Object java.lang.Object ( final java.lang.Object java.lang.Object , final java.lang.String java.lang.String ) throws org.springframework.integration.config.annotation.BeansException { Assert . notNull ( this . org.springframework.integration.config.annotation.ConfigurableListableBeanFactory , STRING ) ; final java.lang.Class<?> < ? > java.lang.Class<?> = this . java.lang.Class<?> ( java.lang.Object ) ; ReflectionUtils . doWithMethods ( java.lang.Class<> , method -> { Map < Class < ? extends Annotation > , List < Annotation > > annotationChains = new HashMap <> ( ) ; for ( Class < ? extends Annotation > annotationType : MessagingAnnotationPostProcessor .this . postProcessors . keySet ( ) ) { if ( AnnotatedElementUtils . isAnnotated ( method , annotationType . getName ( ) ) ) { List < Annotation > annotationChain = getAnnotationChain ( method , annotationType ) ; if ( annotationChain . size ( ) > NUMBER ) { annotationChains . put ( annotationType , annotationChain ) ; } } } for ( Entry < Class < ? extends Annotation > , List < Annotation > > entry : annotationChains . entrySet ( ) ) { Class < ? extends Annotation > annotationType = entry . getKey ( ) ; List < Annotation > annotations = entry . getValue ( ) ; processAnnotationTypeOnMethod ( bean , beanName , method , annotationType , annotations ) ; } } , ReflectionUtils . USER_DECLARED_METHODS ) ; return java.lang.Object ; }  <METHOD_END>
<METHOD_START> protected void void ( java.lang.Object java.lang.Object , java.lang.String java.lang.String , java.lang.reflect.Method java.lang.reflect.Method , java.lang.Class<? extends java.lang.annotation.Annotation> < ? extends java.lang.annotation.Annotation > java.lang.Class<? extends java.lang.annotation.Annotation> , java.util.List<java.lang.annotation.Annotation> < java.lang.annotation.Annotation > java.util.List<java.lang.annotation.Annotation> ) { MethodAnnotationPostProcessor < ? > org.springframework.integration.config.annotation.MethodAnnotationPostProcessor<?> = org.springframework.integration.config.annotation.MessagingAnnotationPostProcessor .this . java.util.Map<java.lang.Class<? extends java.lang.annotation.Annotation>,org.springframework.integration.config.annotation.MethodAnnotationPostProcessor<?>> . get ( java.lang.Class<> ) ; if ( org.springframework.integration.config.annotation.MethodAnnotationPostProcessor<> != null && org.springframework.integration.config.annotation.MethodAnnotationPostProcessor<> . shouldCreateEndpoint ( java.lang.reflect.Method , java.util.List<java.lang.annotation.Annotation> ) ) { java.lang.reflect.Method java.lang.reflect.Method = java.lang.reflect.Method ; if ( AopUtils . isJdkDynamicProxy ( java.lang.Object ) ) { try { java.lang.reflect.Method = java.lang.Object . java.lang.Class<? extends java.lang.Object> ( ) . java.lang.reflect.Method ( java.lang.reflect.Method . java.lang.String ( ) , java.lang.reflect.Method . java.lang.Class<?>[] ( ) ) ; } catch ( java.lang.NoSuchMethodException java.lang.NoSuchMethodException ) { throw new java.lang.IllegalArgumentException ( STRING + STRING + java.lang.String + STRING + STRING + java.lang.reflect.Method + STRING , java.lang.NoSuchMethodException ) ; } } java.lang.Object java.lang.Object = org.springframework.integration.config.annotation.MethodAnnotationPostProcessor<> . postProcess ( java.lang.Object , java.lang.String , java.lang.reflect.Method , java.util.List<java.lang.annotation.Annotation> ) ; if ( java.lang.Object != null && java.lang.Object instanceof AbstractEndpoint ) { AbstractEndpoint org.springframework.integration.config.annotation.AbstractEndpoint = ( AbstractEndpoint ) java.lang.Object ; java.lang.String java.lang.String = MessagingAnnotationUtils . resolveAttribute ( java.util.List<java.lang.annotation.Annotation> , STRING , java.lang.String .class ) ; if ( StringUtils . hasText ( java.lang.String ) ) { java.lang.String = org.springframework.integration.config.annotation.ConfigurableListableBeanFactory ( ) . resolveEmbeddedValue ( java.lang.String ) ; if ( StringUtils . hasText ( java.lang.String ) ) { org.springframework.integration.config.annotation.AbstractEndpoint . setAutoStartup ( java.lang.Boolean . boolean ( java.lang.String ) ) ; } } java.lang.String java.lang.String = MessagingAnnotationUtils . resolveAttribute ( java.util.List<java.lang.annotation.Annotation> , STRING , java.lang.String .class ) ; if ( StringUtils . hasText ( java.lang.String ) ) { java.lang.String = org.springframework.integration.config.annotation.ConfigurableListableBeanFactory ( ) . resolveEmbeddedValue ( java.lang.String ) ; if ( StringUtils . hasText ( java.lang.String ) ) { org.springframework.integration.config.annotation.AbstractEndpoint . setPhase ( java.lang.Integer . int ( java.lang.String ) ) ; } } java.lang.String java.lang.String = java.lang.String ( java.lang.String , java.lang.reflect.Method , java.lang.Class<> ) ; org.springframework.integration.config.annotation.AbstractEndpoint . setBeanName ( java.lang.String ) ; org.springframework.integration.config.annotation.ConfigurableListableBeanFactory ( ) . registerSingleton ( java.lang.String , org.springframework.integration.config.annotation.AbstractEndpoint ) ; org.springframework.integration.config.annotation.ConfigurableListableBeanFactory ( ) . initializeBean ( org.springframework.integration.config.annotation.AbstractEndpoint , java.lang.String ) ; Role org.springframework.integration.config.annotation.Role = AnnotationUtils . findAnnotation ( java.lang.reflect.Method , Role .class ) ; if ( org.springframework.integration.config.annotation.Role != null ) { org.springframework.integration.config.annotation.MessagingAnnotationPostProcessor .this . org.springframework.integration.config.annotation.MultiValueMap<java.lang.String,java.lang.String> . add ( org.springframework.integration.config.annotation.Role . value ( ) , java.lang.String ) ; } } } }  <METHOD_END>
<METHOD_START> protected java.util.List<java.lang.annotation.Annotation> < java.lang.annotation.Annotation > java.util.List<java.lang.annotation.Annotation> ( java.lang.reflect.Method java.lang.reflect.Method , java.lang.Class<? extends java.lang.annotation.Annotation> < ? extends java.lang.annotation.Annotation > java.lang.Class<? extends java.lang.annotation.Annotation> ) { java.lang.annotation.Annotation [] java.lang.annotation.Annotation[] = AnnotationUtils . getAnnotations ( java.lang.reflect.Method ) ; java.util.List<java.lang.annotation.Annotation> < java.lang.annotation.Annotation > java.util.List<java.lang.annotation.Annotation> = new java.util.LinkedList<java.lang.annotation.Annotation> < java.lang.annotation.Annotation > ( ) ; java.util.Set<java.lang.annotation.Annotation> < java.lang.annotation.Annotation > java.util.Set<java.lang.annotation.Annotation> = new java.util.HashSet<java.lang.annotation.Annotation> < java.lang.annotation.Annotation > ( ) ; for ( java.lang.annotation.Annotation java.lang.annotation.Annotation : java.lang.annotation.Annotation[] ) { this . boolean ( java.lang.Class<> , java.lang.annotation.Annotation , java.util.List<java.lang.annotation.Annotation> , java.util.Set<java.lang.annotation.Annotation> ) ; if ( java.util.List<java.lang.annotation.Annotation> . int ( ) > NUMBER ) { java.util.Collections . void ( java.util.List<java.lang.annotation.Annotation> ) ; return java.util.List<java.lang.annotation.Annotation> ; } } return java.util.List<java.lang.annotation.Annotation> ; }  <METHOD_END>
<METHOD_START> protected boolean boolean ( java.lang.Class<? extends java.lang.annotation.Annotation> < ? extends java.lang.annotation.Annotation > java.lang.Class<? extends java.lang.annotation.Annotation> , java.lang.annotation.Annotation java.lang.annotation.Annotation , java.util.List<java.lang.annotation.Annotation> < java.lang.annotation.Annotation > java.util.List<java.lang.annotation.Annotation> , java.util.Set<java.lang.annotation.Annotation> < java.lang.annotation.Annotation > java.util.Set<java.lang.annotation.Annotation> ) { if ( java.lang.annotation.Annotation . java.lang.Class<? extends java.lang.annotation.Annotation> ( ) . boolean ( java.lang.Class<> ) ) { java.util.List<java.lang.annotation.Annotation> . boolean ( java.lang.annotation.Annotation ) ; return true ; } for ( java.lang.annotation.Annotation java.lang.annotation.Annotation : java.lang.annotation.Annotation . java.lang.Class<? extends java.lang.annotation.Annotation> ( ) . java.lang.annotation.Annotation[] ( ) ) { if ( ! java.lang.annotation.Annotation . boolean ( java.lang.annotation.Annotation ) && ! java.util.Set<java.lang.annotation.Annotation> . boolean ( java.lang.annotation.Annotation ) && ! ( java.lang.annotation.Annotation . java.lang.Class<? extends java.lang.annotation.Annotation> ( ) . java.lang.Package ( ) . java.lang.String ( ) . boolean ( STRING ) ) ) { java.util.Set<java.lang.annotation.Annotation> . boolean ( java.lang.annotation.Annotation ) ; if ( this . boolean ( java.lang.Class<> , java.lang.annotation.Annotation , java.util.List<java.lang.annotation.Annotation> , java.util.Set<java.lang.annotation.Annotation> ) ) { java.util.List<java.lang.annotation.Annotation> . boolean ( java.lang.annotation.Annotation ) ; return true ; } } } return false ; }  <METHOD_END>
<METHOD_START> protected java.lang.Class<?> < ? > java.lang.Class<?> ( java.lang.Object java.lang.Object ) { java.lang.Class<?> < ? > java.lang.Class<?> = AopUtils . getTargetClass ( java.lang.Object ) ; return ( java.lang.Class<> != null ) ? java.lang.Class<> : java.lang.Object . java.lang.Class<? extends java.lang.Object> ( ) ; }  <METHOD_END>
<METHOD_START> protected java.lang.String java.lang.String ( java.lang.String java.lang.String , java.lang.reflect.Method java.lang.reflect.Method , java.lang.Class<? extends java.lang.annotation.Annotation> < ? extends java.lang.annotation.Annotation > java.lang.Class<? extends java.lang.annotation.Annotation> ) { java.lang.String java.lang.String = java.lang.String + STRING + java.lang.reflect.Method . java.lang.String ( ) + STRING + ClassUtils . getShortNameAsProperty ( java.lang.Class<> ) ; java.lang.String java.lang.String = java.lang.String ; int int = NUMBER ; while ( this . org.springframework.integration.config.annotation.ConfigurableListableBeanFactory . containsBean ( java.lang.String ) ) { java.lang.String = java.lang.String + STRING + ( ++ int ) ; } return java.lang.String ; }  <METHOD_END>
<METHOD_START> protected java.util.Map<java.lang.Class<? extends java.lang.annotation.Annotation>,org.springframework.integration.config.annotation.MethodAnnotationPostProcessor<?>> < java.lang.Class<? extends java.lang.annotation.Annotation> < ? extends java.lang.annotation.Annotation > , MethodAnnotationPostProcessor < ? > > java.util.Map<java.lang.Class<? extends java.lang.annotation.Annotation>,org.springframework.integration.config.annotation.MethodAnnotationPostProcessor<?>> ( ) { return this . java.util.Map<java.lang.Class<? extends java.lang.annotation.Annotation>,org.springframework.integration.config.annotation.MethodAnnotationPostProcessor<?>> ; }  <METHOD_END>
<METHOD_START> protected org.springframework.integration.config.annotation.MultiValueMap<java.lang.String,java.lang.String> < java.lang.String , java.lang.String > org.springframework.integration.config.annotation.MultiValueMap<java.lang.String,java.lang.String> ( ) { return this . org.springframework.integration.config.annotation.MultiValueMap<java.lang.String,java.lang.String> ; }  <METHOD_END>
