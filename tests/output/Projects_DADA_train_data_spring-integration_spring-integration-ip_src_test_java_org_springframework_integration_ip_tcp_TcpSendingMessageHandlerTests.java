<METHOD_START> private void void ( java.io.InputStream java.io.InputStream , byte [] byte[] ) throws java.io.IOException { for ( int int = NUMBER ; int < byte[] . int ; int ++ ) { byte[] [ int ] = ( byte ) java.io.InputStream . int ( ) ; } }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> < java.net.ServerSocket > java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> = new java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> < java.net.ServerSocket > ( ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; final java.util.concurrent.atomic.AtomicBoolean java.util.concurrent.atomic.AtomicBoolean = new java.util.concurrent.atomic.AtomicBoolean ( ) ; java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . void ( ( ) { try { java.net.ServerSocket java.net.ServerSocket = javax.net.ServerSocketFactory . javax.net.ServerSocketFactory ( ) . java.net.ServerSocket ( NUMBER ) ; java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . void ( java.net.ServerSocket ) ; java.util.concurrent.CountDownLatch . void ( ) ; java.net.Socket java.net.Socket = java.net.ServerSocket . java.net.Socket ( ) ; int int = NUMBER ; while ( true ) { byte [] byte[] = new byte [ NUMBER ] ; void ( java.net.Socket . java.io.InputStream ( ) , byte[] ) ; byte[] = ( STRING + ( ++ int ) + STRING ) . byte[] ( ) ; java.net.Socket . java.io.OutputStream ( ) . void ( byte[] ) ; } } catch ( java.lang.Exception java.lang.Exception ) { if ( ! java.util.concurrent.atomic.AtomicBoolean . boolean ( ) ) { java.lang.Exception . void ( ) ; } } } ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; AbstractConnectionFactory org.springframework.integration.ip.tcp.AbstractConnectionFactory = new TcpNetClientConnectionFactory ( STRING , java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . java.net.ServerSocket ( ) . int ( ) ) ; noopPublisher ( org.springframework.integration.ip.tcp.AbstractConnectionFactory ) ; ByteArrayCrLfSerializer org.springframework.integration.ip.tcp.ByteArrayCrLfSerializer = new ByteArrayCrLfSerializer ( ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . setSerializer ( org.springframework.integration.ip.tcp.ByteArrayCrLfSerializer ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . setDeserializer ( org.springframework.integration.ip.tcp.ByteArrayCrLfSerializer ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . setSoTimeout ( NUMBER ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . start ( ) ; TcpSendingMessageHandler org.springframework.integration.ip.tcp.TcpSendingMessageHandler = new TcpSendingMessageHandler ( ) ; org.springframework.integration.ip.tcp.TcpSendingMessageHandler . setConnectionFactory ( org.springframework.integration.ip.tcp.AbstractConnectionFactory ) ; TcpReceivingChannelAdapter org.springframework.integration.ip.tcp.TcpReceivingChannelAdapter = new TcpReceivingChannelAdapter ( ) ; org.springframework.integration.ip.tcp.TcpReceivingChannelAdapter . setConnectionFactory ( org.springframework.integration.ip.tcp.AbstractConnectionFactory ) ; QueueChannel org.springframework.integration.ip.tcp.QueueChannel = new QueueChannel ( ) ; org.springframework.integration.ip.tcp.TcpReceivingChannelAdapter . setOutputChannel ( org.springframework.integration.ip.tcp.QueueChannel ) ; org.springframework.integration.ip.tcp.TcpSendingMessageHandler . handleMessage ( MessageBuilder . withPayload ( STRING ) . build ( ) ) ; org.springframework.integration.ip.tcp.TcpSendingMessageHandler . handleMessage ( MessageBuilder . withPayload ( STRING ) . build ( ) ) ; Message < ? > org.springframework.integration.ip.tcp.Message<?> = org.springframework.integration.ip.tcp.QueueChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.ip.tcp.Message<> ) ; assertEquals ( STRING , new java.lang.String ( ( byte [] ) org.springframework.integration.ip.tcp.Message<> . getPayload ( ) ) ) ; org.springframework.integration.ip.tcp.Message<?> = org.springframework.integration.ip.tcp.QueueChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.ip.tcp.Message<> ) ; assertEquals ( STRING , new java.lang.String ( ( byte [] ) org.springframework.integration.ip.tcp.Message<> . getPayload ( ) ) ) ; java.util.concurrent.atomic.AtomicBoolean . void ( true ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . stop ( ) ; java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . java.net.ServerSocket ( ) . void ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> < java.net.ServerSocket > java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> = new java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> < java.net.ServerSocket > ( ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; final java.util.concurrent.atomic.AtomicBoolean java.util.concurrent.atomic.AtomicBoolean = new java.util.concurrent.atomic.AtomicBoolean ( ) ; java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . void ( ( ) { try { java.net.ServerSocket java.net.ServerSocket = javax.net.ServerSocketFactory . javax.net.ServerSocketFactory ( ) . java.net.ServerSocket ( NUMBER ) ; java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . void ( java.net.ServerSocket ) ; java.util.concurrent.CountDownLatch . void ( ) ; java.net.Socket java.net.Socket = java.net.ServerSocket . java.net.Socket ( ) ; int int = NUMBER ; while ( true ) { byte [] byte[] = new byte [ NUMBER ] ; void ( java.net.Socket . java.io.InputStream ( ) , byte[] ) ; byte[] = ( STRING + ( ++ int ) + STRING ) . byte[] ( ) ; java.net.Socket . java.io.OutputStream ( ) . void ( byte[] ) ; } } catch ( java.lang.Exception java.lang.Exception ) { if ( ! java.util.concurrent.atomic.AtomicBoolean . boolean ( ) ) { java.lang.Exception . void ( ) ; } } } ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; AbstractConnectionFactory org.springframework.integration.ip.tcp.AbstractConnectionFactory = new TcpNetClientConnectionFactory ( STRING , java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . java.net.ServerSocket ( ) . int ( ) ) ; noopPublisher ( org.springframework.integration.ip.tcp.AbstractConnectionFactory ) ; ByteArrayCrLfSerializer org.springframework.integration.ip.tcp.ByteArrayCrLfSerializer = new ByteArrayCrLfSerializer ( ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . setSerializer ( org.springframework.integration.ip.tcp.ByteArrayCrLfSerializer ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . setDeserializer ( org.springframework.integration.ip.tcp.ByteArrayCrLfSerializer ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . setSoTimeout ( java.lang.Integer . int ) ; TcpSendingMessageHandler org.springframework.integration.ip.tcp.TcpSendingMessageHandler = new TcpSendingMessageHandler ( ) ; org.springframework.integration.ip.tcp.TcpSendingMessageHandler . setConnectionFactory ( org.springframework.integration.ip.tcp.AbstractConnectionFactory ) ; TcpReceivingChannelAdapter org.springframework.integration.ip.tcp.TcpReceivingChannelAdapter = new TcpReceivingChannelAdapter ( ) ; org.springframework.integration.ip.tcp.TcpReceivingChannelAdapter . setConnectionFactory ( org.springframework.integration.ip.tcp.AbstractConnectionFactory ) ; QueueChannel org.springframework.integration.ip.tcp.QueueChannel = new QueueChannel ( ) ; org.springframework.integration.ip.tcp.TcpReceivingChannelAdapter . setOutputChannel ( org.springframework.integration.ip.tcp.QueueChannel ) ; org.springframework.integration.ip.tcp.TcpSendingMessageHandler . setClientMode ( true ) ; org.springframework.integration.ip.tcp.TcpSendingMessageHandler . setRetryInterval ( NUMBER ) ; org.springframework.integration.ip.tcp.TcpSendingMessageHandler . setBeanFactory ( mock ( BeanFactory .class ) ) ; org.springframework.integration.ip.tcp.TcpSendingMessageHandler . afterPropertiesSet ( ) ; ThreadPoolTaskScheduler org.springframework.integration.ip.tcp.ThreadPoolTaskScheduler = new ThreadPoolTaskScheduler ( ) ; org.springframework.integration.ip.tcp.ThreadPoolTaskScheduler . setPoolSize ( NUMBER ) ; org.springframework.integration.ip.tcp.ThreadPoolTaskScheduler . initialize ( ) ; org.springframework.integration.ip.tcp.TcpSendingMessageHandler . setTaskScheduler ( org.springframework.integration.ip.tcp.ThreadPoolTaskScheduler ) ; org.springframework.integration.ip.tcp.TcpSendingMessageHandler . start ( ) ; org.springframework.integration.ip.tcp.TcpReceivingChannelAdapter . start ( ) ; org.springframework.integration.ip.tcp.TcpSendingMessageHandler . handleMessage ( MessageBuilder . withPayload ( STRING ) . build ( ) ) ; org.springframework.integration.ip.tcp.TcpSendingMessageHandler . handleMessage ( MessageBuilder . withPayload ( STRING ) . build ( ) ) ; Message < ? > org.springframework.integration.ip.tcp.Message<?> = org.springframework.integration.ip.tcp.QueueChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.ip.tcp.Message<> ) ; assertEquals ( STRING , new java.lang.String ( ( byte [] ) org.springframework.integration.ip.tcp.Message<> . getPayload ( ) ) ) ; org.springframework.integration.ip.tcp.Message<?> = org.springframework.integration.ip.tcp.QueueChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.ip.tcp.Message<> ) ; assertEquals ( STRING , new java.lang.String ( ( byte [] ) org.springframework.integration.ip.tcp.Message<> . getPayload ( ) ) ) ; java.util.concurrent.atomic.AtomicBoolean . void ( true ) ; org.springframework.integration.ip.tcp.TcpSendingMessageHandler . stop ( ) ; org.springframework.integration.ip.tcp.TcpSendingMessageHandler . start ( ) ; org.springframework.integration.ip.tcp.TcpSendingMessageHandler . stop ( ) ; org.springframework.integration.ip.tcp.TcpReceivingChannelAdapter . stop ( ) ; java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . java.net.ServerSocket ( ) . void ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> < java.net.ServerSocket > java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> = new java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> < java.net.ServerSocket > ( ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; final java.util.concurrent.atomic.AtomicBoolean java.util.concurrent.atomic.AtomicBoolean = new java.util.concurrent.atomic.AtomicBoolean ( ) ; java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . void ( ( ) { try { java.net.ServerSocket java.net.ServerSocket = javax.net.ServerSocketFactory . javax.net.ServerSocketFactory ( ) . java.net.ServerSocket ( NUMBER ) ; java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . void ( java.net.ServerSocket ) ; java.util.concurrent.CountDownLatch . void ( ) ; java.net.Socket java.net.Socket = java.net.ServerSocket . java.net.Socket ( ) ; int int = NUMBER ; while ( true ) { byte [] byte[] = new byte [ NUMBER ] ; void ( java.net.Socket . java.io.InputStream ( ) , byte[] ) ; byte[] = ( STRING + ( ++ int ) + STRING ) . byte[] ( ) ; java.net.Socket . java.io.OutputStream ( ) . void ( byte[] ) ; } } catch ( java.lang.Exception java.lang.Exception ) { if ( ! java.util.concurrent.atomic.AtomicBoolean . boolean ( ) ) { java.lang.Exception . void ( ) ; } } } ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; AbstractConnectionFactory org.springframework.integration.ip.tcp.AbstractConnectionFactory = new TcpNioClientConnectionFactory ( STRING , java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . java.net.ServerSocket ( ) . int ( ) ) ; noopPublisher ( org.springframework.integration.ip.tcp.AbstractConnectionFactory ) ; ByteArrayCrLfSerializer org.springframework.integration.ip.tcp.ByteArrayCrLfSerializer = new ByteArrayCrLfSerializer ( ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . setSerializer ( org.springframework.integration.ip.tcp.ByteArrayCrLfSerializer ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . setDeserializer ( org.springframework.integration.ip.tcp.ByteArrayCrLfSerializer ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . setSoTimeout ( NUMBER ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . start ( ) ; TcpSendingMessageHandler org.springframework.integration.ip.tcp.TcpSendingMessageHandler = new TcpSendingMessageHandler ( ) ; org.springframework.integration.ip.tcp.TcpSendingMessageHandler . setConnectionFactory ( org.springframework.integration.ip.tcp.AbstractConnectionFactory ) ; TcpReceivingChannelAdapter org.springframework.integration.ip.tcp.TcpReceivingChannelAdapter = new TcpReceivingChannelAdapter ( ) ; org.springframework.integration.ip.tcp.TcpReceivingChannelAdapter . setConnectionFactory ( org.springframework.integration.ip.tcp.AbstractConnectionFactory ) ; QueueChannel org.springframework.integration.ip.tcp.QueueChannel = new QueueChannel ( ) ; org.springframework.integration.ip.tcp.TcpReceivingChannelAdapter . setOutputChannel ( org.springframework.integration.ip.tcp.QueueChannel ) ; org.springframework.integration.ip.tcp.TcpSendingMessageHandler . handleMessage ( MessageBuilder . withPayload ( STRING ) . build ( ) ) ; org.springframework.integration.ip.tcp.TcpSendingMessageHandler . handleMessage ( MessageBuilder . withPayload ( STRING ) . build ( ) ) ; java.util.Set<java.lang.String> < java.lang.String > java.util.Set<java.lang.String> = new java.util.HashSet<java.lang.String> < java.lang.String > ( ) ; Message < ? > org.springframework.integration.ip.tcp.Message<?> = org.springframework.integration.ip.tcp.QueueChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.ip.tcp.Message<> ) ; java.util.Set<java.lang.String> . boolean ( new java.lang.String ( ( byte [] ) org.springframework.integration.ip.tcp.Message<> . getPayload ( ) ) ) ; org.springframework.integration.ip.tcp.Message<?> = org.springframework.integration.ip.tcp.QueueChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.ip.tcp.Message<> ) ; java.util.Set<java.lang.String> . boolean ( new java.lang.String ( ( byte [] ) org.springframework.integration.ip.tcp.Message<> . getPayload ( ) ) ) ; assertTrue ( java.util.Set<java.lang.String> . boolean ( STRING ) ) ; assertTrue ( java.util.Set<java.lang.String> . boolean ( STRING ) ) ; java.util.concurrent.atomic.AtomicBoolean . void ( true ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . stop ( ) ; java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . java.net.ServerSocket ( ) . void ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> < java.net.ServerSocket > java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> = new java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> < java.net.ServerSocket > ( ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; final java.util.concurrent.atomic.AtomicBoolean java.util.concurrent.atomic.AtomicBoolean = new java.util.concurrent.atomic.AtomicBoolean ( ) ; java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . void ( ( ) { try { java.net.ServerSocket java.net.ServerSocket = javax.net.ServerSocketFactory . javax.net.ServerSocketFactory ( ) . java.net.ServerSocket ( NUMBER ) ; java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . void ( java.net.ServerSocket ) ; java.util.concurrent.CountDownLatch . void ( ) ; java.net.Socket java.net.Socket = java.net.ServerSocket . java.net.Socket ( ) ; int int = NUMBER ; while ( true ) { byte [] byte[] = new byte [ NUMBER ] ; void ( java.net.Socket . java.io.InputStream ( ) , byte[] ) ; byte[] = ( STRING + ( ++ int ) + STRING ) . byte[] ( ) ; java.net.Socket . java.io.OutputStream ( ) . void ( byte[] ) ; } } catch ( java.lang.Exception java.lang.Exception ) { if ( ! java.util.concurrent.atomic.AtomicBoolean . boolean ( ) ) { java.lang.Exception . void ( ) ; } } } ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; AbstractConnectionFactory org.springframework.integration.ip.tcp.AbstractConnectionFactory = new TcpNetClientConnectionFactory ( STRING , java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . java.net.ServerSocket ( ) . int ( ) ) ; noopPublisher ( org.springframework.integration.ip.tcp.AbstractConnectionFactory ) ; ByteArrayStxEtxSerializer org.springframework.integration.ip.tcp.ByteArrayStxEtxSerializer = new ByteArrayStxEtxSerializer ( ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . setSerializer ( org.springframework.integration.ip.tcp.ByteArrayStxEtxSerializer ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . setDeserializer ( org.springframework.integration.ip.tcp.ByteArrayStxEtxSerializer ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . setSoTimeout ( NUMBER ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . start ( ) ; TcpSendingMessageHandler org.springframework.integration.ip.tcp.TcpSendingMessageHandler = new TcpSendingMessageHandler ( ) ; org.springframework.integration.ip.tcp.TcpSendingMessageHandler . setConnectionFactory ( org.springframework.integration.ip.tcp.AbstractConnectionFactory ) ; TcpReceivingChannelAdapter org.springframework.integration.ip.tcp.TcpReceivingChannelAdapter = new TcpReceivingChannelAdapter ( ) ; org.springframework.integration.ip.tcp.TcpReceivingChannelAdapter . setConnectionFactory ( org.springframework.integration.ip.tcp.AbstractConnectionFactory ) ; QueueChannel org.springframework.integration.ip.tcp.QueueChannel = new QueueChannel ( ) ; org.springframework.integration.ip.tcp.TcpReceivingChannelAdapter . setOutputChannel ( org.springframework.integration.ip.tcp.QueueChannel ) ; org.springframework.integration.ip.tcp.TcpSendingMessageHandler . handleMessage ( MessageBuilder . withPayload ( STRING ) . build ( ) ) ; org.springframework.integration.ip.tcp.TcpSendingMessageHandler . handleMessage ( MessageBuilder . withPayload ( STRING ) . build ( ) ) ; Message < ? > org.springframework.integration.ip.tcp.Message<?> = org.springframework.integration.ip.tcp.QueueChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.ip.tcp.Message<> ) ; assertEquals ( STRING , new java.lang.String ( ( byte [] ) org.springframework.integration.ip.tcp.Message<> . getPayload ( ) ) ) ; org.springframework.integration.ip.tcp.Message<?> = org.springframework.integration.ip.tcp.QueueChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.ip.tcp.Message<> ) ; assertEquals ( STRING , new java.lang.String ( ( byte [] ) org.springframework.integration.ip.tcp.Message<> . getPayload ( ) ) ) ; java.util.concurrent.atomic.AtomicBoolean . void ( true ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . stop ( ) ; java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . java.net.ServerSocket ( ) . void ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> < java.net.ServerSocket > java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> = new java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> < java.net.ServerSocket > ( ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; final java.util.concurrent.atomic.AtomicBoolean java.util.concurrent.atomic.AtomicBoolean = new java.util.concurrent.atomic.AtomicBoolean ( ) ; java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . void ( ( ) { try { java.net.ServerSocket java.net.ServerSocket = javax.net.ServerSocketFactory . javax.net.ServerSocketFactory ( ) . java.net.ServerSocket ( NUMBER ) ; java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . void ( java.net.ServerSocket ) ; java.util.concurrent.CountDownLatch . void ( ) ; java.net.Socket java.net.Socket = java.net.ServerSocket . java.net.Socket ( ) ; int int = NUMBER ; while ( true ) { byte [] byte[] = new byte [ NUMBER ] ; void ( java.net.Socket . java.io.InputStream ( ) , byte[] ) ; byte[] = ( STRING + ( ++ int ) + STRING ) . byte[] ( ) ; java.net.Socket . java.io.OutputStream ( ) . void ( byte[] ) ; } } catch ( java.lang.Exception java.lang.Exception ) { if ( ! java.util.concurrent.atomic.AtomicBoolean . boolean ( ) ) { java.lang.Exception . void ( ) ; } } } ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; AbstractConnectionFactory org.springframework.integration.ip.tcp.AbstractConnectionFactory = new TcpNioClientConnectionFactory ( STRING , java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . java.net.ServerSocket ( ) . int ( ) ) ; noopPublisher ( org.springframework.integration.ip.tcp.AbstractConnectionFactory ) ; ByteArrayStxEtxSerializer org.springframework.integration.ip.tcp.ByteArrayStxEtxSerializer = new ByteArrayStxEtxSerializer ( ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . setSerializer ( org.springframework.integration.ip.tcp.ByteArrayStxEtxSerializer ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . setDeserializer ( org.springframework.integration.ip.tcp.ByteArrayStxEtxSerializer ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . setSoTimeout ( NUMBER ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . start ( ) ; TcpSendingMessageHandler org.springframework.integration.ip.tcp.TcpSendingMessageHandler = new TcpSendingMessageHandler ( ) ; org.springframework.integration.ip.tcp.TcpSendingMessageHandler . setConnectionFactory ( org.springframework.integration.ip.tcp.AbstractConnectionFactory ) ; TcpReceivingChannelAdapter org.springframework.integration.ip.tcp.TcpReceivingChannelAdapter = new TcpReceivingChannelAdapter ( ) ; org.springframework.integration.ip.tcp.TcpReceivingChannelAdapter . setConnectionFactory ( org.springframework.integration.ip.tcp.AbstractConnectionFactory ) ; QueueChannel org.springframework.integration.ip.tcp.QueueChannel = new QueueChannel ( ) ; org.springframework.integration.ip.tcp.TcpReceivingChannelAdapter . setOutputChannel ( org.springframework.integration.ip.tcp.QueueChannel ) ; org.springframework.integration.ip.tcp.TcpSendingMessageHandler . handleMessage ( MessageBuilder . withPayload ( STRING ) . build ( ) ) ; org.springframework.integration.ip.tcp.TcpSendingMessageHandler . handleMessage ( MessageBuilder . withPayload ( STRING ) . build ( ) ) ; java.util.Set<java.lang.String> < java.lang.String > java.util.Set<java.lang.String> = new java.util.HashSet<java.lang.String> < java.lang.String > ( ) ; Message < ? > org.springframework.integration.ip.tcp.Message<?> = org.springframework.integration.ip.tcp.QueueChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.ip.tcp.Message<> ) ; java.util.Set<java.lang.String> . boolean ( new java.lang.String ( ( byte [] ) org.springframework.integration.ip.tcp.Message<> . getPayload ( ) ) ) ; org.springframework.integration.ip.tcp.Message<?> = org.springframework.integration.ip.tcp.QueueChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.ip.tcp.Message<> ) ; java.util.Set<java.lang.String> . boolean ( new java.lang.String ( ( byte [] ) org.springframework.integration.ip.tcp.Message<> . getPayload ( ) ) ) ; assertTrue ( java.util.Set<java.lang.String> . boolean ( STRING ) ) ; assertTrue ( java.util.Set<java.lang.String> . boolean ( STRING ) ) ; java.util.concurrent.atomic.AtomicBoolean . void ( true ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . stop ( ) ; java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . java.net.ServerSocket ( ) . void ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> < java.net.ServerSocket > java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> = new java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> < java.net.ServerSocket > ( ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; final java.util.concurrent.atomic.AtomicBoolean java.util.concurrent.atomic.AtomicBoolean = new java.util.concurrent.atomic.AtomicBoolean ( ) ; java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . void ( ( ) { try { java.net.ServerSocket java.net.ServerSocket = javax.net.ServerSocketFactory . javax.net.ServerSocketFactory ( ) . java.net.ServerSocket ( NUMBER ) ; java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . void ( java.net.ServerSocket ) ; java.util.concurrent.CountDownLatch . void ( ) ; java.net.Socket java.net.Socket = java.net.ServerSocket . java.net.Socket ( ) ; int int = NUMBER ; while ( true ) { byte [] byte[] = new byte [ NUMBER ] ; void ( java.net.Socket . java.io.InputStream ( ) , byte[] ) ; if ( ! STRING . boolean ( new java.lang.String ( byte[] ) ) ) { throw new java.lang.RuntimeException ( STRING ) ; } byte[] = ( STRING + ( ++ int ) ) . byte[] ( ) ; java.net.Socket . java.io.OutputStream ( ) . void ( byte[] ) ; } } catch ( java.lang.Exception java.lang.Exception ) { if ( ! java.util.concurrent.atomic.AtomicBoolean . boolean ( ) ) { java.lang.Exception . void ( ) ; } } } ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; AbstractConnectionFactory org.springframework.integration.ip.tcp.AbstractConnectionFactory = new TcpNetClientConnectionFactory ( STRING , java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . java.net.ServerSocket ( ) . int ( ) ) ; noopPublisher ( org.springframework.integration.ip.tcp.AbstractConnectionFactory ) ; ByteArrayLengthHeaderSerializer org.springframework.integration.ip.tcp.ByteArrayLengthHeaderSerializer = new ByteArrayLengthHeaderSerializer ( ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . setSerializer ( org.springframework.integration.ip.tcp.ByteArrayLengthHeaderSerializer ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . setDeserializer ( org.springframework.integration.ip.tcp.ByteArrayLengthHeaderSerializer ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . setSoTimeout ( NUMBER ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . start ( ) ; TcpSendingMessageHandler org.springframework.integration.ip.tcp.TcpSendingMessageHandler = new TcpSendingMessageHandler ( ) ; org.springframework.integration.ip.tcp.TcpSendingMessageHandler . setConnectionFactory ( org.springframework.integration.ip.tcp.AbstractConnectionFactory ) ; TcpReceivingChannelAdapter org.springframework.integration.ip.tcp.TcpReceivingChannelAdapter = new TcpReceivingChannelAdapter ( ) ; org.springframework.integration.ip.tcp.TcpReceivingChannelAdapter . setConnectionFactory ( org.springframework.integration.ip.tcp.AbstractConnectionFactory ) ; QueueChannel org.springframework.integration.ip.tcp.QueueChannel = new QueueChannel ( ) ; org.springframework.integration.ip.tcp.TcpReceivingChannelAdapter . setOutputChannel ( org.springframework.integration.ip.tcp.QueueChannel ) ; org.springframework.integration.ip.tcp.TcpSendingMessageHandler . handleMessage ( MessageBuilder . withPayload ( STRING ) . build ( ) ) ; org.springframework.integration.ip.tcp.TcpSendingMessageHandler . handleMessage ( MessageBuilder . withPayload ( STRING ) . build ( ) ) ; Message < ? > org.springframework.integration.ip.tcp.Message<?> = org.springframework.integration.ip.tcp.QueueChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.ip.tcp.Message<> ) ; assertEquals ( STRING , new java.lang.String ( ( byte [] ) org.springframework.integration.ip.tcp.Message<> . getPayload ( ) ) ) ; org.springframework.integration.ip.tcp.Message<?> = org.springframework.integration.ip.tcp.QueueChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.ip.tcp.Message<> ) ; assertEquals ( STRING , new java.lang.String ( ( byte [] ) org.springframework.integration.ip.tcp.Message<> . getPayload ( ) ) ) ; java.util.concurrent.atomic.AtomicBoolean . void ( true ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . stop ( ) ; java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . java.net.ServerSocket ( ) . void ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> < java.net.ServerSocket > java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> = new java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> < java.net.ServerSocket > ( ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; final java.util.concurrent.atomic.AtomicBoolean java.util.concurrent.atomic.AtomicBoolean = new java.util.concurrent.atomic.AtomicBoolean ( ) ; java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . void ( ( ) { try { java.net.ServerSocket java.net.ServerSocket = javax.net.ServerSocketFactory . javax.net.ServerSocketFactory ( ) . java.net.ServerSocket ( NUMBER ) ; java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . void ( java.net.ServerSocket ) ; java.util.concurrent.CountDownLatch . void ( ) ; java.net.Socket java.net.Socket = java.net.ServerSocket . java.net.Socket ( ) ; int int = NUMBER ; while ( true ) { byte [] byte[] = new byte [ NUMBER ] ; void ( java.net.Socket . java.io.InputStream ( ) , byte[] ) ; if ( ! STRING . boolean ( new java.lang.String ( byte[] ) ) ) { throw new java.lang.RuntimeException ( STRING ) ; } byte[] = ( STRING + ( ++ int ) ) . byte[] ( ) ; java.net.Socket . java.io.OutputStream ( ) . void ( byte[] ) ; } } catch ( java.lang.Exception java.lang.Exception ) { if ( ! java.util.concurrent.atomic.AtomicBoolean . boolean ( ) ) { java.lang.Exception . void ( ) ; } } } ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; AbstractConnectionFactory org.springframework.integration.ip.tcp.AbstractConnectionFactory = new TcpNioClientConnectionFactory ( STRING , java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . java.net.ServerSocket ( ) . int ( ) ) ; noopPublisher ( org.springframework.integration.ip.tcp.AbstractConnectionFactory ) ; ByteArrayLengthHeaderSerializer org.springframework.integration.ip.tcp.ByteArrayLengthHeaderSerializer = new ByteArrayLengthHeaderSerializer ( ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . setSerializer ( org.springframework.integration.ip.tcp.ByteArrayLengthHeaderSerializer ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . setDeserializer ( org.springframework.integration.ip.tcp.ByteArrayLengthHeaderSerializer ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . setSoTimeout ( NUMBER ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . start ( ) ; TcpSendingMessageHandler org.springframework.integration.ip.tcp.TcpSendingMessageHandler = new TcpSendingMessageHandler ( ) ; org.springframework.integration.ip.tcp.TcpSendingMessageHandler . setConnectionFactory ( org.springframework.integration.ip.tcp.AbstractConnectionFactory ) ; TcpReceivingChannelAdapter org.springframework.integration.ip.tcp.TcpReceivingChannelAdapter = new TcpReceivingChannelAdapter ( ) ; org.springframework.integration.ip.tcp.TcpReceivingChannelAdapter . setConnectionFactory ( org.springframework.integration.ip.tcp.AbstractConnectionFactory ) ; QueueChannel org.springframework.integration.ip.tcp.QueueChannel = new QueueChannel ( ) ; org.springframework.integration.ip.tcp.TcpReceivingChannelAdapter . setOutputChannel ( org.springframework.integration.ip.tcp.QueueChannel ) ; org.springframework.integration.ip.tcp.TcpSendingMessageHandler . handleMessage ( MessageBuilder . withPayload ( STRING ) . build ( ) ) ; org.springframework.integration.ip.tcp.TcpSendingMessageHandler . handleMessage ( MessageBuilder . withPayload ( STRING ) . build ( ) ) ; java.util.Set<java.lang.String> < java.lang.String > java.util.Set<java.lang.String> = new java.util.HashSet<java.lang.String> < java.lang.String > ( ) ; Message < ? > org.springframework.integration.ip.tcp.Message<?> = org.springframework.integration.ip.tcp.QueueChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.ip.tcp.Message<> ) ; java.util.Set<java.lang.String> . boolean ( new java.lang.String ( ( byte [] ) org.springframework.integration.ip.tcp.Message<> . getPayload ( ) ) ) ; org.springframework.integration.ip.tcp.Message<?> = org.springframework.integration.ip.tcp.QueueChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.ip.tcp.Message<> ) ; java.util.Set<java.lang.String> . boolean ( new java.lang.String ( ( byte [] ) org.springframework.integration.ip.tcp.Message<> . getPayload ( ) ) ) ; assertTrue ( java.util.Set<java.lang.String> . boolean ( STRING ) ) ; assertTrue ( java.util.Set<java.lang.String> . boolean ( STRING ) ) ; java.util.concurrent.atomic.AtomicBoolean . void ( true ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . stop ( ) ; java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . java.net.ServerSocket ( ) . void ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> < java.net.ServerSocket > java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> = new java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> < java.net.ServerSocket > ( ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; final java.util.concurrent.atomic.AtomicBoolean java.util.concurrent.atomic.AtomicBoolean = new java.util.concurrent.atomic.AtomicBoolean ( ) ; java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . void ( ( ) { try { java.net.ServerSocket java.net.ServerSocket = javax.net.ServerSocketFactory . javax.net.ServerSocketFactory ( ) . java.net.ServerSocket ( NUMBER ) ; java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . void ( java.net.ServerSocket ) ; java.util.concurrent.CountDownLatch . void ( ) ; java.net.Socket java.net.Socket = java.net.ServerSocket . java.net.Socket ( ) ; int int = NUMBER ; while ( true ) { java.io.ObjectInputStream java.io.ObjectInputStream = new java.io.ObjectInputStream ( java.net.Socket . java.io.InputStream ( ) ) ; java.io.ObjectInputStream . java.lang.Object ( ) ; java.io.ObjectOutputStream java.io.ObjectOutputStream = new java.io.ObjectOutputStream ( java.net.Socket . java.io.OutputStream ( ) ) ; java.io.ObjectOutputStream . void ( STRING + ( ++ int ) ) ; } } catch ( java.lang.Exception java.lang.Exception ) { if ( ! java.util.concurrent.atomic.AtomicBoolean . boolean ( ) ) { java.lang.Exception . void ( ) ; } } } ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; AbstractConnectionFactory org.springframework.integration.ip.tcp.AbstractConnectionFactory = new TcpNetClientConnectionFactory ( STRING , java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . java.net.ServerSocket ( ) . int ( ) ) ; noopPublisher ( org.springframework.integration.ip.tcp.AbstractConnectionFactory ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . setSerializer ( new DefaultSerializer ( ) ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . setDeserializer ( new DefaultDeserializer ( ) ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . setSoTimeout ( NUMBER ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . start ( ) ; TcpSendingMessageHandler org.springframework.integration.ip.tcp.TcpSendingMessageHandler = new TcpSendingMessageHandler ( ) ; org.springframework.integration.ip.tcp.TcpSendingMessageHandler . setConnectionFactory ( org.springframework.integration.ip.tcp.AbstractConnectionFactory ) ; TcpReceivingChannelAdapter org.springframework.integration.ip.tcp.TcpReceivingChannelAdapter = new TcpReceivingChannelAdapter ( ) ; org.springframework.integration.ip.tcp.TcpReceivingChannelAdapter . setConnectionFactory ( org.springframework.integration.ip.tcp.AbstractConnectionFactory ) ; QueueChannel org.springframework.integration.ip.tcp.QueueChannel = new QueueChannel ( ) ; org.springframework.integration.ip.tcp.TcpReceivingChannelAdapter . setOutputChannel ( org.springframework.integration.ip.tcp.QueueChannel ) ; org.springframework.integration.ip.tcp.TcpSendingMessageHandler . handleMessage ( MessageBuilder . withPayload ( STRING ) . build ( ) ) ; org.springframework.integration.ip.tcp.TcpSendingMessageHandler . handleMessage ( MessageBuilder . withPayload ( STRING ) . build ( ) ) ; Message < ? > org.springframework.integration.ip.tcp.Message<?> = org.springframework.integration.ip.tcp.QueueChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.ip.tcp.Message<> ) ; assertEquals ( STRING , org.springframework.integration.ip.tcp.Message<> . getPayload ( ) ) ; org.springframework.integration.ip.tcp.Message<?> = org.springframework.integration.ip.tcp.QueueChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.ip.tcp.Message<> ) ; assertEquals ( STRING , org.springframework.integration.ip.tcp.Message<> . getPayload ( ) ) ; java.util.concurrent.atomic.AtomicBoolean . void ( true ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . stop ( ) ; java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . java.net.ServerSocket ( ) . void ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> < java.net.ServerSocket > java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> = new java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> < java.net.ServerSocket > ( ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; final java.util.concurrent.atomic.AtomicBoolean java.util.concurrent.atomic.AtomicBoolean = new java.util.concurrent.atomic.AtomicBoolean ( ) ; java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . void ( ( ) { try { java.net.ServerSocket java.net.ServerSocket = javax.net.ServerSocketFactory . javax.net.ServerSocketFactory ( ) . java.net.ServerSocket ( NUMBER ) ; java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . void ( java.net.ServerSocket ) ; java.util.concurrent.CountDownLatch . void ( ) ; java.net.Socket java.net.Socket = java.net.ServerSocket . java.net.Socket ( ) ; int int = NUMBER ; while ( true ) { java.io.ObjectInputStream java.io.ObjectInputStream = new java.io.ObjectInputStream ( java.net.Socket . java.io.InputStream ( ) ) ; java.io.ObjectInputStream . java.lang.Object ( ) ; java.io.ObjectOutputStream java.io.ObjectOutputStream = new java.io.ObjectOutputStream ( java.net.Socket . java.io.OutputStream ( ) ) ; java.io.ObjectOutputStream . void ( STRING + ( ++ int ) ) ; } } catch ( java.lang.Exception java.lang.Exception ) { if ( ! java.util.concurrent.atomic.AtomicBoolean . boolean ( ) ) { java.lang.Exception . void ( ) ; } } } ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; AbstractConnectionFactory org.springframework.integration.ip.tcp.AbstractConnectionFactory = new TcpNioClientConnectionFactory ( STRING , java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . java.net.ServerSocket ( ) . int ( ) ) ; noopPublisher ( org.springframework.integration.ip.tcp.AbstractConnectionFactory ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . setSerializer ( new DefaultSerializer ( ) ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . setDeserializer ( new DefaultDeserializer ( ) ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . setSoTimeout ( NUMBER ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . start ( ) ; TcpSendingMessageHandler org.springframework.integration.ip.tcp.TcpSendingMessageHandler = new TcpSendingMessageHandler ( ) ; org.springframework.integration.ip.tcp.TcpSendingMessageHandler . setConnectionFactory ( org.springframework.integration.ip.tcp.AbstractConnectionFactory ) ; TcpReceivingChannelAdapter org.springframework.integration.ip.tcp.TcpReceivingChannelAdapter = new TcpReceivingChannelAdapter ( ) ; org.springframework.integration.ip.tcp.TcpReceivingChannelAdapter . setConnectionFactory ( org.springframework.integration.ip.tcp.AbstractConnectionFactory ) ; QueueChannel org.springframework.integration.ip.tcp.QueueChannel = new QueueChannel ( ) ; org.springframework.integration.ip.tcp.TcpReceivingChannelAdapter . setOutputChannel ( org.springframework.integration.ip.tcp.QueueChannel ) ; org.springframework.integration.ip.tcp.TcpSendingMessageHandler . handleMessage ( MessageBuilder . withPayload ( STRING ) . build ( ) ) ; org.springframework.integration.ip.tcp.TcpSendingMessageHandler . handleMessage ( MessageBuilder . withPayload ( STRING ) . build ( ) ) ; java.util.Set<java.lang.String> < java.lang.String > java.util.Set<java.lang.String> = new java.util.HashSet<java.lang.String> < java.lang.String > ( ) ; Message < ? > org.springframework.integration.ip.tcp.Message<?> = org.springframework.integration.ip.tcp.QueueChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.ip.tcp.Message<> ) ; java.util.Set<java.lang.String> . boolean ( ( java.lang.String ) org.springframework.integration.ip.tcp.Message<> . getPayload ( ) ) ; org.springframework.integration.ip.tcp.Message<?> = org.springframework.integration.ip.tcp.QueueChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.ip.tcp.Message<> ) ; java.util.Set<java.lang.String> . boolean ( ( java.lang.String ) org.springframework.integration.ip.tcp.Message<> . getPayload ( ) ) ; assertTrue ( java.util.Set<java.lang.String> . boolean ( STRING ) ) ; assertTrue ( java.util.Set<java.lang.String> . boolean ( STRING ) ) ; java.util.concurrent.atomic.AtomicBoolean . void ( true ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . stop ( ) ; java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . java.net.ServerSocket ( ) . void ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> < java.net.ServerSocket > java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> = new java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> < java.net.ServerSocket > ( ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; final java.util.concurrent.Semaphore java.util.concurrent.Semaphore = new java.util.concurrent.Semaphore ( NUMBER ) ; final java.util.concurrent.atomic.AtomicBoolean java.util.concurrent.atomic.AtomicBoolean = new java.util.concurrent.atomic.AtomicBoolean ( ) ; java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . void ( ( ) { try { java.net.ServerSocket java.net.ServerSocket = javax.net.ServerSocketFactory . javax.net.ServerSocketFactory ( ) . java.net.ServerSocket ( NUMBER ) ; java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . void ( java.net.ServerSocket ) ; java.util.concurrent.CountDownLatch . void ( ) ; for ( int int = NUMBER ; int < NUMBER ; int ++ ) { java.net.Socket java.net.Socket = java.net.ServerSocket . java.net.Socket ( ) ; java.util.concurrent.Semaphore . void ( ) ; byte [] byte[] = new byte [ NUMBER ] ; void ( java.net.Socket . java.io.InputStream ( ) , byte[] ) ; java.util.concurrent.Semaphore . void ( ) ; java.net.Socket . void ( ) ; } java.net.ServerSocket . void ( ) ; } catch ( java.lang.Exception java.lang.Exception ) { if ( ! java.util.concurrent.atomic.AtomicBoolean . boolean ( ) ) { java.lang.Exception . void ( ) ; } } } ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; AbstractConnectionFactory org.springframework.integration.ip.tcp.AbstractConnectionFactory = new TcpNetClientConnectionFactory ( STRING , java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . java.net.ServerSocket ( ) . int ( ) ) ; noopPublisher ( org.springframework.integration.ip.tcp.AbstractConnectionFactory ) ; ByteArrayCrLfSerializer org.springframework.integration.ip.tcp.ByteArrayCrLfSerializer = new ByteArrayCrLfSerializer ( ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . setSerializer ( org.springframework.integration.ip.tcp.ByteArrayCrLfSerializer ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . setDeserializer ( org.springframework.integration.ip.tcp.ByteArrayCrLfSerializer ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . setSoTimeout ( NUMBER ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . start ( ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . setSingleUse ( true ) ; TcpSendingMessageHandler org.springframework.integration.ip.tcp.TcpSendingMessageHandler = new TcpSendingMessageHandler ( ) ; org.springframework.integration.ip.tcp.TcpSendingMessageHandler . setConnectionFactory ( org.springframework.integration.ip.tcp.AbstractConnectionFactory ) ; org.springframework.integration.ip.tcp.TcpSendingMessageHandler . handleMessage ( MessageBuilder . withPayload ( STRING ) . build ( ) ) ; org.springframework.integration.ip.tcp.TcpSendingMessageHandler . handleMessage ( MessageBuilder . withPayload ( STRING ) . build ( ) ) ; assertTrue ( java.util.concurrent.Semaphore . boolean ( NUMBER , NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; java.util.concurrent.atomic.AtomicBoolean . void ( true ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . stop ( ) ; java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . java.net.ServerSocket ( ) . void ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> < java.net.ServerSocket > java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> = new java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> < java.net.ServerSocket > ( ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; final java.util.concurrent.Semaphore java.util.concurrent.Semaphore = new java.util.concurrent.Semaphore ( NUMBER ) ; final java.util.concurrent.atomic.AtomicBoolean java.util.concurrent.atomic.AtomicBoolean = new java.util.concurrent.atomic.AtomicBoolean ( ) ; java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . void ( ( ) { try { java.net.ServerSocket java.net.ServerSocket = javax.net.ServerSocketFactory . javax.net.ServerSocketFactory ( ) . java.net.ServerSocket ( NUMBER ) ; java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . void ( java.net.ServerSocket ) ; java.util.concurrent.CountDownLatch . void ( ) ; for ( int int = NUMBER ; int < NUMBER ; int ++ ) { java.net.Socket java.net.Socket = java.net.ServerSocket . java.net.Socket ( ) ; java.util.concurrent.Semaphore . void ( ) ; byte [] byte[] = new byte [ NUMBER ] ; void ( java.net.Socket . java.io.InputStream ( ) , byte[] ) ; java.util.concurrent.Semaphore . void ( ) ; java.net.Socket . void ( ) ; } java.net.ServerSocket . void ( ) ; } catch ( java.lang.Exception java.lang.Exception ) { if ( ! java.util.concurrent.atomic.AtomicBoolean . boolean ( ) ) { java.lang.Exception . void ( ) ; } } } ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; AbstractConnectionFactory org.springframework.integration.ip.tcp.AbstractConnectionFactory = new TcpNioClientConnectionFactory ( STRING , java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . java.net.ServerSocket ( ) . int ( ) ) ; noopPublisher ( org.springframework.integration.ip.tcp.AbstractConnectionFactory ) ; ByteArrayCrLfSerializer org.springframework.integration.ip.tcp.ByteArrayCrLfSerializer = new ByteArrayCrLfSerializer ( ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . setSerializer ( org.springframework.integration.ip.tcp.ByteArrayCrLfSerializer ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . setDeserializer ( org.springframework.integration.ip.tcp.ByteArrayCrLfSerializer ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . setSoTimeout ( NUMBER ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . start ( ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . setSingleUse ( true ) ; TcpSendingMessageHandler org.springframework.integration.ip.tcp.TcpSendingMessageHandler = new TcpSendingMessageHandler ( ) ; org.springframework.integration.ip.tcp.TcpSendingMessageHandler . setConnectionFactory ( org.springframework.integration.ip.tcp.AbstractConnectionFactory ) ; org.springframework.integration.ip.tcp.TcpSendingMessageHandler . handleMessage ( MessageBuilder . withPayload ( STRING ) . build ( ) ) ; org.springframework.integration.ip.tcp.TcpSendingMessageHandler . handleMessage ( MessageBuilder . withPayload ( STRING ) . build ( ) ) ; assertTrue ( java.util.concurrent.Semaphore . boolean ( NUMBER , NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; java.util.concurrent.atomic.AtomicBoolean . void ( true ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . stop ( ) ; java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . java.net.ServerSocket ( ) . void ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> < java.net.ServerSocket > java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> = new java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> < java.net.ServerSocket > ( ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; final java.util.concurrent.Semaphore java.util.concurrent.Semaphore = new java.util.concurrent.Semaphore ( NUMBER ) ; final java.util.concurrent.atomic.AtomicBoolean java.util.concurrent.atomic.AtomicBoolean = new java.util.concurrent.atomic.AtomicBoolean ( ) ; java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . void ( ( ) { try { java.net.ServerSocket java.net.ServerSocket = javax.net.ServerSocketFactory . javax.net.ServerSocketFactory ( ) . java.net.ServerSocket ( NUMBER ) ; java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . void ( java.net.ServerSocket ) ; java.util.concurrent.CountDownLatch . void ( ) ; for ( int int = NUMBER ; int < NUMBER ; int ++ ) { java.net.Socket java.net.Socket = java.net.ServerSocket . java.net.Socket ( ) ; java.util.concurrent.Semaphore . void ( ) ; byte [] byte[] = new byte [ NUMBER ] ; void ( java.net.Socket . java.io.InputStream ( ) , byte[] ) ; byte[] = ( STRING + int + STRING ) . byte[] ( ) ; java.net.Socket . java.io.OutputStream ( ) . void ( byte[] ) ; java.net.Socket . void ( ) ; } java.net.ServerSocket . void ( ) ; } catch ( java.lang.Exception java.lang.Exception ) { if ( ! java.util.concurrent.atomic.AtomicBoolean . boolean ( ) ) { java.lang.Exception . void ( ) ; } } } ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; AbstractConnectionFactory org.springframework.integration.ip.tcp.AbstractConnectionFactory = new TcpNetClientConnectionFactory ( STRING , java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . java.net.ServerSocket ( ) . int ( ) ) ; noopPublisher ( org.springframework.integration.ip.tcp.AbstractConnectionFactory ) ; ByteArrayCrLfSerializer org.springframework.integration.ip.tcp.ByteArrayCrLfSerializer = new ByteArrayCrLfSerializer ( ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . setSerializer ( org.springframework.integration.ip.tcp.ByteArrayCrLfSerializer ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . setDeserializer ( org.springframework.integration.ip.tcp.ByteArrayCrLfSerializer ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . setSoTimeout ( NUMBER ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . start ( ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . setSingleUse ( true ) ; TcpSendingMessageHandler org.springframework.integration.ip.tcp.TcpSendingMessageHandler = new TcpSendingMessageHandler ( ) ; org.springframework.integration.ip.tcp.TcpSendingMessageHandler . setConnectionFactory ( org.springframework.integration.ip.tcp.AbstractConnectionFactory ) ; TcpReceivingChannelAdapter org.springframework.integration.ip.tcp.TcpReceivingChannelAdapter = new TcpReceivingChannelAdapter ( ) ; org.springframework.integration.ip.tcp.TcpReceivingChannelAdapter . setConnectionFactory ( org.springframework.integration.ip.tcp.AbstractConnectionFactory ) ; QueueChannel org.springframework.integration.ip.tcp.QueueChannel = new QueueChannel ( ) ; org.springframework.integration.ip.tcp.TcpReceivingChannelAdapter . setOutputChannel ( org.springframework.integration.ip.tcp.QueueChannel ) ; org.springframework.integration.ip.tcp.TcpSendingMessageHandler . handleMessage ( MessageBuilder . withPayload ( STRING ) . build ( ) ) ; org.springframework.integration.ip.tcp.TcpSendingMessageHandler . handleMessage ( MessageBuilder . withPayload ( STRING ) . build ( ) ) ; assertTrue ( java.util.concurrent.Semaphore . boolean ( NUMBER , NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; java.util.Set<java.lang.String> < java.lang.String > java.util.Set<java.lang.String> = new java.util.HashSet<java.lang.String> < java.lang.String > ( ) ; for ( int int = NUMBER ; int < NUMBER ; int ++ ) { Message < ? > org.springframework.integration.ip.tcp.Message<?> = org.springframework.integration.ip.tcp.QueueChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.ip.tcp.Message<> ) ; java.util.Set<java.lang.String> . boolean ( new java.lang.String ( ( byte [] ) org.springframework.integration.ip.tcp.Message<> . getPayload ( ) ) ) ; } assertTrue ( java.util.Set<java.lang.String> . boolean ( STRING ) ) ; assertTrue ( java.util.Set<java.lang.String> . boolean ( STRING ) ) ; java.util.concurrent.atomic.AtomicBoolean . void ( true ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . stop ( ) ; java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . java.net.ServerSocket ( ) . void ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> < java.net.ServerSocket > java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> = new java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> < java.net.ServerSocket > ( ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; final java.util.concurrent.Semaphore java.util.concurrent.Semaphore = new java.util.concurrent.Semaphore ( NUMBER ) ; final java.util.concurrent.atomic.AtomicBoolean java.util.concurrent.atomic.AtomicBoolean = new java.util.concurrent.atomic.AtomicBoolean ( ) ; java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . void ( ( ) { try { java.net.ServerSocket java.net.ServerSocket = javax.net.ServerSocketFactory . javax.net.ServerSocketFactory ( ) . java.net.ServerSocket ( NUMBER ) ; java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . void ( java.net.ServerSocket ) ; java.util.concurrent.CountDownLatch . void ( ) ; for ( int int = NUMBER ; int < NUMBER ; int ++ ) { java.net.Socket java.net.Socket = java.net.ServerSocket . java.net.Socket ( ) ; java.util.concurrent.Semaphore . void ( ) ; byte [] byte[] = new byte [ NUMBER ] ; void ( java.net.Socket . java.io.InputStream ( ) , byte[] ) ; byte[] = ( STRING + int + STRING ) . byte[] ( ) ; java.net.Socket . java.io.OutputStream ( ) . void ( byte[] ) ; java.net.Socket . void ( ) ; } java.net.ServerSocket . void ( ) ; } catch ( java.lang.Exception java.lang.Exception ) { if ( ! java.util.concurrent.atomic.AtomicBoolean . boolean ( ) ) { java.lang.Exception . void ( ) ; } } } ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; AbstractConnectionFactory org.springframework.integration.ip.tcp.AbstractConnectionFactory = new TcpNioClientConnectionFactory ( STRING , java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . java.net.ServerSocket ( ) . int ( ) ) ; noopPublisher ( org.springframework.integration.ip.tcp.AbstractConnectionFactory ) ; ByteArrayCrLfSerializer org.springframework.integration.ip.tcp.ByteArrayCrLfSerializer = new ByteArrayCrLfSerializer ( ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . setSerializer ( org.springframework.integration.ip.tcp.ByteArrayCrLfSerializer ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . setDeserializer ( org.springframework.integration.ip.tcp.ByteArrayCrLfSerializer ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . setSoTimeout ( NUMBER ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . start ( ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . setSingleUse ( true ) ; TcpSendingMessageHandler org.springframework.integration.ip.tcp.TcpSendingMessageHandler = new TcpSendingMessageHandler ( ) ; org.springframework.integration.ip.tcp.TcpSendingMessageHandler . setConnectionFactory ( org.springframework.integration.ip.tcp.AbstractConnectionFactory ) ; TcpReceivingChannelAdapter org.springframework.integration.ip.tcp.TcpReceivingChannelAdapter = new TcpReceivingChannelAdapter ( ) ; org.springframework.integration.ip.tcp.TcpReceivingChannelAdapter . setConnectionFactory ( org.springframework.integration.ip.tcp.AbstractConnectionFactory ) ; QueueChannel org.springframework.integration.ip.tcp.QueueChannel = new QueueChannel ( ) ; org.springframework.integration.ip.tcp.TcpReceivingChannelAdapter . setOutputChannel ( org.springframework.integration.ip.tcp.QueueChannel ) ; org.springframework.integration.ip.tcp.TcpSendingMessageHandler . handleMessage ( MessageBuilder . withPayload ( STRING ) . build ( ) ) ; org.springframework.integration.ip.tcp.TcpSendingMessageHandler . handleMessage ( MessageBuilder . withPayload ( STRING ) . build ( ) ) ; assertTrue ( java.util.concurrent.Semaphore . boolean ( NUMBER , NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; java.util.Set<java.lang.String> < java.lang.String > java.util.Set<java.lang.String> = new java.util.HashSet<java.lang.String> < java.lang.String > ( ) ; for ( int int = NUMBER ; int < NUMBER ; int ++ ) { Message < ? > org.springframework.integration.ip.tcp.Message<?> = org.springframework.integration.ip.tcp.QueueChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.ip.tcp.Message<> ) ; java.util.Set<java.lang.String> . boolean ( new java.lang.String ( ( byte [] ) org.springframework.integration.ip.tcp.Message<> . getPayload ( ) ) ) ; } assertTrue ( java.util.Set<java.lang.String> . boolean ( STRING ) ) ; assertTrue ( java.util.Set<java.lang.String> . boolean ( STRING ) ) ; java.util.concurrent.atomic.AtomicBoolean . void ( true ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . stop ( ) ; java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . java.net.ServerSocket ( ) . void ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> < java.net.ServerSocket > java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> = new java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> < java.net.ServerSocket > ( ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; final java.util.concurrent.Semaphore java.util.concurrent.Semaphore = new java.util.concurrent.Semaphore ( NUMBER ) ; final java.util.concurrent.atomic.AtomicBoolean java.util.concurrent.atomic.AtomicBoolean = new java.util.concurrent.atomic.AtomicBoolean ( ) ; final java.util.List<java.net.Socket> < java.net.Socket > java.util.List<java.net.Socket> = new java.util.ArrayList<java.net.Socket> < java.net.Socket > ( ) ; final java.util.concurrent.ExecutorService java.util.concurrent.ExecutorService = java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) ; java.util.concurrent.ExecutorService . void ( ( ) { try { java.net.ServerSocket java.net.ServerSocket = javax.net.ServerSocketFactory . javax.net.ServerSocketFactory ( ) . java.net.ServerSocket ( NUMBER , NUMBER ) ; java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . void ( java.net.ServerSocket ) ; java.util.concurrent.CountDownLatch . void ( ) ; for ( int int = NUMBER ; int < NUMBER ; int ++ ) { final java.net.Socket java.net.Socket = java.net.ServerSocket . java.net.Socket ( ) ; java.util.List<java.net.Socket> . boolean ( java.net.Socket ) ; final int int = int ; java.util.concurrent.ExecutorService . void ( ( ) { java.util.concurrent.Semaphore . void ( ) ; byte [] byte[] = new byte [ NUMBER ] ; try { void ( java.net.Socket . java.io.InputStream ( ) , byte[] ) ; byte[] = ( STRING + int + STRING ) . byte[] ( ) ; java.net.Socket . java.io.OutputStream ( ) . void ( byte[] ) ; } catch ( java.io.IOException java.io.IOException ) { java.io.IOException . void ( ) ; } finally { try { java.net.Socket . void ( ) ; } catch ( java.io.IOException java.io.IOException ) { } } } ) ; } java.net.ServerSocket . void ( ) ; } catch ( java.lang.Exception java.lang.Exception ) { if ( ! java.util.concurrent.atomic.AtomicBoolean . boolean ( ) ) { java.lang.Exception . void ( ) ; } } } ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; AbstractConnectionFactory org.springframework.integration.ip.tcp.AbstractConnectionFactory = new TcpNioClientConnectionFactory ( STRING , java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . java.net.ServerSocket ( ) . int ( ) ) ; noopPublisher ( org.springframework.integration.ip.tcp.AbstractConnectionFactory ) ; ByteArrayCrLfSerializer org.springframework.integration.ip.tcp.ByteArrayCrLfSerializer = new ByteArrayCrLfSerializer ( ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . setSerializer ( org.springframework.integration.ip.tcp.ByteArrayCrLfSerializer ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . setDeserializer ( org.springframework.integration.ip.tcp.ByteArrayCrLfSerializer ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . setSoTimeout ( NUMBER ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . setSingleUse ( true ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . setTaskExecutor ( java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . start ( ) ; TcpSendingMessageHandler org.springframework.integration.ip.tcp.TcpSendingMessageHandler = new TcpSendingMessageHandler ( ) ; org.springframework.integration.ip.tcp.TcpSendingMessageHandler . setConnectionFactory ( org.springframework.integration.ip.tcp.AbstractConnectionFactory ) ; TcpReceivingChannelAdapter org.springframework.integration.ip.tcp.TcpReceivingChannelAdapter = new TcpReceivingChannelAdapter ( ) ; org.springframework.integration.ip.tcp.TcpReceivingChannelAdapter . setConnectionFactory ( org.springframework.integration.ip.tcp.AbstractConnectionFactory ) ; QueueChannel org.springframework.integration.ip.tcp.QueueChannel = new QueueChannel ( ) ; org.springframework.integration.ip.tcp.TcpReceivingChannelAdapter . setOutputChannel ( org.springframework.integration.ip.tcp.QueueChannel ) ; int int = NUMBER ; try { for ( int = NUMBER ; int < NUMBER ; int ++ ) { org.springframework.integration.ip.tcp.TcpSendingMessageHandler . handleMessage ( MessageBuilder . withPayload ( STRING + int ) . build ( ) ) ; } } catch ( java.lang.Exception java.lang.Exception ) { java.lang.Exception . void ( ) ; fail ( STRING + int ) ; } assertTrue ( java.util.concurrent.Semaphore . boolean ( NUMBER , NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; java.util.Set<java.lang.String> < java.lang.String > java.util.Set<java.lang.String> = new java.util.HashSet<java.lang.String> < java.lang.String > ( ) ; for ( int = NUMBER ; int < NUMBER ; int ++ ) { Message < ? > org.springframework.integration.ip.tcp.Message<?> = org.springframework.integration.ip.tcp.QueueChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.ip.tcp.Message<> ) ; java.util.Set<java.lang.String> . boolean ( new java.lang.String ( ( byte [] ) org.springframework.integration.ip.tcp.Message<> . getPayload ( ) ) ) ; } for ( int = NUMBER ; int < NUMBER ; int ++ ) { assertTrue ( STRING + int + STRING , java.util.Set<java.lang.String> . boolean ( STRING + int ) ) ; } java.util.concurrent.atomic.AtomicBoolean . void ( true ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . stop ( ) ; java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . java.net.ServerSocket ( ) . void ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> < java.net.ServerSocket > java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> = new java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> < java.net.ServerSocket > ( ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; final java.util.concurrent.atomic.AtomicBoolean java.util.concurrent.atomic.AtomicBoolean = new java.util.concurrent.atomic.AtomicBoolean ( ) ; java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . void ( ( ) { try { java.net.ServerSocket java.net.ServerSocket = javax.net.ServerSocketFactory . javax.net.ServerSocketFactory ( ) . java.net.ServerSocket ( NUMBER ) ; java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . void ( java.net.ServerSocket ) ; java.util.concurrent.CountDownLatch . void ( ) ; java.net.Socket java.net.Socket = java.net.ServerSocket . java.net.Socket ( ) ; int int = NUMBER ; while ( true ) { java.io.ObjectInputStream java.io.ObjectInputStream = new java.io.ObjectInputStream ( java.net.Socket . java.io.InputStream ( ) ) ; java.lang.Object java.lang.Object = null ; java.io.ObjectOutputStream java.io.ObjectOutputStream = new java.io.ObjectOutputStream ( java.net.Socket . java.io.OutputStream ( ) ) ; if ( int == NUMBER ) { java.lang.Object = java.io.ObjectInputStream . java.lang.Object ( ) ; org.springframework.integration.ip.tcp.Log . debug ( STRING + java.lang.Object ) ; java.io.ObjectOutputStream . void ( STRING ) ; java.io.ObjectInputStream = new java.io.ObjectInputStream ( java.net.Socket . java.io.InputStream ( ) ) ; java.io.ObjectOutputStream = new java.io.ObjectOutputStream ( java.net.Socket . java.io.OutputStream ( ) ) ; java.lang.Object = java.io.ObjectInputStream . java.lang.Object ( ) ; org.springframework.integration.ip.tcp.Log . debug ( STRING + java.lang.Object ) ; java.io.ObjectOutputStream . void ( STRING ) ; java.io.ObjectInputStream = new java.io.ObjectInputStream ( java.net.Socket . java.io.InputStream ( ) ) ; java.io.ObjectOutputStream = new java.io.ObjectOutputStream ( java.net.Socket . java.io.OutputStream ( ) ) ; } java.lang.Object = java.io.ObjectInputStream . java.lang.Object ( ) ; java.io.ObjectOutputStream . void ( STRING + ( ++ int ) ) ; } } catch ( java.lang.Exception java.lang.Exception ) { if ( ! java.util.concurrent.atomic.AtomicBoolean . boolean ( ) ) { java.lang.Exception . void ( ) ; } } } ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; AbstractConnectionFactory org.springframework.integration.ip.tcp.AbstractConnectionFactory = new TcpNetClientConnectionFactory ( STRING , java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . java.net.ServerSocket ( ) . int ( ) ) ; noopPublisher ( org.springframework.integration.ip.tcp.AbstractConnectionFactory ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . setSerializer ( new DefaultSerializer ( ) ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . setDeserializer ( new DefaultDeserializer ( ) ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . setSoTimeout ( NUMBER ) ; TcpConnectionInterceptorFactoryChain org.springframework.integration.ip.tcp.TcpConnectionInterceptorFactoryChain = new TcpConnectionInterceptorFactoryChain ( ) ; org.springframework.integration.ip.tcp.TcpConnectionInterceptorFactoryChain . setInterceptors ( new TcpConnectionInterceptorFactory [] { newInterceptorFactory ( ) , newInterceptorFactory ( ) } ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . setInterceptorFactoryChain ( org.springframework.integration.ip.tcp.TcpConnectionInterceptorFactoryChain ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . start ( ) ; TcpSendingMessageHandler org.springframework.integration.ip.tcp.TcpSendingMessageHandler = new TcpSendingMessageHandler ( ) ; org.springframework.integration.ip.tcp.TcpSendingMessageHandler . setConnectionFactory ( org.springframework.integration.ip.tcp.AbstractConnectionFactory ) ; TcpReceivingChannelAdapter org.springframework.integration.ip.tcp.TcpReceivingChannelAdapter = new TcpReceivingChannelAdapter ( ) ; org.springframework.integration.ip.tcp.TcpReceivingChannelAdapter . setConnectionFactory ( org.springframework.integration.ip.tcp.AbstractConnectionFactory ) ; QueueChannel org.springframework.integration.ip.tcp.QueueChannel = new QueueChannel ( ) ; org.springframework.integration.ip.tcp.TcpReceivingChannelAdapter . setOutputChannel ( org.springframework.integration.ip.tcp.QueueChannel ) ; org.springframework.integration.ip.tcp.TcpSendingMessageHandler . handleMessage ( MessageBuilder . withPayload ( STRING ) . build ( ) ) ; org.springframework.integration.ip.tcp.TcpSendingMessageHandler . handleMessage ( MessageBuilder . withPayload ( STRING ) . build ( ) ) ; Message < ? > org.springframework.integration.ip.tcp.Message<?> = org.springframework.integration.ip.tcp.QueueChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.ip.tcp.Message<> ) ; assertEquals ( STRING , org.springframework.integration.ip.tcp.Message<> . getPayload ( ) ) ; org.springframework.integration.ip.tcp.Message<?> = org.springframework.integration.ip.tcp.QueueChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.ip.tcp.Message<> ) ; assertEquals ( STRING , org.springframework.integration.ip.tcp.Message<> . getPayload ( ) ) ; java.util.concurrent.atomic.AtomicBoolean . void ( true ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . stop ( ) ; java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . java.net.ServerSocket ( ) . void ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> < java.net.ServerSocket > java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> = new java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> < java.net.ServerSocket > ( ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; final java.util.concurrent.atomic.AtomicBoolean java.util.concurrent.atomic.AtomicBoolean = new java.util.concurrent.atomic.AtomicBoolean ( ) ; java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . void ( ( ) { try { java.net.ServerSocket java.net.ServerSocket = javax.net.ServerSocketFactory . javax.net.ServerSocketFactory ( ) . java.net.ServerSocket ( NUMBER ) ; java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . void ( java.net.ServerSocket ) ; java.util.concurrent.CountDownLatch . void ( ) ; java.net.Socket java.net.Socket = java.net.ServerSocket . java.net.Socket ( ) ; int int = NUMBER ; while ( true ) { java.io.ObjectInputStream java.io.ObjectInputStream = new java.io.ObjectInputStream ( java.net.Socket . java.io.InputStream ( ) ) ; java.lang.Object java.lang.Object ; java.io.ObjectOutputStream java.io.ObjectOutputStream = new java.io.ObjectOutputStream ( java.net.Socket . java.io.OutputStream ( ) ) ; if ( int == NUMBER ) { java.lang.Object = java.io.ObjectInputStream . java.lang.Object ( ) ; org.springframework.integration.ip.tcp.Log . debug ( STRING + java.lang.Object ) ; java.io.ObjectOutputStream . void ( STRING ) ; java.io.ObjectInputStream = new java.io.ObjectInputStream ( java.net.Socket . java.io.InputStream ( ) ) ; java.io.ObjectOutputStream = new java.io.ObjectOutputStream ( java.net.Socket . java.io.OutputStream ( ) ) ; java.lang.Thread . void ( NUMBER ) ; } java.lang.Object = java.io.ObjectInputStream . java.lang.Object ( ) ; java.io.ObjectOutputStream . void ( STRING + ( int ++ ) ) ; } } catch ( java.lang.Exception java.lang.Exception ) { if ( ! java.util.concurrent.atomic.AtomicBoolean . boolean ( ) ) { java.lang.Exception . void ( ) ; } } } ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; AbstractConnectionFactory org.springframework.integration.ip.tcp.AbstractConnectionFactory = new TcpNioClientConnectionFactory ( STRING , java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . java.net.ServerSocket ( ) . int ( ) ) ; noopPublisher ( org.springframework.integration.ip.tcp.AbstractConnectionFactory ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . setSerializer ( new DefaultSerializer ( ) ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . setDeserializer ( new DefaultDeserializer ( ) ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . setSoTimeout ( NUMBER ) ; TcpConnectionInterceptorFactoryChain org.springframework.integration.ip.tcp.TcpConnectionInterceptorFactoryChain = new TcpConnectionInterceptorFactoryChain ( ) ; org.springframework.integration.ip.tcp.TcpConnectionInterceptorFactoryChain . setInterceptors ( new TcpConnectionInterceptorFactory [] { newInterceptorFactory ( ) } ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . setInterceptorFactoryChain ( org.springframework.integration.ip.tcp.TcpConnectionInterceptorFactoryChain ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . start ( ) ; TcpSendingMessageHandler org.springframework.integration.ip.tcp.TcpSendingMessageHandler = new TcpSendingMessageHandler ( ) ; org.springframework.integration.ip.tcp.TcpSendingMessageHandler . setConnectionFactory ( org.springframework.integration.ip.tcp.AbstractConnectionFactory ) ; TcpReceivingChannelAdapter org.springframework.integration.ip.tcp.TcpReceivingChannelAdapter = new TcpReceivingChannelAdapter ( ) ; org.springframework.integration.ip.tcp.TcpReceivingChannelAdapter . setConnectionFactory ( org.springframework.integration.ip.tcp.AbstractConnectionFactory ) ; QueueChannel org.springframework.integration.ip.tcp.QueueChannel = new QueueChannel ( ) ; org.springframework.integration.ip.tcp.TcpReceivingChannelAdapter . setOutputChannel ( org.springframework.integration.ip.tcp.QueueChannel ) ; for ( int int = NUMBER ; int < NUMBER ; int ++ ) { org.springframework.integration.ip.tcp.TcpSendingMessageHandler . handleMessage ( MessageBuilder . withPayload ( STRING ) . build ( ) ) ; } java.util.Set<java.lang.String> < java.lang.String > java.util.Set<java.lang.String> = new java.util.TreeSet<java.lang.String> < java.lang.String > ( ) ; for ( int int = NUMBER ; int < NUMBER ; int ++ ) { Message < ? > org.springframework.integration.ip.tcp.Message<?> = org.springframework.integration.ip.tcp.QueueChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.ip.tcp.Message<> ) ; java.util.Set<java.lang.String> . boolean ( ( java.lang.String ) org.springframework.integration.ip.tcp.Message<> . getPayload ( ) ) ; } org.springframework.integration.ip.tcp.Log . debug ( STRING + java.util.Set<java.lang.String> ) ; for ( int int = NUMBER ; int < NUMBER ; int ++ ) { assertTrue ( STRING + int , java.util.Set<java.lang.String> . boolean ( STRING + int ) ) ; } java.util.concurrent.atomic.AtomicBoolean . void ( true ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . stop ( ) ; java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . java.net.ServerSocket ( ) . void ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> < java.net.ServerSocket > java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> = new java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> < java.net.ServerSocket > ( ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; final java.util.concurrent.atomic.AtomicBoolean java.util.concurrent.atomic.AtomicBoolean = new java.util.concurrent.atomic.AtomicBoolean ( ) ; java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . void ( ( ) { try { java.net.ServerSocket java.net.ServerSocket = javax.net.ServerSocketFactory . javax.net.ServerSocketFactory ( ) . java.net.ServerSocket ( NUMBER ) ; java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . void ( java.net.ServerSocket ) ; java.util.concurrent.CountDownLatch . void ( ) ; java.net.Socket java.net.Socket = java.net.ServerSocket . java.net.Socket ( ) ; java.io.ObjectInputStream java.io.ObjectInputStream = new java.io.ObjectInputStream ( java.net.Socket . java.io.InputStream ( ) ) ; java.io.ObjectOutputStream java.io.ObjectOutputStream = new java.io.ObjectOutputStream ( java.net.Socket . java.io.OutputStream ( ) ) ; java.lang.Object java.lang.Object = java.io.ObjectInputStream . java.lang.Object ( ) ; org.springframework.integration.ip.tcp.Log . debug ( STRING + java.lang.Object ) ; java.io.ObjectOutputStream . void ( STRING ) ; java.io.ObjectInputStream = new java.io.ObjectInputStream ( java.net.Socket . java.io.InputStream ( ) ) ; java.io.ObjectOutputStream = new java.io.ObjectOutputStream ( java.net.Socket . java.io.OutputStream ( ) ) ; java.lang.Object = java.io.ObjectInputStream . java.lang.Object ( ) ; org.springframework.integration.ip.tcp.Log . debug ( STRING + java.lang.Object ) ; java.io.ObjectOutputStream . void ( STRING ) ; java.io.ObjectInputStream = new java.io.ObjectInputStream ( java.net.Socket . java.io.InputStream ( ) ) ; java.io.ObjectOutputStream = new java.io.ObjectOutputStream ( java.net.Socket . java.io.OutputStream ( ) ) ; java.lang.Object = java.io.ObjectInputStream . java.lang.Object ( ) ; java.io.ObjectOutputStream . void ( STRING ) ; java.net.Socket . void ( ) ; java.net.ServerSocket . void ( ) ; } catch ( java.lang.Exception java.lang.Exception ) { if ( ! java.util.concurrent.atomic.AtomicBoolean . boolean ( ) ) { java.lang.Exception . void ( ) ; } } } ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; AbstractConnectionFactory org.springframework.integration.ip.tcp.AbstractConnectionFactory = new TcpNetClientConnectionFactory ( STRING , java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . java.net.ServerSocket ( ) . int ( ) ) ; noopPublisher ( org.springframework.integration.ip.tcp.AbstractConnectionFactory ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . setSerializer ( new DefaultSerializer ( ) ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . setDeserializer ( new DefaultDeserializer ( ) ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . setSoTimeout ( NUMBER ) ; TcpConnectionInterceptorFactoryChain org.springframework.integration.ip.tcp.TcpConnectionInterceptorFactoryChain = new TcpConnectionInterceptorFactoryChain ( ) ; org.springframework.integration.ip.tcp.TcpConnectionInterceptorFactoryChain . setInterceptors ( new TcpConnectionInterceptorFactory [] { newInterceptorFactory ( ) , newInterceptorFactory ( ) } ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . setInterceptorFactoryChain ( org.springframework.integration.ip.tcp.TcpConnectionInterceptorFactoryChain ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . setSingleUse ( true ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . start ( ) ; TcpSendingMessageHandler org.springframework.integration.ip.tcp.TcpSendingMessageHandler = new TcpSendingMessageHandler ( ) ; org.springframework.integration.ip.tcp.TcpSendingMessageHandler . setConnectionFactory ( org.springframework.integration.ip.tcp.AbstractConnectionFactory ) ; org.springframework.integration.ip.tcp.TcpSendingMessageHandler . handleMessage ( MessageBuilder . withPayload ( STRING ) . build ( ) ) ; java.util.concurrent.atomic.AtomicBoolean . void ( true ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . stop ( ) ; java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . java.net.ServerSocket ( ) . void ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> < java.net.ServerSocket > java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> = new java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> < java.net.ServerSocket > ( ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; final java.util.concurrent.atomic.AtomicBoolean java.util.concurrent.atomic.AtomicBoolean = new java.util.concurrent.atomic.AtomicBoolean ( ) ; java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . void ( ( ) { int int = NUMBER ; try { java.net.ServerSocket java.net.ServerSocket = javax.net.ServerSocketFactory . javax.net.ServerSocketFactory ( ) . java.net.ServerSocket ( NUMBER ) ; java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . void ( java.net.ServerSocket ) ; java.util.concurrent.CountDownLatch . void ( ) ; java.net.Socket java.net.Socket = java.net.ServerSocket . java.net.Socket ( ) ; java.io.ObjectInputStream java.io.ObjectInputStream = new java.io.ObjectInputStream ( java.net.Socket . java.io.InputStream ( ) ) ; java.io.ObjectOutputStream java.io.ObjectOutputStream = new java.io.ObjectOutputStream ( java.net.Socket . java.io.OutputStream ( ) ) ; java.lang.Object java.lang.Object = java.io.ObjectInputStream . java.lang.Object ( ) ; org.springframework.integration.ip.tcp.Log . debug ( STRING + java.lang.Object ) ; java.io.ObjectOutputStream . void ( STRING ) ; java.io.ObjectInputStream = new java.io.ObjectInputStream ( java.net.Socket . java.io.InputStream ( ) ) ; java.io.ObjectOutputStream = new java.io.ObjectOutputStream ( java.net.Socket . java.io.OutputStream ( ) ) ; java.lang.Object = java.io.ObjectInputStream . java.lang.Object ( ) ; org.springframework.integration.ip.tcp.Log . debug ( STRING + java.lang.Object ) ; java.io.ObjectOutputStream . void ( STRING ) ; java.io.ObjectInputStream = new java.io.ObjectInputStream ( java.net.Socket . java.io.InputStream ( ) ) ; java.io.ObjectOutputStream = new java.io.ObjectOutputStream ( java.net.Socket . java.io.OutputStream ( ) ) ; java.io.ObjectOutputStream . void ( STRING + ( ++ int ) ) ; java.net.Socket . void ( ) ; java.net.ServerSocket . void ( ) ; } catch ( java.lang.Exception java.lang.Exception ) { if ( int == NUMBER ) { java.lang.Exception . void ( ) ; } } } ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; AbstractConnectionFactory org.springframework.integration.ip.tcp.AbstractConnectionFactory = new TcpNioClientConnectionFactory ( STRING , java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . java.net.ServerSocket ( ) . int ( ) ) ; noopPublisher ( org.springframework.integration.ip.tcp.AbstractConnectionFactory ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . setSerializer ( new DefaultSerializer ( ) ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . setDeserializer ( new DefaultDeserializer ( ) ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . setSoTimeout ( NUMBER ) ; TcpConnectionInterceptorFactoryChain org.springframework.integration.ip.tcp.TcpConnectionInterceptorFactoryChain = new TcpConnectionInterceptorFactoryChain ( ) ; org.springframework.integration.ip.tcp.TcpConnectionInterceptorFactoryChain . setInterceptors ( new TcpConnectionInterceptorFactory [] { newInterceptorFactory ( ) , newInterceptorFactory ( ) } ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . setInterceptorFactoryChain ( org.springframework.integration.ip.tcp.TcpConnectionInterceptorFactoryChain ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . setSingleUse ( true ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . start ( ) ; TcpSendingMessageHandler org.springframework.integration.ip.tcp.TcpSendingMessageHandler = new TcpSendingMessageHandler ( ) ; org.springframework.integration.ip.tcp.TcpSendingMessageHandler . setConnectionFactory ( org.springframework.integration.ip.tcp.AbstractConnectionFactory ) ; org.springframework.integration.ip.tcp.TcpSendingMessageHandler . handleMessage ( MessageBuilder . withPayload ( STRING ) . build ( ) ) ; java.util.concurrent.atomic.AtomicBoolean . void ( true ) ; org.springframework.integration.ip.tcp.AbstractConnectionFactory . stop ( ) ; java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . java.net.ServerSocket ( ) . void ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { AbstractApplicationContext org.springframework.integration.ip.tcp.AbstractApplicationContext = new ClassPathXmlApplicationContext ( STRING , this . java.lang.Class<? extends org.springframework.integration.ip.tcp.TcpSendingMessageHandlerTests> ( ) ) ; AbstractServerConnectionFactory org.springframework.integration.ip.tcp.AbstractServerConnectionFactory = org.springframework.integration.ip.tcp.AbstractApplicationContext . getBean ( AbstractServerConnectionFactory .class ) ; TestingUtilities . waitListening ( org.springframework.integration.ip.tcp.AbstractServerConnectionFactory , null ) ; MessageChannel org.springframework.integration.ip.tcp.MessageChannel = org.springframework.integration.ip.tcp.AbstractApplicationContext . getBean ( STRING , MessageChannel .class ) ; PollableChannel org.springframework.integration.ip.tcp.PollableChannel = org.springframework.integration.ip.tcp.AbstractApplicationContext . getBean ( STRING , PollableChannel .class ) ; java.lang.String java.lang.String = STRING ; org.springframework.integration.ip.tcp.MessageChannel . send ( new GenericMessage < java.lang.String > ( java.lang.String ) ) ; Message < ? > org.springframework.integration.ip.tcp.Message<?> = org.springframework.integration.ip.tcp.PollableChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.ip.tcp.Message<> ) ; assertEquals ( java.lang.String , new java.lang.String ( ( byte [] ) org.springframework.integration.ip.tcp.Message<> . getPayload ( ) ) ) ; org.springframework.integration.ip.tcp.AbstractApplicationContext . close ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { TcpSendingMessageHandler org.springframework.integration.ip.tcp.TcpSendingMessageHandler = new TcpSendingMessageHandler ( ) ; AbstractConnectionFactory org.springframework.integration.ip.tcp.AbstractConnectionFactory = mock ( AbstractClientConnectionFactory .class ) ; Mockito . doAnswer ( invocation -> { throw new SocketException ( STRING ) ; } ) . when ( org.springframework.integration.ip.tcp.AbstractConnectionFactory ) . getConnection ( ) ; org.springframework.integration.ip.tcp.TcpSendingMessageHandler . setConnectionFactory ( org.springframework.integration.ip.tcp.AbstractConnectionFactory ) ; try { org.springframework.integration.ip.tcp.TcpSendingMessageHandler . handleMessage ( new GenericMessage < java.lang.String > ( STRING ) ) ; fail ( STRING ) ; } catch ( java.lang.Exception java.lang.Exception ) { assertTrue ( java.lang.Exception instanceof MessagingException ) ; assertTrue ( java.lang.Exception . java.lang.Throwable ( ) != null ) ; assertTrue ( java.lang.Exception . java.lang.Throwable ( ) instanceof java.net.SocketException ) ; assertEquals ( STRING , java.lang.Exception . java.lang.Throwable ( ) . java.lang.String ( ) ) ; } }  <METHOD_END>
