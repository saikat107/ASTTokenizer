<METHOD_START> public void ( ConfigurableListableBeanFactory org.springframework.integration.config.annotation.ConfigurableListableBeanFactory ) { super( org.springframework.integration.config.annotation.ConfigurableListableBeanFactory ); this . messageHandlerAttributes . addAll ( java.util.Arrays .< java.lang.String > java.util.List<java.lang.String> ( STRING , STRING , STRING ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected org.springframework.integration.config.annotation.MessageHandler org.springframework.integration.config.annotation.MessageHandler ( java.lang.Object java.lang.Object , java.lang.reflect.Method java.lang.reflect.Method , java.util.List<java.lang.annotation.Annotation> < java.lang.annotation.Annotation > java.util.List<java.lang.annotation.Annotation> ) { java.lang.String java.lang.String = MessagingAnnotationUtils . resolveAttribute ( java.util.List<java.lang.annotation.Annotation> , STRING , java.lang.String .class ) ; AbstractMessageSplitter org.springframework.integration.config.annotation.AbstractMessageSplitter ; if ( AnnotatedElementUtils . isAnnotated ( java.lang.reflect.Method , Bean .class . java.lang.String ( ) ) ) { java.lang.Object java.lang.Object = this . resolveTargetBeanFromMethodWithBeanAnnotation ( java.lang.reflect.Method ) ; org.springframework.integration.config.annotation.AbstractMessageSplitter = this . extractTypeIfPossible ( java.lang.Object , AbstractMessageSplitter .class ) ; if ( org.springframework.integration.config.annotation.AbstractMessageSplitter == null ) { if ( java.lang.Object instanceof MessageHandler ) { Assert . hasText ( java.lang.String , STRING + STRING + java.lang.Object . java.lang.Class<? extends java.lang.Object> ( ) ) ; return ( MessageHandler ) java.lang.Object ; } else { org.springframework.integration.config.annotation.AbstractMessageSplitter = new MethodInvokingSplitter ( java.lang.Object ) ; } } else { checkMessageHandlerAttributes ( resolveTargetBeanName ( java.lang.reflect.Method ) , java.util.List<java.lang.annotation.Annotation> ) ; return org.springframework.integration.config.annotation.AbstractMessageSplitter ; } } else { org.springframework.integration.config.annotation.AbstractMessageSplitter = new MethodInvokingSplitter ( java.lang.Object , java.lang.reflect.Method ) ; } if ( StringUtils . hasText ( java.lang.String ) ) { java.lang.String java.lang.String = this . beanFactory . resolveEmbeddedValue ( java.lang.String ) ; if ( StringUtils . hasText ( java.lang.String ) ) { org.springframework.integration.config.annotation.AbstractMessageSplitter . setApplySequence ( java.lang.Boolean . boolean ( java.lang.String ) ) ; } } this . setOutputChannelIfPresent ( java.util.List<java.lang.annotation.Annotation> , org.springframework.integration.config.annotation.AbstractMessageSplitter ) ; return org.springframework.integration.config.annotation.AbstractMessageSplitter ; }  <METHOD_END>
