<METHOD_START> @ java.lang.Override protected org.springframework.http.server.reactive.RandomHandlerIntegrationTests.RandomHandler org.springframework.http.server.reactive.RandomHandlerIntegrationTests.RandomHandler ( ) { return org.springframework.http.server.reactive.RandomHandlerIntegrationTests.RandomHandler ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Throwable { RestTemplate org.springframework.http.server.reactive.RestTemplate = new RestTemplate ( ) ; byte [] byte[] = byte[] ( ) ; RequestEntity < byte [] > org.springframework.http.server.reactive.RequestEntity<byte[]> = RequestEntity . post ( new java.net.URI ( STRING + port ) ) . body ( byte[] ) ; ResponseEntity < byte [] > org.springframework.http.server.reactive.ResponseEntity<byte[]> = org.springframework.http.server.reactive.RestTemplate . exchange ( org.springframework.http.server.reactive.RequestEntity<byte[]> , byte [] .class ) ; assertNotNull ( org.springframework.http.server.reactive.ResponseEntity<byte[]> . getBody ( ) ) ; assertEquals ( int , org.springframework.http.server.reactive.ResponseEntity<byte[]> . getHeaders ( ) . getContentLength ( ) ) ; assertEquals ( int , org.springframework.http.server.reactive.ResponseEntity<byte[]> . getBody ( ) . length ) ; }  <METHOD_END>
<METHOD_START> private byte [] byte[] ( ) { byte [] byte[] = new byte [ int ] ; java.util.Random . void ( byte[] ) ; return byte[] ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.http.server.reactive.Mono<java.lang.Void> < java.lang.Void > org.springframework.http.server.reactive.Mono<java.lang.Void> ( ServerHttpRequest org.springframework.http.server.reactive.ServerHttpRequest , ServerHttpResponse org.springframework.http.server.reactive.ServerHttpResponse ) { Mono < java.lang.Integer > org.springframework.http.server.reactive.Mono<java.lang.Integer> = org.springframework.http.server.reactive.ServerHttpRequest . getBody ( ) . reduce ( NUMBER , ( integer , dataBuffer ) -> integer + dataBuffer . readableByteCount ( ) ) . doAfterTerminate ( ( size , throwable ) -> { assertNull ( throwable ) ; assertEquals ( REQUEST_SIZE , ( long ) size ) ; } ) ; org.springframework.http.server.reactive.ServerHttpResponse . getHeaders ( ) . setContentLength ( int ) ; return org.springframework.http.server.reactive.Mono<java.lang.Integer> . then ( org.springframework.http.server.reactive.ServerHttpResponse . writeWith ( org.springframework.http.server.reactive.Publisher<org.springframework.http.server.reactive.DataBuffer> ( ) ) ) ; }  <METHOD_END>
<METHOD_START> private org.springframework.http.server.reactive.Publisher<org.springframework.http.server.reactive.DataBuffer> < DataBuffer > org.springframework.http.server.reactive.Publisher<org.springframework.http.server.reactive.DataBuffer> ( ) { int int = int / int ; return Flux . range ( NUMBER , int ) . map ( integer -> randomBuffer ( chunkSize ) ) ; }  <METHOD_END>
<METHOD_START> private org.springframework.http.server.reactive.DataBuffer org.springframework.http.server.reactive.DataBuffer ( int int ) { byte [] byte[] = new byte [ int ] ; java.util.Random . void ( byte[] ) ; DataBuffer org.springframework.http.server.reactive.DataBuffer = org.springframework.http.server.reactive.DataBufferFactory . allocateBuffer ( int ) ; org.springframework.http.server.reactive.DataBuffer . write ( byte[] ) ; return org.springframework.http.server.reactive.DataBuffer ; }  <METHOD_END>
