<METHOD_START> public void void ( ApplicationEventPublisher org.springframework.data.mapping.context.ApplicationEventPublisher ) { this . org.springframework.data.mapping.context.ApplicationEventPublisher = org.springframework.data.mapping.context.ApplicationEventPublisher ; }  <METHOD_END>
<METHOD_START> public void void ( java.util.Set<? extends java.lang.Class<?>> < ? extends java.lang.Class<?> < ? > > java.util.Set<? extends java.lang.Class<?>> ) { this . java.util.Set<? extends java.lang.Class<?>> = java.util.Set<> ; }  <METHOD_END>
<METHOD_START> public void void ( boolean boolean ) { this . boolean = boolean ; }  <METHOD_END>
<METHOD_START> public void void ( SimpleTypeHolder org.springframework.data.mapping.context.SimpleTypeHolder ) { Assert . notNull ( org.springframework.data.mapping.context.SimpleTypeHolder , STRING ) ; this . org.springframework.data.mapping.context.SimpleTypeHolder = org.springframework.data.mapping.context.SimpleTypeHolder ; }  <METHOD_END>
<METHOD_START> public java.util.Collection<E> < E > java.util.Collection<E> ( ) { try { java.util.concurrent.locks.Lock . void ( ) ; return java.util.Map<org.springframework.data.mapping.context.TypeInformation<?>,java.util.Optional<E>> . values ( ) . stream ( ) . flatMap ( Optionals :: toStream ) . collect ( java.util.stream.Collectors . java.util.stream.Collector<java.lang.Object,?,java.util.Set<java.lang.Object>> ( ) ) ; } finally { java.util.concurrent.locks.Lock . void ( ) ; } }  <METHOD_END>
<METHOD_START> public java.util.Optional<E> < E > java.util.Optional<E> ( java.lang.Class<?> < ? > java.lang.Class<?> ) { return java.util.Optional<E> ( ClassTypeInformation . from ( java.lang.Class<> ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public E E ( java.lang.Class<?> < ? > java.lang.Class<?> ) { return java.util.Optional<E> ( java.lang.Class<> ) . E ( ( ) new java.lang.IllegalArgumentException ( java.lang.String . java.lang.String ( STRING , java.lang.Class<> ) ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( java.lang.Class<?> < ? > java.lang.Class<?> ) { Assert . notNull ( java.lang.Class<> , STRING ) ; return java.util.Map<org.springframework.data.mapping.context.TypeInformation<?>,java.util.Optional<E>> . containsKey ( ClassTypeInformation . from ( java.lang.Class<> ) ) ; }  <METHOD_END>
<METHOD_START> public java.util.Optional<E> < E > java.util.Optional<E> ( TypeInformation < ? > org.springframework.data.mapping.context.TypeInformation<?> ) { Assert . notNull ( org.springframework.data.mapping.context.TypeInformation<> , STRING ) ; try { java.util.concurrent.locks.Lock . void ( ) ; java.util.Optional<E> < E > java.util.Optional<E> = java.util.Map<org.springframework.data.mapping.context.TypeInformation<?>,java.util.Optional<E>> . get ( org.springframework.data.mapping.context.TypeInformation<> ) ; if ( java.util.Optional<E> != null ) { return java.util.Optional<E> ; } } finally { java.util.concurrent.locks.Lock . void ( ) ; } if ( ! boolean ( org.springframework.data.mapping.context.TypeInformation<> ) ) { try { java.util.concurrent.locks.Lock . void ( ) ; java.util.Map<org.springframework.data.mapping.context.TypeInformation<?>,java.util.Optional<E>> . put ( org.springframework.data.mapping.context.TypeInformation<> , java.util.Optional<E> ) ; } finally { java.util.concurrent.locks.Lock . void ( ) ; } return java.util.Optional<E> ; } if ( boolean ) { throw new MappingException ( STRING + org.springframework.data.mapping.context.TypeInformation<> ) ; } return java.util.Optional<E> ( org.springframework.data.mapping.context.TypeInformation<> ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public E E ( TypeInformation < ? > org.springframework.data.mapping.context.TypeInformation<?> ) { return java.util.Optional<E> ( org.springframework.data.mapping.context.TypeInformation<> ) . orElseThrow ( ( ) new MappingException ( String . format ( STRING , type ) ) ) ; }  <METHOD_END>
<METHOD_START> public java.util.Optional<E> < E > java.util.Optional<E> ( P P ) { Assert . notNull ( P , STRING ) ; TypeInformation < ? > org.springframework.data.mapping.context.TypeInformation<?> = P . getTypeInformation ( ) ; return java.util.Optional<E> ( org.springframework.data.mapping.context.TypeInformation<> . getActualType ( ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public E E ( P P ) { return java.util.Optional<E> ( P ) . E ( ( ) new java.lang.IllegalArgumentException ( java.lang.String . java.lang.String ( STRING , P ) ) ) ; }  <METHOD_END>
<METHOD_START> public org.springframework.data.mapping.context.PersistentPropertyPath<P> < P > org.springframework.data.mapping.context.PersistentPropertyPath<P> ( PropertyPath org.springframework.data.mapping.context.PropertyPath ) { Assert . notNull ( org.springframework.data.mapping.context.PropertyPath , STRING ) ; return org.springframework.data.mapping.context.PersistentPropertyPath<P> ( org.springframework.data.mapping.context.PropertyPath . toDotPath ( ) , org.springframework.data.mapping.context.PropertyPath . getOwningType ( ) ) ; }  <METHOD_END>
<METHOD_START> public org.springframework.data.mapping.context.PersistentPropertyPath<P> < P > org.springframework.data.mapping.context.PersistentPropertyPath<P> ( java.lang.String java.lang.String , java.lang.Class<?> < ? > java.lang.Class<?> ) { Assert . notNull ( java.lang.String , STRING ) ; Assert . notNull ( java.lang.Class<> , STRING ) ; return org.springframework.data.mapping.context.PersistentPropertyPath<P> ( java.lang.String , ClassTypeInformation . from ( java.lang.Class<> ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.data.mapping.context.PersistentPropertyPath<P> < P > org.springframework.data.mapping.context.PersistentPropertyPath<P> ( InvalidPersistentPropertyPath org.springframework.data.mapping.context.InvalidPersistentPropertyPath ) { return org.springframework.data.mapping.context.PersistentPropertyPath<P> ( org.springframework.data.mapping.context.InvalidPersistentPropertyPath . getResolvedPath ( ) , org.springframework.data.mapping.context.InvalidPersistentPropertyPath . getType ( ) ) ; }  <METHOD_END>
<METHOD_START> private org.springframework.data.mapping.context.PersistentPropertyPath<P> < P > org.springframework.data.mapping.context.PersistentPropertyPath<P> ( java.lang.String java.lang.String , TypeInformation < ? > org.springframework.data.mapping.context.TypeInformation<?> ) { return org.springframework.data.mapping.context.PersistentPropertyPath<P> ( java.util.Arrays . java.util.List<java.lang.String> ( java.lang.String . java.lang.String[] ( STRING ) ) , org.springframework.data.mapping.context.TypeInformation<> ) ; }  <METHOD_END>
<METHOD_START> private org.springframework.data.mapping.context.PersistentPropertyPath<P> < P > org.springframework.data.mapping.context.PersistentPropertyPath<P> ( java.util.Collection<java.lang.String> < java.lang.String > java.util.Collection<java.lang.String> , TypeInformation < ? > org.springframework.data.mapping.context.TypeInformation<?> ) { DefaultPersistentPropertyPath < P > org.springframework.data.mapping.context.DefaultPersistentPropertyPath<P> = DefaultPersistentPropertyPath . empty ( ) ; java.util.Iterator<java.lang.String> < java.lang.String > java.util.Iterator<java.lang.String> = java.util.Collection<java.lang.String> . java.util.Iterator<java.lang.String> ( ) ; E E = E ( org.springframework.data.mapping.context.TypeInformation<> ) ; while ( java.util.Iterator<java.lang.String> . boolean ( ) ) { java.lang.String java.lang.String = java.util.Iterator<java.lang.String> . java.lang.String ( ) ; final DefaultPersistentPropertyPath < P > org.springframework.data.mapping.context.DefaultPersistentPropertyPath<P> = org.springframework.data.mapping.context.DefaultPersistentPropertyPath<P> ; final E E = E ; Pair < DefaultPersistentPropertyPath < P > , E > org.springframework.data.mapping.context.Pair<org.springframework.data.mapping.context.DefaultPersistentPropertyPath<P>,E> = java.util.Optional<org.springframework.data.mapping.context.Pair<org.springframework.data.mapping.context.DefaultPersistentPropertyPath<P>,E>> ( org.springframework.data.mapping.context.DefaultPersistentPropertyPath<P> , java.util.Iterator<java.lang.String> , java.lang.String , E ) . orElseThrow ( ( ) { String source = StringUtils . collectionToDelimitedString ( parts , STRING ) ; String resolvedPath = foo . toDotPath ( ) ; return new InvalidPersistentPropertyPath ( source , type , segment , resolvedPath , String . format ( STRING , segment , bar . getName ( ) ) ) ; } ) ; org.springframework.data.mapping.context.DefaultPersistentPropertyPath<P> = org.springframework.data.mapping.context.Pair<org.springframework.data.mapping.context.DefaultPersistentPropertyPath<P>,E> . getFirst ( ) ; E = org.springframework.data.mapping.context.Pair<org.springframework.data.mapping.context.DefaultPersistentPropertyPath<P>,E> . getSecond ( ) ; } return org.springframework.data.mapping.context.DefaultPersistentPropertyPath<P> ; }  <METHOD_END>
<METHOD_START> private java.util.Optional<org.springframework.data.mapping.context.Pair<org.springframework.data.mapping.context.DefaultPersistentPropertyPath<P>,E>> < Pair < DefaultPersistentPropertyPath < P > , E > > java.util.Optional<org.springframework.data.mapping.context.Pair<org.springframework.data.mapping.context.DefaultPersistentPropertyPath<P>,E>> ( DefaultPersistentPropertyPath < P > org.springframework.data.mapping.context.DefaultPersistentPropertyPath<P> , java.util.Iterator<java.lang.String> < java.lang.String > java.util.Iterator<java.lang.String> , java.lang.String java.lang.String , E E ) { java.util.Optional<P> < P > java.util.Optional<P> = E . getPersistentProperty ( java.lang.String ) ; return java.util.Optional<P> . java.util.Optional<org.springframework.data.mapping.context.Pair<org.springframework.data.mapping.context.DefaultPersistentPropertyPath<P>,E>> ( P -> { TypeInformation < ? > org.springframework.data.mapping.context.TypeInformation<?> = P . getTypeInformation ( ) . getActualType ( ) ; return Pair . of ( org.springframework.data.mapping.context.DefaultPersistentPropertyPath<P> . append ( P ) , java.util.Iterator<java.lang.String> . boolean ( ) ? E ( org.springframework.data.mapping.context.TypeInformation<> ) : E ) ; } ) ; }  <METHOD_END>
<METHOD_START> protected java.util.Optional<E> < E > java.util.Optional<E> ( java.lang.Class<?> < ? > java.lang.Class<?> ) { return java.util.Optional<E> ( ClassTypeInformation . from ( java.lang.Class<> ) ) ; }  <METHOD_END>
<METHOD_START> protected java.util.Optional<E> < E > java.util.Optional<E> ( TypeInformation < ? > org.springframework.data.mapping.context.TypeInformation<?> ) { Assert . notNull ( org.springframework.data.mapping.context.TypeInformation<> , STRING ) ; try { java.util.concurrent.locks.Lock . void ( ) ; java.util.Optional<E> < E > java.util.Optional<E> = java.util.Map<org.springframework.data.mapping.context.TypeInformation<?>,java.util.Optional<E>> . get ( org.springframework.data.mapping.context.TypeInformation<> ) ; if ( java.util.Optional<E> != null ) { return java.util.Optional<E> ; } } finally { java.util.concurrent.locks.Lock . void ( ) ; } java.lang.Class<?> < ? > java.lang.Class<?> = org.springframework.data.mapping.context.TypeInformation<> . getType ( ) ; try { java.util.concurrent.locks.Lock . void ( ) ; final E E = E ( org.springframework.data.mapping.context.TypeInformation<> ) ; java.util.Map<org.springframework.data.mapping.context.TypeInformation<?>,java.util.Optional<E>> . put ( org.springframework.data.mapping.context.TypeInformation<> , java.util.Optional . java.util.Optional<E> ( E ) ) ; java.beans.PropertyDescriptor [] java.beans.PropertyDescriptor[] = BeanUtils . getPropertyDescriptors ( java.lang.Class<> ) ; final java.util.Map<java.lang.String,java.beans.PropertyDescriptor> < java.lang.String , java.beans.PropertyDescriptor > java.util.Map<java.lang.String,java.beans.PropertyDescriptor> = new java.util.HashMap<java.lang.String,java.beans.PropertyDescriptor> <> ( ) ; for ( java.beans.PropertyDescriptor java.beans.PropertyDescriptor : java.beans.PropertyDescriptor[] ) { java.util.Map<java.lang.String,java.beans.PropertyDescriptor> . java.beans.PropertyDescriptor ( java.beans.PropertyDescriptor . java.lang.String ( ) , java.beans.PropertyDescriptor ) ; } try { org.springframework.data.mapping.context.AbstractMappingContext<E,P>.PersistentPropertyCreator org.springframework.data.mapping.context.AbstractMappingContext<E,P>.PersistentPropertyCreator = new org.springframework.data.mapping.context.AbstractMappingContext<E,P>.PersistentPropertyCreator ( E , java.util.Map<java.lang.String,java.beans.PropertyDescriptor> ) ; ReflectionUtils . doWithFields ( java.lang.Class<> , org.springframework.data.mapping.context.AbstractMappingContext<E,P>.PersistentPropertyCreator , org.springframework.data.mapping.context.AbstractMappingContext.PersistentPropertyFilter . org.springframework.data.mapping.context.AbstractMappingContext.PersistentPropertyFilter ) ; org.springframework.data.mapping.context.AbstractMappingContext<E,P>.PersistentPropertyCreator . void ( ) ; E . verify ( ) ; if ( org.springframework.data.mapping.context.PersistentPropertyAccessorFactory . isSupported ( E ) ) { E . setPersistentPropertyAccessorFactory ( org.springframework.data.mapping.context.PersistentPropertyAccessorFactory ) ; } } catch ( MappingException org.springframework.data.mapping.context.MappingException ) { java.util.Map<org.springframework.data.mapping.context.TypeInformation<?>,java.util.Optional<E>> . remove ( org.springframework.data.mapping.context.TypeInformation<> ) ; throw org.springframework.data.mapping.context.MappingException ; } if ( null != org.springframework.data.mapping.context.ApplicationEventPublisher ) { org.springframework.data.mapping.context.ApplicationEventPublisher . publishEvent ( new MappingContextEvent <> ( this , E ) ) ; } return java.util.Optional . java.util.Optional<E> ( E ) ; } catch ( BeansException org.springframework.data.mapping.context.BeansException ) { throw new MappingException ( org.springframework.data.mapping.context.BeansException . getMessage ( ) , org.springframework.data.mapping.context.BeansException ) ; } finally { java.util.concurrent.locks.Lock . void ( ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.util.Collection<org.springframework.data.mapping.context.TypeInformation<?>> < TypeInformation < ? > > java.util.Collection<org.springframework.data.mapping.context.TypeInformation<?>> ( ) { try { java.util.concurrent.locks.Lock . void ( ) ; return java.util.Collections . java.util.Set<org.springframework.data.mapping.context.TypeInformation<?>> ( new java.util.HashSet <> ( java.util.Map<org.springframework.data.mapping.context.TypeInformation<?>,java.util.Optional<E>> . keySet ( ) ) ) ; } finally { java.util.concurrent.locks.Lock . void ( ) ; } }  <METHOD_END>
<METHOD_START> protected abstract < T > E E ( TypeInformation < T > org.springframework.data.mapping.context.TypeInformation<T> );  <METHOD_END>
<METHOD_START> protected abstract P P ( Property org.springframework.data.mapping.context.Property , E E , SimpleTypeHolder org.springframework.data.mapping.context.SimpleTypeHolder );  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ) { void ( ) ; }  <METHOD_END>
<METHOD_START> public void void ( ) { java.util.Set<> . void ( this :: java.util.Optional<E> ) ; }  <METHOD_END>
<METHOD_START> protected boolean boolean ( TypeInformation < ? > org.springframework.data.mapping.context.TypeInformation<?> ) { return ! org.springframework.data.mapping.context.SimpleTypeHolder . isSimpleType ( org.springframework.data.mapping.context.TypeInformation<> . getType ( ) ) ; }  <METHOD_END>
<METHOD_START> public void ( E E , java.util.Map<java.lang.String,java.beans.PropertyDescriptor> < java.lang.String , java.beans.PropertyDescriptor > java.util.Map<java.lang.String,java.beans.PropertyDescriptor> ) { this( E , java.util.Map<java.lang.String,java.beans.PropertyDescriptor> , java.util.Map<java.lang.String,java.beans.PropertyDescriptor> ); }  <METHOD_END>
<METHOD_START> public void void ( java.lang.reflect.Field java.lang.reflect.Field ) { java.lang.String java.lang.String = java.lang.reflect.Field . java.lang.String ( ) ; ReflectionUtils . makeAccessible ( java.lang.reflect.Field ) ; Property org.springframework.data.mapping.context.Property = java.util.Optional . java.util.Optional<java.beans.PropertyDescriptor> ( java.util.Map<java.lang.String,java.beans.PropertyDescriptor> . java.beans.PropertyDescriptor ( java.lang.String ) ) . java.util.Optional<java.lang.Object> ( java.beans.PropertyDescriptor -> Property . of ( java.lang.reflect.Field , java.beans.PropertyDescriptor ) ) . orElseGet ( ( ) Property . of ( field ) ) ; void ( org.springframework.data.mapping.context.Property ) ; this . java.util.Map<java.lang.String,java.beans.PropertyDescriptor> . java.beans.PropertyDescriptor ( java.lang.String ) ; }  <METHOD_END>
<METHOD_START> public void void ( ) { java.util.Map<java.lang.String,java.beans.PropertyDescriptor> . java.util.Collection<java.beans.PropertyDescriptor> ( ) . java.util.stream.Stream<java.beans.PropertyDescriptor> ( ) . java.util.stream.Stream ( Property :: of ) . filter ( org.springframework.data.mapping.context.AbstractMappingContext.PersistentPropertyFilter . org.springframework.data.mapping.context.AbstractMappingContext.PersistentPropertyFilter :: matches ) . forEach ( this :: void ) ; }  <METHOD_END>
<METHOD_START> private void void ( Property org.springframework.data.mapping.context.Property ) { P P = P ( org.springframework.data.mapping.context.Property , E , org.springframework.data.mapping.context.SimpleTypeHolder ) ; if ( P . isTransient ( ) ) { return; } if ( ! org.springframework.data.mapping.context.Property . isFieldBacked ( ) && ! P . usePropertyAccess ( ) ) { return; } E . addPersistentProperty ( P ) ; P . getAssociation ( ) . ifPresent ( E :: addAssociation ) ; if ( E . getType ( ) . equals ( P . getRawType ( ) ) ) { return; } P . getPersistentEntityType ( ) . forEach ( org.springframework.data.mapping.context.AbstractMappingContext .this :: addPersistentEntity ) ; }  <METHOD_END>
<METHOD_START> public boolean boolean ( java.lang.reflect.Field java.lang.reflect.Field ) { if ( java.lang.reflect.Modifier . boolean ( java.lang.reflect.Field . int ( ) ) ) { return false ; } return ! org.springframework.data.mapping.context.Streamable<org.springframework.data.mapping.context.AbstractMappingContext.PersistentPropertyFilter.PropertyMatch> . stream ( ) . anyMatch ( it -> it . matches ( field . getName ( ) , field . getType ( ) ) ) ; }  <METHOD_END>
<METHOD_START> public boolean boolean ( Property org.springframework.data.mapping.context.Property ) { Assert . notNull ( org.springframework.data.mapping.context.Property , STRING ) ; if ( ! org.springframework.data.mapping.context.Property . hasAccessor ( ) ) { return false ; } return ! org.springframework.data.mapping.context.Streamable<org.springframework.data.mapping.context.AbstractMappingContext.PersistentPropertyFilter.PropertyMatch> . stream ( ) . anyMatch ( it -> it . matches ( property . getName ( ) , property . getType ( ) ) ) ; }  <METHOD_END>
<METHOD_START> public void ( java.lang.String java.lang.String , java.lang.String java.lang.String ) { Assert . isTrue ( ! ( java.lang.String == null && java.lang.String == null ) , STRING ) ; this . java.lang.String = java.lang.String ; this . java.lang.String = java.lang.String ; }  <METHOD_END>
<METHOD_START> public boolean boolean ( java.lang.String java.lang.String , java.lang.Class<?> < ? > java.lang.Class<?> ) { if ( java.lang.String != null && ! java.lang.String . boolean ( java.lang.String ) ) { return false ; } if ( java.lang.String != null && ! java.lang.Class<> . java.lang.String ( ) . boolean ( java.lang.String ) ) { return false ; } return true ; }  <METHOD_END>
