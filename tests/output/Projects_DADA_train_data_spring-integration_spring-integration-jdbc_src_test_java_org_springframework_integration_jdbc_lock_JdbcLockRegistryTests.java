<METHOD_START> @ Before public void void ( ) { this . org.springframework.integration.jdbc.lock.JdbcLockRegistry . expireUnusedOlderThan ( NUMBER ) ; this . org.springframework.integration.jdbc.lock.LockRepository . close ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { for ( int int = NUMBER ; int < NUMBER ; int ++ ) { java.util.concurrent.locks.Lock java.util.concurrent.locks.Lock = this . org.springframework.integration.jdbc.lock.JdbcLockRegistry . obtain ( STRING ) ; java.util.concurrent.locks.Lock . void ( ) ; try { assertEquals ( NUMBER , TestUtils . getPropertyValue ( this . org.springframework.integration.jdbc.lock.JdbcLockRegistry , STRING , java.util.Map .class ) . size ( ) ) ; } finally { java.util.concurrent.locks.Lock . void ( ) ; } } java.lang.Thread . void ( NUMBER ) ; this . org.springframework.integration.jdbc.lock.JdbcLockRegistry . expireUnusedOlderThan ( NUMBER ) ; assertEquals ( NUMBER , TestUtils . getPropertyValue ( this . org.springframework.integration.jdbc.lock.JdbcLockRegistry , STRING , java.util.Map .class ) . size ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { for ( int int = NUMBER ; int < NUMBER ; int ++ ) { java.util.concurrent.locks.Lock java.util.concurrent.locks.Lock = this . org.springframework.integration.jdbc.lock.JdbcLockRegistry . obtain ( STRING ) ; java.util.concurrent.locks.Lock . void ( ) ; try { assertEquals ( NUMBER , TestUtils . getPropertyValue ( this . org.springframework.integration.jdbc.lock.JdbcLockRegistry , STRING , java.util.Map .class ) . size ( ) ) ; } finally { java.util.concurrent.locks.Lock . void ( ) ; } } }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { for ( int int = NUMBER ; int < NUMBER ; int ++ ) { java.util.concurrent.locks.Lock java.util.concurrent.locks.Lock = this . org.springframework.integration.jdbc.lock.JdbcLockRegistry . obtain ( STRING ) ; java.util.concurrent.locks.Lock . void ( ) ; try { java.util.concurrent.locks.Lock java.util.concurrent.locks.Lock = this . org.springframework.integration.jdbc.lock.JdbcLockRegistry . obtain ( STRING ) ; assertSame ( java.util.concurrent.locks.Lock , java.util.concurrent.locks.Lock ) ; java.util.concurrent.locks.Lock . void ( ) ; java.util.concurrent.locks.Lock . void ( ) ; } finally { java.util.concurrent.locks.Lock . void ( ) ; } } }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { for ( int int = NUMBER ; int < NUMBER ; int ++ ) { java.util.concurrent.locks.Lock java.util.concurrent.locks.Lock = this . org.springframework.integration.jdbc.lock.JdbcLockRegistry . obtain ( STRING ) ; java.util.concurrent.locks.Lock . void ( ) ; try { java.util.concurrent.locks.Lock java.util.concurrent.locks.Lock = this . org.springframework.integration.jdbc.lock.JdbcLockRegistry . obtain ( STRING ) ; assertSame ( java.util.concurrent.locks.Lock , java.util.concurrent.locks.Lock ) ; java.util.concurrent.locks.Lock . void ( ) ; java.util.concurrent.locks.Lock . void ( ) ; } finally { java.util.concurrent.locks.Lock . void ( ) ; } } }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { for ( int int = NUMBER ; int < NUMBER ; int ++ ) { java.util.concurrent.locks.Lock java.util.concurrent.locks.Lock = this . org.springframework.integration.jdbc.lock.JdbcLockRegistry . obtain ( STRING ) ; java.util.concurrent.locks.Lock . void ( ) ; try { java.util.concurrent.locks.Lock java.util.concurrent.locks.Lock = this . org.springframework.integration.jdbc.lock.JdbcLockRegistry . obtain ( STRING ) ; assertNotSame ( java.util.concurrent.locks.Lock , java.util.concurrent.locks.Lock ) ; java.util.concurrent.locks.Lock . void ( ) ; java.util.concurrent.locks.Lock . void ( ) ; } finally { java.util.concurrent.locks.Lock . void ( ) ; } } }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final java.util.concurrent.locks.Lock java.util.concurrent.locks.Lock = this . org.springframework.integration.jdbc.lock.JdbcLockRegistry . obtain ( STRING ) ; java.util.concurrent.locks.Lock . void ( ) ; final java.util.concurrent.atomic.AtomicBoolean java.util.concurrent.atomic.AtomicBoolean = new java.util.concurrent.atomic.AtomicBoolean ( ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; java.util.concurrent.Future<java.lang.Object> < java.lang.Object > java.util.concurrent.Future<java.lang.Object> = java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . java.util.concurrent.Future<java.lang.Object> ( ( ) { java.util.concurrent.locks.Lock java.util.concurrent.locks.Lock = org.springframework.integration.jdbc.lock.JdbcLockRegistryTests .this . org.springframework.integration.jdbc.lock.JdbcLockRegistry . obtain ( STRING ) ; java.util.concurrent.atomic.AtomicBoolean . void ( java.util.concurrent.locks.Lock . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; java.util.concurrent.CountDownLatch . void ( ) ; try { java.util.concurrent.locks.Lock . void ( ) ; } catch ( java.lang.Exception java.lang.Exception ) { return java.lang.Exception ; } return null ; } ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; assertFalse ( java.util.concurrent.atomic.AtomicBoolean . boolean ( ) ) ; java.util.concurrent.locks.Lock . void ( ) ; java.lang.Object java.lang.Object = java.util.concurrent.Future<java.lang.Object> . java.lang.Object ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ; assertThat ( java.lang.Object , instanceOf ( java.lang.IllegalMonitorStateException .class ) ) ; assertThat ( ( ( java.lang.Exception ) java.lang.Object ) . java.lang.String ( ) , containsString ( STRING ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final java.util.concurrent.locks.Lock java.util.concurrent.locks.Lock = this . org.springframework.integration.jdbc.lock.JdbcLockRegistry . obtain ( STRING ) ; final java.util.concurrent.atomic.AtomicBoolean java.util.concurrent.atomic.AtomicBoolean = new java.util.concurrent.atomic.AtomicBoolean ( ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; java.util.concurrent.locks.Lock . void ( ) ; java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . void ( ( ) { java.util.concurrent.locks.Lock java.util.concurrent.locks.Lock = org.springframework.integration.jdbc.lock.JdbcLockRegistryTests .this . org.springframework.integration.jdbc.lock.JdbcLockRegistry . obtain ( STRING ) ; try { java.util.concurrent.CountDownLatch . void ( ) ; java.util.concurrent.locks.Lock . void ( ) ; java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ; java.util.concurrent.atomic.AtomicBoolean . void ( true ) ; } catch ( java.lang.InterruptedException java.lang.InterruptedException ) { java.lang.Thread . java.lang.Thread ( ) . void ( ) ; } finally { java.util.concurrent.locks.Lock . void ( ) ; java.util.concurrent.CountDownLatch . void ( ) ; } } ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; assertFalse ( java.util.concurrent.atomic.AtomicBoolean . boolean ( ) ) ; java.util.concurrent.locks.Lock . void ( ) ; java.util.concurrent.CountDownLatch . void ( ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; assertTrue ( java.util.concurrent.atomic.AtomicBoolean . boolean ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { for ( int int = NUMBER ; int < NUMBER ; int ++ ) { final JdbcLockRegistry org.springframework.integration.jdbc.lock.JdbcLockRegistry = new JdbcLockRegistry ( this . org.springframework.integration.jdbc.lock.LockRepository ) ; final JdbcLockRegistry org.springframework.integration.jdbc.lock.JdbcLockRegistry = new JdbcLockRegistry ( this . org.springframework.integration.jdbc.lock.LockRepository ) ; final java.util.concurrent.locks.Lock java.util.concurrent.locks.Lock = org.springframework.integration.jdbc.lock.JdbcLockRegistry . obtain ( STRING ) ; final java.util.concurrent.atomic.AtomicBoolean java.util.concurrent.atomic.AtomicBoolean = new java.util.concurrent.atomic.AtomicBoolean ( ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; java.util.concurrent.locks.Lock . void ( ) ; java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . void ( ( ) { java.util.concurrent.locks.Lock java.util.concurrent.locks.Lock = org.springframework.integration.jdbc.lock.JdbcLockRegistry . obtain ( STRING ) ; try { java.util.concurrent.CountDownLatch . void ( ) ; java.util.concurrent.locks.Lock . void ( ) ; java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ; java.util.concurrent.atomic.AtomicBoolean . void ( true ) ; } catch ( java.lang.InterruptedException java.lang.InterruptedException ) { java.lang.Thread . java.lang.Thread ( ) . void ( ) ; } finally { java.util.concurrent.locks.Lock . void ( ) ; java.util.concurrent.CountDownLatch . void ( ) ; } } ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; assertFalse ( java.util.concurrent.atomic.AtomicBoolean . boolean ( ) ) ; java.util.concurrent.locks.Lock . void ( ) ; java.util.concurrent.CountDownLatch . void ( ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; assertTrue ( java.util.concurrent.atomic.AtomicBoolean . boolean ( ) ) ; } }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final java.util.concurrent.locks.Lock java.util.concurrent.locks.Lock = this . org.springframework.integration.jdbc.lock.JdbcLockRegistry . obtain ( STRING ) ; java.util.concurrent.locks.Lock . void ( ) ; final java.util.concurrent.atomic.AtomicBoolean java.util.concurrent.atomic.AtomicBoolean = new java.util.concurrent.atomic.AtomicBoolean ( ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; java.util.concurrent.Future<java.lang.Object> < java.lang.Object > java.util.concurrent.Future<java.lang.Object> = java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . java.util.concurrent.Future<java.lang.Object> ( ( ) { try { java.util.concurrent.locks.Lock . void ( ) ; } catch ( java.lang.Exception java.lang.Exception ) { java.util.concurrent.CountDownLatch . void ( ) ; return java.lang.Exception ; } return null ; } ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; assertFalse ( java.util.concurrent.atomic.AtomicBoolean . boolean ( ) ) ; java.util.concurrent.locks.Lock . void ( ) ; java.lang.Object java.lang.Object = java.util.concurrent.Future<java.lang.Object> . java.lang.Object ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ; assertThat ( java.lang.Object , instanceOf ( java.lang.IllegalMonitorStateException .class ) ) ; assertThat ( ( ( java.lang.Exception ) java.lang.Object ) . java.lang.String ( ) , containsString ( STRING ) ) ; }  <METHOD_END>
