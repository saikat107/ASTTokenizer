<METHOD_START> public void ( ConcurrentMetadataStore org.springframework.integration.file.filters.ConcurrentMetadataStore , java.lang.String java.lang.String ) { Assert . notNull ( org.springframework.integration.file.filters.ConcurrentMetadataStore , STRING ) ; Assert . notNull ( java.lang.String , STRING ) ; this . org.springframework.integration.file.filters.ConcurrentMetadataStore = org.springframework.integration.file.filters.ConcurrentMetadataStore ; this . java.lang.String = java.lang.String ; if ( org.springframework.integration.file.filters.ConcurrentMetadataStore instanceof java.io.Flushable ) { this . java.io.Flushable = ( java.io.Flushable ) org.springframework.integration.file.filters.ConcurrentMetadataStore ; } else { this . java.io.Flushable = null ; } }  <METHOD_END>
<METHOD_START> public void void ( boolean boolean ) { this . boolean = boolean ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( F F ) { java.lang.String java.lang.String = java.lang.String ( F ) ; synchronized ( this . java.lang.Object ) { java.lang.String java.lang.String = java.lang.String ( F ) ; java.lang.String java.lang.String = this . org.springframework.integration.file.filters.ConcurrentMetadataStore . putIfAbsent ( java.lang.String , java.lang.String ) ; if ( java.lang.String == null ) { void ( ) ; return true ; } if ( ! boolean ( F , java.lang.String ) && this . org.springframework.integration.file.filters.ConcurrentMetadataStore . replace ( java.lang.String , java.lang.String , java.lang.String ) ) { void ( ) ; return true ; } return false ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( F F , java.util.List<F> < F > java.util.List<F> ) { boolean boolean = false ; for ( F F : java.util.List<F> ) { if ( F . boolean ( F ) ) { boolean = true ; } if ( boolean ) { boolean ( F ) ; } } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( F F ) { java.lang.String java.lang.String = this . org.springframework.integration.file.filters.ConcurrentMetadataStore . remove ( java.lang.String ( F ) ) ; void ( ) ; return java.lang.String != null ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ) java.io.IOException { if ( this . org.springframework.integration.file.filters.ConcurrentMetadataStore instanceof java.io.Closeable ) { ( ( java.io.Closeable ) this . org.springframework.integration.file.filters.ConcurrentMetadataStore ) . void ( ) ; } }  <METHOD_END>
<METHOD_START> private java.lang.String java.lang.String ( F F ) { return java.lang.Long . java.lang.String ( this . long ( F ) ) ; }  <METHOD_END>
<METHOD_START> protected boolean boolean ( F F , java.lang.String java.lang.String ) { return java.lang.Long . java.lang.Long ( java.lang.String ) == this . long ( F ) ; }  <METHOD_END>
<METHOD_START> protected java.lang.String java.lang.String ( F F ) { return this . java.lang.String + this . java.lang.String ( F ) ; }  <METHOD_END>
<METHOD_START> protected void void ( ) { if ( this . boolean && this . java.io.Flushable != null ) { try { this . java.io.Flushable . void ( ) ; } catch ( java.io.IOException java.io.IOException ) { } } }  <METHOD_END>
<METHOD_START> protected abstract long long ( F F );  <METHOD_END>
<METHOD_START> protected abstract java.lang.String java.lang.String ( F F );  <METHOD_END>
