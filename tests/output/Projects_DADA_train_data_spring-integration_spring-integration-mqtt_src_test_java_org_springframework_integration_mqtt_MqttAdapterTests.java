<METHOD_START> @ Test public void void ( ) { DefaultMqttPahoClientFactory org.springframework.integration.mqtt.DefaultMqttPahoClientFactory = new DefaultMqttPahoClientFactory ( ) ; org.springframework.integration.mqtt.DefaultMqttPahoClientFactory . setCleanSession ( false ) ; org.springframework.integration.mqtt.DefaultMqttPahoClientFactory . setConnectionTimeout ( NUMBER ) ; org.springframework.integration.mqtt.DefaultMqttPahoClientFactory . setKeepAliveInterval ( NUMBER ) ; org.springframework.integration.mqtt.DefaultMqttPahoClientFactory . setPassword ( STRING ) ; javax.net.SocketFactory javax.net.SocketFactory = mock ( javax.net.SocketFactory .class ) ; org.springframework.integration.mqtt.DefaultMqttPahoClientFactory . setSocketFactory ( javax.net.SocketFactory ) ; java.util.Properties java.util.Properties = new java.util.Properties ( ) ; org.springframework.integration.mqtt.DefaultMqttPahoClientFactory . setSslProperties ( java.util.Properties ) ; org.springframework.integration.mqtt.DefaultMqttPahoClientFactory . setUserName ( STRING ) ; Will org.springframework.integration.mqtt.Will = new Will ( STRING , STRING . byte[] ( ) , NUMBER , true ) ; org.springframework.integration.mqtt.DefaultMqttPahoClientFactory . setWill ( org.springframework.integration.mqtt.Will ) ; MqttConnectOptions org.springframework.integration.mqtt.MqttConnectOptions = org.springframework.integration.mqtt.DefaultMqttPahoClientFactory . getConnectionOptions ( ) ; assertEquals ( NUMBER , org.springframework.integration.mqtt.MqttConnectOptions . getConnectionTimeout ( ) ) ; assertEquals ( NUMBER , org.springframework.integration.mqtt.MqttConnectOptions . getKeepAliveInterval ( ) ) ; assertEquals ( STRING , new java.lang.String ( org.springframework.integration.mqtt.MqttConnectOptions . getPassword ( ) ) ) ; assertSame ( javax.net.SocketFactory , org.springframework.integration.mqtt.MqttConnectOptions . getSocketFactory ( ) ) ; assertSame ( java.util.Properties , org.springframework.integration.mqtt.MqttConnectOptions . getSSLProperties ( ) ) ; assertEquals ( STRING , org.springframework.integration.mqtt.MqttConnectOptions . getUserName ( ) ) ; assertEquals ( STRING , org.springframework.integration.mqtt.MqttConnectOptions . getWillDestination ( ) ) ; assertEquals ( STRING , new java.lang.String ( org.springframework.integration.mqtt.MqttConnectOptions . getWillMessage ( ) . getPayload ( ) ) ) ; assertEquals ( NUMBER , org.springframework.integration.mqtt.MqttConnectOptions . getWillMessage ( ) . getQos ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { DefaultMqttPahoClientFactory org.springframework.integration.mqtt.DefaultMqttPahoClientFactory = new DefaultMqttPahoClientFactory ( ) ; org.springframework.integration.mqtt.DefaultMqttPahoClientFactory . setCleanSession ( false ) ; org.springframework.integration.mqtt.DefaultMqttPahoClientFactory . setConnectionTimeout ( NUMBER ) ; org.springframework.integration.mqtt.DefaultMqttPahoClientFactory . setKeepAliveInterval ( NUMBER ) ; org.springframework.integration.mqtt.DefaultMqttPahoClientFactory . setPassword ( STRING ) ; MemoryPersistence org.springframework.integration.mqtt.MemoryPersistence = new MemoryPersistence ( ) ; org.springframework.integration.mqtt.DefaultMqttPahoClientFactory . setPersistence ( org.springframework.integration.mqtt.MemoryPersistence ) ; final javax.net.SocketFactory javax.net.SocketFactory = mock ( javax.net.SocketFactory .class ) ; org.springframework.integration.mqtt.DefaultMqttPahoClientFactory . setSocketFactory ( javax.net.SocketFactory ) ; final java.util.Properties java.util.Properties = new java.util.Properties ( ) ; org.springframework.integration.mqtt.DefaultMqttPahoClientFactory . setSslProperties ( java.util.Properties ) ; org.springframework.integration.mqtt.DefaultMqttPahoClientFactory . setUserName ( STRING ) ; Will org.springframework.integration.mqtt.Will = new Will ( STRING , STRING . byte[] ( ) , NUMBER , true ) ; org.springframework.integration.mqtt.DefaultMqttPahoClientFactory . setWill ( org.springframework.integration.mqtt.Will ) ; org.springframework.integration.mqtt.DefaultMqttPahoClientFactory = spy ( org.springframework.integration.mqtt.DefaultMqttPahoClientFactory ) ; final MqttAsyncClient org.springframework.integration.mqtt.MqttAsyncClient = mock ( MqttAsyncClient .class ) ; willAnswer ( invocation -> client ) . given ( org.springframework.integration.mqtt.DefaultMqttPahoClientFactory ) . getAsyncClientInstance ( anyString ( ) , anyString ( ) ) ; MqttPahoMessageHandler org.springframework.integration.mqtt.MqttPahoMessageHandler = new MqttPahoMessageHandler ( STRING , STRING , org.springframework.integration.mqtt.DefaultMqttPahoClientFactory ) ; org.springframework.integration.mqtt.MqttPahoMessageHandler . setDefaultTopic ( STRING ) ; org.springframework.integration.mqtt.MqttPahoMessageHandler . setBeanFactory ( mock ( BeanFactory .class ) ) ; org.springframework.integration.mqtt.MqttPahoMessageHandler . afterPropertiesSet ( ) ; org.springframework.integration.mqtt.MqttPahoMessageHandler . start ( ) ; final MqttToken org.springframework.integration.mqtt.MqttToken = mock ( MqttToken .class ) ; final java.util.concurrent.atomic.AtomicBoolean java.util.concurrent.atomic.AtomicBoolean = new java.util.concurrent.atomic.AtomicBoolean ( ) ; willAnswer ( invocation -> { MqttConnectOptions options = invocation . getArgument ( NUMBER ) ; assertEquals ( NUMBER , options . getConnectionTimeout ( ) ) ; assertEquals ( NUMBER , options . getKeepAliveInterval ( ) ) ; assertEquals ( STRING , new String ( options . getPassword ( ) ) ) ; assertSame ( socketFactory , options . getSocketFactory ( ) ) ; assertSame ( props , options . getSSLProperties ( ) ) ; assertEquals ( STRING , options . getUserName ( ) ) ; assertEquals ( STRING , options . getWillDestination ( ) ) ; assertEquals ( STRING , new String ( options . getWillMessage ( ) . getPayload ( ) ) ) ; assertEquals ( NUMBER , options . getWillMessage ( ) . getQos ( ) ) ; connectCalled . set ( true ) ; return token ; } ) . given ( org.springframework.integration.mqtt.MqttAsyncClient ) . connect ( any ( MqttConnectOptions .class ) ) ; willReturn ( org.springframework.integration.mqtt.MqttToken ) . given ( org.springframework.integration.mqtt.MqttAsyncClient ) . subscribe ( any ( java.lang.String [] .class ) , any ( int [] .class ) ) ; final MqttDeliveryToken org.springframework.integration.mqtt.MqttDeliveryToken = mock ( MqttDeliveryToken .class ) ; final java.util.concurrent.atomic.AtomicBoolean java.util.concurrent.atomic.AtomicBoolean = new java.util.concurrent.atomic.AtomicBoolean ( ) ; willAnswer ( invocation -> { assertEquals ( STRING , invocation . getArguments ( ) [ NUMBER ] ) ; MqttMessage message = invocation . getArgument ( NUMBER ) ; assertEquals ( STRING , new String ( message . getPayload ( ) ) ) ; publishCalled . set ( true ) ; return deliveryToken ; } ) . given ( org.springframework.integration.mqtt.MqttAsyncClient ) . publish ( anyString ( ) , any ( MqttMessage .class ) ) ; org.springframework.integration.mqtt.MqttPahoMessageHandler . handleMessage ( new GenericMessage < java.lang.String > ( STRING ) ) ; verify ( org.springframework.integration.mqtt.MqttAsyncClient , times ( NUMBER ) ) . connect ( any ( MqttConnectOptions .class ) ) ; assertTrue ( java.util.concurrent.atomic.AtomicBoolean . boolean ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { DefaultMqttPahoClientFactory org.springframework.integration.mqtt.DefaultMqttPahoClientFactory = new DefaultMqttPahoClientFactory ( ) ; org.springframework.integration.mqtt.DefaultMqttPahoClientFactory . setCleanSession ( false ) ; org.springframework.integration.mqtt.DefaultMqttPahoClientFactory . setConnectionTimeout ( NUMBER ) ; org.springframework.integration.mqtt.DefaultMqttPahoClientFactory . setKeepAliveInterval ( NUMBER ) ; org.springframework.integration.mqtt.DefaultMqttPahoClientFactory . setPassword ( STRING ) ; MemoryPersistence org.springframework.integration.mqtt.MemoryPersistence = new MemoryPersistence ( ) ; org.springframework.integration.mqtt.DefaultMqttPahoClientFactory . setPersistence ( org.springframework.integration.mqtt.MemoryPersistence ) ; final javax.net.SocketFactory javax.net.SocketFactory = mock ( javax.net.SocketFactory .class ) ; org.springframework.integration.mqtt.DefaultMqttPahoClientFactory . setSocketFactory ( javax.net.SocketFactory ) ; final java.util.Properties java.util.Properties = new java.util.Properties ( ) ; org.springframework.integration.mqtt.DefaultMqttPahoClientFactory . setSslProperties ( java.util.Properties ) ; org.springframework.integration.mqtt.DefaultMqttPahoClientFactory . setUserName ( STRING ) ; Will org.springframework.integration.mqtt.Will = new Will ( STRING , STRING . byte[] ( ) , NUMBER , true ) ; org.springframework.integration.mqtt.DefaultMqttPahoClientFactory . setWill ( org.springframework.integration.mqtt.Will ) ; org.springframework.integration.mqtt.DefaultMqttPahoClientFactory = spy ( org.springframework.integration.mqtt.DefaultMqttPahoClientFactory ) ; final IMqttClient org.springframework.integration.mqtt.IMqttClient = mock ( IMqttClient .class ) ; willAnswer ( invocation -> client ) . given ( org.springframework.integration.mqtt.DefaultMqttPahoClientFactory ) . getClientInstance ( anyString ( ) , anyString ( ) ) ; final java.util.concurrent.atomic.AtomicBoolean java.util.concurrent.atomic.AtomicBoolean = new java.util.concurrent.atomic.AtomicBoolean ( ) ; final java.util.concurrent.atomic.AtomicBoolean java.util.concurrent.atomic.AtomicBoolean = new java.util.concurrent.atomic.AtomicBoolean ( ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; final MqttException org.springframework.integration.mqtt.MqttException = new MqttException ( MqttException . REASON_CODE_SERVER_CONNECT_ERROR ) ; willAnswer ( invocation -> { if ( failConnection . get ( ) ) { failInProcess . countDown ( ) ; waitToFail . await ( NUMBER , TimeUnit . SECONDS ) ; throw reconnectException ; } MqttConnectOptions options = invocation . getArgument ( NUMBER ) ; assertEquals ( NUMBER , options . getConnectionTimeout ( ) ) ; assertEquals ( NUMBER , options . getKeepAliveInterval ( ) ) ; assertEquals ( STRING , new String ( options . getPassword ( ) ) ) ; assertSame ( socketFactory , options . getSocketFactory ( ) ) ; assertSame ( props , options . getSSLProperties ( ) ) ; assertEquals ( STRING , options . getUserName ( ) ) ; assertEquals ( STRING , options . getWillDestination ( ) ) ; assertEquals ( STRING , new String ( options . getWillMessage ( ) . getPayload ( ) ) ) ; assertEquals ( NUMBER , options . getWillMessage ( ) . getQos ( ) ) ; connectCalled . set ( true ) ; goodConnection . countDown ( ) ; return null ; } ) . given ( org.springframework.integration.mqtt.IMqttClient ) . connect ( any ( MqttConnectOptions .class ) ) ; final java.util.concurrent.atomic.AtomicReference<org.springframework.integration.mqtt.MqttCallback> < MqttCallback > java.util.concurrent.atomic.AtomicReference<org.springframework.integration.mqtt.MqttCallback> = new java.util.concurrent.atomic.AtomicReference<org.springframework.integration.mqtt.MqttCallback> < MqttCallback > ( ) ; willAnswer ( invocation -> { callback . set ( invocation . getArgument ( NUMBER ) ) ; return null ; } ) . given ( org.springframework.integration.mqtt.IMqttClient ) . setCallback ( any ( MqttCallback .class ) ) ; given ( org.springframework.integration.mqtt.IMqttClient . isConnected ( ) ) . willReturn ( true ) ; MqttPahoMessageDrivenChannelAdapter org.springframework.integration.mqtt.MqttPahoMessageDrivenChannelAdapter = new MqttPahoMessageDrivenChannelAdapter ( STRING , STRING , org.springframework.integration.mqtt.DefaultMqttPahoClientFactory , STRING , STRING ) ; QueueChannel org.springframework.integration.mqtt.QueueChannel = new QueueChannel ( ) ; org.springframework.integration.mqtt.MqttPahoMessageDrivenChannelAdapter . setOutputChannel ( org.springframework.integration.mqtt.QueueChannel ) ; ThreadPoolTaskScheduler org.springframework.integration.mqtt.ThreadPoolTaskScheduler = new ThreadPoolTaskScheduler ( ) ; org.springframework.integration.mqtt.ThreadPoolTaskScheduler . initialize ( ) ; org.springframework.integration.mqtt.MqttPahoMessageDrivenChannelAdapter . setTaskScheduler ( org.springframework.integration.mqtt.ThreadPoolTaskScheduler ) ; org.springframework.integration.mqtt.MqttPahoMessageDrivenChannelAdapter . setBeanFactory ( mock ( BeanFactory .class ) ) ; ApplicationEventPublisher org.springframework.integration.mqtt.ApplicationEventPublisher = mock ( ApplicationEventPublisher .class ) ; final java.util.concurrent.BlockingQueue<org.springframework.integration.mqtt.MqttIntegrationEvent> < MqttIntegrationEvent > java.util.concurrent.BlockingQueue<org.springframework.integration.mqtt.MqttIntegrationEvent> = new java.util.concurrent.LinkedBlockingQueue<org.springframework.integration.mqtt.MqttIntegrationEvent> < MqttIntegrationEvent > ( ) ; willAnswer ( invocation -> { events . add ( invocation . getArgument ( NUMBER ) ) ; return null ; } ) . given ( org.springframework.integration.mqtt.ApplicationEventPublisher ) . publishEvent ( any ( MqttIntegrationEvent .class ) ) ; org.springframework.integration.mqtt.MqttPahoMessageDrivenChannelAdapter . setApplicationEventPublisher ( org.springframework.integration.mqtt.ApplicationEventPublisher ) ; org.springframework.integration.mqtt.MqttPahoMessageDrivenChannelAdapter . setRecoveryInterval ( NUMBER ) ; org.springframework.integration.mqtt.MqttPahoMessageDrivenChannelAdapter . afterPropertiesSet ( ) ; org.springframework.integration.mqtt.MqttPahoMessageDrivenChannelAdapter . start ( ) ; verify ( org.springframework.integration.mqtt.IMqttClient , times ( NUMBER ) ) . connect ( any ( MqttConnectOptions .class ) ) ; assertTrue ( java.util.concurrent.atomic.AtomicBoolean . boolean ( ) ) ; MqttMessage org.springframework.integration.mqtt.MqttMessage = new MqttMessage ( STRING . byte[] ( ) ) ; java.util.concurrent.atomic.AtomicReference<org.springframework.integration.mqtt.MqttCallback> . get ( ) . messageArrived ( STRING , org.springframework.integration.mqtt.MqttMessage ) ; Message < ? > org.springframework.integration.mqtt.Message<?> = org.springframework.integration.mqtt.QueueChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.mqtt.Message<> ) ; assertEquals ( STRING , org.springframework.integration.mqtt.Message<> . getPayload ( ) ) ; MqttIntegrationEvent org.springframework.integration.mqtt.MqttIntegrationEvent = java.util.concurrent.BlockingQueue<org.springframework.integration.mqtt.MqttIntegrationEvent> . poll ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ; assertThat ( org.springframework.integration.mqtt.MqttIntegrationEvent , instanceOf ( MqttSubscribedEvent .class ) ) ; assertEquals ( STRING , ( ( MqttSubscribedEvent ) org.springframework.integration.mqtt.MqttIntegrationEvent ) . getMessage ( ) ) ; java.util.concurrent.atomic.AtomicBoolean . void ( true ) ; java.lang.RuntimeException java.lang.RuntimeException = new java.lang.RuntimeException ( STRING ) ; org.springframework.integration.mqtt.MqttPahoMessageDrivenChannelAdapter . connectionLost ( java.lang.RuntimeException ) ; org.springframework.integration.mqtt.MqttIntegrationEvent = java.util.concurrent.BlockingQueue<org.springframework.integration.mqtt.MqttIntegrationEvent> . poll ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ; assertThat ( org.springframework.integration.mqtt.MqttIntegrationEvent , instanceOf ( MqttConnectionFailedEvent .class ) ) ; assertSame ( org.springframework.integration.mqtt.MqttIntegrationEvent . getCause ( ) , java.lang.RuntimeException ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; java.util.concurrent.CountDownLatch . void ( ) ; java.util.concurrent.atomic.AtomicBoolean . void ( false ) ; org.springframework.integration.mqtt.MqttIntegrationEvent = java.util.concurrent.BlockingQueue<org.springframework.integration.mqtt.MqttIntegrationEvent> . poll ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ; assertThat ( org.springframework.integration.mqtt.MqttIntegrationEvent , instanceOf ( MqttConnectionFailedEvent .class ) ) ; assertSame ( org.springframework.integration.mqtt.MqttIntegrationEvent . getCause ( ) , org.springframework.integration.mqtt.MqttException ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; int int = NUMBER ; while ( ! ( org.springframework.integration.mqtt.MqttIntegrationEvent instanceof MqttSubscribedEvent ) && int ++ < NUMBER ) { org.springframework.integration.mqtt.MqttIntegrationEvent = java.util.concurrent.BlockingQueue<org.springframework.integration.mqtt.MqttIntegrationEvent> . poll ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ; } assertThat ( org.springframework.integration.mqtt.MqttIntegrationEvent , instanceOf ( MqttSubscribedEvent .class ) ) ; assertEquals ( STRING , ( ( MqttSubscribedEvent ) org.springframework.integration.mqtt.MqttIntegrationEvent ) . getMessage ( ) ) ; org.springframework.integration.mqtt.ThreadPoolTaskScheduler . destroy ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final IMqttClient org.springframework.integration.mqtt.IMqttClient = mock ( IMqttClient .class ) ; MqttPahoMessageDrivenChannelAdapter org.springframework.integration.mqtt.MqttPahoMessageDrivenChannelAdapter = org.springframework.integration.mqtt.MqttPahoMessageDrivenChannelAdapter ( org.springframework.integration.mqtt.IMqttClient , null , null ) ; org.springframework.integration.mqtt.MqttPahoMessageDrivenChannelAdapter . start ( ) ; org.springframework.integration.mqtt.MqttPahoMessageDrivenChannelAdapter . stop ( ) ; void ( org.springframework.integration.mqtt.IMqttClient ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final IMqttClient org.springframework.integration.mqtt.IMqttClient = mock ( IMqttClient .class ) ; MqttPahoMessageDrivenChannelAdapter org.springframework.integration.mqtt.MqttPahoMessageDrivenChannelAdapter = org.springframework.integration.mqtt.MqttPahoMessageDrivenChannelAdapter ( org.springframework.integration.mqtt.IMqttClient , false , null ) ; org.springframework.integration.mqtt.MqttPahoMessageDrivenChannelAdapter . start ( ) ; org.springframework.integration.mqtt.MqttPahoMessageDrivenChannelAdapter . stop ( ) ; void ( org.springframework.integration.mqtt.IMqttClient ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final IMqttClient org.springframework.integration.mqtt.IMqttClient = mock ( IMqttClient .class ) ; MqttPahoMessageDrivenChannelAdapter org.springframework.integration.mqtt.MqttPahoMessageDrivenChannelAdapter = org.springframework.integration.mqtt.MqttPahoMessageDrivenChannelAdapter ( org.springframework.integration.mqtt.IMqttClient , false , ConsumerStopAction . UNSUBSCRIBE_ALWAYS ) ; org.springframework.integration.mqtt.MqttPahoMessageDrivenChannelAdapter . start ( ) ; org.springframework.integration.mqtt.MqttPahoMessageDrivenChannelAdapter . stop ( ) ; void ( org.springframework.integration.mqtt.IMqttClient ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final IMqttClient org.springframework.integration.mqtt.IMqttClient = mock ( IMqttClient .class ) ; MqttPahoMessageDrivenChannelAdapter org.springframework.integration.mqtt.MqttPahoMessageDrivenChannelAdapter = org.springframework.integration.mqtt.MqttPahoMessageDrivenChannelAdapter ( org.springframework.integration.mqtt.IMqttClient , null , ConsumerStopAction . UNSUBSCRIBE_NEVER ) ; org.springframework.integration.mqtt.MqttPahoMessageDrivenChannelAdapter . start ( ) ; org.springframework.integration.mqtt.MqttPahoMessageDrivenChannelAdapter . stop ( ) ; void ( org.springframework.integration.mqtt.IMqttClient ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.SuppressWarnings ( STRING ) @ Test public void void ( ) { AnnotationConfigApplicationContext org.springframework.integration.mqtt.AnnotationConfigApplicationContext = new AnnotationConfigApplicationContext ( org.springframework.integration.mqtt.MqttAdapterTests.Config .class ) ; MqttPahoMessageHandler org.springframework.integration.mqtt.MqttPahoMessageHandler = org.springframework.integration.mqtt.AnnotationConfigApplicationContext . getBean ( STRING , MqttPahoMessageHandler .class ) ; GenericMessage < java.lang.String > org.springframework.integration.mqtt.GenericMessage<java.lang.String> = new GenericMessage <> ( STRING ) ; assertEquals ( STRING , TestUtils . getPropertyValue ( org.springframework.integration.mqtt.MqttPahoMessageHandler , STRING , MessageProcessor .class ) . processMessage ( org.springframework.integration.mqtt.GenericMessage<java.lang.String> ) ) ; assertEquals ( NUMBER , TestUtils . getPropertyValue ( org.springframework.integration.mqtt.MqttPahoMessageHandler , STRING , MessageProcessor .class ) . processMessage ( org.springframework.integration.mqtt.GenericMessage<java.lang.String> ) ) ; assertEquals ( java.lang.Boolean . java.lang.Boolean , TestUtils . getPropertyValue ( org.springframework.integration.mqtt.MqttPahoMessageHandler , STRING , MessageProcessor .class ) . processMessage ( org.springframework.integration.mqtt.GenericMessage<java.lang.String> ) ) ; org.springframework.integration.mqtt.MqttPahoMessageHandler = org.springframework.integration.mqtt.AnnotationConfigApplicationContext . getBean ( STRING , MqttPahoMessageHandler .class ) ; assertEquals ( NUMBER , TestUtils . getPropertyValue ( org.springframework.integration.mqtt.MqttPahoMessageHandler , STRING , DefaultPahoMessageConverter .class ) . fromMessage ( org.springframework.integration.mqtt.GenericMessage<java.lang.String> , null ) . getQos ( ) ) ; assertEquals ( java.lang.Boolean . java.lang.Boolean , TestUtils . getPropertyValue ( org.springframework.integration.mqtt.MqttPahoMessageHandler , STRING , DefaultPahoMessageConverter .class ) . fromMessage ( org.springframework.integration.mqtt.GenericMessage<java.lang.String> , null ) . isRetained ( ) ) ; org.springframework.integration.mqtt.AnnotationConfigApplicationContext . close ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final IMqttClient org.springframework.integration.mqtt.IMqttClient = mock ( IMqttClient .class ) ; MqttPahoMessageDrivenChannelAdapter org.springframework.integration.mqtt.MqttPahoMessageDrivenChannelAdapter = org.springframework.integration.mqtt.MqttPahoMessageDrivenChannelAdapter ( org.springframework.integration.mqtt.IMqttClient , null , ConsumerStopAction . UNSUBSCRIBE_NEVER ) ; org.springframework.integration.mqtt.MqttPahoMessageDrivenChannelAdapter . setRecoveryInterval ( NUMBER ) ; Log org.springframework.integration.mqtt.Log = spy ( TestUtils . getPropertyValue ( org.springframework.integration.mqtt.MqttPahoMessageDrivenChannelAdapter , STRING , Log .class ) ) ; new DirectFieldAccessor ( org.springframework.integration.mqtt.MqttPahoMessageDrivenChannelAdapter ) . setPropertyValue ( STRING , org.springframework.integration.mqtt.Log ) ; given ( org.springframework.integration.mqtt.Log . isDebugEnabled ( ) ) . willReturn ( true ) ; final java.util.concurrent.atomic.AtomicInteger java.util.concurrent.atomic.AtomicInteger = new java.util.concurrent.atomic.AtomicInteger ( ) ; willAnswer ( i -> { if ( attemptingReconnectCount . getAndIncrement ( ) == NUMBER ) { adapter . connectionLost ( new RuntimeException ( STRING ) ) ; } i . callRealMethod ( ) ; return null ; } ) . given ( org.springframework.integration.mqtt.Log ) . debug ( STRING ) ; ThreadPoolTaskScheduler org.springframework.integration.mqtt.ThreadPoolTaskScheduler = new ThreadPoolTaskScheduler ( ) ; org.springframework.integration.mqtt.ThreadPoolTaskScheduler . initialize ( ) ; org.springframework.integration.mqtt.MqttPahoMessageDrivenChannelAdapter . setTaskScheduler ( org.springframework.integration.mqtt.ThreadPoolTaskScheduler ) ; org.springframework.integration.mqtt.MqttPahoMessageDrivenChannelAdapter . start ( ) ; org.springframework.integration.mqtt.MqttPahoMessageDrivenChannelAdapter . connectionLost ( new java.lang.RuntimeException ( STRING ) ) ; java.lang.Thread . void ( NUMBER ) ; assertThat ( java.util.concurrent.atomic.AtomicInteger . int ( ) , lessThanOrEqualTo ( NUMBER ) ) ; org.springframework.integration.mqtt.MqttPahoMessageDrivenChannelAdapter . stop ( ) ; org.springframework.integration.mqtt.ThreadPoolTaskScheduler . destroy ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { DefaultMqttPahoClientFactory org.springframework.integration.mqtt.DefaultMqttPahoClientFactory = new DefaultMqttPahoClientFactory ( ) ; org.springframework.integration.mqtt.DefaultMqttPahoClientFactory . setCleanSession ( false ) ; org.springframework.integration.mqtt.DefaultMqttPahoClientFactory . setConnectionTimeout ( NUMBER ) ; org.springframework.integration.mqtt.DefaultMqttPahoClientFactory . setKeepAliveInterval ( NUMBER ) ; org.springframework.integration.mqtt.DefaultMqttPahoClientFactory . setPassword ( STRING ) ; MemoryPersistence org.springframework.integration.mqtt.MemoryPersistence = new MemoryPersistence ( ) ; org.springframework.integration.mqtt.DefaultMqttPahoClientFactory . setPersistence ( org.springframework.integration.mqtt.MemoryPersistence ) ; final javax.net.SocketFactory javax.net.SocketFactory = mock ( javax.net.SocketFactory .class ) ; org.springframework.integration.mqtt.DefaultMqttPahoClientFactory . setSocketFactory ( javax.net.SocketFactory ) ; final java.util.Properties java.util.Properties = new java.util.Properties ( ) ; org.springframework.integration.mqtt.DefaultMqttPahoClientFactory . setSslProperties ( java.util.Properties ) ; org.springframework.integration.mqtt.DefaultMqttPahoClientFactory . setUserName ( STRING ) ; Will org.springframework.integration.mqtt.Will = new Will ( STRING , STRING . byte[] ( ) , NUMBER , true ) ; org.springframework.integration.mqtt.DefaultMqttPahoClientFactory . setWill ( org.springframework.integration.mqtt.Will ) ; org.springframework.integration.mqtt.DefaultMqttPahoClientFactory = spy ( org.springframework.integration.mqtt.DefaultMqttPahoClientFactory ) ; MqttAsyncClient org.springframework.integration.mqtt.MqttAsyncClient = mock ( MqttAsyncClient .class ) ; final MqttClient org.springframework.integration.mqtt.MqttClient = mock ( MqttClient .class ) ; willAnswer ( invocation -> client ) . given ( org.springframework.integration.mqtt.DefaultMqttPahoClientFactory ) . getClientInstance ( anyString ( ) , anyString ( ) ) ; given ( org.springframework.integration.mqtt.MqttClient . isConnected ( ) ) . willReturn ( true ) ; new DirectFieldAccessor ( org.springframework.integration.mqtt.MqttClient ) . setPropertyValue ( STRING , org.springframework.integration.mqtt.MqttAsyncClient ) ; willAnswer ( new CallsRealMethods ( ) ) . given ( org.springframework.integration.mqtt.MqttClient ) . connect ( any ( MqttConnectOptions .class ) ) ; willAnswer ( new CallsRealMethods ( ) ) . given ( org.springframework.integration.mqtt.MqttClient ) . subscribe ( any ( java.lang.String [] .class ) , any ( int [] .class ) ) ; willReturn ( org.springframework.integration.mqtt.IMqttToken ) . given ( org.springframework.integration.mqtt.MqttAsyncClient ) . connect ( any ( MqttConnectOptions .class ) , any ( ) , any ( ) ) ; IMqttToken org.springframework.integration.mqtt.IMqttToken = mock ( IMqttToken .class ) ; given ( org.springframework.integration.mqtt.IMqttToken . getGrantedQos ( ) ) . willReturn ( new int [] { NUMBER } ) ; willReturn ( org.springframework.integration.mqtt.IMqttToken ) . given ( org.springframework.integration.mqtt.MqttAsyncClient ) . subscribe ( any ( java.lang.String [] .class ) , any ( int [] .class ) , any ( ) , any ( ) ) ; MqttPahoMessageDrivenChannelAdapter org.springframework.integration.mqtt.MqttPahoMessageDrivenChannelAdapter = new MqttPahoMessageDrivenChannelAdapter ( STRING , STRING , org.springframework.integration.mqtt.DefaultMqttPahoClientFactory , STRING , STRING ) ; java.util.concurrent.atomic.AtomicReference<java.lang.reflect.Method> < java.lang.reflect.Method > java.util.concurrent.atomic.AtomicReference<java.lang.reflect.Method> = new java.util.concurrent.atomic.AtomicReference<java.lang.reflect.Method> <> ( ) ; ReflectionUtils . doWithMethods ( MqttPahoMessageDrivenChannelAdapter .class , m -> { m . setAccessible ( true ) ; method . set ( m ) ; } , m -> m . getName ( ) . equals ( STRING ) ) ; assertNotNull ( java.util.concurrent.atomic.AtomicReference<java.lang.reflect.Method> . java.lang.reflect.Method ( ) ) ; try { java.util.concurrent.atomic.AtomicReference<java.lang.reflect.Method> . java.lang.reflect.Method ( ) . java.lang.Object ( org.springframework.integration.mqtt.MqttPahoMessageDrivenChannelAdapter ) ; fail ( STRING ) ; } catch ( java.lang.reflect.InvocationTargetException java.lang.reflect.InvocationTargetException ) { assertThat ( java.lang.reflect.InvocationTargetException . java.lang.Throwable ( ) , instanceOf ( MqttException .class ) ) ; assertThat ( ( ( MqttException ) java.lang.reflect.InvocationTargetException . java.lang.Throwable ( ) ) . getReasonCode ( ) , equalTo ( ( int ) MqttException . REASON_CODE_SUBSCRIBE_FAILED ) ) ; } }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { DefaultMqttPahoClientFactory org.springframework.integration.mqtt.DefaultMqttPahoClientFactory = new DefaultMqttPahoClientFactory ( ) ; org.springframework.integration.mqtt.DefaultMqttPahoClientFactory . setCleanSession ( false ) ; org.springframework.integration.mqtt.DefaultMqttPahoClientFactory . setConnectionTimeout ( NUMBER ) ; org.springframework.integration.mqtt.DefaultMqttPahoClientFactory . setKeepAliveInterval ( NUMBER ) ; org.springframework.integration.mqtt.DefaultMqttPahoClientFactory . setPassword ( STRING ) ; MemoryPersistence org.springframework.integration.mqtt.MemoryPersistence = new MemoryPersistence ( ) ; org.springframework.integration.mqtt.DefaultMqttPahoClientFactory . setPersistence ( org.springframework.integration.mqtt.MemoryPersistence ) ; final javax.net.SocketFactory javax.net.SocketFactory = mock ( javax.net.SocketFactory .class ) ; org.springframework.integration.mqtt.DefaultMqttPahoClientFactory . setSocketFactory ( javax.net.SocketFactory ) ; final java.util.Properties java.util.Properties = new java.util.Properties ( ) ; org.springframework.integration.mqtt.DefaultMqttPahoClientFactory . setSslProperties ( java.util.Properties ) ; org.springframework.integration.mqtt.DefaultMqttPahoClientFactory . setUserName ( STRING ) ; Will org.springframework.integration.mqtt.Will = new Will ( STRING , STRING . byte[] ( ) , NUMBER , true ) ; org.springframework.integration.mqtt.DefaultMqttPahoClientFactory . setWill ( org.springframework.integration.mqtt.Will ) ; org.springframework.integration.mqtt.DefaultMqttPahoClientFactory = spy ( org.springframework.integration.mqtt.DefaultMqttPahoClientFactory ) ; MqttAsyncClient org.springframework.integration.mqtt.MqttAsyncClient = mock ( MqttAsyncClient .class ) ; final MqttClient org.springframework.integration.mqtt.MqttClient = mock ( MqttClient .class ) ; willAnswer ( invocation -> client ) . given ( org.springframework.integration.mqtt.DefaultMqttPahoClientFactory ) . getClientInstance ( anyString ( ) , anyString ( ) ) ; given ( org.springframework.integration.mqtt.MqttClient . isConnected ( ) ) . willReturn ( true ) ; new DirectFieldAccessor ( org.springframework.integration.mqtt.MqttClient ) . setPropertyValue ( STRING , org.springframework.integration.mqtt.MqttAsyncClient ) ; willAnswer ( new CallsRealMethods ( ) ) . given ( org.springframework.integration.mqtt.MqttClient ) . connect ( any ( MqttConnectOptions .class ) ) ; willAnswer ( new CallsRealMethods ( ) ) . given ( org.springframework.integration.mqtt.MqttClient ) . subscribe ( any ( java.lang.String [] .class ) , any ( int [] .class ) ) ; willReturn ( org.springframework.integration.mqtt.IMqttToken ) . given ( org.springframework.integration.mqtt.MqttAsyncClient ) . connect ( any ( MqttConnectOptions .class ) , any ( ) , any ( ) ) ; IMqttToken org.springframework.integration.mqtt.IMqttToken = mock ( IMqttToken .class ) ; given ( org.springframework.integration.mqtt.IMqttToken . getGrantedQos ( ) ) . willReturn ( new int [] { NUMBER , NUMBER } ) ; willReturn ( org.springframework.integration.mqtt.IMqttToken ) . given ( org.springframework.integration.mqtt.MqttAsyncClient ) . subscribe ( any ( java.lang.String [] .class ) , any ( int [] .class ) , any ( ) , any ( ) ) ; MqttPahoMessageDrivenChannelAdapter org.springframework.integration.mqtt.MqttPahoMessageDrivenChannelAdapter = new MqttPahoMessageDrivenChannelAdapter ( STRING , STRING , org.springframework.integration.mqtt.DefaultMqttPahoClientFactory , STRING , STRING ) ; java.util.concurrent.atomic.AtomicReference<java.lang.reflect.Method> < java.lang.reflect.Method > java.util.concurrent.atomic.AtomicReference<java.lang.reflect.Method> = new java.util.concurrent.atomic.AtomicReference<java.lang.reflect.Method> <> ( ) ; ReflectionUtils . doWithMethods ( MqttPahoMessageDrivenChannelAdapter .class , m -> { m . setAccessible ( true ) ; method . set ( m ) ; } , m -> m . getName ( ) . equals ( STRING ) ) ; assertNotNull ( java.util.concurrent.atomic.AtomicReference<java.lang.reflect.Method> . java.lang.reflect.Method ( ) ) ; Log org.springframework.integration.mqtt.Log = spy ( TestUtils . getPropertyValue ( org.springframework.integration.mqtt.MqttPahoMessageDrivenChannelAdapter , STRING , Log .class ) ) ; new DirectFieldAccessor ( org.springframework.integration.mqtt.MqttPahoMessageDrivenChannelAdapter ) . setPropertyValue ( STRING , org.springframework.integration.mqtt.Log ) ; given ( org.springframework.integration.mqtt.Log . isWarnEnabled ( ) ) . willReturn ( true ) ; java.util.concurrent.atomic.AtomicReference<java.lang.reflect.Method> . java.lang.reflect.Method ( ) . java.lang.Object ( org.springframework.integration.mqtt.MqttPahoMessageDrivenChannelAdapter ) ; verify ( org.springframework.integration.mqtt.Log , atLeastOnce ( ) ) . warn ( STRING ) ; verify ( org.springframework.integration.mqtt.MqttClient ) . setTimeToWait ( NUMBER ) ; }  <METHOD_END>
<METHOD_START> private org.springframework.integration.mqtt.MqttPahoMessageDrivenChannelAdapter org.springframework.integration.mqtt.MqttPahoMessageDrivenChannelAdapter ( final IMqttClient org.springframework.integration.mqtt.IMqttClient , java.lang.Boolean java.lang.Boolean , ConsumerStopAction org.springframework.integration.mqtt.ConsumerStopAction ) throws org.springframework.integration.mqtt.MqttException , org.springframework.integration.mqtt.MqttSecurityException { DefaultMqttPahoClientFactory org.springframework.integration.mqtt.DefaultMqttPahoClientFactory = new DefaultMqttPahoClientFactory ( ) { @ java.lang.Override public org.springframework.integration.mqtt.IMqttClient org.springframework.integration.mqtt.IMqttClient ( java.lang.String java.lang.String , java.lang.String java.lang.String ) throws org.springframework.integration.mqtt.MqttException { return org.springframework.integration.mqtt.IMqttClient ; } } ; org.springframework.integration.mqtt.DefaultMqttPahoClientFactory . setServerURIs ( STRING ) ; if ( java.lang.Boolean != null ) { org.springframework.integration.mqtt.DefaultMqttPahoClientFactory . setCleanSession ( java.lang.Boolean ) ; } if ( org.springframework.integration.mqtt.ConsumerStopAction != null ) { org.springframework.integration.mqtt.DefaultMqttPahoClientFactory . setConsumerStopAction ( org.springframework.integration.mqtt.ConsumerStopAction ) ; } given ( org.springframework.integration.mqtt.IMqttClient . isConnected ( ) ) . willReturn ( true ) ; MqttPahoMessageDrivenChannelAdapter org.springframework.integration.mqtt.MqttPahoMessageDrivenChannelAdapter = new MqttPahoMessageDrivenChannelAdapter ( STRING , org.springframework.integration.mqtt.DefaultMqttPahoClientFactory , STRING ) ; org.springframework.integration.mqtt.MqttPahoMessageDrivenChannelAdapter . setApplicationEventPublisher ( mock ( ApplicationEventPublisher .class ) ) ; org.springframework.integration.mqtt.MqttPahoMessageDrivenChannelAdapter . setOutputChannel ( new NullChannel ( ) ) ; org.springframework.integration.mqtt.MqttPahoMessageDrivenChannelAdapter . setTaskScheduler ( mock ( TaskScheduler .class ) ) ; org.springframework.integration.mqtt.MqttPahoMessageDrivenChannelAdapter . afterPropertiesSet ( ) ; return org.springframework.integration.mqtt.MqttPahoMessageDrivenChannelAdapter ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.integration.mqtt.IMqttClient org.springframework.integration.mqtt.IMqttClient ( java.lang.String java.lang.String , java.lang.String java.lang.String ) throws org.springframework.integration.mqtt.MqttException { return org.springframework.integration.mqtt.IMqttClient ; }  <METHOD_END>
<METHOD_START> private void void ( IMqttClient org.springframework.integration.mqtt.IMqttClient ) throws java.lang.Exception { verify ( org.springframework.integration.mqtt.IMqttClient ) . connect ( any ( MqttConnectOptions .class ) ) ; verify ( org.springframework.integration.mqtt.IMqttClient ) . subscribe ( any ( java.lang.String [] .class ) , any ( int [] .class ) ) ; verify ( org.springframework.integration.mqtt.IMqttClient ) . unsubscribe ( any ( java.lang.String [] .class ) ) ; verify ( org.springframework.integration.mqtt.IMqttClient ) . disconnectForcibly ( anyLong ( ) ) ; }  <METHOD_END>
<METHOD_START> private void void ( IMqttClient org.springframework.integration.mqtt.IMqttClient ) throws java.lang.Exception { verify ( org.springframework.integration.mqtt.IMqttClient ) . connect ( any ( MqttConnectOptions .class ) ) ; verify ( org.springframework.integration.mqtt.IMqttClient ) . subscribe ( any ( java.lang.String [] .class ) , any ( int [] .class ) ) ; verify ( org.springframework.integration.mqtt.IMqttClient , never ( ) ) . unsubscribe ( any ( java.lang.String [] .class ) ) ; verify ( org.springframework.integration.mqtt.IMqttClient ) . disconnectForcibly ( anyLong ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.integration.mqtt.MqttPahoMessageHandler org.springframework.integration.mqtt.MqttPahoMessageHandler ( ) { MqttPahoMessageHandler org.springframework.integration.mqtt.MqttPahoMessageHandler = new MqttPahoMessageHandler ( STRING , STRING ) ; org.springframework.integration.mqtt.MqttPahoMessageHandler . setTopicExpressionString ( STRING ) ; org.springframework.integration.mqtt.MqttPahoMessageHandler . setQosExpressionString ( STRING ) ; org.springframework.integration.mqtt.MqttPahoMessageHandler . setRetainedExpressionString ( STRING ) ; return org.springframework.integration.mqtt.MqttPahoMessageHandler ; }  <METHOD_END>
<METHOD_START> @ Bean public java.lang.String java.lang.String ( ) { return STRING ; }  <METHOD_END>
<METHOD_START> @ Bean public java.lang.Integer java.lang.Integer ( ) { return NUMBER ; }  <METHOD_END>
<METHOD_START> @ Bean public java.lang.Boolean java.lang.Boolean ( ) { return true ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.integration.mqtt.MqttPahoMessageHandler org.springframework.integration.mqtt.MqttPahoMessageHandler ( ) { MqttPahoMessageHandler org.springframework.integration.mqtt.MqttPahoMessageHandler = new MqttPahoMessageHandler ( STRING , STRING ) ; org.springframework.integration.mqtt.MqttPahoMessageHandler . setDefaultQos ( NUMBER ) ; org.springframework.integration.mqtt.MqttPahoMessageHandler . setQosExpressionString ( STRING ) ; org.springframework.integration.mqtt.MqttPahoMessageHandler . setDefaultRetained ( true ) ; org.springframework.integration.mqtt.MqttPahoMessageHandler . setRetainedExpressionString ( STRING ) ; return org.springframework.integration.mqtt.MqttPahoMessageHandler ; }  <METHOD_END>
