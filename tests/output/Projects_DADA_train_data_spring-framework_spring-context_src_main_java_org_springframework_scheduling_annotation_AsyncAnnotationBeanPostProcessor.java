<METHOD_START> public void ( ) { setBeforeExistingAdvisors ( true ) ; }  <METHOD_END>
<METHOD_START> public void void ( java.lang.Class<? extends java.lang.annotation.Annotation> < ? extends java.lang.annotation.Annotation > java.lang.Class<? extends java.lang.annotation.Annotation> ) { Assert . notNull ( java.lang.Class<> , STRING ) ; this . java.lang.Class<? extends java.lang.annotation.Annotation> = java.lang.Class<> ; }  <METHOD_END>
<METHOD_START> public void void ( java.util.concurrent.Executor java.util.concurrent.Executor ) { this . java.util.concurrent.Executor = java.util.concurrent.Executor ; }  <METHOD_END>
<METHOD_START> public void void ( AsyncUncaughtExceptionHandler org.springframework.scheduling.annotation.AsyncUncaughtExceptionHandler ) { this . org.springframework.scheduling.annotation.AsyncUncaughtExceptionHandler = org.springframework.scheduling.annotation.AsyncUncaughtExceptionHandler ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( BeanFactory org.springframework.scheduling.annotation.BeanFactory ) { super. setBeanFactory ( org.springframework.scheduling.annotation.BeanFactory ) ; AsyncAnnotationAdvisor org.springframework.scheduling.annotation.AsyncAnnotationAdvisor = new AsyncAnnotationAdvisor ( this . java.util.concurrent.Executor , this . org.springframework.scheduling.annotation.AsyncUncaughtExceptionHandler ) ; if ( this . java.lang.Class<> != null ) { org.springframework.scheduling.annotation.AsyncAnnotationAdvisor . setAsyncAnnotationType ( this . java.lang.Class<> ) ; } org.springframework.scheduling.annotation.AsyncAnnotationAdvisor . setBeanFactory ( org.springframework.scheduling.annotation.BeanFactory ) ; this . advisor = org.springframework.scheduling.annotation.AsyncAnnotationAdvisor ; }  <METHOD_END>
