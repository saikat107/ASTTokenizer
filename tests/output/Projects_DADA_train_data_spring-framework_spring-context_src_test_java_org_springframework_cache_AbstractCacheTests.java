<METHOD_START> protected abstract T T ( )  <METHOD_END>
<METHOD_START> protected abstract java.lang.Object java.lang.Object ( )  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { assertEquals ( java.lang.String , T ( ) . getName ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { assertSame ( java.lang.Object ( ) , T ( ) . getNativeCache ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { T T = T ( ) ; java.lang.String java.lang.String = java.lang.String ( ) ; java.lang.Object java.lang.Object = STRING ; assertNull ( T . get ( java.lang.String ) ) ; assertNull ( T . get ( java.lang.String , java.lang.String .class ) ) ; assertNull ( T . get ( java.lang.String , java.lang.Object .class ) ) ; T . put ( java.lang.String , java.lang.Object ) ; assertEquals ( java.lang.Object , T . get ( java.lang.String ) . get ( ) ) ; assertEquals ( java.lang.Object , T . get ( java.lang.String , java.lang.String .class ) ) ; assertEquals ( java.lang.Object , T . get ( java.lang.String , java.lang.Object .class ) ) ; assertEquals ( java.lang.Object , T . get ( java.lang.String , ( java.lang.Class<?> < ? > ) null ) ) ; T . put ( java.lang.String , null ) ; assertNotNull ( T . get ( java.lang.String ) ) ; assertNull ( T . get ( java.lang.String ) . get ( ) ) ; assertNull ( T . get ( java.lang.String , java.lang.String .class ) ) ; assertNull ( T . get ( java.lang.String , java.lang.Object .class ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { T T = T ( ) ; java.lang.String java.lang.String = java.lang.String ( ) ; java.lang.Object java.lang.Object = STRING ; assertNull ( T . get ( java.lang.String ) ) ; assertNull ( T . putIfAbsent ( java.lang.String , java.lang.Object ) ) ; assertEquals ( java.lang.Object , T . get ( java.lang.String ) . get ( ) ) ; assertEquals ( STRING , T . putIfAbsent ( java.lang.String , STRING ) . get ( ) ) ; assertEquals ( java.lang.Object , T . get ( java.lang.String ) . get ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { T T = T ( ) ; java.lang.String java.lang.String = java.lang.String ( ) ; java.lang.Object java.lang.Object = STRING ; assertNull ( T . get ( java.lang.String ) ) ; T . put ( java.lang.String , java.lang.Object ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { T T = T ( ) ; assertNull ( T . get ( STRING ) ) ; T . put ( STRING , STRING ) ; assertNull ( T . get ( STRING ) ) ; T . put ( STRING , STRING ) ; T . clear ( ) ; assertNull ( T . get ( STRING ) ) ; assertNull ( T . get ( STRING ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { void ( STRING ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { void ( null ) ; }  <METHOD_END>
<METHOD_START> private void void ( java.lang.Object java.lang.Object ) { T T = T ( ) ; java.lang.String java.lang.String = java.lang.String ( ) ; assertNull ( T . get ( java.lang.String ) ) ; java.lang.Object java.lang.Object = T . get ( java.lang.String , ( ) returnValue ) ; assertEquals ( java.lang.Object , java.lang.Object ) ; assertEquals ( java.lang.Object , T . get ( java.lang.String ) . get ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { void ( STRING ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { void ( null ) ; }  <METHOD_END>
<METHOD_START> private void void ( java.lang.Object java.lang.Object ) { T T = T ( ) ; java.lang.String java.lang.String = java.lang.String ( ) ; T . put ( java.lang.String , java.lang.Object ) ; java.lang.Object java.lang.Object = T . get ( java.lang.String , ( ) { throw new IllegalStateException ( STRING ) ; } ) ; assertEquals ( java.lang.Object , java.lang.Object ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { T T = T ( ) ; java.lang.String java.lang.String = java.lang.String ( ) ; assertNull ( T . get ( java.lang.String ) ) ; try { T . get ( java.lang.String , ( ) { throw new UnsupportedOperationException ( STRING ) ; } ) ; } catch ( Cache . Cache Cache.ValueRetrievalException ) { assertNotNull ( Cache.ValueRetrievalException . getCause ( ) ) ; assertEquals ( java.lang.UnsupportedOperationException .class , Cache.ValueRetrievalException . getCause ( ) . getClass ( ) ) ; } }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.InterruptedException { T T = T ( ) ; final java.util.concurrent.atomic.AtomicInteger java.util.concurrent.atomic.AtomicInteger = new java.util.concurrent.atomic.AtomicInteger ( ) ; final java.util.List<java.lang.Object> < java.lang.Object > java.util.List<java.lang.Object> = new java.util.concurrent.CopyOnWriteArrayList<java.lang.Object> <> ( ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; java.lang.String java.lang.String = java.lang.String ( ) ; java.lang.Runnable java.lang.Runnable = ( ) { try { java.lang.Integer java.lang.Integer = T . get ( java.lang.String , ( ) { Thread . sleep ( NUMBER ) ; return counter . incrementAndGet ( ) ; } ) ; java.util.List<java.lang.Object> . boolean ( java.lang.Integer ) ; } finally { java.util.concurrent.CountDownLatch . void ( ) ; } } ; for ( int int = NUMBER ; int < NUMBER ; int ++ ) { new java.lang.Thread ( java.lang.Runnable ) . void ( ) ; } java.util.concurrent.CountDownLatch . void ( ) ; assertEquals ( NUMBER , java.util.List<java.lang.Object> . int ( ) ) ; java.util.List<java.lang.Object> . void ( java.lang.Object -> assertThat ( java.lang.Object , is ( NUMBER ) ) ) ; }  <METHOD_END>
<METHOD_START> protected java.lang.String java.lang.String ( ) { return java.util.UUID . java.util.UUID ( ) . java.lang.String ( ) ; }  <METHOD_END>
