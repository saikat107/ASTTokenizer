<METHOD_START> public void ( int int , int int ) { this( int , int , new DefaultLockRegistry ( ) ); }  <METHOD_END>
<METHOD_START> public void ( int int , int int , long long ) { this( int , int , long , new DefaultLockRegistry ( ) ); }  <METHOD_END>
<METHOD_START> public void ( int int , int int , LockRegistry org.springframework.integration.store.LockRegistry ) { this( int , int , NUMBER , org.springframework.integration.store.LockRegistry ); }  <METHOD_END>
<METHOD_START> public void ( int int , int int , long long , LockRegistry org.springframework.integration.store.LockRegistry ) { super( false ); Assert . notNull ( org.springframework.integration.store.LockRegistry , STRING ) ; this . org.springframework.integration.store.UpperBound = new UpperBound ( int ) ; this . int = int ; this . int = int ; this . org.springframework.integration.store.LockRegistry = org.springframework.integration.store.LockRegistry ; this . long = long ; }  <METHOD_END>
<METHOD_START> public void ( int int ) { this( int , int ); }  <METHOD_END>
<METHOD_START> public void ( ) { this( NUMBER ); }  <METHOD_END>
<METHOD_START> public void void ( boolean boolean ) { this . boolean = boolean ; }  <METHOD_END>
<METHOD_START> public void void ( LockRegistry org.springframework.integration.store.LockRegistry ) { Assert . notNull ( org.springframework.integration.store.LockRegistry , STRING ) ; Assert . isTrue ( ! ( this . boolean ) , STRING ) ; this . org.springframework.integration.store.LockRegistry = org.springframework.integration.store.LockRegistry ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( boolean boolean ) { throw new java.lang.UnsupportedOperationException ( STRING ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override @ ManagedAttribute public long long ( ) { return this . java.util.concurrent.ConcurrentMap<java.util.UUID,org.springframework.integration.store.Message<?>> . size ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public < T > org.springframework.integration.store.Message<T> < T > org.springframework.integration.store.Message<T> ( Message < T > org.springframework.integration.store.Message<T> ) { this . boolean = true ; if ( ! this . org.springframework.integration.store.UpperBound . tryAcquire ( this . long ) ) { throw new MessagingException ( this . java.lang.Class<? extends org.springframework.integration.store.SimpleMessageStore> ( ) . java.lang.String ( ) + STRING + this . int + STRING ) ; } this . java.util.concurrent.ConcurrentMap<java.util.UUID,org.springframework.integration.store.Message<?>> . put ( org.springframework.integration.store.Message<T> . getHeaders ( ) . getId ( ) , org.springframework.integration.store.Message<T> ) ; return org.springframework.integration.store.Message<T> ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.integration.store.Message<?> < ? > org.springframework.integration.store.Message<?> ( java.util.UUID java.util.UUID ) { return ( java.util.UUID != null ) ? this . java.util.concurrent.ConcurrentMap<java.util.UUID,org.springframework.integration.store.Message<?>> . get ( java.util.UUID ) : null ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.integration.store.MessageMetadata org.springframework.integration.store.MessageMetadata ( java.util.UUID java.util.UUID ) { Message < ? > org.springframework.integration.store.Message<?> = org.springframework.integration.store.Message<?> ( java.util.UUID ) ; if ( org.springframework.integration.store.Message<> != null ) { MessageMetadata org.springframework.integration.store.MessageMetadata = new MessageMetadata ( java.util.UUID ) ; org.springframework.integration.store.MessageMetadata . setTimestamp ( org.springframework.integration.store.Message<> . getHeaders ( ) . getTimestamp ( ) ) ; return org.springframework.integration.store.MessageMetadata ; } else { return null ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.integration.store.Message<?> < ? > org.springframework.integration.store.Message<?> ( java.util.UUID java.util.UUID ) { if ( java.util.UUID != null ) { Message < ? > org.springframework.integration.store.Message<?> = this . java.util.concurrent.ConcurrentMap<java.util.UUID,org.springframework.integration.store.Message<?>> . remove ( java.util.UUID ) ; if ( org.springframework.integration.store.Message<> != null ) { this . org.springframework.integration.store.UpperBound . release ( ) ; } return org.springframework.integration.store.Message<> ; } else { return null ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.integration.store.MessageGroup org.springframework.integration.store.MessageGroup ( java.lang.Object java.lang.Object ) { Assert . notNull ( java.lang.Object , STRING ) ; MessageGroup org.springframework.integration.store.MessageGroup = this . java.util.concurrent.ConcurrentMap<java.lang.Object,org.springframework.integration.store.MessageGroup> . get ( java.lang.Object ) ; if ( org.springframework.integration.store.MessageGroup == null ) { return getMessageGroupFactory ( ) . create ( java.lang.Object ) ; } if ( this . boolean ) { return org.springframework.integration.store.MessageGroup ( org.springframework.integration.store.MessageGroup ) ; } else { return org.springframework.integration.store.MessageGroup ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected org.springframework.integration.store.MessageGroup org.springframework.integration.store.MessageGroup ( MessageGroup org.springframework.integration.store.MessageGroup ) { java.lang.Object java.lang.Object = org.springframework.integration.store.MessageGroup . getGroupId ( ) ; java.util.concurrent.locks.Lock java.util.concurrent.locks.Lock = this . org.springframework.integration.store.LockRegistry . obtain ( java.lang.Object ) ; try { java.util.concurrent.locks.Lock . void ( ) ; try { MessageGroup org.springframework.integration.store.MessageGroup = getMessageGroupFactory ( ) . create ( org.springframework.integration.store.MessageGroup . getMessages ( ) , java.lang.Object , org.springframework.integration.store.MessageGroup . getTimestamp ( ) , org.springframework.integration.store.MessageGroup . isComplete ( ) ) ; org.springframework.integration.store.MessageGroup . setLastModified ( org.springframework.integration.store.MessageGroup . getLastModified ( ) ) ; org.springframework.integration.store.MessageGroup . setLastReleasedMessageSequenceNumber ( org.springframework.integration.store.MessageGroup . getLastReleasedMessageSequenceNumber ( ) ) ; return org.springframework.integration.store.MessageGroup ; } finally { java.util.concurrent.locks.Lock . void ( ) ; } } catch ( java.lang.InterruptedException java.lang.InterruptedException ) { java.lang.Thread . java.lang.Thread ( ) . void ( ) ; throw new MessagingException ( STRING , java.lang.InterruptedException ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( java.lang.Object java.lang.Object , org.springframework.integration.store.Message<?> < ? > ... org.springframework.integration.store.Message<?>[] ) { Assert . notNull ( java.lang.Object , STRING ) ; Assert . notNull ( org.springframework.integration.store.Message<?>[] , STRING ) ; java.util.concurrent.locks.Lock java.util.concurrent.locks.Lock = this . org.springframework.integration.store.LockRegistry . obtain ( java.lang.Object ) ; try { java.util.concurrent.locks.Lock . void ( ) ; boolean boolean = false ; try { UpperBound org.springframework.integration.store.UpperBound ; MessageGroup org.springframework.integration.store.MessageGroup = this . java.util.concurrent.ConcurrentMap<java.lang.Object,org.springframework.integration.store.MessageGroup> . get ( java.lang.Object ) ; MessagingException org.springframework.integration.store.MessagingException = new MessagingException ( java.lang.Class<? extends org.springframework.integration.store.SimpleMessageStore> ( ) . java.lang.String ( ) + STRING + this . int + STRING + java.lang.Object + STRING ) ; if ( org.springframework.integration.store.MessageGroup == null ) { if ( this . int > NUMBER && messages . length > this . int ) { throw org.springframework.integration.store.MessagingException ; } org.springframework.integration.store.MessageGroup = getMessageGroupFactory ( ) . create ( java.lang.Object ) ; this . java.util.concurrent.ConcurrentMap<java.lang.Object,org.springframework.integration.store.MessageGroup> . put ( java.lang.Object , org.springframework.integration.store.MessageGroup ) ; org.springframework.integration.store.UpperBound = new UpperBound ( this . int ) ; for ( Message < ? > org.springframework.integration.store.Message<?> : org.springframework.integration.store.Message<?>[] ) { org.springframework.integration.store.UpperBound . tryAcquire ( - NUMBER ) ; org.springframework.integration.store.MessageGroup . add ( org.springframework.integration.store.Message<> ) ; } this . java.util.concurrent.ConcurrentMap<java.lang.Object,org.springframework.integration.store.UpperBound> . put ( java.lang.Object , org.springframework.integration.store.UpperBound ) ; } else { org.springframework.integration.store.UpperBound = this . java.util.concurrent.ConcurrentMap<java.lang.Object,org.springframework.integration.store.UpperBound> . get ( java.lang.Object ) ; Assert . state ( org.springframework.integration.store.UpperBound != null , STRING ) ; for ( Message < ? > org.springframework.integration.store.Message<?> : org.springframework.integration.store.Message<?>[] ) { java.util.concurrent.locks.Lock . void ( ) ; if ( ! org.springframework.integration.store.UpperBound . tryAcquire ( this . long ) ) { boolean = true ; throw org.springframework.integration.store.MessagingException ; } java.util.concurrent.locks.Lock . void ( ) ; org.springframework.integration.store.MessageGroup . add ( org.springframework.integration.store.Message<> ) ; } } org.springframework.integration.store.MessageGroup . setLastModified ( java.lang.System . long ( ) ) ; } finally { if ( ! boolean ) { java.util.concurrent.locks.Lock . void ( ) ; } } } catch ( java.lang.InterruptedException java.lang.InterruptedException ) { java.lang.Thread . java.lang.Thread ( ) . void ( ) ; throw new MessagingException ( STRING , java.lang.InterruptedException ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( java.lang.Object java.lang.Object ) { java.util.concurrent.locks.Lock java.util.concurrent.locks.Lock = this . org.springframework.integration.store.LockRegistry . obtain ( java.lang.Object ) ; try { java.util.concurrent.locks.Lock . void ( ) ; try { MessageGroup org.springframework.integration.store.MessageGroup = this . java.util.concurrent.ConcurrentMap<java.lang.Object,org.springframework.integration.store.MessageGroup> . remove ( java.lang.Object ) ; if ( org.springframework.integration.store.MessageGroup != null ) { UpperBound org.springframework.integration.store.UpperBound = this . java.util.concurrent.ConcurrentMap<java.lang.Object,org.springframework.integration.store.UpperBound> . remove ( java.lang.Object ) ; Assert . state ( org.springframework.integration.store.UpperBound != null , STRING ) ; org.springframework.integration.store.UpperBound . release ( this . int ) ; } } finally { java.util.concurrent.locks.Lock . void ( ) ; } } catch ( java.lang.InterruptedException java.lang.InterruptedException ) { java.lang.Thread . java.lang.Thread ( ) . void ( ) ; throw new MessagingException ( STRING , java.lang.InterruptedException ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( java.lang.Object java.lang.Object , java.util.Collection<org.springframework.integration.store.Message<?>> < Message < ? > > java.util.Collection<org.springframework.integration.store.Message<?>> ) { java.util.concurrent.locks.Lock java.util.concurrent.locks.Lock = this . org.springframework.integration.store.LockRegistry . obtain ( java.lang.Object ) ; try { java.util.concurrent.locks.Lock . void ( ) ; try { MessageGroup org.springframework.integration.store.MessageGroup = this . java.util.concurrent.ConcurrentMap<java.lang.Object,org.springframework.integration.store.MessageGroup> . get ( java.lang.Object ) ; Assert . notNull ( org.springframework.integration.store.MessageGroup , STRING + java.lang.Object + STRING + STRING ) ; UpperBound org.springframework.integration.store.UpperBound = this . java.util.concurrent.ConcurrentMap<java.lang.Object,org.springframework.integration.store.UpperBound> . get ( java.lang.Object ) ; Assert . state ( org.springframework.integration.store.UpperBound != null , STRING ) ; boolean boolean = false ; for ( Message < ? > org.springframework.integration.store.Message<?> : java.util.Collection<org.springframework.integration.store.Message<?>> ) { if ( org.springframework.integration.store.MessageGroup . remove ( org.springframework.integration.store.Message<> ) ) { org.springframework.integration.store.UpperBound . release ( ) ; boolean = true ; } } if ( boolean ) { org.springframework.integration.store.MessageGroup . setLastModified ( java.lang.System . long ( ) ) ; } } finally { java.util.concurrent.locks.Lock . void ( ) ; } } catch ( java.lang.InterruptedException java.lang.InterruptedException ) { java.lang.Thread . java.lang.Thread ( ) . void ( ) ; throw new MessagingException ( STRING , java.lang.InterruptedException ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.util.Iterator<org.springframework.integration.store.MessageGroup> < MessageGroup > java.util.Iterator<org.springframework.integration.store.MessageGroup> ( ) { return new java.util.HashSet<org.springframework.integration.store.MessageGroup> < MessageGroup > ( this . java.util.concurrent.ConcurrentMap<java.lang.Object,org.springframework.integration.store.MessageGroup> . values ( ) ) . java.util.Iterator<org.springframework.integration.store.MessageGroup> ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( java.lang.Object java.lang.Object , int int ) { java.util.concurrent.locks.Lock java.util.concurrent.locks.Lock = this . org.springframework.integration.store.LockRegistry . obtain ( java.lang.Object ) ; try { java.util.concurrent.locks.Lock . void ( ) ; try { MessageGroup org.springframework.integration.store.MessageGroup = this . java.util.concurrent.ConcurrentMap<java.lang.Object,org.springframework.integration.store.MessageGroup> . get ( java.lang.Object ) ; Assert . notNull ( org.springframework.integration.store.MessageGroup , STRING + java.lang.Object + STRING + STRING ) ; org.springframework.integration.store.MessageGroup . setLastReleasedMessageSequenceNumber ( int ) ; org.springframework.integration.store.MessageGroup . setLastModified ( java.lang.System . long ( ) ) ; } finally { java.util.concurrent.locks.Lock . void ( ) ; } } catch ( java.lang.InterruptedException java.lang.InterruptedException ) { java.lang.Thread . java.lang.Thread ( ) . void ( ) ; throw new MessagingException ( STRING , java.lang.InterruptedException ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( java.lang.Object java.lang.Object ) { java.util.concurrent.locks.Lock java.util.concurrent.locks.Lock = this . org.springframework.integration.store.LockRegistry . obtain ( java.lang.Object ) ; try { java.util.concurrent.locks.Lock . void ( ) ; try { MessageGroup org.springframework.integration.store.MessageGroup = this . java.util.concurrent.ConcurrentMap<java.lang.Object,org.springframework.integration.store.MessageGroup> . get ( java.lang.Object ) ; Assert . notNull ( org.springframework.integration.store.MessageGroup , STRING + java.lang.Object + STRING + STRING ) ; org.springframework.integration.store.MessageGroup . complete ( ) ; org.springframework.integration.store.MessageGroup . setLastModified ( java.lang.System . long ( ) ) ; } finally { java.util.concurrent.locks.Lock . void ( ) ; } } catch ( java.lang.InterruptedException java.lang.InterruptedException ) { java.lang.Thread . java.lang.Thread ( ) . void ( ) ; throw new MessagingException ( STRING , java.lang.InterruptedException ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.integration.store.Message<?> < ? > org.springframework.integration.store.Message<?> ( java.lang.Object java.lang.Object ) { java.util.Collection<org.springframework.integration.store.Message<?>> < Message < ? > > java.util.Collection<org.springframework.integration.store.Message<?>> = org.springframework.integration.store.MessageGroup ( java.lang.Object ) . getMessages ( ) ; Message < ? > org.springframework.integration.store.Message<?> = null ; if ( ! CollectionUtils . isEmpty ( java.util.Collection<org.springframework.integration.store.Message<?>> ) ) { org.springframework.integration.store.Message<?> = java.util.Collection<org.springframework.integration.store.Message<?>> . iterator ( ) . next ( ) ; if ( org.springframework.integration.store.Message<> != null ) { this . void ( java.lang.Object , org.springframework.integration.store.Message<> ) ; } } return org.springframework.integration.store.Message<> ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public int int ( java.lang.Object java.lang.Object ) { return org.springframework.integration.store.MessageGroup ( java.lang.Object ) . size ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.integration.store.MessageGroupMetadata org.springframework.integration.store.MessageGroupMetadata ( java.lang.Object java.lang.Object ) { return new MessageGroupMetadata ( org.springframework.integration.store.MessageGroup ( java.lang.Object ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.integration.store.Message<?> < ? > org.springframework.integration.store.Message<?> ( java.lang.Object java.lang.Object ) { return org.springframework.integration.store.MessageGroup ( java.lang.Object ) . getOne ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.util.Collection<org.springframework.integration.store.Message<?>> < Message < ? > > java.util.Collection<org.springframework.integration.store.Message<?>> ( java.lang.Object java.lang.Object ) { return org.springframework.integration.store.MessageGroup ( java.lang.Object ) . getMessages ( ) ; }  <METHOD_END>
<METHOD_START> public void void ( java.lang.Object java.lang.Object ) { java.util.concurrent.locks.Lock java.util.concurrent.locks.Lock = this . org.springframework.integration.store.LockRegistry . obtain ( java.lang.Object ) ; try { java.util.concurrent.locks.Lock . void ( ) ; try { MessageGroup org.springframework.integration.store.MessageGroup = this . java.util.concurrent.ConcurrentMap<java.lang.Object,org.springframework.integration.store.MessageGroup> . get ( java.lang.Object ) ; Assert . notNull ( org.springframework.integration.store.MessageGroup , STRING + java.lang.Object + STRING + STRING ) ; org.springframework.integration.store.MessageGroup . clear ( ) ; org.springframework.integration.store.MessageGroup . setLastModified ( java.lang.System . long ( ) ) ; UpperBound org.springframework.integration.store.UpperBound = this . java.util.concurrent.ConcurrentMap<java.lang.Object,org.springframework.integration.store.UpperBound> . get ( java.lang.Object ) ; Assert . state ( org.springframework.integration.store.UpperBound != null , STRING ) ; org.springframework.integration.store.UpperBound . release ( this . int ) ; } finally { java.util.concurrent.locks.Lock . void ( ) ; } } catch ( java.lang.InterruptedException java.lang.InterruptedException ) { java.lang.Thread . java.lang.Thread ( ) . void ( ) ; throw new MessagingException ( STRING , java.lang.InterruptedException ) ; } }  <METHOD_END>
