<METHOD_START> public void ( java.lang.reflect.Method java.lang.reflect.Method ) { this . java.lang.reflect.Method = java.lang.reflect.Method ; if ( java.lang.reflect.Method . boolean ( ) ) { java.lang.Class<?> < ? > [] java.lang.Class<?>[] = java.lang.reflect.Method . java.lang.Class<?>[] ( ) ; this . java.lang.Integer = java.lang.Class<?>[] . int - NUMBER ; } else { this . java.lang.Integer = null ; } }  <METHOD_END>
<METHOD_START> public java.lang.reflect.Method java.lang.reflect.Method ( ) { return this . java.lang.reflect.Method ; }  <METHOD_END>
<METHOD_START> public java.lang.Class<?> < ? > java.lang.Class<?> ( ) { if ( ! boolean ) { this . java.lang.Class<?> = java.lang.Class<?> ( java.lang.reflect.Method , java.lang.reflect.Method . java.lang.Class<?> ( ) ) ; this . boolean = true ; } return this . java.lang.Class<> ; }  <METHOD_END>
<METHOD_START> private java.lang.Class<?> < ? > java.lang.Class<?> ( java.lang.reflect.Method java.lang.reflect.Method , java.lang.Class<?> < ? > java.lang.Class<?> ) { if ( java.lang.reflect.Modifier . boolean ( java.lang.Class<> . int ( ) ) ) { try { java.lang.Class<> . java.lang.reflect.Method ( java.lang.reflect.Method . java.lang.String ( ) , java.lang.reflect.Method . java.lang.Class<?>[] ( ) ) ; return java.lang.Class<> ; } catch ( java.lang.NoSuchMethodException java.lang.NoSuchMethodException ) { } } java.lang.Class<?> < ? > [] java.lang.Class<?>[] = java.lang.Class<> . java.lang.Class<?>[] ( ) ; for ( java.lang.Class<?> < ? > java.lang.Class<?> : java.lang.Class<?>[] ) { java.lang.Class<?> ( java.lang.reflect.Method , java.lang.Class<> ) ; } if ( java.lang.Class<> . java.lang.Class<? super > ( ) != null ) { return java.lang.Class<?> ( java.lang.reflect.Method , java.lang.Class<> . java.lang.Class<? super > ( ) ) ; } return null ; }  <METHOD_END>
<METHOD_START> public boolean boolean ( ) { return this . boolean ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.expression.spel.support.TypedValue org.springframework.expression.spel.support.TypedValue ( EvaluationContext org.springframework.expression.spel.support.EvaluationContext , java.lang.Object java.lang.Object , java.lang.Object ... java.lang.Object[] ) throws org.springframework.expression.spel.support.AccessException { try { if ( java.lang.Object[] != null ) { this . boolean = ReflectionHelper . convertArguments ( org.springframework.expression.spel.support.EvaluationContext . getTypeConverter ( ) , java.lang.Object[] , this . java.lang.reflect.Method , this . java.lang.Integer ) ; } if ( this . java.lang.reflect.Method . boolean ( ) ) { java.lang.Object[] = ReflectionHelper . setupArgumentsForVarargsInvocation ( this . java.lang.reflect.Method . java.lang.Class<?>[] ( ) , java.lang.Object[] ) ; } ReflectionUtils . makeAccessible ( this . java.lang.reflect.Method ) ; java.lang.Object java.lang.Object = this . java.lang.reflect.Method . java.lang.Object ( java.lang.Object , java.lang.Object[] ) ; return new TypedValue ( java.lang.Object , new TypeDescriptor ( new MethodParameter ( this . java.lang.reflect.Method , - NUMBER ) ) . narrow ( java.lang.Object ) ) ; } catch ( java.lang.Exception java.lang.Exception ) { throw new AccessException ( STRING + this . java.lang.reflect.Method , java.lang.Exception ) ; } }  <METHOD_END>
