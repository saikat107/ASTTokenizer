<METHOD_START> public void ( Cache org.springframework.cache.jcache.interceptor.Cache ) { this . org.springframework.cache.jcache.interceptor.Cache = org.springframework.cache.jcache.interceptor.Cache ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override @ CacheResult public java.lang.Long java.lang.Long ( java.lang.String java.lang.String ) { return java.util.concurrent.atomic.AtomicLong . long ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override @ CacheResult public java.lang.Long java.lang.Long ( java.lang.String java.lang.String ) { return null ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override @ CacheResult ( exceptionCacheName = STRING , nonCachedExceptions = java.lang.NullPointerException .class ) public java.lang.Long java.lang.Long ( @ CacheKey java.lang.String java.lang.String , boolean boolean ) { void ( boolean ) ; return NUMBER ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override @ CacheResult ( exceptionCacheName = STRING , nonCachedExceptions = java.lang.NullPointerException .class ) public java.lang.Long java.lang.Long ( @ CacheKey java.lang.String java.lang.String , boolean boolean ) throws java.io.IOException { void ( boolean ) ; return NUMBER ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override @ CacheResult ( skipGet = true ) public java.lang.Long java.lang.Long ( java.lang.String java.lang.String ) { return java.util.concurrent.atomic.AtomicLong . long ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override @ CacheResult public java.lang.Long java.lang.Long ( @ CacheKey java.lang.String java.lang.String , boolean boolean ) { return java.util.concurrent.atomic.AtomicLong . long ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override @ CacheResult ( cacheResolverFactory = TestableCacheResolverFactory .class ) public java.lang.Long java.lang.Long ( java.lang.String java.lang.String ) { return java.util.concurrent.atomic.AtomicLong . long ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override @ CacheResult ( cacheKeyGenerator = TestableCacheKeyGenerator .class ) public java.lang.Long java.lang.Long ( java.lang.String java.lang.String , java.lang.String java.lang.String ) { return java.util.concurrent.atomic.AtomicLong . long ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override @ CachePut public void void ( java.lang.String java.lang.String , @ CacheValue java.lang.Object java.lang.Object ) {	}  <METHOD_END>
<METHOD_START> @ java.lang.Override @ CachePut ( cacheFor = java.lang.UnsupportedOperationException .class ) public void void ( @ CacheKey java.lang.String java.lang.String , @ CacheValue java.lang.Object java.lang.Object , boolean boolean ) { void ( boolean ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override @ CachePut ( afterInvocation = false ) public void void ( java.lang.String java.lang.String , @ CacheValue java.lang.Object java.lang.Object ) { java.lang.Object java.lang.Object = SimpleKeyGenerator . generateKey ( java.lang.String ) ; Cache . Cache Cache.ValueWrapper = org.springframework.cache.jcache.interceptor.Cache . get ( java.lang.Object ) ; if ( Cache.ValueWrapper == null ) { throw new java.lang.AssertionError ( STRING + java.lang.Object ) ; } java.lang.Object java.lang.Object = Cache.ValueWrapper . get ( ) ; if ( java.lang.Object != java.lang.Object ) { throw new java.lang.AssertionError ( STRING + java.lang.Object + STRING + STRING + java.lang.Object + STRING + java.lang.Object ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override @ CachePut ( afterInvocation = false ) public void void ( @ CacheKey java.lang.String java.lang.String , @ CacheValue java.lang.Object java.lang.Object , boolean boolean ) { void ( boolean ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override @ CacheRemove public void void ( java.lang.String java.lang.String ) {	}  <METHOD_END>
<METHOD_START> @ java.lang.Override @ CacheRemove ( noEvictFor = java.lang.NullPointerException .class ) public void void ( @ CacheKey java.lang.String java.lang.String , boolean boolean ) { void ( boolean ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override @ CacheRemove ( afterInvocation = false ) public void void ( java.lang.String java.lang.String ) { java.lang.Object java.lang.Object = SimpleKeyGenerator . generateKey ( java.lang.String ) ; Cache . Cache Cache.ValueWrapper = org.springframework.cache.jcache.interceptor.Cache . get ( java.lang.Object ) ; if ( Cache.ValueWrapper != null ) { throw new java.lang.AssertionError ( STRING + java.lang.Object + STRING ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override @ CacheRemove ( afterInvocation = false , evictFor = java.lang.UnsupportedOperationException .class ) public void void ( @ CacheKey java.lang.String java.lang.String , boolean boolean ) { void ( boolean ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override @ CacheRemoveAll public void void ( ) {	}  <METHOD_END>
<METHOD_START> @ java.lang.Override @ CacheRemoveAll ( noEvictFor = java.lang.NullPointerException .class ) public void void ( boolean boolean ) { void ( boolean ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override @ CacheRemoveAll ( afterInvocation = false ) public void void ( ) { java.util.concurrent.ConcurrentHashMap<?,?> < ? , ? > java.util.concurrent.ConcurrentHashMap<?,?> = ( java.util.concurrent.ConcurrentHashMap<?,?> < ? , ? > ) org.springframework.cache.jcache.interceptor.Cache . getNativeCache ( ) ; if ( ! java.util.concurrent.ConcurrentHashMap<,> . boolean ( ) ) { throw new java.lang.AssertionError ( STRING ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override @ CacheRemoveAll ( afterInvocation = false , evictFor = java.lang.UnsupportedOperationException .class ) public void void ( boolean boolean ) { void ( boolean ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Deprecated public void void ( ) {	}  <METHOD_END>
<METHOD_START> @ java.lang.Override public long long ( ) { return java.util.concurrent.atomic.AtomicLong . long ( ) ; }  <METHOD_END>
<METHOD_START> private void void ( boolean boolean ) { long long = java.util.concurrent.atomic.AtomicLong . long ( ) ; if ( boolean ) { throw new java.lang.UnsupportedOperationException ( STRING + long + STRING ) ; } else { throw new java.lang.NullPointerException ( STRING + long + STRING ) ; } }  <METHOD_END>
<METHOD_START> private void void ( boolean boolean ) throws java.io.IOException { long long = java.util.concurrent.atomic.AtomicLong . long ( ) ; if ( boolean ) { throw new java.io.IOException ( STRING + long + STRING ) ; } else { throw new java.lang.NullPointerException ( STRING + long + STRING ) ; } }  <METHOD_END>
