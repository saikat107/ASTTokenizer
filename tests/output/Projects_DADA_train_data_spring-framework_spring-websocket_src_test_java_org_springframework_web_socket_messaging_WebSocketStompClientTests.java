<METHOD_START> @ Before public void void ( ) java.lang.Exception { MockitoAnnotations . initMocks ( this ) ; WebSocketClient org.springframework.web.socket.messaging.WebSocketClient = mock ( WebSocketClient .class ) ; this . org.springframework.web.socket.messaging.WebSocketStompClientTests.TestWebSocketStompClient = new org.springframework.web.socket.messaging.WebSocketStompClientTests.TestWebSocketStompClient ( org.springframework.web.socket.messaging.WebSocketClient ) ; this . org.springframework.web.socket.messaging.WebSocketStompClientTests.TestWebSocketStompClient . setTaskScheduler ( this . org.springframework.web.socket.messaging.TaskScheduler ) ; this . org.springframework.web.socket.messaging.WebSocketStompClientTests.TestWebSocketStompClient . void ( this . org.springframework.web.socket.messaging.ConnectionHandlingStompSession ) ; this . org.springframework.web.socket.messaging.ArgumentCaptor<org.springframework.web.socket.messaging.WebSocketHandler> = ArgumentCaptor . forClass ( WebSocketHandler .class ) ; this . org.springframework.web.socket.messaging.SettableListenableFuture<org.springframework.web.socket.messaging.WebSocketSession> = new SettableListenableFuture <> ( ) ; when ( org.springframework.web.socket.messaging.WebSocketClient . doHandshake ( this . org.springframework.web.socket.messaging.ArgumentCaptor<org.springframework.web.socket.messaging.WebSocketHandler> . capture ( ) , any ( ) , any ( java.net.URI .class ) ) ) . thenReturn ( this . org.springframework.web.socket.messaging.SettableListenableFuture<org.springframework.web.socket.messaging.WebSocketSession> ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { org.springframework.web.socket.messaging.WebSocketHandler ( ) ; java.lang.IllegalStateException java.lang.IllegalStateException = new java.lang.IllegalStateException ( STRING ) ; this . org.springframework.web.socket.messaging.SettableListenableFuture<org.springframework.web.socket.messaging.WebSocketSession> . setException ( java.lang.IllegalStateException ) ; verify ( this . org.springframework.web.socket.messaging.ConnectionHandlingStompSession ) . afterConnectFailure ( same ( java.lang.IllegalStateException ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { org.springframework.web.socket.messaging.WebSocketHandler ( ) . afterConnectionEstablished ( this . org.springframework.web.socket.messaging.WebSocketSession ) ; verify ( this . org.springframework.web.socket.messaging.ConnectionHandlingStompSession ) . afterConnected ( notNull ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.lang.IllegalStateException java.lang.IllegalStateException = new java.lang.IllegalStateException ( STRING ) ; org.springframework.web.socket.messaging.WebSocketHandler ( ) . handleTransportError ( this . org.springframework.web.socket.messaging.WebSocketSession , java.lang.IllegalStateException ) ; verify ( this . org.springframework.web.socket.messaging.ConnectionHandlingStompSession ) . handleFailure ( same ( java.lang.IllegalStateException ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { org.springframework.web.socket.messaging.WebSocketHandler ( ) . afterConnectionClosed ( this . org.springframework.web.socket.messaging.WebSocketSession , CloseStatus . NORMAL ) ; verify ( this . org.springframework.web.socket.messaging.ConnectionHandlingStompSession ) . afterConnectionClosed ( ) ; }  <METHOD_END>
<METHOD_START> @ Test @ java.lang.SuppressWarnings ( { STRING , STRING } ) public void void ( ) java.lang.Exception { java.lang.String java.lang.String = STRING ; org.springframework.web.socket.messaging.WebSocketHandler ( ) . handleMessage ( this . org.springframework.web.socket.messaging.WebSocketSession , new TextMessage ( java.lang.String ) ) ; ArgumentCaptor < Message > org.springframework.web.socket.messaging.ArgumentCaptor<org.springframework.web.socket.messaging.Message> = ArgumentCaptor . forClass ( Message .class ) ; verify ( this . org.springframework.web.socket.messaging.ConnectionHandlingStompSession ) . handleMessage ( org.springframework.web.socket.messaging.ArgumentCaptor<org.springframework.web.socket.messaging.Message> . capture ( ) ) ; Message < byte [] > org.springframework.web.socket.messaging.Message<byte[]> = org.springframework.web.socket.messaging.ArgumentCaptor<org.springframework.web.socket.messaging.Message> . getValue ( ) ; assertNotNull ( org.springframework.web.socket.messaging.Message<byte[]> ) ; StompHeaderAccessor org.springframework.web.socket.messaging.StompHeaderAccessor = MessageHeaderAccessor . getAccessor ( org.springframework.web.socket.messaging.Message<byte[]> , StompHeaderAccessor .class ) ; StompHeaders org.springframework.web.socket.messaging.StompHeaders = StompHeaders . readOnlyStompHeaders ( org.springframework.web.socket.messaging.StompHeaderAccessor . toNativeHeaderMap ( ) ) ; assertEquals ( StompCommand . SEND , org.springframework.web.socket.messaging.StompHeaderAccessor . getCommand ( ) ) ; assertEquals ( STRING , org.springframework.web.socket.messaging.StompHeaders . getFirst ( STRING ) ) ; assertEquals ( STRING , new java.lang.String ( org.springframework.web.socket.messaging.Message<byte[]> . getPayload ( ) , java.nio.charset.StandardCharsets . java.nio.charset.Charset ) ) ; }  <METHOD_END>
<METHOD_START> @ Test @ java.lang.SuppressWarnings ( { STRING , STRING } ) public void void ( ) java.lang.Exception { WebSocketHandler org.springframework.web.socket.messaging.WebSocketHandler = org.springframework.web.socket.messaging.WebSocketHandler ( ) ; java.lang.String java.lang.String = STRING ; org.springframework.web.socket.messaging.WebSocketHandler . handleMessage ( this . org.springframework.web.socket.messaging.WebSocketSession , new TextMessage ( java.lang.String ) ) ; verifyNoMoreInteractions ( this . org.springframework.web.socket.messaging.ConnectionHandlingStompSession ) ; java.lang.String java.lang.String = STRING ; org.springframework.web.socket.messaging.WebSocketHandler . handleMessage ( this . org.springframework.web.socket.messaging.WebSocketSession , new TextMessage ( java.lang.String ) ) ; ArgumentCaptor < Message > org.springframework.web.socket.messaging.ArgumentCaptor<org.springframework.web.socket.messaging.Message> = ArgumentCaptor . forClass ( Message .class ) ; verify ( this . org.springframework.web.socket.messaging.ConnectionHandlingStompSession ) . handleMessage ( org.springframework.web.socket.messaging.ArgumentCaptor<org.springframework.web.socket.messaging.Message> . capture ( ) ) ; Message < byte [] > org.springframework.web.socket.messaging.Message<byte[]> = org.springframework.web.socket.messaging.ArgumentCaptor<org.springframework.web.socket.messaging.Message> . getValue ( ) ; assertNotNull ( org.springframework.web.socket.messaging.Message<byte[]> ) ; StompHeaderAccessor org.springframework.web.socket.messaging.StompHeaderAccessor = MessageHeaderAccessor . getAccessor ( org.springframework.web.socket.messaging.Message<byte[]> , StompHeaderAccessor .class ) ; StompHeaders org.springframework.web.socket.messaging.StompHeaders = StompHeaders . readOnlyStompHeaders ( org.springframework.web.socket.messaging.StompHeaderAccessor . toNativeHeaderMap ( ) ) ; assertEquals ( StompCommand . SEND , org.springframework.web.socket.messaging.StompHeaderAccessor . getCommand ( ) ) ; assertEquals ( STRING , org.springframework.web.socket.messaging.StompHeaders . getFirst ( STRING ) ) ; assertEquals ( STRING , new java.lang.String ( org.springframework.web.socket.messaging.Message<byte[]> . getPayload ( ) , java.nio.charset.StandardCharsets . java.nio.charset.Charset ) ) ; }  <METHOD_END>
<METHOD_START> @ Test @ java.lang.SuppressWarnings ( { STRING , STRING } ) public void void ( ) java.lang.Exception { java.lang.String java.lang.String = STRING ; org.springframework.web.socket.messaging.WebSocketHandler ( ) . handleMessage ( this . org.springframework.web.socket.messaging.WebSocketSession , new BinaryMessage ( java.lang.String . byte[] ( java.nio.charset.StandardCharsets . java.nio.charset.Charset ) ) ) ; ArgumentCaptor < Message > org.springframework.web.socket.messaging.ArgumentCaptor<org.springframework.web.socket.messaging.Message> = ArgumentCaptor . forClass ( Message .class ) ; verify ( this . org.springframework.web.socket.messaging.ConnectionHandlingStompSession ) . handleMessage ( org.springframework.web.socket.messaging.ArgumentCaptor<org.springframework.web.socket.messaging.Message> . capture ( ) ) ; Message < byte [] > org.springframework.web.socket.messaging.Message<byte[]> = org.springframework.web.socket.messaging.ArgumentCaptor<org.springframework.web.socket.messaging.Message> . getValue ( ) ; assertNotNull ( org.springframework.web.socket.messaging.Message<byte[]> ) ; StompHeaderAccessor org.springframework.web.socket.messaging.StompHeaderAccessor = MessageHeaderAccessor . getAccessor ( org.springframework.web.socket.messaging.Message<byte[]> , StompHeaderAccessor .class ) ; StompHeaders org.springframework.web.socket.messaging.StompHeaders = StompHeaders . readOnlyStompHeaders ( org.springframework.web.socket.messaging.StompHeaderAccessor . toNativeHeaderMap ( ) ) ; assertEquals ( StompCommand . SEND , org.springframework.web.socket.messaging.StompHeaderAccessor . getCommand ( ) ) ; assertEquals ( STRING , org.springframework.web.socket.messaging.StompHeaders . getFirst ( STRING ) ) ; assertEquals ( STRING , new java.lang.String ( org.springframework.web.socket.messaging.Message<byte[]> . getPayload ( ) , java.nio.charset.StandardCharsets . java.nio.charset.Charset ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { org.springframework.web.socket.messaging.WebSocketHandler ( ) . handleMessage ( this . org.springframework.web.socket.messaging.WebSocketSession , new PongMessage ( ) ) ; verifyNoMoreInteractions ( this . org.springframework.web.socket.messaging.ConnectionHandlingStompSession ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { StompHeaderAccessor org.springframework.web.socket.messaging.StompHeaderAccessor = StompHeaderAccessor . create ( StompCommand . SEND ) ; org.springframework.web.socket.messaging.StompHeaderAccessor . setDestination ( STRING ) ; byte [] byte[] = STRING . byte[] ( java.nio.charset.StandardCharsets . java.nio.charset.Charset ) ; org.springframework.web.socket.messaging.TcpConnection<byte[]> ( ) . send ( MessageBuilder . createMessage ( byte[] , org.springframework.web.socket.messaging.StompHeaderAccessor . getMessageHeaders ( ) ) ) ; ArgumentCaptor < TextMessage > org.springframework.web.socket.messaging.ArgumentCaptor<org.springframework.web.socket.messaging.TextMessage> = ArgumentCaptor . forClass ( TextMessage .class ) ; verify ( this . org.springframework.web.socket.messaging.WebSocketSession ) . sendMessage ( org.springframework.web.socket.messaging.ArgumentCaptor<org.springframework.web.socket.messaging.TextMessage> . capture ( ) ) ; TextMessage org.springframework.web.socket.messaging.TextMessage = org.springframework.web.socket.messaging.ArgumentCaptor<org.springframework.web.socket.messaging.TextMessage> . getValue ( ) ; assertNotNull ( org.springframework.web.socket.messaging.TextMessage ) ; assertEquals ( STRING , org.springframework.web.socket.messaging.TextMessage . getPayload ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { StompHeaderAccessor org.springframework.web.socket.messaging.StompHeaderAccessor = StompHeaderAccessor . create ( StompCommand . SEND ) ; org.springframework.web.socket.messaging.StompHeaderAccessor . setDestination ( STRING ) ; org.springframework.web.socket.messaging.StompHeaderAccessor . setContentType ( MimeTypeUtils . APPLICATION_OCTET_STREAM ) ; byte [] byte[] = STRING . byte[] ( java.nio.charset.StandardCharsets . java.nio.charset.Charset ) ; org.springframework.web.socket.messaging.TcpConnection<byte[]> ( ) . send ( MessageBuilder . createMessage ( byte[] , org.springframework.web.socket.messaging.StompHeaderAccessor . getMessageHeaders ( ) ) ) ; ArgumentCaptor < BinaryMessage > org.springframework.web.socket.messaging.ArgumentCaptor<org.springframework.web.socket.messaging.BinaryMessage> = ArgumentCaptor . forClass ( BinaryMessage .class ) ; verify ( this . org.springframework.web.socket.messaging.WebSocketSession ) . sendMessage ( org.springframework.web.socket.messaging.ArgumentCaptor<org.springframework.web.socket.messaging.BinaryMessage> . capture ( ) ) ; BinaryMessage org.springframework.web.socket.messaging.BinaryMessage = org.springframework.web.socket.messaging.ArgumentCaptor<org.springframework.web.socket.messaging.BinaryMessage> . getValue ( ) ; assertNotNull ( org.springframework.web.socket.messaging.BinaryMessage ) ; assertEquals ( STRING , new java.lang.String ( org.springframework.web.socket.messaging.BinaryMessage . getPayload ( ) . array ( ) , java.nio.charset.StandardCharsets . java.nio.charset.Charset ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { WebSocketStompClient org.springframework.web.socket.messaging.WebSocketStompClient = new WebSocketStompClient ( mock ( WebSocketClient .class ) ) ; assertArrayEquals ( new long [] { NUMBER , NUMBER } , org.springframework.web.socket.messaging.WebSocketStompClient . getDefaultHeartbeat ( ) ) ; StompHeaders org.springframework.web.socket.messaging.StompHeaders = org.springframework.web.socket.messaging.WebSocketStompClient . processConnectHeaders ( null ) ; assertArrayEquals ( new long [] { NUMBER , NUMBER } , org.springframework.web.socket.messaging.StompHeaders . getHeartbeat ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { WebSocketStompClient org.springframework.web.socket.messaging.WebSocketStompClient = new WebSocketStompClient ( mock ( WebSocketClient .class ) ) ; org.springframework.web.socket.messaging.WebSocketStompClient . setTaskScheduler ( mock ( TaskScheduler .class ) ) ; assertArrayEquals ( new long [] { NUMBER , NUMBER } , org.springframework.web.socket.messaging.WebSocketStompClient . getDefaultHeartbeat ( ) ) ; StompHeaders org.springframework.web.socket.messaging.StompHeaders = org.springframework.web.socket.messaging.WebSocketStompClient . processConnectHeaders ( null ) ; assertArrayEquals ( new long [] { NUMBER , NUMBER } , org.springframework.web.socket.messaging.StompHeaders . getHeartbeat ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { WebSocketStompClient org.springframework.web.socket.messaging.WebSocketStompClient = new WebSocketStompClient ( mock ( WebSocketClient .class ) ) ; org.springframework.web.socket.messaging.WebSocketStompClient . setDefaultHeartbeat ( new long [] { NUMBER , NUMBER } ) ; try { org.springframework.web.socket.messaging.WebSocketStompClient . processConnectHeaders ( null ) ; fail ( STRING ) ; } catch ( java.lang.IllegalStateException java.lang.IllegalStateException ) { } }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { TcpConnection < byte [] > org.springframework.web.socket.messaging.TcpConnection<byte[]> = org.springframework.web.socket.messaging.TcpConnection<byte[]> ( ) ; java.lang.Runnable java.lang.Runnable = mock ( java.lang.Runnable .class ) ; long long = NUMBER ; org.springframework.web.socket.messaging.TcpConnection<byte[]> . onReadInactivity ( java.lang.Runnable , long ) ; void ( java.lang.Runnable , long , NUMBER ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { TcpConnection < byte [] > org.springframework.web.socket.messaging.TcpConnection<byte[]> = org.springframework.web.socket.messaging.TcpConnection<byte[]> ( ) ; java.lang.Runnable java.lang.Runnable = mock ( java.lang.Runnable .class ) ; long long = NUMBER ; org.springframework.web.socket.messaging.TcpConnection<byte[]> . onReadInactivity ( java.lang.Runnable , long ) ; void ( java.lang.Runnable , long , NUMBER ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { TcpConnection < byte [] > org.springframework.web.socket.messaging.TcpConnection<byte[]> = org.springframework.web.socket.messaging.TcpConnection<byte[]> ( ) ; java.lang.Runnable java.lang.Runnable = mock ( java.lang.Runnable .class ) ; long long = NUMBER ; org.springframework.web.socket.messaging.TcpConnection<byte[]> . onWriteInactivity ( java.lang.Runnable , long ) ; void ( java.lang.Runnable , long , NUMBER ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { TcpConnection < byte [] > org.springframework.web.socket.messaging.TcpConnection<byte[]> = org.springframework.web.socket.messaging.TcpConnection<byte[]> ( ) ; java.lang.Runnable java.lang.Runnable = mock ( java.lang.Runnable .class ) ; long long = NUMBER ; org.springframework.web.socket.messaging.TcpConnection<byte[]> . onWriteInactivity ( java.lang.Runnable , long ) ; void ( java.lang.Runnable , long , NUMBER ) ; }  <METHOD_END>
<METHOD_START> @ Test @ java.lang.SuppressWarnings ( { STRING , STRING } ) public void void ( ) java.lang.Exception { TcpConnection < byte [] > org.springframework.web.socket.messaging.TcpConnection<byte[]> = org.springframework.web.socket.messaging.TcpConnection<byte[]> ( ) ; java.util.concurrent.ScheduledFuture java.util.concurrent.ScheduledFuture = mock ( java.util.concurrent.ScheduledFuture .class ) ; when ( this . org.springframework.web.socket.messaging.TaskScheduler . scheduleWithFixedDelay ( any ( ) , eq ( NUMBER ) ) ) . thenReturn ( java.util.concurrent.ScheduledFuture ) ; org.springframework.web.socket.messaging.TcpConnection<byte[]> . onReadInactivity ( mock ( java.lang.Runnable .class ) , NUMBER ) ; org.springframework.web.socket.messaging.TcpConnection<byte[]> . onWriteInactivity ( mock ( java.lang.Runnable .class ) , NUMBER ) ; this . org.springframework.web.socket.messaging.ArgumentCaptor<org.springframework.web.socket.messaging.WebSocketHandler> . getValue ( ) . afterConnectionClosed ( this . org.springframework.web.socket.messaging.WebSocketSession , CloseStatus . NORMAL ) ; verify ( java.util.concurrent.ScheduledFuture , times ( NUMBER ) ) . cancel ( true ) ; verifyNoMoreInteractions ( java.util.concurrent.ScheduledFuture ) ; }  <METHOD_END>
<METHOD_START> private org.springframework.web.socket.messaging.WebSocketHandler org.springframework.web.socket.messaging.WebSocketHandler ( ) { this . org.springframework.web.socket.messaging.WebSocketStompClientTests.TestWebSocketStompClient . connect ( STRING , mock ( StompSessionHandler .class ) ) ; verify ( this . org.springframework.web.socket.messaging.ConnectionHandlingStompSession ) . getSessionFuture ( ) ; verifyNoMoreInteractions ( this . org.springframework.web.socket.messaging.ConnectionHandlingStompSession ) ; WebSocketHandler org.springframework.web.socket.messaging.WebSocketHandler = this . org.springframework.web.socket.messaging.ArgumentCaptor<org.springframework.web.socket.messaging.WebSocketHandler> . getValue ( ) ; assertNotNull ( org.springframework.web.socket.messaging.WebSocketHandler ) ; return org.springframework.web.socket.messaging.WebSocketHandler ; }  <METHOD_END>
<METHOD_START> @ java.lang.SuppressWarnings ( STRING ) private org.springframework.web.socket.messaging.TcpConnection<byte[]> < byte [] > org.springframework.web.socket.messaging.TcpConnection<byte[]> ( ) java.lang.Exception { WebSocketHandler org.springframework.web.socket.messaging.WebSocketHandler = org.springframework.web.socket.messaging.WebSocketHandler ( ) ; org.springframework.web.socket.messaging.WebSocketHandler . afterConnectionEstablished ( this . org.springframework.web.socket.messaging.WebSocketSession ) ; return ( TcpConnection < byte [] > ) org.springframework.web.socket.messaging.WebSocketHandler ; }  <METHOD_END>
<METHOD_START> private void void ( java.lang.Runnable java.lang.Runnable , long long , long long )			throws java.lang.InterruptedException { ArgumentCaptor < java.lang.Runnable > org.springframework.web.socket.messaging.ArgumentCaptor<java.lang.Runnable> = ArgumentCaptor . forClass ( java.lang.Runnable .class ) ; verify ( this . org.springframework.web.socket.messaging.TaskScheduler ) . scheduleWithFixedDelay ( org.springframework.web.socket.messaging.ArgumentCaptor<java.lang.Runnable> . capture ( ) , eq ( long / NUMBER ) ) ; verifyNoMoreInteractions ( this . org.springframework.web.socket.messaging.TaskScheduler ) ; if ( long > NUMBER ) { java.lang.Thread . void ( long ) ; } java.lang.Runnable java.lang.Runnable = org.springframework.web.socket.messaging.ArgumentCaptor<java.lang.Runnable> . getValue ( ) ; assertNotNull ( java.lang.Runnable ) ; java.lang.Runnable . void ( ) ; if ( long > NUMBER ) { verify ( java.lang.Runnable ) . run ( ) ; } else { verifyNoMoreInteractions ( java.lang.Runnable ) ; } }  <METHOD_END>
<METHOD_START> public void ( WebSocketClient org.springframework.web.socket.messaging.WebSocketClient ) { super( org.springframework.web.socket.messaging.WebSocketClient ); }  <METHOD_END>
<METHOD_START> public void void ( ConnectionHandlingStompSession org.springframework.web.socket.messaging.ConnectionHandlingStompSession ) { this . org.springframework.web.socket.messaging.ConnectionHandlingStompSession = org.springframework.web.socket.messaging.ConnectionHandlingStompSession ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected org.springframework.web.socket.messaging.ConnectionHandlingStompSession org.springframework.web.socket.messaging.ConnectionHandlingStompSession ( StompHeaders org.springframework.web.socket.messaging.StompHeaders , StompSessionHandler org.springframework.web.socket.messaging.StompSessionHandler ) { return this . org.springframework.web.socket.messaging.ConnectionHandlingStompSession ; }  <METHOD_END>
