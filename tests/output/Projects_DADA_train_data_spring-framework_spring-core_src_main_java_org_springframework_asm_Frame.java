<METHOD_START> final void void ( ClassWriter org.springframework.asm.ClassWriter , final int int , final java.lang.Object [] java.lang.Object[] , final int int , final java.lang.Object [] java.lang.Object[] ) { int int = int ( org.springframework.asm.ClassWriter , int , java.lang.Object[] , int[] ) ; while ( int < java.lang.Object[] . int ) { int[] [ int ++ ] = int ; } int int = NUMBER ; for ( int int = NUMBER ; int < int ; ++ int ) { if ( java.lang.Object[] [ int ] == Opcodes . LONG || java.lang.Object[] [ int ] == Opcodes . DOUBLE ) { ++ int ; } } int[] = new int [ int + int ] ; int ( org.springframework.asm.ClassWriter , int , java.lang.Object[] , int[] ) ; int = NUMBER ; int = NUMBER ; }  <METHOD_END>
<METHOD_START> private static int int ( ClassWriter org.springframework.asm.ClassWriter , int int , java.lang.Object [] java.lang.Object[] , int [] int[] ) { int int = NUMBER ; for ( int int = NUMBER ; int < int ; ++ int ) { if ( java.lang.Object[] [ int ] instanceof java.lang.Integer ) { int[] [ int ++ ] = int | ( ( java.lang.Integer ) java.lang.Object[] [ int ] ) . int ( ) ; if ( java.lang.Object[] [ int ] == Opcodes . LONG || java.lang.Object[] [ int ] == Opcodes . DOUBLE ) { int[] [ int ++ ] = int ; } } else if ( java.lang.Object[] [ int ] instanceof java.lang.String ) { int[] [ int ++ ] = int ( org.springframework.asm.ClassWriter , Type . getObjectType ( ( java.lang.String ) java.lang.Object[] [ int ] ) . getDescriptor ( ) ) ; } else { int[] [ int ++ ] = int | org.springframework.asm.ClassWriter . addUninitializedType ( STRING , ( ( Label ) java.lang.Object[] [ int ] ) . position ) ; } } return int ; }  <METHOD_END>
<METHOD_START> final void void ( final org.springframework.asm.Frame org.springframework.asm.Frame ) { int[] = org.springframework.asm.Frame . int[] ; int[] = org.springframework.asm.Frame . int[] ; int[] = org.springframework.asm.Frame . int[] ; int[] = org.springframework.asm.Frame . int[] ; int = org.springframework.asm.Frame . int ; int = org.springframework.asm.Frame . int ; int[] = org.springframework.asm.Frame . int[] ; }  <METHOD_END>
<METHOD_START> private int int ( final int int ) { if ( int[] == null || int >= int[] . int ) { return int | int ; } else { int int = int[] [ int ] ; if ( int == NUMBER ) { int = int[] [ int ] = int | int ; } return int ; } }  <METHOD_END>
<METHOD_START> private void void ( final int int , final int int ) { if ( int[] == null ) { int[] = new int [ NUMBER ] ; } int int = int[] . int ; if ( int >= int ) { int [] int[] = new int [ java.lang.Math . int ( int + NUMBER , NUMBER * int ) ] ; java.lang.System . void ( int[] , NUMBER , int[] , NUMBER , int ) ; int[] = int[] ; } int[] [ int ] = int ; }  <METHOD_END>
<METHOD_START> private void void ( final int int ) { if ( int[] == null ) { int[] = new int [ NUMBER ] ; } int int = int[] . int ; if ( int >= int ) { int [] int[] = new int [ java.lang.Math . int ( int + NUMBER , NUMBER * int ) ] ; java.lang.System . void ( int[] , NUMBER , int[] , NUMBER , int ) ; int[] = int[] ; } int[] [ int ++ ] = int ; int int = org.springframework.asm.Label . inputStackTop + int ; if ( int > org.springframework.asm.Label . outputStackMax ) { org.springframework.asm.Label . outputStackMax = int ; } }  <METHOD_END>
<METHOD_START> private void void ( final ClassWriter org.springframework.asm.ClassWriter , final java.lang.String java.lang.String ) { int int = int ( org.springframework.asm.ClassWriter , java.lang.String ) ; if ( int != NUMBER ) { void ( int ) ; if ( int == int || int == int ) { void ( int ) ; } } }  <METHOD_END>
<METHOD_START> private static int int ( final ClassWriter org.springframework.asm.ClassWriter , final java.lang.String java.lang.String ) { java.lang.String java.lang.String ; int int = java.lang.String . char ( NUMBER ) == '(' ? java.lang.String . int ( ')' ) + NUMBER : NUMBER ; switch ( java.lang.String . char ( int ) ) { case 'V' : return NUMBER ; case 'Z' : case 'C' : case 'B' : case 'S' : case 'I' : return int ; case 'F' : return int ; case 'J' : return int ; case 'D' : return int ; case 'L' : java.lang.String = java.lang.String . java.lang.String ( int + NUMBER , java.lang.String . int ( ) - NUMBER ) ; return int | org.springframework.asm.ClassWriter . addType ( java.lang.String ) ; default: int int ; int int = int + NUMBER ; while ( java.lang.String . char ( int ) == '[' ) { ++ int ; } switch ( java.lang.String . char ( int ) ) { case 'Z' : int = int ; break; case 'C' : int = int ; break; case 'B' : int = int ; break; case 'S' : int = int ; break; case 'I' : int = int ; break; case 'F' : int = int ; break; case 'J' : int = int ; break; case 'D' : int = int ; break; default: java.lang.String = java.lang.String . java.lang.String ( int + NUMBER , java.lang.String . int ( ) - NUMBER ) ; int = int | org.springframework.asm.ClassWriter . addType ( java.lang.String ) ; } return ( int - int ) << NUMBER | int ; } }  <METHOD_END>
<METHOD_START> private int int ( ) { if ( int > NUMBER ) { return int[] [ -- int ] ; } else { return int | - ( -- org.springframework.asm.Label . inputStackTop ) ; } }  <METHOD_END>
<METHOD_START> private void void ( final int int ) { if ( int >= int ) { int -= int ; } else { org.springframework.asm.Label . inputStackTop -= int - int ; int = NUMBER ; } }  <METHOD_END>
<METHOD_START> private void void ( final java.lang.String java.lang.String ) { char char = java.lang.String . char ( NUMBER ) ; if ( char == '(' ) { void ( ( Type . getArgumentsAndReturnSizes ( java.lang.String ) >> NUMBER ) - NUMBER ) ; } else if ( char == 'J' || char == 'D' ) { void ( NUMBER ) ; } else { void ( NUMBER ) ; } }  <METHOD_END>
<METHOD_START> private void void ( final int int ) { if ( int[] == null ) { int[] = new int [ NUMBER ] ; } int int = int[] . int ; if ( int >= int ) { int [] int[] = new int [ java.lang.Math . int ( int + NUMBER , NUMBER * int ) ] ; java.lang.System . void ( int[] , NUMBER , int[] , NUMBER , int ) ; int[] = int[] ; } int[] [ int ++ ] = int ; }  <METHOD_END>
<METHOD_START> private int int ( final ClassWriter org.springframework.asm.ClassWriter , final int int ) { int int ; if ( int == int ) { int = int | org.springframework.asm.ClassWriter . addType ( cw . thisName ) ; } else if ( ( int & ( int | int ) ) == int ) { java.lang.String java.lang.String = cw . typeTable [ int & int ] . strVal1 ; int = int | org.springframework.asm.ClassWriter . addType ( java.lang.String ) ; } else { return int ; } for ( int int = NUMBER ; int < int ; ++ int ) { int int = int[] [ int ] ; int int = int & int ; int int = int & int ; if ( int == int ) { int = int + int[] [ int & int ] ; } else if ( int == int ) { int = int + int[] [ int[] . int - ( int & int ) ] ; } if ( int == int ) { return int ; } } return int ; }  <METHOD_END>
<METHOD_START> final void void ( final ClassWriter org.springframework.asm.ClassWriter , final int int , final Type [] org.springframework.asm.Type[] , final int int ) { int[] = new int [ int ] ; int[] = new int [ NUMBER ] ; int int = NUMBER ; if ( ( int & Opcodes . ACC_STATIC ) == NUMBER ) { if ( ( int & MethodWriter . ACC_CONSTRUCTOR ) == NUMBER ) { int[] [ int ++ ] = int | org.springframework.asm.ClassWriter . addType ( cw . thisName ) ; } else { int[] [ int ++ ] = int ; } } for ( int int = NUMBER ; int < args . length ; ++ int ) { int int = int ( org.springframework.asm.ClassWriter , org.springframework.asm.Type[] [ int ] . getDescriptor ( ) ) ; int[] [ int ++ ] = int ; if ( int == int || int == int ) { int[] [ int ++ ] = int ; } } while ( int < int ) { int[] [ int ++ ] = int ; } }  <METHOD_END>
<METHOD_START> void void ( final int int , final int int , final ClassWriter org.springframework.asm.ClassWriter , final Item org.springframework.asm.Item ) { int int , int , int , int ; switch ( int ) { case Opcodes . NOP : case Opcodes . INEG : case Opcodes . LNEG : case Opcodes . FNEG : case Opcodes . DNEG : case Opcodes . I2B : case Opcodes . I2C : case Opcodes . I2S : case Opcodes . GOTO : case Opcodes . RETURN : break; case Opcodes . ACONST_NULL : void ( int ) ; break; case Opcodes . ICONST_M1 : case Opcodes . ICONST_0 : case Opcodes . ICONST_1 : case Opcodes . ICONST_2 : case Opcodes . ICONST_3 : case Opcodes . ICONST_4 : case Opcodes . ICONST_5 : case Opcodes . BIPUSH : case Opcodes . SIPUSH : case Opcodes . ILOAD : void ( int ) ; break; case Opcodes . LCONST_0 : case Opcodes . LCONST_1 : case Opcodes . LLOAD : void ( int ) ; void ( int ) ; break; case Opcodes . FCONST_0 : case Opcodes . FCONST_1 : case Opcodes . FCONST_2 : case Opcodes . FLOAD : void ( int ) ; break; case Opcodes . DCONST_0 : case Opcodes . DCONST_1 : case Opcodes . DLOAD : void ( int ) ; void ( int ) ; break; case Opcodes . LDC : switch ( item . type ) { case ClassWriter . INT : void ( int ) ; break; case ClassWriter . LONG : void ( int ) ; void ( int ) ; break; case ClassWriter . FLOAT : void ( int ) ; break; case ClassWriter . DOUBLE : void ( int ) ; void ( int ) ; break; case ClassWriter . CLASS : void ( int | org.springframework.asm.ClassWriter . addType ( STRING ) ) ; break; case ClassWriter . STR : void ( int | org.springframework.asm.ClassWriter . addType ( STRING ) ) ; break; case ClassWriter . MTYPE : void ( int | org.springframework.asm.ClassWriter . addType ( STRING ) ) ; break; default: void ( int | org.springframework.asm.ClassWriter . addType ( STRING ) ) ; } break; case Opcodes . ALOAD : void ( int ( int ) ) ; break; case Opcodes . IALOAD : case Opcodes . BALOAD : case Opcodes . CALOAD : case Opcodes . SALOAD : void ( NUMBER ) ; void ( int ) ; break; case Opcodes . LALOAD : case Opcodes . D2L : void ( NUMBER ) ; void ( int ) ; void ( int ) ; break; case Opcodes . FALOAD : void ( NUMBER ) ; void ( int ) ; break; case Opcodes . DALOAD : case Opcodes . L2D : void ( NUMBER ) ; void ( int ) ; void ( int ) ; break; case Opcodes . AALOAD : void ( NUMBER ) ; int = int ( ) ; void ( int + int ) ; break; case Opcodes . ISTORE : case Opcodes . FSTORE : case Opcodes . ASTORE : int = int ( ) ; void ( int , int ) ; if ( int > NUMBER ) { int = int ( int - NUMBER ) ; if ( int == int || int == int ) { void ( int - NUMBER , int ) ; } else if ( ( int & int ) != int ) { void ( int - NUMBER , int | int ) ; } } break; case Opcodes . LSTORE : case Opcodes . DSTORE : void ( NUMBER ) ; int = int ( ) ; void ( int , int ) ; void ( int + NUMBER , int ) ; if ( int > NUMBER ) { int = int ( int - NUMBER ) ; if ( int == int || int == int ) { void ( int - NUMBER , int ) ; } else if ( ( int & int ) != int ) { void ( int - NUMBER , int | int ) ; } } break; case Opcodes . IASTORE : case Opcodes . BASTORE : case Opcodes . CASTORE : case Opcodes . SASTORE : case Opcodes . FASTORE : case Opcodes . AASTORE : void ( NUMBER ) ; break; case Opcodes . LASTORE : case Opcodes . DASTORE : void ( NUMBER ) ; break; case Opcodes . POP : case Opcodes . IFEQ : case Opcodes . IFNE : case Opcodes . IFLT : case Opcodes . IFGE : case Opcodes . IFGT : case Opcodes . IFLE : case Opcodes . IRETURN : case Opcodes . FRETURN : case Opcodes . ARETURN : case Opcodes . TABLESWITCH : case Opcodes . LOOKUPSWITCH : case Opcodes . ATHROW : case Opcodes . MONITORENTER : case Opcodes . MONITOREXIT : case Opcodes . IFNULL : case Opcodes . IFNONNULL : void ( NUMBER ) ; break; case Opcodes . POP2 : case Opcodes . IF_ICMPEQ : case Opcodes . IF_ICMPNE : case Opcodes . IF_ICMPLT : case Opcodes . IF_ICMPGE : case Opcodes . IF_ICMPGT : case Opcodes . IF_ICMPLE : case Opcodes . IF_ACMPEQ : case Opcodes . IF_ACMPNE : case Opcodes . LRETURN : case Opcodes . DRETURN : void ( NUMBER ) ; break; case Opcodes . DUP : int = int ( ) ; void ( int ) ; void ( int ) ; break; case Opcodes . DUP_X1 : int = int ( ) ; int = int ( ) ; void ( int ) ; void ( int ) ; void ( int ) ; break; case Opcodes . DUP_X2 : int = int ( ) ; int = int ( ) ; int = int ( ) ; void ( int ) ; void ( int ) ; void ( int ) ; void ( int ) ; break; case Opcodes . DUP2 : int = int ( ) ; int = int ( ) ; void ( int ) ; void ( int ) ; void ( int ) ; void ( int ) ; break; case Opcodes . DUP2_X1 : int = int ( ) ; int = int ( ) ; int = int ( ) ; void ( int ) ; void ( int ) ; void ( int ) ; void ( int ) ; void ( int ) ; break; case Opcodes . DUP2_X2 : int = int ( ) ; int = int ( ) ; int = int ( ) ; int = int ( ) ; void ( int ) ; void ( int ) ; void ( int ) ; void ( int ) ; void ( int ) ; void ( int ) ; break; case Opcodes . SWAP : int = int ( ) ; int = int ( ) ; void ( int ) ; void ( int ) ; break; case Opcodes . IADD : case Opcodes . ISUB : case Opcodes . IMUL : case Opcodes . IDIV : case Opcodes . IREM : case Opcodes . IAND : case Opcodes . IOR : case Opcodes . IXOR : case Opcodes . ISHL : case Opcodes . ISHR : case Opcodes . IUSHR : case Opcodes . L2I : case Opcodes . D2I : case Opcodes . FCMPL : case Opcodes . FCMPG : void ( NUMBER ) ; void ( int ) ; break; case Opcodes . LADD : case Opcodes . LSUB : case Opcodes . LMUL : case Opcodes . LDIV : case Opcodes . LREM : case Opcodes . LAND : case Opcodes . LOR : case Opcodes . LXOR : void ( NUMBER ) ; void ( int ) ; void ( int ) ; break; case Opcodes . FADD : case Opcodes . FSUB : case Opcodes . FMUL : case Opcodes . FDIV : case Opcodes . FREM : case Opcodes . L2F : case Opcodes . D2F : void ( NUMBER ) ; void ( int ) ; break; case Opcodes . DADD : case Opcodes . DSUB : case Opcodes . DMUL : case Opcodes . DDIV : case Opcodes . DREM : void ( NUMBER ) ; void ( int ) ; void ( int ) ; break; case Opcodes . LSHL : case Opcodes . LSHR : case Opcodes . LUSHR : void ( NUMBER ) ; void ( int ) ; void ( int ) ; break; case Opcodes . IINC : void ( int , int ) ; break; case Opcodes . I2L : case Opcodes . F2L : void ( NUMBER ) ; void ( int ) ; void ( int ) ; break; case Opcodes . I2F : void ( NUMBER ) ; void ( int ) ; break; case Opcodes . I2D : case Opcodes . F2D : void ( NUMBER ) ; void ( int ) ; void ( int ) ; break; case Opcodes . F2I : case Opcodes . ARRAYLENGTH : case Opcodes . INSTANCEOF : void ( NUMBER ) ; void ( int ) ; break; case Opcodes . LCMP : case Opcodes . DCMPL : case Opcodes . DCMPG : void ( NUMBER ) ; void ( int ) ; break; case Opcodes . JSR : case Opcodes . RET : throw new java.lang.RuntimeException ( STRING ) ; case Opcodes . GETSTATIC : void ( org.springframework.asm.ClassWriter , item . strVal3 ) ; break; case Opcodes . PUTSTATIC : void ( item . strVal3 ) ; break; case Opcodes . GETFIELD : void ( NUMBER ) ; void ( org.springframework.asm.ClassWriter , item . strVal3 ) ; break; case Opcodes . PUTFIELD : void ( item . strVal3 ) ; int ( ) ; break; case Opcodes . INVOKEVIRTUAL : case Opcodes . INVOKESPECIAL : case Opcodes . INVOKESTATIC : case Opcodes . INVOKEINTERFACE : void ( item . strVal3 ) ; if ( int != Opcodes . INVOKESTATIC ) { int = int ( ) ; if ( int == Opcodes . INVOKESPECIAL && item . strVal2 . charAt ( NUMBER ) == '<' ) { void ( int ) ; } } void ( org.springframework.asm.ClassWriter , item . strVal3 ) ; break; case Opcodes . INVOKEDYNAMIC : void ( item . strVal2 ) ; void ( org.springframework.asm.ClassWriter , item . strVal2 ) ; break; case Opcodes . NEW : void ( int | org.springframework.asm.ClassWriter . addUninitializedType ( item . strVal1 , int ) ) ; break; case Opcodes . NEWARRAY : int ( ) ; switch ( int ) { case Opcodes . T_BOOLEAN : void ( int | int ) ; break; case Opcodes . T_CHAR : void ( int | int ) ; break; case Opcodes . T_BYTE : void ( int | int ) ; break; case Opcodes . T_SHORT : void ( int | int ) ; break; case Opcodes . T_INT : void ( int | int ) ; break; case Opcodes . T_FLOAT : void ( int | int ) ; break; case Opcodes . T_DOUBLE : void ( int | int ) ; break; default: void ( int | int ) ; break; } break; case Opcodes . ANEWARRAY : java.lang.String java.lang.String = item . strVal1 ; int ( ) ; if ( java.lang.String . char ( NUMBER ) == '[' ) { void ( org.springframework.asm.ClassWriter , '[' + java.lang.String ) ; } else { void ( int | int | org.springframework.asm.ClassWriter . addType ( java.lang.String ) ) ; } break; case Opcodes . CHECKCAST : java.lang.String = item . strVal1 ; int ( ) ; if ( java.lang.String . char ( NUMBER ) == '[' ) { void ( org.springframework.asm.ClassWriter , java.lang.String ) ; } else { void ( int | org.springframework.asm.ClassWriter . addType ( java.lang.String ) ) ; } break; default: void ( int ) ; void ( org.springframework.asm.ClassWriter , item . strVal1 ) ; break; } }  <METHOD_END>
<METHOD_START> final boolean boolean ( final ClassWriter org.springframework.asm.ClassWriter , final org.springframework.asm.Frame org.springframework.asm.Frame , final int int ) { boolean boolean = false ; int int , int , int , int , int ; int int = int[] . int ; int int = int[] . int ; if ( org.springframework.asm.Frame . int[] == null ) { org.springframework.asm.Frame . int[] = new int [ int ] ; boolean = true ; } for ( int = NUMBER ; int < int ; ++ int ) { if ( int[] != null && int < int[] . int ) { int = int[] [ int ] ; if ( int == NUMBER ) { int = int[] [ int ] ; } else { int = int & int ; int = int & int ; if ( int == int ) { int = int ; } else { if ( int == int ) { int = int + int[] [ int & int ] ; } else { int = int + int[] [ int - ( int & int ) ] ; } if ( ( int & int ) != NUMBER && ( int == int || int == int ) ) { int = int ; } } } } else { int = int[] [ int ] ; } if ( int[] != null ) { int = int ( org.springframework.asm.ClassWriter , int ) ; } boolean |= boolean ( org.springframework.asm.ClassWriter , int , org.springframework.asm.Frame . int[] , int ) ; } if ( int > NUMBER ) { for ( int = NUMBER ; int < int ; ++ int ) { int = int[] [ int ] ; boolean |= boolean ( org.springframework.asm.ClassWriter , int , org.springframework.asm.Frame . int[] , int ) ; } if ( org.springframework.asm.Frame . int[] == null ) { org.springframework.asm.Frame . int[] = new int [ NUMBER ] ; boolean = true ; } boolean |= boolean ( org.springframework.asm.ClassWriter , int , org.springframework.asm.Frame . int[] , NUMBER ) ; return boolean ; } int int = int[] . int + org.springframework.asm.Label . inputStackTop ; if ( org.springframework.asm.Frame . int[] == null ) { org.springframework.asm.Frame . int[] = new int [ int + int ] ; boolean = true ; } for ( int = NUMBER ; int < int ; ++ int ) { int = int[] [ int ] ; if ( int[] != null ) { int = int ( org.springframework.asm.ClassWriter , int ) ; } boolean |= boolean ( org.springframework.asm.ClassWriter , int , org.springframework.asm.Frame . int[] , int ) ; } for ( int = NUMBER ; int < int ; ++ int ) { int = int[] [ int ] ; int = int & int ; int = int & int ; if ( int == int ) { int = int ; } else { if ( int == int ) { int = int + int[] [ int & int ] ; } else { int = int + int[] [ int - ( int & int ) ] ; } if ( ( int & int ) != NUMBER && ( int == int || int == int ) ) { int = int ; } } if ( int[] != null ) { int = int ( org.springframework.asm.ClassWriter , int ) ; } boolean |= boolean ( org.springframework.asm.ClassWriter , int , org.springframework.asm.Frame . int[] , int + int ) ; } return boolean ; }  <METHOD_END>
<METHOD_START> private static boolean boolean ( final ClassWriter org.springframework.asm.ClassWriter , int int , final int [] int[] , final int int ) { int int = int[] [ int ] ; if ( int == int ) { return false ; } if ( ( int & ~ int ) == int ) { if ( int == int ) { return false ; } int = int ; } if ( int == NUMBER ) { int[] [ int ] = int ; return true ; } int int ; if ( ( int & int ) == int || ( int & int ) != NUMBER ) { if ( int == int ) { return false ; } else if ( ( int & ( int | int ) ) == ( int & ( int | int ) ) ) { if ( ( int & int ) == int ) { int = ( int & int ) | int | org.springframework.asm.ClassWriter . getMergedType ( int & int , int & int ) ; } else { int int = int + ( int & int ) ; int = int | int | org.springframework.asm.ClassWriter . addType ( STRING ) ; } } else if ( ( int & int ) == int || ( int & int ) != NUMBER ) { int int = ( ( ( int & int ) == NUMBER || ( int & int ) == int ) ? NUMBER : int ) + ( int & int ) ; int int = ( ( ( int & int ) == NUMBER || ( int & int ) == int ) ? NUMBER : int ) + ( int & int ) ; int = java.lang.Math . int ( int , int ) | int | org.springframework.asm.ClassWriter . addType ( STRING ) ; } else { int = int ; } } else if ( int == int ) { int = ( int & int ) == int || ( int & int ) != NUMBER ? int : int ; } else { int = int ; } if ( int != int ) { int[] [ int ] = int ; return true ; } return false ; }  <METHOD_END>
