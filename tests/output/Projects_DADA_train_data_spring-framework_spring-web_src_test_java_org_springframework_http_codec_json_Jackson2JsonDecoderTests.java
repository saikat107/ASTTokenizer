<METHOD_START> @ Test public void void ( ) { Jackson2JsonDecoder org.springframework.http.codec.json.Jackson2JsonDecoder = new Jackson2JsonDecoder ( ) ; assertTrue ( org.springframework.http.codec.json.Jackson2JsonDecoder . canDecode ( forClass ( Pojo .class ) , APPLICATION_JSON ) ) ; assertTrue ( org.springframework.http.codec.json.Jackson2JsonDecoder . canDecode ( forClass ( Pojo .class ) , null ) ) ; assertFalse ( org.springframework.http.codec.json.Jackson2JsonDecoder . canDecode ( forClass ( java.lang.String .class ) , null ) ) ; assertFalse ( org.springframework.http.codec.json.Jackson2JsonDecoder . canDecode ( forClass ( Pojo .class ) , APPLICATION_XML ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { Flux < DataBuffer > org.springframework.http.codec.json.Flux<org.springframework.http.codec.json.DataBuffer> = Flux . just ( stringBuffer ( STRING ) ) ; ResolvableType org.springframework.http.codec.json.ResolvableType = forClass ( Pojo .class ) ; Flux < java.lang.Object > org.springframework.http.codec.json.Flux<java.lang.Object> = new Jackson2JsonDecoder ( ) . decode ( org.springframework.http.codec.json.Flux<org.springframework.http.codec.json.DataBuffer> , org.springframework.http.codec.json.ResolvableType , null , java.util.Map<java.lang.Object,java.lang.Object> ( ) ) ; StepVerifier . create ( org.springframework.http.codec.json.Flux<java.lang.Object> ) . expectNext ( new Pojo ( STRING , STRING ) ) . verifyComplete ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { Flux < DataBuffer > org.springframework.http.codec.json.Flux<org.springframework.http.codec.json.DataBuffer> = Flux . just ( stringBuffer ( STRING ) ) ; ResolvableType org.springframework.http.codec.json.ResolvableType = forClass ( Pojo .class ) ; Flux < java.lang.Object > org.springframework.http.codec.json.Flux<java.lang.Object> = new Jackson2JsonDecoder ( ) . decode ( org.springframework.http.codec.json.Flux<org.springframework.http.codec.json.DataBuffer> , org.springframework.http.codec.json.ResolvableType , null , java.util.Map<java.lang.Object,java.lang.Object> ( ) ) ; StepVerifier . create ( org.springframework.http.codec.json.Flux<java.lang.Object> ) . verifyError ( CodecException .class ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { Flux < DataBuffer > org.springframework.http.codec.json.Flux<org.springframework.http.codec.json.DataBuffer> = Flux . just ( stringBuffer ( STRING ) ) ; ResolvableType org.springframework.http.codec.json.ResolvableType = ResolvableType . forClassWithGenerics ( java.util.List .class , Pojo .class ) ; Mono < java.lang.Object > org.springframework.http.codec.json.Mono<java.lang.Object> = new Jackson2JsonDecoder ( ) . decodeToMono ( org.springframework.http.codec.json.Flux<org.springframework.http.codec.json.DataBuffer> , org.springframework.http.codec.json.ResolvableType , null , java.util.Map<java.lang.Object,java.lang.Object> ( ) ) ; StepVerifier . create ( org.springframework.http.codec.json.Mono<java.lang.Object> ) . expectNext ( java.util.List ( new Pojo ( STRING , STRING ) , new Pojo ( STRING , STRING ) ) ) . expectComplete ( ) . verify ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { Flux < DataBuffer > org.springframework.http.codec.json.Flux<org.springframework.http.codec.json.DataBuffer> = Flux . just ( stringBuffer ( STRING ) ) ; ResolvableType org.springframework.http.codec.json.ResolvableType = forClass ( Pojo .class ) ; Flux < java.lang.Object > org.springframework.http.codec.json.Flux<java.lang.Object> = new Jackson2JsonDecoder ( ) . decode ( org.springframework.http.codec.json.Flux<org.springframework.http.codec.json.DataBuffer> , org.springframework.http.codec.json.ResolvableType , null , java.util.Map<java.lang.Object,java.lang.Object> ( ) ) ; StepVerifier . create ( org.springframework.http.codec.json.Flux<java.lang.Object> ) . expectNext ( new Pojo ( STRING , STRING ) ) . expectNext ( new Pojo ( STRING , STRING ) ) . verifyComplete ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { Flux < DataBuffer > org.springframework.http.codec.json.Flux<org.springframework.http.codec.json.DataBuffer> = Flux . just ( stringBuffer ( STRING ) ) ; ResolvableType org.springframework.http.codec.json.ResolvableType = forClass ( JacksonViewBean .class ) ; java.util.Map<java.lang.String,java.lang.Object> < java.lang.String , java.lang.Object > java.util.Map<java.lang.String,java.lang.Object> = java.util.Map ( JSON_VIEW_HINT , MyJacksonView1 .class ) ; Flux < JacksonViewBean > org.springframework.http.codec.json.Flux<org.springframework.http.codec.json.JacksonViewBean> = new Jackson2JsonDecoder ( ) . decode ( org.springframework.http.codec.json.Flux<org.springframework.http.codec.json.DataBuffer> , org.springframework.http.codec.json.ResolvableType , null , java.util.Map<java.lang.String,java.lang.Object> ) . cast ( JacksonViewBean .class ) ; StepVerifier . create ( org.springframework.http.codec.json.Flux<org.springframework.http.codec.json.JacksonViewBean> ) . consumeNextWith ( b -> { assertTrue ( b . getWithView1 ( ) . equals ( STRING ) ) ; assertNull ( b . getWithView2 ( ) ) ; assertNull ( b . getWithoutView ( ) ) ; } ) . verifyComplete ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { Flux < DataBuffer > org.springframework.http.codec.json.Flux<org.springframework.http.codec.json.DataBuffer> = Flux . just ( stringBuffer ( STRING ) ) ; ResolvableType org.springframework.http.codec.json.ResolvableType = forClass ( JacksonViewBean .class ) ; java.util.Map<java.lang.String,java.lang.Object> < java.lang.String , java.lang.Object > java.util.Map<java.lang.String,java.lang.Object> = java.util.Map ( JSON_VIEW_HINT , MyJacksonView3 .class ) ; Flux < JacksonViewBean > org.springframework.http.codec.json.Flux<org.springframework.http.codec.json.JacksonViewBean> = new Jackson2JsonDecoder ( ) . decode ( org.springframework.http.codec.json.Flux<org.springframework.http.codec.json.DataBuffer> , org.springframework.http.codec.json.ResolvableType , null , java.util.Map<java.lang.String,java.lang.Object> ) . cast ( JacksonViewBean .class ) ; StepVerifier . create ( org.springframework.http.codec.json.Flux<org.springframework.http.codec.json.JacksonViewBean> ) . consumeNextWith ( b -> { assertNull ( b . getWithView1 ( ) ) ; assertNull ( b . getWithView2 ( ) ) ; assertTrue ( b . getWithoutView ( ) . equals ( STRING ) ) ; } ) . verifyComplete ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { Flux < DataBuffer > org.springframework.http.codec.json.Flux<org.springframework.http.codec.json.DataBuffer> = Flux . empty ( ) ; ResolvableType org.springframework.http.codec.json.ResolvableType = forClass ( Pojo .class ) ; Mono < java.lang.Object > org.springframework.http.codec.json.Mono<java.lang.Object> = new Jackson2JsonDecoder ( ) . decodeToMono ( org.springframework.http.codec.json.Flux<org.springframework.http.codec.json.DataBuffer> , org.springframework.http.codec.json.ResolvableType , null , java.util.Map<java.lang.Object,java.lang.Object> ( ) ) ; StepVerifier . create ( org.springframework.http.codec.json.Mono<java.lang.Object> ) . expectNextCount ( NUMBER ) . verifyComplete ( ) ; }  <METHOD_END>
