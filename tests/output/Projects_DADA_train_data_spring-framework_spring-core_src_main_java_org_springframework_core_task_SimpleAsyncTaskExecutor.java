<METHOD_START> public void ( ) { super(); }  <METHOD_END>
<METHOD_START> public void ( java.lang.String java.lang.String ) { super( java.lang.String ); }  <METHOD_END>
<METHOD_START> public void ( java.util.concurrent.ThreadFactory java.util.concurrent.ThreadFactory ) { this . java.util.concurrent.ThreadFactory = java.util.concurrent.ThreadFactory ; }  <METHOD_END>
<METHOD_START> public void void ( java.util.concurrent.ThreadFactory java.util.concurrent.ThreadFactory ) { this . java.util.concurrent.ThreadFactory = java.util.concurrent.ThreadFactory ; }  <METHOD_END>
<METHOD_START> public final java.util.concurrent.ThreadFactory java.util.concurrent.ThreadFactory ( ) { return this . java.util.concurrent.ThreadFactory ; }  <METHOD_END>
<METHOD_START> public final void void ( TaskDecorator org.springframework.core.task.TaskDecorator ) { this . org.springframework.core.task.TaskDecorator = org.springframework.core.task.TaskDecorator ; }  <METHOD_END>
<METHOD_START> public void void ( int int ) { this . org.springframework.core.task.SimpleAsyncTaskExecutor.ConcurrencyThrottleAdapter . setConcurrencyLimit ( int ) ; }  <METHOD_END>
<METHOD_START> public final int int ( ) { return this . org.springframework.core.task.SimpleAsyncTaskExecutor.ConcurrencyThrottleAdapter . getConcurrencyLimit ( ) ; }  <METHOD_END>
<METHOD_START> public final boolean boolean ( ) { return this . org.springframework.core.task.SimpleAsyncTaskExecutor.ConcurrencyThrottleAdapter . isThrottleActive ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( java.lang.Runnable java.lang.Runnable ) { void ( java.lang.Runnable , TIMEOUT_INDEFINITE ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( java.lang.Runnable java.lang.Runnable , long long ) { Assert . notNull ( java.lang.Runnable , STRING ) ; java.lang.Runnable java.lang.Runnable = ( this . org.springframework.core.task.TaskDecorator != null ? this . org.springframework.core.task.TaskDecorator . decorate ( java.lang.Runnable ) : java.lang.Runnable ) ; if ( boolean ( ) && long > TIMEOUT_IMMEDIATE ) { this . org.springframework.core.task.SimpleAsyncTaskExecutor.ConcurrencyThrottleAdapter . void ( ) ; void ( new org.springframework.core.task.SimpleAsyncTaskExecutor.ConcurrencyThrottlingRunnable ( java.lang.Runnable ) ) ; } else { void ( java.lang.Runnable ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.util.concurrent.Future<?> < ? > java.util.concurrent.Future<?> ( java.lang.Runnable java.lang.Runnable ) { java.util.concurrent.FutureTask<java.lang.Object> < java.lang.Object > java.util.concurrent.FutureTask<java.lang.Object> = new java.util.concurrent.FutureTask<java.lang.Object> <> ( java.lang.Runnable , null ) ; void ( java.util.concurrent.FutureTask<java.lang.Object> , TIMEOUT_INDEFINITE ) ; return java.util.concurrent.FutureTask<java.lang.Object> ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public < T > java.util.concurrent.Future<T> < T > java.util.concurrent.Future<T> ( java.util.concurrent.Callable<T> < T > java.util.concurrent.Callable<T> ) { java.util.concurrent.FutureTask<T> < T > java.util.concurrent.FutureTask<T> = new java.util.concurrent.FutureTask<T> <> ( java.util.concurrent.Callable<T> ) ; void ( java.util.concurrent.FutureTask<T> , TIMEOUT_INDEFINITE ) ; return java.util.concurrent.FutureTask<T> ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.core.task.ListenableFuture<?> < ? > org.springframework.core.task.ListenableFuture<?> ( java.lang.Runnable java.lang.Runnable ) { ListenableFutureTask < java.lang.Object > org.springframework.core.task.ListenableFutureTask<java.lang.Object> = new ListenableFutureTask <> ( java.lang.Runnable , null ) ; void ( org.springframework.core.task.ListenableFutureTask<java.lang.Object> , TIMEOUT_INDEFINITE ) ; return org.springframework.core.task.ListenableFutureTask<java.lang.Object> ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public < T > org.springframework.core.task.ListenableFuture<T> < T > org.springframework.core.task.ListenableFuture<T> ( java.util.concurrent.Callable<T> < T > java.util.concurrent.Callable<T> ) { ListenableFutureTask < T > org.springframework.core.task.ListenableFutureTask<T> = new ListenableFutureTask <> ( java.util.concurrent.Callable<T> ) ; void ( org.springframework.core.task.ListenableFutureTask<T> , TIMEOUT_INDEFINITE ) ; return org.springframework.core.task.ListenableFutureTask<T> ; }  <METHOD_END>
<METHOD_START> protected void void ( java.lang.Runnable java.lang.Runnable ) { java.lang.Thread java.lang.Thread = ( this . java.util.concurrent.ThreadFactory != null ? this . java.util.concurrent.ThreadFactory . java.lang.Thread ( java.lang.Runnable ) : createThread ( java.lang.Runnable ) ) ; java.lang.Thread . void ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( ) { super. beforeAccess ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( ) { super. afterAccess ( ) ; }  <METHOD_END>
<METHOD_START> public void ( java.lang.Runnable java.lang.Runnable ) { this . java.lang.Runnable = java.lang.Runnable ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ) { try { this . java.lang.Runnable . void ( ) ; } finally { org.springframework.core.task.SimpleAsyncTaskExecutor.ConcurrencyThrottleAdapter . void ( ) ; } }  <METHOD_END>
