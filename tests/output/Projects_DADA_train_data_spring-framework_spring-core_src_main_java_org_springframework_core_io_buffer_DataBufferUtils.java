<METHOD_START> public static org.springframework.core.io.buffer.Flux<org.springframework.core.io.buffer.DataBuffer> < DataBuffer > org.springframework.core.io.buffer.Flux<org.springframework.core.io.buffer.DataBuffer> ( java.io.InputStream java.io.InputStream , DataBufferFactory org.springframework.core.io.buffer.DataBufferFactory , int int ) { Assert . notNull ( java.io.InputStream , STRING ) ; Assert . notNull ( org.springframework.core.io.buffer.DataBufferFactory , STRING ) ; java.nio.channels.ReadableByteChannel java.nio.channels.ReadableByteChannel = java.nio.channels.Channels . java.nio.channels.ReadableByteChannel ( java.io.InputStream ) ; return org.springframework.core.io.buffer.Flux<org.springframework.core.io.buffer.DataBuffer> ( java.nio.channels.ReadableByteChannel , org.springframework.core.io.buffer.DataBufferFactory , int ) ; }  <METHOD_END>
<METHOD_START> public static org.springframework.core.io.buffer.Flux<org.springframework.core.io.buffer.DataBuffer> < DataBuffer > org.springframework.core.io.buffer.Flux<org.springframework.core.io.buffer.DataBuffer> ( java.nio.channels.ReadableByteChannel java.nio.channels.ReadableByteChannel , DataBufferFactory org.springframework.core.io.buffer.DataBufferFactory , int int ) { Assert . notNull ( java.nio.channels.ReadableByteChannel , STRING ) ; Assert . notNull ( org.springframework.core.io.buffer.DataBufferFactory , STRING ) ; return Flux . generate ( ( ) channel , new org.springframework.core.io.buffer.DataBufferUtils.ReadableByteChannelGenerator ( org.springframework.core.io.buffer.DataBufferFactory , int ) , org.springframework.core.io.buffer.DataBufferUtils :: void ) ; }  <METHOD_END>
<METHOD_START> public static org.springframework.core.io.buffer.Flux<org.springframework.core.io.buffer.DataBuffer> < DataBuffer > org.springframework.core.io.buffer.Flux<org.springframework.core.io.buffer.DataBuffer> ( java.nio.channels.AsynchronousFileChannel java.nio.channels.AsynchronousFileChannel , DataBufferFactory org.springframework.core.io.buffer.DataBufferFactory , int int ) { return org.springframework.core.io.buffer.Flux<org.springframework.core.io.buffer.DataBuffer> ( java.nio.channels.AsynchronousFileChannel , NUMBER , org.springframework.core.io.buffer.DataBufferFactory , int ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.SuppressWarnings ( STRING ) public static org.springframework.core.io.buffer.Flux<org.springframework.core.io.buffer.DataBuffer> < DataBuffer > org.springframework.core.io.buffer.Flux<org.springframework.core.io.buffer.DataBuffer> ( java.nio.channels.AsynchronousFileChannel java.nio.channels.AsynchronousFileChannel , long long , DataBufferFactory org.springframework.core.io.buffer.DataBufferFactory , int int ) { Assert . notNull ( java.nio.channels.AsynchronousFileChannel , STRING ) ; Assert . notNull ( org.springframework.core.io.buffer.DataBufferFactory , STRING ) ; Assert . isTrue ( long >= NUMBER , STRING ) ; java.nio.ByteBuffer java.nio.ByteBuffer = java.nio.ByteBuffer . java.nio.ByteBuffer ( int ) ; return Flux . create ( emitter -> { emitter . setCancellation ( ( ) closeChannel ( channel ) ) ; AsynchronousFileChannelCompletionHandler completionHandler = new AsynchronousFileChannelCompletionHandler ( emitter , position , dataBufferFactory , byteBuffer ) ; channel . read ( byteBuffer , position , channel , completionHandler ) ; } ) ; }  <METHOD_END>
<METHOD_START> private static void void ( java.nio.channels.Channel java.nio.channels.Channel ) { try { if ( java.nio.channels.Channel != null ) { java.nio.channels.Channel . void ( ) ; } } catch ( java.io.IOException java.io.IOException ) {		} }  <METHOD_END>
<METHOD_START> public static org.springframework.core.io.buffer.Flux<org.springframework.core.io.buffer.DataBuffer> < DataBuffer > org.springframework.core.io.buffer.Flux<org.springframework.core.io.buffer.DataBuffer> ( Publisher < DataBuffer > org.springframework.core.io.buffer.Publisher<org.springframework.core.io.buffer.DataBuffer> , long long ) { Assert . notNull ( org.springframework.core.io.buffer.Publisher<org.springframework.core.io.buffer.DataBuffer> , STRING ) ; Assert . isTrue ( long >= NUMBER , STRING ) ; java.util.concurrent.atomic.AtomicLong java.util.concurrent.atomic.AtomicLong = new java.util.concurrent.atomic.AtomicLong ( long ) ; return Flux . from ( org.springframework.core.io.buffer.Publisher<org.springframework.core.io.buffer.DataBuffer> ) . takeWhile ( dataBuffer -> { int delta = - dataBuffer . readableByteCount ( ) ; long currentCount = byteCountDown . getAndAdd ( delta ) ; return currentCount >= NUMBER ; } ) . map ( dataBuffer -> { long currentCount = byteCountDown . get ( ) ; if ( currentCount >= NUMBER ) { return dataBuffer ; } else { int size = ( int ) ( currentCount + dataBuffer . readableByteCount ( ) ) ; return dataBuffer . slice ( NUMBER , size ) ; } } ) ; }  <METHOD_END>
<METHOD_START> public static org.springframework.core.io.buffer.Flux<org.springframework.core.io.buffer.DataBuffer> < DataBuffer > org.springframework.core.io.buffer.Flux<org.springframework.core.io.buffer.DataBuffer> ( Publisher < DataBuffer > org.springframework.core.io.buffer.Publisher<org.springframework.core.io.buffer.DataBuffer> , long long ) { Assert . notNull ( org.springframework.core.io.buffer.Publisher<org.springframework.core.io.buffer.DataBuffer> , STRING ) ; Assert . isTrue ( long >= NUMBER , STRING ) ; java.util.concurrent.atomic.AtomicLong java.util.concurrent.atomic.AtomicLong = new java.util.concurrent.atomic.AtomicLong ( long ) ; return Flux . from ( org.springframework.core.io.buffer.Publisher<org.springframework.core.io.buffer.DataBuffer> ) . skipUntil ( dataBuffer -> { int delta = - dataBuffer . readableByteCount ( ) ; long currentCount = byteCountDown . addAndGet ( delta ) ; if( currentCount < NUMBER ) { return true ; } else { DataBufferUtils . release ( dataBuffer ) ; return false ; } } ) . map ( dataBuffer -> { long currentCount = byteCountDown . get ( ) ; if ( currentCount < NUMBER ) { int skip = ( int ) ( currentCount + dataBuffer . readableByteCount ( ) ) ; byteCountDown . set ( NUMBER ) ; return dataBuffer . slice ( skip , dataBuffer . readableByteCount ( ) - skip ) ; } return dataBuffer ; } ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.SuppressWarnings ( STRING ) public static < T extends org.springframework.core.io.buffer.DataBuffer > T T ( T T ) { if ( T instanceof PooledDataBuffer ) { return ( T ) ( ( PooledDataBuffer ) T ) . retain ( ) ; } else { return T ; } }  <METHOD_END>
<METHOD_START> public static boolean boolean ( DataBuffer org.springframework.core.io.buffer.DataBuffer ) { if ( org.springframework.core.io.buffer.DataBuffer instanceof PooledDataBuffer ) { return ( ( PooledDataBuffer ) org.springframework.core.io.buffer.DataBuffer ) . release ( ) ; } return false ; }  <METHOD_END>
<METHOD_START> public void ( DataBufferFactory org.springframework.core.io.buffer.DataBufferFactory , int int ) { this . org.springframework.core.io.buffer.DataBufferFactory = org.springframework.core.io.buffer.DataBufferFactory ; this . java.nio.ByteBuffer = java.nio.ByteBuffer . java.nio.ByteBuffer ( int ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.nio.channels.ReadableByteChannel java.nio.channels.ReadableByteChannel ( java.nio.channels.ReadableByteChannel java.nio.channels.ReadableByteChannel , SynchronousSink < DataBuffer > org.springframework.core.io.buffer.SynchronousSink<org.springframework.core.io.buffer.DataBuffer> ) { try { int int ; if ( ( int = java.nio.channels.ReadableByteChannel . int ( this . java.nio.ByteBuffer ) ) >= NUMBER ) { this . java.nio.ByteBuffer . java.nio.Buffer ( ) ; boolean boolean = true ; DataBuffer org.springframework.core.io.buffer.DataBuffer = this . org.springframework.core.io.buffer.DataBufferFactory . allocateBuffer ( int ) ; try { org.springframework.core.io.buffer.DataBuffer . write ( this . java.nio.ByteBuffer ) ; boolean = false ; org.springframework.core.io.buffer.SynchronousSink<org.springframework.core.io.buffer.DataBuffer> . next ( org.springframework.core.io.buffer.DataBuffer ) ; } finally { if ( boolean ) { boolean ( org.springframework.core.io.buffer.DataBuffer ) ; } } this . java.nio.ByteBuffer . java.nio.Buffer ( ) ; } else { org.springframework.core.io.buffer.SynchronousSink<org.springframework.core.io.buffer.DataBuffer> . complete ( ) ; } } catch ( java.io.IOException java.io.IOException ) { org.springframework.core.io.buffer.SynchronousSink<org.springframework.core.io.buffer.DataBuffer> . error ( java.io.IOException ) ; } return java.nio.channels.ReadableByteChannel ; }  <METHOD_END>
<METHOD_START> private void ( FluxSink < DataBuffer > org.springframework.core.io.buffer.FluxSink<org.springframework.core.io.buffer.DataBuffer> , long long , DataBufferFactory org.springframework.core.io.buffer.DataBufferFactory , java.nio.ByteBuffer java.nio.ByteBuffer ) { this . org.springframework.core.io.buffer.FluxSink<org.springframework.core.io.buffer.DataBuffer> = org.springframework.core.io.buffer.FluxSink<org.springframework.core.io.buffer.DataBuffer> ; this . long = long ; this . org.springframework.core.io.buffer.DataBufferFactory = org.springframework.core.io.buffer.DataBufferFactory ; this . java.nio.ByteBuffer = java.nio.ByteBuffer ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( java.lang.Integer java.lang.Integer , java.nio.channels.AsynchronousFileChannel java.nio.channels.AsynchronousFileChannel ) { if ( java.lang.Integer != - NUMBER ) { this . long += java.lang.Integer ; this . java.nio.ByteBuffer . java.nio.Buffer ( ) ; boolean boolean = true ; DataBuffer org.springframework.core.io.buffer.DataBuffer = this . org.springframework.core.io.buffer.DataBufferFactory . allocateBuffer ( java.lang.Integer ) ; try { org.springframework.core.io.buffer.DataBuffer . write ( this . java.nio.ByteBuffer ) ; boolean = false ; this . org.springframework.core.io.buffer.FluxSink<org.springframework.core.io.buffer.DataBuffer> . next ( org.springframework.core.io.buffer.DataBuffer ) ; } finally { if ( boolean ) { boolean ( org.springframework.core.io.buffer.DataBuffer ) ; } } this . java.nio.ByteBuffer . java.nio.Buffer ( ) ; if ( ! this . org.springframework.core.io.buffer.FluxSink<org.springframework.core.io.buffer.DataBuffer> . isCancelled ( ) ) { java.nio.channels.AsynchronousFileChannel . void ( this . java.nio.ByteBuffer , this . long , java.nio.channels.AsynchronousFileChannel , this ) ; } } else { this . org.springframework.core.io.buffer.FluxSink<org.springframework.core.io.buffer.DataBuffer> . complete ( ) ; void ( java.nio.channels.AsynchronousFileChannel ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( java.lang.Throwable java.lang.Throwable , java.nio.channels.AsynchronousFileChannel java.nio.channels.AsynchronousFileChannel ) { this . org.springframework.core.io.buffer.FluxSink<org.springframework.core.io.buffer.DataBuffer> . error ( java.lang.Throwable ) ; void ( java.nio.channels.AsynchronousFileChannel ) ; }  <METHOD_END>
