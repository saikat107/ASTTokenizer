<METHOD_START> public void ( java.util.concurrent.Executor java.util.concurrent.Executor ) { this( java.util.concurrent.Executor , new RoundRobinLoadBalancingStrategy ( ) ); }  <METHOD_END>
<METHOD_START> public void ( java.util.concurrent.Executor java.util.concurrent.Executor , LoadBalancingStrategy org.springframework.integration.channel.LoadBalancingStrategy ) { super( java.util.concurrent.Executor ); Assert . notNull ( java.util.concurrent.Executor , STRING ) ; UnicastingDispatcher org.springframework.integration.channel.UnicastingDispatcher = new UnicastingDispatcher ( java.util.concurrent.Executor ) ; if ( org.springframework.integration.channel.LoadBalancingStrategy != null ) { this . org.springframework.integration.channel.LoadBalancingStrategy = org.springframework.integration.channel.LoadBalancingStrategy ; org.springframework.integration.channel.UnicastingDispatcher . setLoadBalancingStrategy ( org.springframework.integration.channel.LoadBalancingStrategy ) ; } this . dispatcher = org.springframework.integration.channel.UnicastingDispatcher ; }  <METHOD_END>
<METHOD_START> public void void ( boolean boolean ) { this . boolean = boolean ; org.springframework.integration.channel.UnicastingDispatcher ( ) . setFailover ( boolean ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected org.springframework.integration.channel.UnicastingDispatcher org.springframework.integration.channel.UnicastingDispatcher ( ) { return ( UnicastingDispatcher ) this . dispatcher ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public final void void ( ) java.lang.Exception { Assert . state ( org.springframework.integration.channel.UnicastingDispatcher ( ) . getHandlerCount ( ) == NUMBER , STRING + STRING ) ; super. onInit ( ) ; if ( ! ( this . executor instanceof ErrorHandlingTaskExecutor ) ) { ErrorHandler org.springframework.integration.channel.ErrorHandler = new MessagePublishingErrorHandler ( new BeanFactoryChannelResolver ( this . getBeanFactory ( ) ) ) ; this . executor = new ErrorHandlingTaskExecutor ( this . executor , org.springframework.integration.channel.ErrorHandler ) ; } UnicastingDispatcher org.springframework.integration.channel.UnicastingDispatcher = new UnicastingDispatcher ( this . executor ) ; org.springframework.integration.channel.UnicastingDispatcher . setFailover ( this . boolean ) ; if ( this . maxSubscribers == null ) { this . maxSubscribers = getIntegrationProperty ( IntegrationProperties . CHANNELS_MAX_UNICAST_SUBSCRIBERS , java.lang.Integer .class ) ; } org.springframework.integration.channel.UnicastingDispatcher . setMaxSubscribers ( this . maxSubscribers ) ; if ( this . org.springframework.integration.channel.LoadBalancingStrategy != null ) { org.springframework.integration.channel.UnicastingDispatcher . setLoadBalancingStrategy ( this . org.springframework.integration.channel.LoadBalancingStrategy ) ; } org.springframework.integration.channel.UnicastingDispatcher . setMessageHandlingTaskDecorator ( task -> { if ( ExecutorChannel .this . executorInterceptorsSize > NUMBER ) { return new MessageHandlingTask ( task ) ; } else { return task ; } } ) ; this . dispatcher = org.springframework.integration.channel.UnicastingDispatcher ; }  <METHOD_END>
