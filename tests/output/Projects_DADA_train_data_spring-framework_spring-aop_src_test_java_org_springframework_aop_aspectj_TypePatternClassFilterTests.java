<METHOD_START> @ Test ( expected = java.lang.IllegalArgumentException .class ) public void void ( ) { new TypePatternClassFilter ( STRING ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { TypePatternClassFilter org.springframework.aop.aspectj.TypePatternClassFilter = new TypePatternClassFilter ( STRING ) ; assertTrue ( STRING , org.springframework.aop.aspectj.TypePatternClassFilter . matches ( TestBean .class ) ) ; assertTrue ( STRING , org.springframework.aop.aspectj.TypePatternClassFilter . matches ( ITestBean .class ) ) ; assertTrue ( STRING , org.springframework.aop.aspectj.TypePatternClassFilter . matches ( IOther .class ) ) ; assertFalse ( STRING , org.springframework.aop.aspectj.TypePatternClassFilter . matches ( DeepBean .class ) ) ; assertFalse ( STRING , org.springframework.aop.aspectj.TypePatternClassFilter . matches ( BeanFactory .class ) ) ; assertFalse ( STRING , org.springframework.aop.aspectj.TypePatternClassFilter . matches ( DefaultListableBeanFactory .class ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { TypePatternClassFilter org.springframework.aop.aspectj.TypePatternClassFilter = new TypePatternClassFilter ( STRING ) ; assertTrue ( STRING , org.springframework.aop.aspectj.TypePatternClassFilter . matches ( TestBean .class ) ) ; assertTrue ( STRING , org.springframework.aop.aspectj.TypePatternClassFilter . matches ( ITestBean .class ) ) ; assertTrue ( STRING , org.springframework.aop.aspectj.TypePatternClassFilter . matches ( CountingTestBean .class ) ) ; assertFalse ( STRING , org.springframework.aop.aspectj.TypePatternClassFilter . matches ( IOther .class ) ) ; assertFalse ( STRING , org.springframework.aop.aspectj.TypePatternClassFilter . matches ( DefaultListableBeanFactory .class ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { TypePatternClassFilter org.springframework.aop.aspectj.TypePatternClassFilter = new TypePatternClassFilter ( STRING ) ; assertFalse ( STRING , org.springframework.aop.aspectj.TypePatternClassFilter . matches ( java.lang.Number .class ) ) ; assertTrue ( STRING , org.springframework.aop.aspectj.TypePatternClassFilter . matches ( java.lang.Object .class ) ) ; assertTrue ( STRING , org.springframework.aop.aspectj.TypePatternClassFilter . matches ( java.lang.String .class ) ) ; org.springframework.aop.aspectj.TypePatternClassFilter = new TypePatternClassFilter ( STRING ) ; assertTrue ( STRING , org.springframework.aop.aspectj.TypePatternClassFilter . matches ( java.lang.Float .class ) ) ; assertFalse ( STRING , org.springframework.aop.aspectj.TypePatternClassFilter . matches ( java.lang.Double .class ) ) ; org.springframework.aop.aspectj.TypePatternClassFilter = new TypePatternClassFilter ( STRING ) ; assertFalse ( STRING , org.springframework.aop.aspectj.TypePatternClassFilter . matches ( java.lang.Float .class ) ) ; assertTrue ( STRING , org.springframework.aop.aspectj.TypePatternClassFilter . matches ( java.lang.Double .class ) ) ; }  <METHOD_END>
<METHOD_START> @ Test ( expected = java.lang.IllegalArgumentException .class ) public void void ( ) java.lang.Exception { new TypePatternClassFilter ( null ) ; }  <METHOD_END>
<METHOD_START> @ Test ( expected = java.lang.IllegalStateException .class ) public void void ( ) java.lang.Exception { new TypePatternClassFilter ( ) . matches ( java.lang.String .class ) ; }  <METHOD_END>
