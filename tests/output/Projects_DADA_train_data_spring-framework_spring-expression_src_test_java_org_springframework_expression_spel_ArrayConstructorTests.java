<METHOD_START> @ Test public void void ( ) { java.lang.String ( STRING , STRING ) ; java.lang.String ( STRING , STRING ) ; evaluate ( STRING , STRING , java.lang.Integer .class ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { evaluate ( STRING , STRING , java.lang.String .class ) ; evaluate ( STRING , NUMBER , java.lang.Integer .class ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { evaluateAndCheckError ( STRING , SpelMessage . MULTIDIM_ARRAY_INITIALIZER_NOT_SUPPORTED ) ; evaluateAndCheckError ( STRING , SpelMessage . MISSING_ARRAY_DIMENSION ) ; evaluateAndCheckError ( STRING , SpelMessage . MISSING_ARRAY_DIMENSION ) ; evaluateAndCheckError ( STRING , SpelMessage . MISSING_ARRAY_DIMENSION ) ; evaluateAndCheckError ( STRING , SpelMessage . MISSING_ARRAY_DIMENSION ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { java.lang.String ( STRING , STRING ) ; java.lang.String ( STRING , STRING ) ; java.lang.String ( STRING , STRING ) ; java.lang.String ( STRING , STRING ) ; java.lang.String ( STRING , STRING ) ; java.lang.String ( STRING , STRING ) ; java.lang.String ( STRING , STRING ) ; java.lang.String ( STRING , STRING ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { evaluate ( STRING , NUMBER , java.lang.Integer .class ) ; evaluate ( STRING , true , java.lang.Boolean .class ) ; evaluate ( STRING , 'a' , java.lang.Character .class ) ; evaluate ( STRING , NUMBER , java.lang.Long .class ) ; evaluate ( STRING , ( short ) NUMBER , java.lang.Short .class ) ; evaluate ( STRING , ( double ) NUMBER , java.lang.Double .class ) ; evaluate ( STRING , ( float ) NUMBER , java.lang.Float .class ) ; evaluate ( STRING , ( byte ) NUMBER , java.lang.Byte .class ) ; evaluate ( STRING , STRING , java.lang.String .class ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { evaluateAndCheckError ( STRING , SpelMessage . INITIALIZER_LENGTH_INCORRECT ) ; evaluateAndCheckError ( STRING , SpelMessage . INITIALIZER_LENGTH_INCORRECT ) ; evaluateAndCheckError ( STRING , SpelMessage . TYPE_CONVERSION_ERROR ) ; evaluateAndCheckError ( STRING , SpelMessage . CONSTRUCTOR_INVOCATION_PROBLEM ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { evaluate ( STRING , STRING , java.lang.String .class ) ; evaluateAndCheckError ( STRING , SpelMessage . METHOD_NOT_FOUND , NUMBER , STRING , STRING ) ; evaluate ( STRING , NUMBER , java.lang.Integer .class ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { evaluate ( STRING , STRING , java.lang.String [] .class ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { evaluate ( STRING , STRING , java.lang.String [] [] .class ) ; evaluate ( STRING , STRING , java.lang.String [] [] [] .class ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { evaluateAndCheckError ( STRING , SpelMessage . MISSING_ARRAY_DIMENSION ) ; }  <METHOD_END>
<METHOD_START> public void void ( ) { evaluateAndCheckError ( STRING , SpelMessage . INCORRECT_ELEMENT_TYPE_FOR_ARRAY , NUMBER ) ; }  <METHOD_END>
<METHOD_START> private java.lang.String java.lang.String ( java.lang.String java.lang.String , java.lang.String java.lang.String ) { SpelExpressionParser org.springframework.expression.spel.SpelExpressionParser = new SpelExpressionParser ( ) ; Expression org.springframework.expression.spel.Expression = org.springframework.expression.spel.SpelExpressionParser . parseExpression ( java.lang.String ) ; java.lang.Object java.lang.Object = org.springframework.expression.spel.Expression . getValue ( ) ; assertNotNull ( java.lang.Object ) ; assertTrue ( java.lang.Object . java.lang.Class<? extends java.lang.Object> ( ) . boolean ( ) ) ; java.lang.StringBuilder java.lang.StringBuilder = new java.lang.StringBuilder ( ) ; java.lang.StringBuilder . java.lang.StringBuilder ( '[' ) ; if ( java.lang.Object instanceof int [] ) { int [] int[] = ( int [] ) java.lang.Object ; for ( int int = NUMBER ; int < int[] . int ; int ++ ) { if ( int > NUMBER ) { java.lang.StringBuilder . java.lang.StringBuilder ( ',' ) ; } java.lang.StringBuilder . java.lang.StringBuilder ( int[] [ int ] ) ; } } else if ( java.lang.Object instanceof boolean [] ) { boolean [] boolean[] = ( boolean [] ) java.lang.Object ; for ( int int = NUMBER ; int < boolean[] . int ; int ++ ) { if ( int > NUMBER ) { java.lang.StringBuilder . java.lang.StringBuilder ( ',' ) ; } java.lang.StringBuilder . java.lang.StringBuilder ( boolean[] [ int ] ) ; } } else if ( java.lang.Object instanceof char [] ) { char [] char[] = ( char [] ) java.lang.Object ; for ( int int = NUMBER ; int < char[] . int ; int ++ ) { if ( int > NUMBER ) { java.lang.StringBuilder . java.lang.StringBuilder ( ',' ) ; } java.lang.StringBuilder . java.lang.StringBuilder ( char[] [ int ] ) ; } } else if ( java.lang.Object instanceof long [] ) { long [] long[] = ( long [] ) java.lang.Object ; for ( int int = NUMBER ; int < long[] . int ; int ++ ) { if ( int > NUMBER ) { java.lang.StringBuilder . java.lang.StringBuilder ( ',' ) ; } java.lang.StringBuilder . java.lang.StringBuilder ( long[] [ int ] ) ; } } else if ( java.lang.Object instanceof short [] ) { short [] short[] = ( short [] ) java.lang.Object ; for ( int int = NUMBER ; int < short[] . int ; int ++ ) { if ( int > NUMBER ) { java.lang.StringBuilder . java.lang.StringBuilder ( ',' ) ; } java.lang.StringBuilder . java.lang.StringBuilder ( short[] [ int ] ) ; } } else if ( java.lang.Object instanceof double [] ) { double [] double[] = ( double [] ) java.lang.Object ; for ( int int = NUMBER ; int < double[] . int ; int ++ ) { if ( int > NUMBER ) { java.lang.StringBuilder . java.lang.StringBuilder ( ',' ) ; } java.lang.StringBuilder . java.lang.StringBuilder ( double[] [ int ] ) ; } } else if ( java.lang.Object instanceof float [] ) { float [] float[] = ( float [] ) java.lang.Object ; for ( int int = NUMBER ; int < float[] . int ; int ++ ) { if ( int > NUMBER ) { java.lang.StringBuilder . java.lang.StringBuilder ( ',' ) ; } java.lang.StringBuilder . java.lang.StringBuilder ( float[] [ int ] ) ; } } else if ( java.lang.Object instanceof byte [] ) { byte [] byte[] = ( byte [] ) java.lang.Object ; for ( int int = NUMBER ; int < byte[] . int ; int ++ ) { if ( int > NUMBER ) { java.lang.StringBuilder . java.lang.StringBuilder ( ',' ) ; } java.lang.StringBuilder . java.lang.StringBuilder ( byte[] [ int ] ) ; } } else { fail ( STRING + java.lang.Object . java.lang.Class<? extends java.lang.Object> ( ) ) ; } java.lang.StringBuilder . java.lang.StringBuilder ( ']' ) ; assertEquals ( java.lang.String , java.lang.StringBuilder . java.lang.String ( ) ) ; return java.lang.StringBuilder . java.lang.String ( ) ; }  <METHOD_END>
