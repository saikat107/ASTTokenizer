<METHOD_START> @ Test ( expected = java.lang.IllegalArgumentException .class ) public void void ( ) java.lang.Exception { new PartTree ( null , java.lang.Class<? extends org.springframework.data.repository.query.parser.PartTreeUnitTests> ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test ( expected = java.lang.IllegalArgumentException .class ) public void void ( ) java.lang.Exception { new PartTree ( STRING , null ) ; }  <METHOD_END>
<METHOD_START> @ Test ( expected = java.lang.IllegalArgumentException .class ) public void void ( ) java.lang.Exception { partTree ( STRING ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { PartTree org.springframework.data.repository.query.parser.PartTree = partTree ( STRING ) ; assertPart ( org.springframework.data.repository.query.parser.PartTree , parts ( STRING ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { PartTree org.springframework.data.repository.query.parser.PartTree = partTree ( STRING ) ; assertPart ( org.springframework.data.repository.query.parser.PartTree , parts ( STRING , STRING ) ) ; assertThat ( org.springframework.data.repository.query.parser.PartTree . getSort ( ) . isSorted ( ) ) . isFalse ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { PartTree org.springframework.data.repository.query.parser.PartTree = partTree ( STRING ) ; assertPart ( org.springframework.data.repository.query.parser.PartTree , parts ( STRING ) , parts ( STRING ) ) ; assertThat ( org.springframework.data.repository.query.parser.PartTree . getSort ( ) . isSorted ( ) ) . isFalse ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { PartTree org.springframework.data.repository.query.parser.PartTree = partTree ( STRING ) ; assertPart ( org.springframework.data.repository.query.parser.PartTree , parts ( STRING , STRING ) , parts ( STRING ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { assertThat ( partTree ( STRING ) . getSort ( ) ) . isEqualTo ( Sort . by ( STRING ) . descending ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { void ( STRING ) ; void ( STRING ) ; void ( STRING ) ; }  <METHOD_END>
<METHOD_START> private void void ( java.lang.String java.lang.String ) throws java.lang.Exception { PartTree org.springframework.data.repository.query.parser.PartTree = partTree ( java.lang.String ) ; assertThat ( org.springframework.data.repository.query.parser.PartTree . getSort ( ) ) . isEqualTo ( Sort . by ( STRING ) . descending ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { for ( java.lang.String java.lang.String : java.lang.String[] ) { org.springframework.data.repository.query.parser.PartTree ( java.lang.String + STRING , true ) ; org.springframework.data.repository.query.parser.PartTree ( java.lang.String + STRING , true ) ; org.springframework.data.repository.query.parser.PartTree ( java.lang.String + STRING , true ) ; org.springframework.data.repository.query.parser.PartTree ( java.lang.String + STRING , false ) ; org.springframework.data.repository.query.parser.PartTree ( java.lang.String + STRING , false ) ; PartTree org.springframework.data.repository.query.parser.PartTree = org.springframework.data.repository.query.parser.PartTree ( java.lang.String + STRING , false ) ; assertThat ( org.springframework.data.repository.query.parser.PartTree . getSort ( ) ) . isEqualTo ( Sort . by ( STRING ) . descending ( ) ) ; } }  <METHOD_END>
<METHOD_START> private org.springframework.data.repository.query.parser.PartTree org.springframework.data.repository.query.parser.PartTree ( java.lang.String java.lang.String , boolean boolean ) { PartTree org.springframework.data.repository.query.parser.PartTree = partTree ( java.lang.String ) ; assertThat ( org.springframework.data.repository.query.parser.PartTree . isDistinct ( ) ) . isEqualTo ( boolean ) ; return org.springframework.data.repository.query.parser.PartTree ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { PartTree org.springframework.data.repository.query.parser.PartTree = partTree ( STRING ) ; for ( Part org.springframework.data.repository.query.parser.Part : org.springframework.data.repository.query.parser.PartTree . getParts ( ) ) { assertThat ( org.springframework.data.repository.query.parser.Part . getType ( ) ) . isEqualTo ( Type . WITHIN ) ; assertThat ( org.springframework.data.repository.query.parser.Part . getProperty ( ) ) . isEqualTo ( newProperty ( STRING ) ) ; } }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { assertType ( java.util.Collections . java.util.List<java.lang.String> ( STRING ) , NEAR , STRING ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { assertType ( java.util.Collections . java.util.List<java.lang.String> ( STRING ) , SIMPLE_PROPERTY , STRING ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { PartTree org.springframework.data.repository.query.parser.PartTree = partTree ( STRING ) ; assertThat ( org.springframework.data.repository.query.parser.PartTree . toString ( ) ) . isEqualTo ( STRING ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { void ( STRING , IgnoreCaseType . WHEN_POSSIBLE ) ; void ( STRING , IgnoreCaseType . WHEN_POSSIBLE ) ; void ( STRING , IgnoreCaseType . WHEN_POSSIBLE ) ; void ( STRING , IgnoreCaseType . WHEN_POSSIBLE ) ; void ( STRING , IgnoreCaseType . NEVER ) ; void ( STRING , IgnoreCaseType . NEVER ) ; }  <METHOD_END>
<METHOD_START> private void void ( java.lang.String java.lang.String , IgnoreCaseType org.springframework.data.repository.query.parser.IgnoreCaseType ) throws java.lang.Exception { PartTree org.springframework.data.repository.query.parser.PartTree = partTree ( java.lang.String ) ; for ( Part org.springframework.data.repository.query.parser.Part : org.springframework.data.repository.query.parser.PartTree . getParts ( ) ) { assertThat ( org.springframework.data.repository.query.parser.Part . shouldIgnoreCase ( ) ) . isEqualTo ( org.springframework.data.repository.query.parser.IgnoreCaseType ) ; } }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { PartTree org.springframework.data.repository.query.parser.PartTree = partTree ( STRING ) ; assertPart ( org.springframework.data.repository.query.parser.PartTree , parts ( STRING , STRING ) ) ; java.util.Iterator<org.springframework.data.repository.query.parser.Part> < Part > java.util.Iterator<org.springframework.data.repository.query.parser.Part> = org.springframework.data.repository.query.parser.PartTree . getParts ( ) . iterator ( ) ; assertThat ( java.util.Iterator<org.springframework.data.repository.query.parser.Part> . next ( ) . shouldIgnoreCase ( ) ) . isEqualTo ( IgnoreCaseType . ALWAYS ) ; assertThat ( java.util.Iterator<org.springframework.data.repository.query.parser.Part> . next ( ) . shouldIgnoreCase ( ) ) . isEqualTo ( IgnoreCaseType . NEVER ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { PartTree org.springframework.data.repository.query.parser.PartTree = partTree ( STRING ) ; assertPart ( org.springframework.data.repository.query.parser.PartTree , parts ( STRING , STRING ) ) ; java.util.Iterator<org.springframework.data.repository.query.parser.Part> < Part > java.util.Iterator<org.springframework.data.repository.query.parser.Part> = org.springframework.data.repository.query.parser.PartTree . getParts ( ) . iterator ( ) ; assertThat ( java.util.Iterator<org.springframework.data.repository.query.parser.Part> . next ( ) . shouldIgnoreCase ( ) ) . isEqualTo ( IgnoreCaseType . ALWAYS ) ; assertThat ( java.util.Iterator<org.springframework.data.repository.query.parser.Part> . next ( ) . shouldIgnoreCase ( ) ) . isEqualTo ( IgnoreCaseType . NEVER ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { assertType ( java.util.Arrays . java.util.List<java.lang.String> ( STRING , STRING ) , LESS_THAN_EQUAL , STRING ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { assertType ( java.util.Arrays . java.util.List<java.lang.String> ( STRING , STRING ) , GREATER_THAN_EQUAL , STRING ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { PartTree org.springframework.data.repository.query.parser.PartTree = partTree ( STRING ) ; assertPart ( org.springframework.data.repository.query.parser.PartTree , parts ( STRING , STRING ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { PartTree org.springframework.data.repository.query.parser.PartTree = partTree ( STRING ) ; java.util.Collection<org.springframework.data.repository.query.parser.Part> < Part > java.util.Collection<org.springframework.data.repository.query.parser.Part> = toCollection ( org.springframework.data.repository.query.parser.PartTree . getParts ( Type . SIMPLE_PROPERTY ) ) ; assertThat ( java.util.Collection<org.springframework.data.repository.query.parser.Part> ) . containsExactly ( part ( STRING ) ) ; java.util.Collection<org.springframework.data.repository.query.parser.Part> = toCollection ( org.springframework.data.repository.query.parser.PartTree . getParts ( Type . GREATER_THAN ) ) ; assertThat ( java.util.Collection<org.springframework.data.repository.query.parser.Part> ) . containsExactly ( new Part ( STRING , User .class ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { assertType ( java.util.Collections . java.util.List<java.lang.String> ( STRING ) , EXISTS , STRING , NUMBER , false ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { assertType ( java.util.List<java.lang.String> ( STRING , STRING , STRING ) , REGEX , STRING ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { assertType ( java.util.List<java.lang.String> ( STRING , STRING ) , TRUE , STRING , NUMBER , false ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { assertType ( java.util.List<java.lang.String> ( STRING , STRING ) , FALSE , STRING , NUMBER , false ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { assertType ( java.util.List<java.lang.String> ( STRING , STRING , STRING ) , STARTING_WITH , STRING ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { assertType ( java.util.List<java.lang.String> ( STRING , STRING , STRING ) , ENDING_WITH , STRING ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { assertType ( java.util.List<java.lang.String> ( STRING , STRING , STRING ) , CONTAINING , STRING ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { assertType ( java.util.List<java.lang.String> ( STRING , STRING ) , Type . AFTER , STRING ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { assertType ( java.util.Arrays . java.util.List<java.lang.String> ( STRING , STRING ) , Type . BEFORE , STRING ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { assertType ( java.util.List<java.lang.String> ( STRING , STRING ) , LIKE , STRING ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { assertType ( java.util.List<java.lang.String> ( STRING , STRING ) , NOT_LIKE , STRING ) ; }  <METHOD_END>
