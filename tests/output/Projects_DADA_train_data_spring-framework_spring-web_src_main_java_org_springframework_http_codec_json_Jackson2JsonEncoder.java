<METHOD_START> public void ( ) { this( Jackson2ObjectMapperBuilder . json ( ) . build ( ) ); }  <METHOD_END>
<METHOD_START> public void ( ObjectMapper org.springframework.http.codec.json.ObjectMapper ) { super( org.springframework.http.codec.json.ObjectMapper ); this . java.util.List<org.springframework.http.codec.json.MediaType> . add ( MediaType . APPLICATION_STREAM_JSON ) ; this . org.springframework.http.codec.json.PrettyPrinter = org.springframework.http.codec.json.PrettyPrinter ( ) ; }  <METHOD_END>
<METHOD_START> private static org.springframework.http.codec.json.PrettyPrinter org.springframework.http.codec.json.PrettyPrinter ( ) { DefaultPrettyPrinter org.springframework.http.codec.json.DefaultPrettyPrinter = new DefaultPrettyPrinter ( ) ; org.springframework.http.codec.json.DefaultPrettyPrinter . indentObjectsWith ( new DefaultIndenter ( STRING , STRING ) ) ; return org.springframework.http.codec.json.DefaultPrettyPrinter ; }  <METHOD_END>
<METHOD_START> public void void ( java.util.List<org.springframework.http.codec.json.MediaType> < MediaType > java.util.List<org.springframework.http.codec.json.MediaType> ) { this . java.util.List<org.springframework.http.codec.json.MediaType> . clear ( ) ; this . java.util.List<org.springframework.http.codec.json.MediaType> . addAll ( java.util.List<org.springframework.http.codec.json.MediaType> ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.util.List<org.springframework.http.codec.json.MimeType> < MimeType > java.util.List<org.springframework.http.codec.json.MimeType> ( ) { return JSON_MIME_TYPES ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( ResolvableType org.springframework.http.codec.json.ResolvableType , MimeType org.springframework.http.codec.json.MimeType ) { java.lang.Class<?> < ? > java.lang.Class<?> = org.springframework.http.codec.json.ResolvableType . getRawClass ( ) ; return ( this . objectMapper . canSerialize ( java.lang.Class<> ) && supportsMimeType ( org.springframework.http.codec.json.MimeType ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.http.codec.json.Flux<org.springframework.http.codec.json.DataBuffer> < DataBuffer > org.springframework.http.codec.json.Flux<org.springframework.http.codec.json.DataBuffer> ( Publisher < ? > org.springframework.http.codec.json.Publisher<?> , DataBufferFactory org.springframework.http.codec.json.DataBufferFactory , ResolvableType org.springframework.http.codec.json.ResolvableType , MimeType org.springframework.http.codec.json.MimeType , java.util.Map<java.lang.String,java.lang.Object> < java.lang.String , java.lang.Object > java.util.Map<java.lang.String,java.lang.Object> ) { Assert . notNull ( org.springframework.http.codec.json.Publisher<> , STRING ) ; Assert . notNull ( org.springframework.http.codec.json.DataBufferFactory , STRING ) ; Assert . notNull ( org.springframework.http.codec.json.ResolvableType , STRING ) ; if ( org.springframework.http.codec.json.Publisher<> instanceof Mono ) { return Flux . from ( org.springframework.http.codec.json.Publisher<> ) . map ( value -> encodeValue ( value , mimeType , bufferFactory , elementType , hints ) ) ; } else if ( MediaType . APPLICATION_STREAM_JSON . isCompatibleWith ( org.springframework.http.codec.json.MimeType ) ) { return Flux . from ( org.springframework.http.codec.json.Publisher<> ) . map ( value -> { DataBuffer buffer = encodeValue ( value , mimeType , bufferFactory , elementType , hints ) ; buffer . write ( new byte [] { '\n' } ) ; return buffer ; } ) ; } else { ResolvableType org.springframework.http.codec.json.ResolvableType = ResolvableType . forClassWithGenerics ( java.util.List .class , org.springframework.http.codec.json.ResolvableType ) ; return Flux . from ( org.springframework.http.codec.json.Publisher<> ) . collectList ( ) . map ( list -> encodeValue ( list , mimeType , bufferFactory , listType , hints ) ) . flux ( ) ; } }  <METHOD_END>
<METHOD_START> private org.springframework.http.codec.json.DataBuffer org.springframework.http.codec.json.DataBuffer ( java.lang.Object java.lang.Object , MimeType org.springframework.http.codec.json.MimeType , DataBufferFactory org.springframework.http.codec.json.DataBufferFactory , ResolvableType org.springframework.http.codec.json.ResolvableType , java.util.Map<java.lang.String,java.lang.Object> < java.lang.String , java.lang.Object > java.util.Map<java.lang.String,java.lang.Object> ) { TypeFactory org.springframework.http.codec.json.TypeFactory = this . objectMapper . getTypeFactory ( ) ; JavaType org.springframework.http.codec.json.JavaType = org.springframework.http.codec.json.TypeFactory . constructType ( org.springframework.http.codec.json.ResolvableType . getType ( ) ) ; if ( org.springframework.http.codec.json.ResolvableType . isInstance ( java.lang.Object ) ) { org.springframework.http.codec.json.JavaType = getJavaType ( org.springframework.http.codec.json.ResolvableType . getType ( ) , null ) ; } java.lang.Class<?> < ? > java.lang.Class<?> = ( java.lang.Class<?> < ? > ) java.util.Map<java.lang.String,java.lang.Object> . java.lang.Object ( Jackson2CodecSupport . JSON_VIEW_HINT ) ; ObjectWriter org.springframework.http.codec.json.ObjectWriter = ( java.lang.Class<> != null ? this . objectMapper . writerWithView ( java.lang.Class<> ) : this . objectMapper . writer ( ) ) ; if ( org.springframework.http.codec.json.JavaType != null && org.springframework.http.codec.json.JavaType . isContainerType ( ) ) { org.springframework.http.codec.json.ObjectWriter = org.springframework.http.codec.json.ObjectWriter . forType ( org.springframework.http.codec.json.JavaType ) ; } if ( MediaType . TEXT_EVENT_STREAM . isCompatibleWith ( org.springframework.http.codec.json.MimeType ) && org.springframework.http.codec.json.ObjectWriter . getConfig ( ) . isEnabled ( SerializationFeature . INDENT_OUTPUT ) ) { org.springframework.http.codec.json.ObjectWriter = org.springframework.http.codec.json.ObjectWriter . with ( this . org.springframework.http.codec.json.PrettyPrinter ) ; } DataBuffer org.springframework.http.codec.json.DataBuffer = org.springframework.http.codec.json.DataBufferFactory . allocateBuffer ( ) ; java.io.OutputStream java.io.OutputStream = org.springframework.http.codec.json.DataBuffer . asOutputStream ( ) ; try { org.springframework.http.codec.json.ObjectWriter . writeValue ( java.io.OutputStream , java.lang.Object ) ; } catch ( java.io.IOException java.io.IOException ) { throw new CodecException ( STRING , java.io.IOException ) ; } return org.springframework.http.codec.json.DataBuffer ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.util.List<org.springframework.http.codec.json.MediaType> < MediaType > java.util.List<org.springframework.http.codec.json.MediaType> ( ) { return java.util.Collections . java.util.List<org.springframework.http.codec.json.MediaType> ( this . java.util.List<org.springframework.http.codec.json.MediaType> ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.util.Map<java.lang.String,java.lang.Object> < java.lang.String , java.lang.Object > java.util.Map<java.lang.String,java.lang.Object> ( ResolvableType org.springframework.http.codec.json.ResolvableType , ResolvableType org.springframework.http.codec.json.ResolvableType , MediaType org.springframework.http.codec.json.MediaType , ServerHttpRequest org.springframework.http.codec.json.ServerHttpRequest , ServerHttpResponse org.springframework.http.codec.json.ServerHttpResponse ) { return getHints ( org.springframework.http.codec.json.ResolvableType ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected < A extends java.lang.annotation.Annotation > A A ( MethodParameter org.springframework.http.codec.json.MethodParameter , java.lang.Class<A> < A > java.lang.Class<A> ) { return org.springframework.http.codec.json.MethodParameter . getMethodAnnotation ( java.lang.Class<A> ) ; }  <METHOD_END>
