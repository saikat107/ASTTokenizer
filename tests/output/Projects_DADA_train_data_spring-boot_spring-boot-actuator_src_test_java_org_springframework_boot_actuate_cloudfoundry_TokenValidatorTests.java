<METHOD_START> @ Before public void void ( ) java.lang.Exception { MockitoAnnotations . initMocks ( this ) ; this . org.springframework.boot.actuate.cloudfoundry.TokenValidator = new TokenValidator ( this . org.springframework.boot.actuate.cloudfoundry.CloudFoundrySecurityService ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { ReflectionTestUtils . setField ( this . org.springframework.boot.actuate.cloudfoundry.TokenValidator , STRING , java.util.Map<java.lang.String,java.lang.String> ) ; given ( this . org.springframework.boot.actuate.cloudfoundry.CloudFoundrySecurityService . fetchTokenKeys ( ) ) . willReturn ( java.util.Map<java.lang.String,java.lang.String> ) ; java.lang.String java.lang.String = STRING ; java.lang.String java.lang.String = STRING ; this . org.springframework.boot.actuate.cloudfoundry.ExpectedException . expect ( AuthorizationExceptionMatcher . withReason ( Reason . INVALID_KEY_ID ) ) ; this . org.springframework.boot.actuate.cloudfoundry.TokenValidator . validate ( new Token ( java.lang.String ( java.lang.String . byte[] ( ) , java.lang.String . byte[] ( ) ) ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { ReflectionTestUtils . setField ( this . org.springframework.boot.actuate.cloudfoundry.TokenValidator , STRING , java.util.Map<java.lang.String,java.lang.String> ) ; given ( this . org.springframework.boot.actuate.cloudfoundry.CloudFoundrySecurityService . fetchTokenKeys ( ) ) . willReturn ( java.util.Map<java.lang.String,java.lang.String> ) ; given ( this . org.springframework.boot.actuate.cloudfoundry.CloudFoundrySecurityService . getUaaUrl ( ) ) . willReturn ( STRING ) ; java.lang.String java.lang.String = STRING ; java.lang.String java.lang.String = STRING ; this . org.springframework.boot.actuate.cloudfoundry.TokenValidator . validate ( new Token ( java.lang.String ( java.lang.String . byte[] ( ) , java.lang.String . byte[] ( ) ) ) ) ; verify ( this . org.springframework.boot.actuate.cloudfoundry.CloudFoundrySecurityService ) . fetchTokenKeys ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { given ( this . org.springframework.boot.actuate.cloudfoundry.CloudFoundrySecurityService . fetchTokenKeys ( ) ) . willReturn ( java.util.Map<java.lang.String,java.lang.String> ) ; given ( this . org.springframework.boot.actuate.cloudfoundry.CloudFoundrySecurityService . getUaaUrl ( ) ) . willReturn ( STRING ) ; java.lang.String java.lang.String = STRING ; java.lang.String java.lang.String = STRING ; this . org.springframework.boot.actuate.cloudfoundry.TokenValidator . validate ( new Token ( java.lang.String ( java.lang.String . byte[] ( ) , java.lang.String . byte[] ( ) ) ) ) ; verify ( this . org.springframework.boot.actuate.cloudfoundry.CloudFoundrySecurityService ) . fetchTokenKeys ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { ReflectionTestUtils . setField ( this . org.springframework.boot.actuate.cloudfoundry.TokenValidator , STRING , java.util.Map<java.lang.String,java.lang.String> ) ; given ( this . org.springframework.boot.actuate.cloudfoundry.CloudFoundrySecurityService . getUaaUrl ( ) ) . willReturn ( STRING ) ; java.lang.String java.lang.String = STRING ; java.lang.String java.lang.String = STRING ; this . org.springframework.boot.actuate.cloudfoundry.TokenValidator . validate ( new Token ( java.lang.String ( java.lang.String . byte[] ( ) , java.lang.String . byte[] ( ) ) ) ) ; verify ( this . org.springframework.boot.actuate.cloudfoundry.CloudFoundrySecurityService , Mockito . never ( ) ) . fetchTokenKeys ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { ReflectionTestUtils . setField ( this . org.springframework.boot.actuate.cloudfoundry.TokenValidator , STRING , java.util.Collections . java.util.Map<java.lang.String,java.lang.String> ( STRING , java.lang.String ) ) ; given ( this . org.springframework.boot.actuate.cloudfoundry.CloudFoundrySecurityService . getUaaUrl ( ) ) . willReturn ( STRING ) ; java.lang.String java.lang.String = STRING ; java.lang.String java.lang.String = STRING ; this . org.springframework.boot.actuate.cloudfoundry.ExpectedException . expect ( AuthorizationExceptionMatcher . withReason ( Reason . INVALID_SIGNATURE ) ) ; this . org.springframework.boot.actuate.cloudfoundry.TokenValidator . validate ( new Token ( java.lang.String ( java.lang.String . byte[] ( ) , java.lang.String . byte[] ( ) ) ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { given ( this . org.springframework.boot.actuate.cloudfoundry.CloudFoundrySecurityService . fetchTokenKeys ( ) ) . willReturn ( java.util.Map<java.lang.String,java.lang.String> ) ; java.lang.String java.lang.String = STRING ; java.lang.String java.lang.String = STRING ; this . org.springframework.boot.actuate.cloudfoundry.ExpectedException . expect ( AuthorizationExceptionMatcher . withReason ( Reason . UNSUPPORTED_TOKEN_SIGNING_ALGORITHM ) ) ; this . org.springframework.boot.actuate.cloudfoundry.TokenValidator . validate ( new Token ( java.lang.String ( java.lang.String . byte[] ( ) , java.lang.String . byte[] ( ) ) ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { given ( this . org.springframework.boot.actuate.cloudfoundry.CloudFoundrySecurityService . fetchTokenKeys ( ) ) . willReturn ( java.util.Map<java.lang.String,java.lang.String> ) ; given ( this . org.springframework.boot.actuate.cloudfoundry.CloudFoundrySecurityService . fetchTokenKeys ( ) ) . willReturn ( java.util.Map<java.lang.String,java.lang.String> ) ; java.lang.String java.lang.String = STRING ; java.lang.String java.lang.String = STRING ; this . org.springframework.boot.actuate.cloudfoundry.ExpectedException . expect ( AuthorizationExceptionMatcher . withReason ( Reason . TOKEN_EXPIRED ) ) ; this . org.springframework.boot.actuate.cloudfoundry.TokenValidator . validate ( new Token ( java.lang.String ( java.lang.String . byte[] ( ) , java.lang.String . byte[] ( ) ) ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { given ( this . org.springframework.boot.actuate.cloudfoundry.CloudFoundrySecurityService . fetchTokenKeys ( ) ) . willReturn ( java.util.Map<java.lang.String,java.lang.String> ) ; given ( this . org.springframework.boot.actuate.cloudfoundry.CloudFoundrySecurityService . getUaaUrl ( ) ) . willReturn ( STRING ) ; java.lang.String java.lang.String = STRING ; java.lang.String java.lang.String = STRING ; this . org.springframework.boot.actuate.cloudfoundry.ExpectedException . expect ( AuthorizationExceptionMatcher . withReason ( Reason . INVALID_ISSUER ) ) ; this . org.springframework.boot.actuate.cloudfoundry.TokenValidator . validate ( new Token ( java.lang.String ( java.lang.String . byte[] ( ) , java.lang.String . byte[] ( ) ) ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { given ( this . org.springframework.boot.actuate.cloudfoundry.CloudFoundrySecurityService . fetchTokenKeys ( ) ) . willReturn ( java.util.Map<java.lang.String,java.lang.String> ) ; given ( this . org.springframework.boot.actuate.cloudfoundry.CloudFoundrySecurityService . getUaaUrl ( ) ) . willReturn ( STRING ) ; java.lang.String java.lang.String = STRING ; java.lang.String java.lang.String = STRING ; this . org.springframework.boot.actuate.cloudfoundry.ExpectedException . expect ( AuthorizationExceptionMatcher . withReason ( Reason . INVALID_AUDIENCE ) ) ; this . org.springframework.boot.actuate.cloudfoundry.TokenValidator . validate ( new Token ( java.lang.String ( java.lang.String . byte[] ( ) , java.lang.String . byte[] ( ) ) ) ) ; }  <METHOD_END>
<METHOD_START> private java.lang.String java.lang.String ( byte [] byte[] , byte [] byte[] ) throws java.lang.Exception { java.security.PrivateKey java.security.PrivateKey = java.security.PrivateKey ( ) ; java.security.Signature java.security.Signature = java.security.Signature . java.security.Signature ( STRING ) ; java.security.Signature . void ( java.security.PrivateKey ) ; byte [] byte[] = byte[] ( Base64Utils . encodeUrlSafe ( byte[] ) , Base64Utils . encode ( byte[] ) ) ; java.security.Signature . void ( byte[] ) ; byte [] byte[] = java.security.Signature . byte[] ( ) ; byte [] byte[] = byte[] ( Base64Utils . encodeUrlSafe ( byte[] ) , Base64Utils . encodeUrlSafe ( byte[] ) , Base64Utils . encodeUrlSafe ( byte[] ) ) ; return new java.lang.String ( byte[] , java.nio.charset.Charset ) ; }  <METHOD_END>
<METHOD_START> private java.security.PrivateKey java.security.PrivateKey ( ) java.security.spec.InvalidKeySpecException , java.security.NoSuchAlgorithmException { java.lang.String java.lang.String = STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING ; java.lang.String java.lang.String = java.lang.String . java.lang.String ( STRING , STRING ) ; java.lang.String = java.lang.String . java.lang.String ( STRING , STRING ) ; byte [] byte[] = Base64 . decodeBase64 ( java.lang.String ) ; java.security.spec.PKCS8EncodedKeySpec java.security.spec.PKCS8EncodedKeySpec = new java.security.spec.PKCS8EncodedKeySpec ( byte[] ) ; java.security.KeyFactory java.security.KeyFactory = java.security.KeyFactory . java.security.KeyFactory ( STRING ) ; return java.security.KeyFactory . java.security.PrivateKey ( java.security.spec.PKCS8EncodedKeySpec ) ; }  <METHOD_END>
<METHOD_START> private byte [] byte[] ( byte [] ... byte[][] ) throws java.io.IOException { java.io.ByteArrayOutputStream java.io.ByteArrayOutputStream = new java.io.ByteArrayOutputStream ( ) ; for ( int int = NUMBER ; int < byte[][] . int ; int ++ ) { if ( int > NUMBER ) { StreamUtils . copy ( byte[] , java.io.ByteArrayOutputStream ) ; } StreamUtils . copy ( byte[][] [ int ] , java.io.ByteArrayOutputStream ) ; } return java.io.ByteArrayOutputStream . byte[] ( ) ; }  <METHOD_END>
