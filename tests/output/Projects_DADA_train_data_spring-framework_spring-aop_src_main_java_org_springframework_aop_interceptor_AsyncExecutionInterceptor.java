<METHOD_START> public void ( java.util.concurrent.Executor java.util.concurrent.Executor ) { super( java.util.concurrent.Executor ); }  <METHOD_END>
<METHOD_START> public void ( java.util.concurrent.Executor java.util.concurrent.Executor , AsyncUncaughtExceptionHandler org.springframework.aop.interceptor.AsyncUncaughtExceptionHandler ) { super( java.util.concurrent.Executor , org.springframework.aop.interceptor.AsyncUncaughtExceptionHandler ); }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.Object java.lang.Object ( final MethodInvocation org.springframework.aop.interceptor.MethodInvocation ) throws java.lang.Throwable { java.lang.Class<?> < ? > java.lang.Class<?> = ( org.springframework.aop.interceptor.MethodInvocation . getThis ( ) != null ? AopUtils . getTargetClass ( org.springframework.aop.interceptor.MethodInvocation . getThis ( ) ) : null ) ; java.lang.reflect.Method java.lang.reflect.Method = ClassUtils . getMostSpecificMethod ( org.springframework.aop.interceptor.MethodInvocation . getMethod ( ) , java.lang.Class<> ) ; final java.lang.reflect.Method java.lang.reflect.Method = BridgeMethodResolver . findBridgedMethod ( java.lang.reflect.Method ) ; AsyncTaskExecutor org.springframework.aop.interceptor.AsyncTaskExecutor = determineAsyncExecutor ( java.lang.reflect.Method ) ; if ( org.springframework.aop.interceptor.AsyncTaskExecutor == null ) { throw new java.lang.IllegalStateException ( STRING ) ; } java.util.concurrent.Callable<java.lang.Object> < java.lang.Object > java.util.concurrent.Callable<java.lang.Object> = new java.util.concurrent.Callable<java.lang.Object> < java.lang.Object > ( ) { @ java.lang.Override public java.lang.Object java.lang.Object ( ) java.lang.Exception { try { java.lang.Object java.lang.Object = org.springframework.aop.interceptor.MethodInvocation . proceed ( ) ; if ( java.lang.Object instanceof java.util.concurrent.Future ) { return ( ( java.util.concurrent.Future<?> < ? > ) java.lang.Object ) . get ( ) ; } } catch ( java.util.concurrent.ExecutionException java.util.concurrent.ExecutionException ) { handleError ( java.util.concurrent.ExecutionException . java.lang.Throwable ( ) , java.lang.reflect.Method , org.springframework.aop.interceptor.MethodInvocation . getArguments ( ) ) ; } catch ( java.lang.Throwable java.lang.Throwable ) { handleError ( java.lang.Throwable , java.lang.reflect.Method , org.springframework.aop.interceptor.MethodInvocation . getArguments ( ) ) ; } return null ; } } ; return doSubmit ( java.util.concurrent.Callable<java.lang.Object> , org.springframework.aop.interceptor.AsyncTaskExecutor , org.springframework.aop.interceptor.MethodInvocation . getMethod ( ) . getReturnType ( ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.Object java.lang.Object ( ) java.lang.Exception { try { java.lang.Object java.lang.Object = org.springframework.aop.interceptor.MethodInvocation . proceed ( ) ; if ( java.lang.Object instanceof java.util.concurrent.Future ) { return ( ( java.util.concurrent.Future<?> < ? > ) java.lang.Object ) . get ( ) ; } } catch ( java.util.concurrent.ExecutionException java.util.concurrent.ExecutionException ) { handleError ( java.util.concurrent.ExecutionException . java.lang.Throwable ( ) , java.lang.reflect.Method , org.springframework.aop.interceptor.MethodInvocation . getArguments ( ) ) ; } catch ( java.lang.Throwable java.lang.Throwable ) { handleError ( java.lang.Throwable , java.lang.reflect.Method , org.springframework.aop.interceptor.MethodInvocation . getArguments ( ) ) ; } return null ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected java.lang.String java.lang.String ( java.lang.reflect.Method java.lang.reflect.Method ) { return null ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected java.util.concurrent.Executor java.util.concurrent.Executor ( BeanFactory org.springframework.aop.interceptor.BeanFactory ) { java.util.concurrent.Executor java.util.concurrent.Executor = super. getDefaultExecutor ( org.springframework.aop.interceptor.BeanFactory ) ; return ( java.util.concurrent.Executor != null ? java.util.concurrent.Executor : new SimpleAsyncTaskExecutor ( ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public int int ( ) { return Ordered . HIGHEST_PRECEDENCE ; }  <METHOD_END>
