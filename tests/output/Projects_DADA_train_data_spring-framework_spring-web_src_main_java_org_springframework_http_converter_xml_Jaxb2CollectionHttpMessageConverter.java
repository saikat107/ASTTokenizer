<METHOD_START> @ java.lang.Override public boolean boolean ( java.lang.Class<?> < ? > java.lang.Class<?> , MediaType org.springframework.http.converter.xml.MediaType ) { return false ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( java.lang.reflect.Type java.lang.reflect.Type , java.lang.Class<?> < ? > java.lang.Class<?> , MediaType org.springframework.http.converter.xml.MediaType ) { if ( ! ( java.lang.reflect.Type instanceof java.lang.reflect.ParameterizedType ) ) { return false ; } java.lang.reflect.ParameterizedType java.lang.reflect.ParameterizedType = ( java.lang.reflect.ParameterizedType ) java.lang.reflect.Type ; if ( ! ( java.lang.reflect.ParameterizedType . java.lang.reflect.Type ( ) instanceof java.lang.Class ) ) { return false ; } java.lang.Class<?> < ? > java.lang.Class<?> = ( java.lang.Class<?> < ? > ) java.lang.reflect.ParameterizedType . java.lang.reflect.Type ( ) ; if ( ! ( java.util.Collection .class . boolean ( java.lang.Class<> ) ) ) { return false ; } if ( java.lang.reflect.ParameterizedType . java.lang.reflect.Type[] ( ) . int != NUMBER ) { return false ; } java.lang.reflect.Type java.lang.reflect.Type = java.lang.reflect.ParameterizedType . java.lang.reflect.Type[] ( ) [ NUMBER ] ; if ( ! ( java.lang.reflect.Type instanceof java.lang.Class ) ) { return false ; } java.lang.Class<?> < ? > java.lang.Class<?> = ( java.lang.Class<?> < ? > ) java.lang.reflect.Type ; return ( java.lang.Class<> . boolean ( javax.xml.bind.annotation.XmlRootElement .class ) || java.lang.Class<> . boolean ( javax.xml.bind.annotation.XmlType .class ) ) && boolean ( org.springframework.http.converter.xml.MediaType ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( java.lang.Class<?> < ? > java.lang.Class<?> , MediaType org.springframework.http.converter.xml.MediaType ) { return false ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( java.lang.reflect.Type java.lang.reflect.Type , java.lang.Class<?> < ? > java.lang.Class<?> , MediaType org.springframework.http.converter.xml.MediaType ) { return false ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected boolean boolean ( java.lang.Class<?> < ? > java.lang.Class<?> ) { throw new java.lang.UnsupportedOperationException ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected T T ( java.lang.Class<? extends T> < ? extends T > java.lang.Class<? extends T> , HttpHeaders org.springframework.http.converter.xml.HttpHeaders , javax.xml.transform.Source javax.xml.transform.Source ) throws java.io.IOException { throw new java.lang.UnsupportedOperationException ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override @ java.lang.SuppressWarnings ( STRING ) public T T ( java.lang.reflect.Type java.lang.reflect.Type , java.lang.Class<?> < ? > java.lang.Class<?> , HttpInputMessage org.springframework.http.converter.xml.HttpInputMessage )			throws java.io.IOException , org.springframework.http.converter.xml.HttpMessageNotReadableException { java.lang.reflect.ParameterizedType java.lang.reflect.ParameterizedType = ( java.lang.reflect.ParameterizedType ) java.lang.reflect.Type ; T T = T ( ( java.lang.Class<?> < ? > ) java.lang.reflect.ParameterizedType . java.lang.reflect.Type ( ) ) ; java.lang.Class<?> < ? > java.lang.Class<?> = ( java.lang.Class<?> < ? > ) java.lang.reflect.ParameterizedType . java.lang.reflect.Type[] ( ) [ NUMBER ] ; try { javax.xml.bind.Unmarshaller javax.xml.bind.Unmarshaller = createUnmarshaller ( java.lang.Class<> ) ; javax.xml.stream.XMLStreamReader javax.xml.stream.XMLStreamReader = this . javax.xml.stream.XMLInputFactory . javax.xml.stream.XMLStreamReader ( org.springframework.http.converter.xml.HttpInputMessage . getBody ( ) ) ; int int = int ( javax.xml.stream.XMLStreamReader ) ; while ( int != javax.xml.stream.XMLStreamReader . int ) { if ( java.lang.Class<> . boolean ( javax.xml.bind.annotation.XmlRootElement .class ) ) { T . boolean ( javax.xml.bind.Unmarshaller . java.lang.Object ( javax.xml.stream.XMLStreamReader ) ) ; } else if ( java.lang.Class<> . boolean ( javax.xml.bind.annotation.XmlType .class ) ) { T . boolean ( javax.xml.bind.Unmarshaller . javax.xml.bind.JAXBElement<> ( javax.xml.stream.XMLStreamReader , java.lang.Class<> ) . getValue ( ) ) ; } else { throw new HttpMessageConversionException ( STRING + java.lang.Class<> + STRING ) ; } int = int ( javax.xml.stream.XMLStreamReader ) ; } return T ; } catch ( javax.xml.bind.UnmarshalException javax.xml.bind.UnmarshalException ) { throw new HttpMessageNotReadableException ( STRING + java.lang.Class<> + STRING + javax.xml.bind.UnmarshalException . java.lang.String ( ) , javax.xml.bind.UnmarshalException ) ; } catch ( javax.xml.bind.JAXBException javax.xml.bind.JAXBException ) { throw new HttpMessageConversionException ( STRING + javax.xml.bind.JAXBException . java.lang.String ( ) , javax.xml.bind.JAXBException ) ; } catch ( javax.xml.stream.XMLStreamException javax.xml.stream.XMLStreamException ) { throw new HttpMessageConversionException ( javax.xml.stream.XMLStreamException . java.lang.String ( ) , javax.xml.stream.XMLStreamException ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.SuppressWarnings ( STRING ) protected T T ( java.lang.Class<?> < ? > java.lang.Class<?> ) { if ( ! java.lang.Class<> . boolean ( ) ) { try { return ( T ) ReflectionUtils . accessibleConstructor ( java.lang.Class<> ) . newInstance ( ) ; } catch ( java.lang.Throwable java.lang.Throwable ) { throw new java.lang.IllegalArgumentException ( STRING + java.lang.Class<> . java.lang.String ( ) , java.lang.Throwable ) ; } } else if ( java.util.List .class == java.lang.Class<> ) { return ( T ) new java.util.ArrayList ( ) ; } else if ( java.util.SortedSet .class == java.lang.Class<> ) { return ( T ) new java.util.TreeSet ( ) ; } else { return ( T ) new java.util.LinkedHashSet ( ) ; } }  <METHOD_END>
<METHOD_START> private int int ( javax.xml.stream.XMLStreamReader javax.xml.stream.XMLStreamReader ) throws javax.xml.stream.XMLStreamException { int int = javax.xml.stream.XMLStreamReader . int ( ) ; while ( int != javax.xml.stream.XMLStreamReader . int ) { int = javax.xml.stream.XMLStreamReader . int ( ) ; } int = javax.xml.stream.XMLStreamReader . int ( ) ; while ( ( int != javax.xml.stream.XMLStreamReader . int ) && ( int != javax.xml.stream.XMLStreamReader . int ) ) { int = javax.xml.stream.XMLStreamReader . int ( ) ; } return int ; }  <METHOD_END>
<METHOD_START> private int int ( javax.xml.stream.XMLStreamReader javax.xml.stream.XMLStreamReader ) throws javax.xml.stream.XMLStreamException { int int = javax.xml.stream.XMLStreamReader . int ( ) ; while ( int != javax.xml.stream.XMLStreamReader . int && int != javax.xml.stream.XMLStreamReader . int ) { int = javax.xml.stream.XMLStreamReader . int ( ) ; } return int ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( T T , java.lang.reflect.Type java.lang.reflect.Type , MediaType org.springframework.http.converter.xml.MediaType , HttpOutputMessage org.springframework.http.converter.xml.HttpOutputMessage )			throws java.io.IOException , org.springframework.http.converter.xml.HttpMessageNotWritableException { throw new java.lang.UnsupportedOperationException ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( T T , HttpHeaders org.springframework.http.converter.xml.HttpHeaders , javax.xml.transform.Result javax.xml.transform.Result ) throws java.io.IOException { throw new java.lang.UnsupportedOperationException ( ) ; }  <METHOD_END>
<METHOD_START> protected javax.xml.stream.XMLInputFactory javax.xml.stream.XMLInputFactory ( ) { javax.xml.stream.XMLInputFactory javax.xml.stream.XMLInputFactory = javax.xml.stream.XMLInputFactory . javax.xml.stream.XMLInputFactory ( ) ; javax.xml.stream.XMLInputFactory . void ( javax.xml.stream.XMLInputFactory . java.lang.String , false ) ; javax.xml.stream.XMLInputFactory . void ( javax.xml.stream.XMLInputFactory . java.lang.String , false ) ; javax.xml.stream.XMLInputFactory . void ( javax.xml.stream.XMLResolver ) ; return javax.xml.stream.XMLInputFactory ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.Object java.lang.Object ( java.lang.String java.lang.String , java.lang.String java.lang.String , java.lang.String java.lang.String , java.lang.String java.lang.String ) { return StreamUtils . emptyInput ( ) ; }  <METHOD_END>
