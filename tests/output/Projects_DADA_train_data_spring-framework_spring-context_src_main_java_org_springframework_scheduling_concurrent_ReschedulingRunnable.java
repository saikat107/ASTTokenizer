<METHOD_START> public void ( java.lang.Runnable java.lang.Runnable , Trigger org.springframework.scheduling.concurrent.Trigger , java.util.concurrent.ScheduledExecutorService java.util.concurrent.ScheduledExecutorService , ErrorHandler org.springframework.scheduling.concurrent.ErrorHandler ) { super( java.lang.Runnable , org.springframework.scheduling.concurrent.ErrorHandler ); this . org.springframework.scheduling.concurrent.Trigger = org.springframework.scheduling.concurrent.Trigger ; this . java.util.concurrent.ScheduledExecutorService = java.util.concurrent.ScheduledExecutorService ; }  <METHOD_END>
<METHOD_START> public java.util.concurrent.ScheduledFuture<?> < ? > java.util.concurrent.ScheduledFuture<?> ( ) { synchronized ( this . java.lang.Object ) { this . java.util.Date = this . org.springframework.scheduling.concurrent.Trigger . nextExecutionTime ( this . org.springframework.scheduling.concurrent.SimpleTriggerContext ) ; if ( this . java.util.Date == null ) { return null ; } long long = this . java.util.Date . long ( ) - java.lang.System . long ( ) ; this . java.util.concurrent.ScheduledFuture<?> = this . java.util.concurrent.ScheduledExecutorService . java.util.concurrent.ScheduledFuture<?> ( this , long , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ; return this ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ) { java.util.Date java.util.Date = new java.util.Date ( ) ; super. run ( ) ; java.util.Date java.util.Date = new java.util.Date ( ) ; synchronized ( this . java.lang.Object ) { this . org.springframework.scheduling.concurrent.SimpleTriggerContext . update ( this . java.util.Date , java.util.Date , java.util.Date ) ; if ( ! this . java.util.concurrent.ScheduledFuture<> . boolean ( ) ) { java.util.concurrent.ScheduledFuture<?> ( ) ; } } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( boolean boolean ) { synchronized ( this . java.lang.Object ) { return this . java.util.concurrent.ScheduledFuture<> . boolean ( boolean ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( ) { synchronized ( this . java.lang.Object ) { return this . java.util.concurrent.ScheduledFuture<> . boolean ( ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( ) { synchronized ( this . java.lang.Object ) { return this . java.util.concurrent.ScheduledFuture<> . boolean ( ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.Object java.lang.Object ( ) java.lang.InterruptedException , java.util.concurrent.ExecutionException { java.util.concurrent.ScheduledFuture<?> < ? > java.util.concurrent.ScheduledFuture<?> ; synchronized ( this . java.lang.Object ) { java.util.concurrent.ScheduledFuture<?> = this . java.util.concurrent.ScheduledFuture<> ; } return java.util.concurrent.ScheduledFuture<> . get ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.Object java.lang.Object ( long long , java.util.concurrent.TimeUnit java.util.concurrent.TimeUnit ) throws java.lang.InterruptedException , java.util.concurrent.ExecutionException , java.util.concurrent.TimeoutException { java.util.concurrent.ScheduledFuture<?> < ? > java.util.concurrent.ScheduledFuture<?> ; synchronized ( this . java.lang.Object ) { java.util.concurrent.ScheduledFuture<?> = this . java.util.concurrent.ScheduledFuture<> ; } return java.util.concurrent.ScheduledFuture<> . get ( long , java.util.concurrent.TimeUnit ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public long long ( java.util.concurrent.TimeUnit java.util.concurrent.TimeUnit ) { java.util.concurrent.ScheduledFuture<?> < ? > java.util.concurrent.ScheduledFuture<?> ; synchronized ( this . java.lang.Object ) { java.util.concurrent.ScheduledFuture<?> = this . java.util.concurrent.ScheduledFuture<> ; } return java.util.concurrent.ScheduledFuture<> . long ( java.util.concurrent.TimeUnit ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public int int ( java.util.concurrent.Delayed java.util.concurrent.Delayed ) { if ( this == java.util.concurrent.Delayed ) { return NUMBER ; } long long = long ( java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) - java.util.concurrent.Delayed . long ( java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ; return ( long == NUMBER ? NUMBER : ( ( long < NUMBER ) ? - NUMBER : NUMBER ) ) ; }  <METHOD_END>
