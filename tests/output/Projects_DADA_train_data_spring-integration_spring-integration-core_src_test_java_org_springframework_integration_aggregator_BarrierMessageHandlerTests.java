<METHOD_START> @ Test public void void ( ) java.lang.Exception { final BarrierMessageHandler org.springframework.integration.aggregator.BarrierMessageHandler = new BarrierMessageHandler ( NUMBER ) ; QueueChannel org.springframework.integration.aggregator.QueueChannel = new QueueChannel ( ) ; org.springframework.integration.aggregator.BarrierMessageHandler . setOutputChannel ( org.springframework.integration.aggregator.QueueChannel ) ; org.springframework.integration.aggregator.BarrierMessageHandler . setBeanFactory ( mock ( BeanFactory .class ) ) ; org.springframework.integration.aggregator.BarrierMessageHandler . afterPropertiesSet ( ) ; final java.util.concurrent.atomic.AtomicReference<java.lang.Exception> < java.lang.Exception > java.util.concurrent.atomic.AtomicReference<java.lang.Exception> = new java.util.concurrent.atomic.AtomicReference<java.lang.Exception> < java.lang.Exception > ( ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; java.lang.Runnable java.lang.Runnable = ( ) { try { org.springframework.integration.aggregator.BarrierMessageHandler . handleMessage ( MessageBuilder . withPayload ( STRING ) . setCorrelationId ( STRING ) . build ( ) ) ; } catch ( MessagingException org.springframework.integration.aggregator.MessagingException ) { java.util.concurrent.atomic.AtomicReference<java.lang.Exception> . void ( org.springframework.integration.aggregator.MessagingException ) ; } java.util.concurrent.CountDownLatch . void ( ) ; } ; java.util.concurrent.ExecutorService java.util.concurrent.ExecutorService = java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) ; java.util.concurrent.ExecutorService . void ( java.lang.Runnable ) ; java.util.concurrent.ExecutorService . void ( java.lang.Runnable ) ; java.util.Map<?,?> < ? , ? > java.util.Map<?,?> = TestUtils . getPropertyValue ( org.springframework.integration.aggregator.BarrierMessageHandler , STRING , java.util.Map .class ) ; int int = NUMBER ; while ( int ++ < NUMBER && java.util.Map<,> . int ( ) == NUMBER ) { java.lang.Thread . void ( NUMBER ) ; } java.util.Map<?,?> < ? , ? > java.util.Map<?,?> = TestUtils . getPropertyValue ( org.springframework.integration.aggregator.BarrierMessageHandler , STRING , java.util.Map .class ) ; assertEquals ( NUMBER , java.util.Map<,> . int ( ) ) ; assertTrue ( STRING , int < NUMBER ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; assertNotNull ( java.util.concurrent.atomic.AtomicReference<java.lang.Exception> . java.lang.Exception ( ) ) ; assertThat ( java.util.concurrent.atomic.AtomicReference<java.lang.Exception> . java.lang.Exception ( ) . java.lang.String ( ) , startsWith ( STRING ) ) ; org.springframework.integration.aggregator.BarrierMessageHandler . trigger ( MessageBuilder . withPayload ( STRING ) . setCorrelationId ( STRING ) . build ( ) ) ; Message < ? > org.springframework.integration.aggregator.Message<?> = org.springframework.integration.aggregator.QueueChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.aggregator.Message<> ) ; java.util.List<?> < ? > java.util.List<?> = ( java.util.List<?> < ? > ) org.springframework.integration.aggregator.Message<> . getPayload ( ) ; assertEquals ( STRING , java.util.List<> . get ( NUMBER ) ) ; assertEquals ( STRING , java.util.List<> . get ( NUMBER ) ) ; assertEquals ( NUMBER , java.util.Map<,> . int ( ) ) ; assertEquals ( NUMBER , java.util.Map<,> . int ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final BarrierMessageHandler org.springframework.integration.aggregator.BarrierMessageHandler = new BarrierMessageHandler ( NUMBER ) ; QueueChannel org.springframework.integration.aggregator.QueueChannel = new QueueChannel ( ) ; org.springframework.integration.aggregator.BarrierMessageHandler . setOutputChannel ( org.springframework.integration.aggregator.QueueChannel ) ; org.springframework.integration.aggregator.BarrierMessageHandler . setBeanFactory ( mock ( BeanFactory .class ) ) ; org.springframework.integration.aggregator.BarrierMessageHandler . afterPropertiesSet ( ) ; java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . void ( ( ) org.springframework.integration.aggregator.BarrierMessageHandler . trigger ( MessageBuilder . withPayload ( STRING ) . setCorrelationId ( STRING ) . build ( ) ) ) ; java.util.Map<?,?> < ? , ? > java.util.Map<?,?> = TestUtils . getPropertyValue ( org.springframework.integration.aggregator.BarrierMessageHandler , STRING , java.util.Map .class ) ; int int = NUMBER ; while ( int ++ < NUMBER && java.util.Map<,> . int ( ) == NUMBER ) { java.lang.Thread . void ( NUMBER ) ; } assertTrue ( STRING , int < NUMBER ) ; org.springframework.integration.aggregator.BarrierMessageHandler . handleMessage ( MessageBuilder . withPayload ( STRING ) . setCorrelationId ( STRING ) . build ( ) ) ; Message < ? > org.springframework.integration.aggregator.Message<?> = org.springframework.integration.aggregator.QueueChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.aggregator.Message<> ) ; java.util.List<?> < ? > java.util.List<?> = ( java.util.ArrayList<?> < ? > ) org.springframework.integration.aggregator.Message<> . getPayload ( ) ; assertEquals ( STRING , java.util.List<> . get ( NUMBER ) ) ; assertEquals ( STRING , java.util.List<> . get ( NUMBER ) ) ; assertEquals ( NUMBER , java.util.Map<,> . int ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final BarrierMessageHandler org.springframework.integration.aggregator.BarrierMessageHandler = new BarrierMessageHandler ( NUMBER ) ; QueueChannel org.springframework.integration.aggregator.QueueChannel = new QueueChannel ( ) ; QueueChannel org.springframework.integration.aggregator.QueueChannel = new QueueChannel ( ) ; org.springframework.integration.aggregator.BarrierMessageHandler . setOutputChannel ( org.springframework.integration.aggregator.QueueChannel ) ; org.springframework.integration.aggregator.BarrierMessageHandler . setDiscardChannelName ( STRING ) ; org.springframework.integration.aggregator.BarrierMessageHandler . setChannelResolver ( s -> discardChannel ) ; org.springframework.integration.aggregator.BarrierMessageHandler . setBeanFactory ( mock ( BeanFactory .class ) ) ; org.springframework.integration.aggregator.BarrierMessageHandler . afterPropertiesSet ( ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . void ( ( ) { org.springframework.integration.aggregator.BarrierMessageHandler . handleMessage ( MessageBuilder . withPayload ( STRING ) . setCorrelationId ( STRING ) . build ( ) ) ; java.util.concurrent.CountDownLatch . void ( ) ; } ) ; java.util.Map<?,?> < ? , ? > java.util.Map<?,?> = TestUtils . getPropertyValue ( org.springframework.integration.aggregator.BarrierMessageHandler , STRING , java.util.Map .class ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; assertEquals ( STRING , NUMBER , java.util.Map<,> . int ( ) ) ; Log org.springframework.integration.aggregator.Log = spy ( TestUtils . getPropertyValue ( org.springframework.integration.aggregator.BarrierMessageHandler , STRING , Log .class ) ) ; new DirectFieldAccessor ( org.springframework.integration.aggregator.BarrierMessageHandler ) . setPropertyValue ( STRING , org.springframework.integration.aggregator.Log ) ; final Message < java.lang.String > org.springframework.integration.aggregator.Message<java.lang.String> = MessageBuilder . withPayload ( STRING ) . setCorrelationId ( STRING ) . build ( ) ; org.springframework.integration.aggregator.BarrierMessageHandler . trigger ( org.springframework.integration.aggregator.Message<java.lang.String> ) ; ArgumentCaptor < java.lang.String > org.springframework.integration.aggregator.ArgumentCaptor<java.lang.String> = ArgumentCaptor . forClass ( java.lang.String .class ) ; verify ( org.springframework.integration.aggregator.Log ) . error ( org.springframework.integration.aggregator.ArgumentCaptor<java.lang.String> . capture ( ) ) ; assertThat ( org.springframework.integration.aggregator.ArgumentCaptor<java.lang.String> . getValue ( ) , allOf ( containsString ( STRING ) , containsString ( STRING ) ) ) ; assertEquals ( NUMBER , java.util.Map<,> . int ( ) ) ; Message < ? > org.springframework.integration.aggregator.Message<?> = org.springframework.integration.aggregator.QueueChannel . receive ( NUMBER ) ; assertSame ( org.springframework.integration.aggregator.Message<> , org.springframework.integration.aggregator.Message<java.lang.String> ) ; org.springframework.integration.aggregator.BarrierMessageHandler . handleMessage ( MessageBuilder . withPayload ( STRING ) . setCorrelationId ( STRING ) . build ( ) ) ; assertEquals ( NUMBER , java.util.Map<,> . int ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final BarrierMessageHandler org.springframework.integration.aggregator.BarrierMessageHandler = new BarrierMessageHandler ( NUMBER ) ; QueueChannel org.springframework.integration.aggregator.QueueChannel = new QueueChannel ( ) ; org.springframework.integration.aggregator.BarrierMessageHandler . setOutputChannel ( org.springframework.integration.aggregator.QueueChannel ) ; org.springframework.integration.aggregator.BarrierMessageHandler . setBeanFactory ( mock ( BeanFactory .class ) ) ; org.springframework.integration.aggregator.BarrierMessageHandler . setRequiresReply ( true ) ; org.springframework.integration.aggregator.BarrierMessageHandler . afterPropertiesSet ( ) ; try { org.springframework.integration.aggregator.BarrierMessageHandler . handleMessage ( MessageBuilder . withPayload ( STRING ) . setCorrelationId ( STRING ) . build ( ) ) ; fail ( STRING ) ; } catch ( java.lang.Exception java.lang.Exception ) { assertThat ( java.lang.Exception , Matchers . instanceOf ( ReplyRequiredException .class ) ) ; } }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final BarrierMessageHandler org.springframework.integration.aggregator.BarrierMessageHandler = new BarrierMessageHandler ( NUMBER ) ; QueueChannel org.springframework.integration.aggregator.QueueChannel = new QueueChannel ( ) ; org.springframework.integration.aggregator.BarrierMessageHandler . setOutputChannel ( org.springframework.integration.aggregator.QueueChannel ) ; org.springframework.integration.aggregator.BarrierMessageHandler . setBeanFactory ( mock ( BeanFactory .class ) ) ; org.springframework.integration.aggregator.BarrierMessageHandler . afterPropertiesSet ( ) ; final java.util.concurrent.atomic.AtomicReference<java.lang.Exception> < java.lang.Exception > java.util.concurrent.atomic.AtomicReference<java.lang.Exception> = new java.util.concurrent.atomic.AtomicReference<java.lang.Exception> < java.lang.Exception > ( ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . void ( ( ) { try { org.springframework.integration.aggregator.BarrierMessageHandler . handleMessage ( MessageBuilder . withPayload ( STRING ) . setCorrelationId ( STRING ) . build ( ) ) ; } catch ( java.lang.Exception java.lang.Exception ) { java.util.concurrent.atomic.AtomicReference<java.lang.Exception> . void ( java.lang.Exception ) ; java.util.concurrent.CountDownLatch . void ( ) ; } } ) ; java.util.Map<?,?> < ? , ? > java.util.Map<?,?> = TestUtils . getPropertyValue ( org.springframework.integration.aggregator.BarrierMessageHandler , STRING , java.util.Map .class ) ; int int = NUMBER ; while ( int ++ < NUMBER && java.util.Map<,> . int ( ) == NUMBER ) { java.lang.Thread . void ( NUMBER ) ; } assertTrue ( STRING , int < NUMBER ) ; java.lang.Exception java.lang.Exception = new java.lang.RuntimeException ( ) ; org.springframework.integration.aggregator.BarrierMessageHandler . trigger ( MessageBuilder . withPayload ( java.lang.Exception ) . setCorrelationId ( STRING ) . build ( ) ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; assertSame ( java.lang.Exception , java.util.concurrent.atomic.AtomicReference<java.lang.Exception> . java.lang.Exception ( ) . java.lang.Throwable ( ) ) ; assertEquals ( NUMBER , java.util.Map<,> . int ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { Message < ? > org.springframework.integration.aggregator.Message<?> = MessageBuilder . withPayload ( STRING ) . setCorrelationId ( STRING ) . build ( ) ; this . org.springframework.integration.aggregator.MessageChannel . send ( org.springframework.integration.aggregator.Message<> ) ; Message < ? > org.springframework.integration.aggregator.Message<?> = MessageBuilder . withPayload ( STRING ) . setCorrelationId ( STRING ) . build ( ) ; this . org.springframework.integration.aggregator.MessageChannel . send ( org.springframework.integration.aggregator.Message<> ) ; Message < ? > org.springframework.integration.aggregator.Message<?> = this . org.springframework.integration.aggregator.PollableChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.aggregator.Message<> ) ; assertEquals ( STRING , org.springframework.integration.aggregator.Message<> . getPayload ( ) . toString ( ) ) ; Message < ? > org.springframework.integration.aggregator.Message<?> = this . org.springframework.integration.aggregator.PollableChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.aggregator.Message<> ) ; assertEquals ( STRING , org.springframework.integration.aggregator.Message<> . getPayload ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.integration.aggregator.MessageChannel org.springframework.integration.aggregator.MessageChannel ( ) { return new DirectChannel ( ) ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.integration.aggregator.MessageChannel org.springframework.integration.aggregator.MessageChannel ( ) { return new QueueChannel ( ) ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.integration.aggregator.MessageChannel org.springframework.integration.aggregator.MessageChannel ( ) { return new QueueChannel ( ) ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.integration.aggregator.PollableChannel org.springframework.integration.aggregator.PollableChannel ( ) { return new QueueChannel ( ) ; }  <METHOD_END>
<METHOD_START> @ ServiceActivator ( inputChannel = STRING ) @ Bean public org.springframework.integration.aggregator.BarrierMessageHandler org.springframework.integration.aggregator.BarrierMessageHandler ( ) { BarrierMessageHandler org.springframework.integration.aggregator.BarrierMessageHandler = new BarrierMessageHandler ( NUMBER ) ; org.springframework.integration.aggregator.BarrierMessageHandler . setOutputChannel ( org.springframework.integration.aggregator.MessageChannel ( ) ) ; return org.springframework.integration.aggregator.BarrierMessageHandler ; }  <METHOD_END>
<METHOD_START> @ ServiceActivator ( inputChannel = STRING , poller = @ Poller ( fixedDelay = STRING ) ) @ Bean public org.springframework.integration.aggregator.MessageHandler org.springframework.integration.aggregator.MessageHandler ( ) { return new MessageHandler ( ) { @ java.lang.Override @ Publisher ( channel = STRING ) @ Payload ( STRING ) public void void ( Message < ? > org.springframework.integration.aggregator.Message<?> ) throws org.springframework.integration.aggregator.MessagingException { org.springframework.integration.aggregator.BarrierMessageHandler ( ) . trigger ( org.springframework.integration.aggregator.Message<> ) ; } } ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override @ Publisher ( channel = STRING ) @ Payload ( STRING ) public void void ( Message < ? > org.springframework.integration.aggregator.Message<?> ) throws org.springframework.integration.aggregator.MessagingException { org.springframework.integration.aggregator.BarrierMessageHandler ( ) . trigger ( org.springframework.integration.aggregator.Message<> ) ; }  <METHOD_END>
