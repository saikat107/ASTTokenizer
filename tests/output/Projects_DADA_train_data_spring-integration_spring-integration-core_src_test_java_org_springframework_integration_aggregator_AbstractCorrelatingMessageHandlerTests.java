<METHOD_START> @ Test public void void ( ) java.lang.Exception { final MessageGroupStore org.springframework.integration.aggregator.MessageGroupStore = new SimpleMessageStore ( ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; AbstractCorrelatingMessageHandler org.springframework.integration.aggregator.AbstractCorrelatingMessageHandler = new AbstractCorrelatingMessageHandler ( group -> group , org.springframework.integration.aggregator.MessageGroupStore ) { @ java.lang.Override protected void void ( MessageGroup org.springframework.integration.aggregator.MessageGroup , java.util.Collection<org.springframework.integration.aggregator.Message<?>> < Message < ? > > java.util.Collection<org.springframework.integration.aggregator.Message<?>> ) {			} } ; org.springframework.integration.aggregator.AbstractCorrelatingMessageHandler . setReleasePartialSequences ( true ) ; java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . void ( ( ) { try { java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ; } catch ( java.lang.InterruptedException java.lang.InterruptedException ) { java.lang.Thread . java.lang.Thread ( ) . void ( ) ; } java.util.concurrent.CountDownLatch . void ( ) ; try { java.lang.Thread . void ( NUMBER ) ; } catch ( java.lang.InterruptedException java.lang.InterruptedException ) { java.lang.Thread . java.lang.Thread ( ) . void ( ) ; } org.springframework.integration.aggregator.MessageGroupStore . expireMessageGroups ( NUMBER ) ; java.util.concurrent.CountDownLatch . void ( ) ; } ) ; final java.util.List<org.springframework.integration.aggregator.Message<?>> < Message < ? > > java.util.List<org.springframework.integration.aggregator.Message<?>> = new java.util.ArrayList<org.springframework.integration.aggregator.Message<?>> < Message < ? > > ( ) ; org.springframework.integration.aggregator.AbstractCorrelatingMessageHandler . setOutputChannel ( ( message , timeout ) -> { outputMessages . add ( message ) ; waitReapStartLatch . countDown ( ) ; try { waitForSendLatch . await ( NUMBER , TimeUnit . SECONDS ) ; Thread . sleep ( NUMBER ) ; groupStore . removeMessageGroup ( STRING ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; } return true ; } ) ; org.springframework.integration.aggregator.AbstractCorrelatingMessageHandler . setReleaseStrategy ( group -> group . size ( ) == NUMBER ) ; QueueChannel org.springframework.integration.aggregator.QueueChannel = new QueueChannel ( ) ; org.springframework.integration.aggregator.AbstractCorrelatingMessageHandler . setDiscardChannel ( org.springframework.integration.aggregator.QueueChannel ) ; org.springframework.integration.aggregator.AbstractCorrelatingMessageHandler . setSendPartialResultOnExpiry ( true ) ; Message < java.lang.String > org.springframework.integration.aggregator.Message<java.lang.String> = MessageBuilder . withPayload ( STRING ) . setCorrelationId ( STRING ) . build ( ) ; org.springframework.integration.aggregator.AbstractCorrelatingMessageHandler . handleMessage ( org.springframework.integration.aggregator.Message<java.lang.String> ) ; org.springframework.integration.aggregator.Message<java.lang.String> = MessageBuilder . withPayload ( STRING ) . setCorrelationId ( STRING ) . build ( ) ; org.springframework.integration.aggregator.AbstractCorrelatingMessageHandler . handleMessage ( org.springframework.integration.aggregator.Message<java.lang.String> ) ; org.springframework.integration.aggregator.Message<java.lang.String> = MessageBuilder . withPayload ( STRING ) . setCorrelationId ( STRING ) . build ( ) ; org.springframework.integration.aggregator.AbstractCorrelatingMessageHandler . handleMessage ( org.springframework.integration.aggregator.Message<java.lang.String> ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; assertEquals ( NUMBER , java.util.List<org.springframework.integration.aggregator.Message<?>> . size ( ) ) ; assertEquals ( NUMBER , ( ( MessageGroup ) java.util.List<org.springframework.integration.aggregator.Message<?>> . get ( NUMBER ) . getPayload ( ) ) . size ( ) ) ; assertEquals ( NUMBER , ( ( MessageGroup ) java.util.List<org.springframework.integration.aggregator.Message<?>> . get ( NUMBER ) . getPayload ( ) ) . size ( ) ) ; assertNull ( org.springframework.integration.aggregator.QueueChannel . receive ( NUMBER ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( MessageGroup org.springframework.integration.aggregator.MessageGroup , java.util.Collection<org.springframework.integration.aggregator.Message<?>> < Message < ? > > java.util.Collection<org.springframework.integration.aggregator.Message<?>> ) {			}  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final MessageGroupStore org.springframework.integration.aggregator.MessageGroupStore = new SimpleMessageStore ( ) ; AggregatingMessageHandler org.springframework.integration.aggregator.AggregatingMessageHandler = new AggregatingMessageHandler ( group -> group , org.springframework.integration.aggregator.MessageGroupStore ) ; final java.util.List<org.springframework.integration.aggregator.Message<?>> < Message < ? > > java.util.List<org.springframework.integration.aggregator.Message<?>> = new java.util.ArrayList<org.springframework.integration.aggregator.Message<?>> < Message < ? > > ( ) ; org.springframework.integration.aggregator.AggregatingMessageHandler . setOutputChannel ( ( message , timeout ) -> { outputMessages . add ( message ) ; return true ; } ) ; org.springframework.integration.aggregator.AggregatingMessageHandler . setReleaseStrategy ( group -> group . size ( ) == NUMBER ) ; Message < java.lang.String > org.springframework.integration.aggregator.Message<java.lang.String> = MessageBuilder . withPayload ( STRING ) . setCorrelationId ( STRING ) . build ( ) ; org.springframework.integration.aggregator.AggregatingMessageHandler . handleMessage ( org.springframework.integration.aggregator.Message<java.lang.String> ) ; assertEquals ( NUMBER , java.util.List<org.springframework.integration.aggregator.Message<?>> . size ( ) ) ; assertEquals ( NUMBER , TestUtils . getPropertyValue ( org.springframework.integration.aggregator.AggregatingMessageHandler , STRING , java.util.Map .class ) . size ( ) ) ; org.springframework.integration.aggregator.MessageGroupStore . expireMessageGroups ( NUMBER ) ; assertEquals ( NUMBER , TestUtils . getPropertyValue ( org.springframework.integration.aggregator.AggregatingMessageHandler , STRING , java.util.Map .class ) . size ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final MessageGroupStore org.springframework.integration.aggregator.MessageGroupStore = new SimpleMessageStore ( ) ; AggregatingMessageHandler org.springframework.integration.aggregator.AggregatingMessageHandler = new AggregatingMessageHandler ( group -> group , org.springframework.integration.aggregator.MessageGroupStore ) ; final java.util.List<org.springframework.integration.aggregator.Message<?>> < Message < ? > > java.util.List<org.springframework.integration.aggregator.Message<?>> = new java.util.ArrayList<org.springframework.integration.aggregator.Message<?>> < Message < ? > > ( ) ; org.springframework.integration.aggregator.AggregatingMessageHandler . setOutputChannel ( ( message , timeout ) -> { outputMessages . add ( message ) ; return true ; } ) ; org.springframework.integration.aggregator.AggregatingMessageHandler . setReleaseStrategy ( group -> group . size ( ) == NUMBER ) ; Message < java.lang.String > org.springframework.integration.aggregator.Message<java.lang.String> = MessageBuilder . withPayload ( STRING ) . setCorrelationId ( STRING ) . build ( ) ; org.springframework.integration.aggregator.AggregatingMessageHandler . handleMessage ( org.springframework.integration.aggregator.Message<java.lang.String> ) ; org.springframework.integration.aggregator.AggregatingMessageHandler . setMinimumTimeoutForEmptyGroups ( NUMBER ) ; assertEquals ( NUMBER , java.util.List<org.springframework.integration.aggregator.Message<?>> . size ( ) ) ; assertEquals ( NUMBER , TestUtils . getPropertyValue ( org.springframework.integration.aggregator.AggregatingMessageHandler , STRING , java.util.Map .class ) . size ( ) ) ; org.springframework.integration.aggregator.MessageGroupStore . expireMessageGroups ( NUMBER ) ; assertEquals ( NUMBER , TestUtils . getPropertyValue ( org.springframework.integration.aggregator.AggregatingMessageHandler , STRING , java.util.Map .class ) . size ( ) ) ; org.springframework.integration.aggregator.AggregatingMessageHandler . setMinimumTimeoutForEmptyGroups ( NUMBER ) ; int int = NUMBER ; while ( int ++ < NUMBER ) { org.springframework.integration.aggregator.MessageGroupStore . expireMessageGroups ( NUMBER ) ; if ( TestUtils . getPropertyValue ( org.springframework.integration.aggregator.AggregatingMessageHandler , STRING , java.util.Map .class ) . size ( ) > NUMBER ) { java.lang.Thread . void ( NUMBER ) ; } else { break; } } assertTrue ( int < NUMBER ) ; assertEquals ( NUMBER , TestUtils . getPropertyValue ( org.springframework.integration.aggregator.AggregatingMessageHandler , STRING , java.util.Map .class ) . size ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { MessageGroupProcessor org.springframework.integration.aggregator.MessageGroupProcessor = new DefaultAggregatingMessageGroupProcessor ( ) ; AggregatingMessageHandler org.springframework.integration.aggregator.AggregatingMessageHandler = new AggregatingMessageHandler ( org.springframework.integration.aggregator.MessageGroupProcessor ) ; org.springframework.integration.aggregator.AggregatingMessageHandler . setReleaseStrategy ( group -> true ) ; QueueChannel org.springframework.integration.aggregator.QueueChannel = new QueueChannel ( ) ; org.springframework.integration.aggregator.AggregatingMessageHandler . setOutputChannel ( org.springframework.integration.aggregator.QueueChannel ) ; MessageGroupStore org.springframework.integration.aggregator.MessageGroupStore = TestUtils . getPropertyValue ( org.springframework.integration.aggregator.AggregatingMessageHandler , STRING , MessageGroupStore .class ) ; java.lang.reflect.Method java.lang.reflect.Method = AbstractCorrelatingMessageHandler .class . java.lang.reflect.Method ( STRING , MessageGroup .class ) ; java.lang.reflect.Method . void ( true ) ; GenericMessage < java.lang.String > org.springframework.integration.aggregator.GenericMessage<java.lang.String> = new GenericMessage < java.lang.String > ( STRING ) ; org.springframework.integration.aggregator.MessageGroupStore . addMessagesToGroup ( STRING , new GenericMessage < java.lang.String > ( STRING ) , org.springframework.integration.aggregator.GenericMessage<java.lang.String> ) ; MessageGroup org.springframework.integration.aggregator.MessageGroup = org.springframework.integration.aggregator.MessageGroupStore . getMessageGroup ( STRING ) ; org.springframework.integration.aggregator.MessageGroupStore . removeMessagesFromGroup ( STRING , org.springframework.integration.aggregator.GenericMessage<java.lang.String> ) ; MessageGroup org.springframework.integration.aggregator.MessageGroup = org.springframework.integration.aggregator.MessageGroupStore . getMessageGroup ( STRING ) ; new DirectFieldAccessor ( org.springframework.integration.aggregator.MessageGroup ) . setPropertyValue ( STRING , org.springframework.integration.aggregator.MessageGroup . getLastModified ( ) ) ; java.lang.reflect.Method . java.lang.Object ( org.springframework.integration.aggregator.AggregatingMessageHandler , org.springframework.integration.aggregator.MessageGroup ) ; Message < ? > org.springframework.integration.aggregator.Message<?> = org.springframework.integration.aggregator.QueueChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.aggregator.Message<> ) ; java.util.Collection<?> < ? > java.util.Collection<?> = ( java.util.Collection<?> < ? > ) org.springframework.integration.aggregator.Message<> . getPayload ( ) ; assertEquals ( NUMBER , java.util.Collection<> . int ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { MessageGroupProcessor org.springframework.integration.aggregator.MessageGroupProcessor = new DefaultAggregatingMessageGroupProcessor ( ) ; AggregatingMessageHandler org.springframework.integration.aggregator.AggregatingMessageHandler = new AggregatingMessageHandler ( org.springframework.integration.aggregator.MessageGroupProcessor ) ; org.springframework.integration.aggregator.AggregatingMessageHandler . setReleaseStrategy ( group -> true ) ; QueueChannel org.springframework.integration.aggregator.QueueChannel = new QueueChannel ( ) ; org.springframework.integration.aggregator.AggregatingMessageHandler . setOutputChannel ( org.springframework.integration.aggregator.QueueChannel ) ; MessageGroupStore org.springframework.integration.aggregator.MessageGroupStore = TestUtils . getPropertyValue ( org.springframework.integration.aggregator.AggregatingMessageHandler , STRING , MessageGroupStore .class ) ; org.springframework.integration.aggregator.MessageGroupStore . addMessagesToGroup ( STRING , new GenericMessage < java.lang.String > ( STRING ) ) ; org.springframework.integration.aggregator.MessageGroupStore . completeGroup ( STRING ) ; org.springframework.integration.aggregator.MessageGroupStore = spy ( org.springframework.integration.aggregator.MessageGroupStore ) ; new DirectFieldAccessor ( org.springframework.integration.aggregator.AggregatingMessageHandler ) . setPropertyValue ( STRING , org.springframework.integration.aggregator.MessageGroupStore ) ; java.lang.reflect.Method java.lang.reflect.Method = AbstractCorrelatingMessageHandler .class . java.lang.reflect.Method ( STRING , MessageGroup .class ) ; java.lang.reflect.Method . void ( true ) ; MessageGroup org.springframework.integration.aggregator.MessageGroup = ( MessageGroup ) TestUtils . getPropertyValue ( org.springframework.integration.aggregator.MessageGroupStore , STRING , java.util.Map .class ) . get ( STRING ) ; assertTrue ( org.springframework.integration.aggregator.MessageGroup . isComplete ( ) ) ; java.lang.reflect.Method . java.lang.Object ( org.springframework.integration.aggregator.AggregatingMessageHandler , org.springframework.integration.aggregator.MessageGroup ) ; verify ( org.springframework.integration.aggregator.MessageGroupStore , never ( ) ) . getMessageGroup ( STRING ) ; assertNull ( org.springframework.integration.aggregator.QueueChannel . receive ( NUMBER ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { MessageGroupProcessor org.springframework.integration.aggregator.MessageGroupProcessor = new DefaultAggregatingMessageGroupProcessor ( ) ; AggregatingMessageHandler org.springframework.integration.aggregator.AggregatingMessageHandler = new AggregatingMessageHandler ( org.springframework.integration.aggregator.MessageGroupProcessor ) ; org.springframework.integration.aggregator.AggregatingMessageHandler . setReleaseStrategy ( group -> true ) ; QueueChannel org.springframework.integration.aggregator.QueueChannel = new QueueChannel ( ) ; org.springframework.integration.aggregator.AggregatingMessageHandler . setOutputChannel ( org.springframework.integration.aggregator.QueueChannel ) ; MessageGroupStore org.springframework.integration.aggregator.MessageGroupStore = TestUtils . getPropertyValue ( org.springframework.integration.aggregator.AggregatingMessageHandler , STRING , MessageGroupStore .class ) ; org.springframework.integration.aggregator.MessageGroupStore . addMessagesToGroup ( STRING , new GenericMessage < java.lang.String > ( STRING ) ) ; MessageGroup org.springframework.integration.aggregator.MessageGroup = new SimpleMessageGroup ( org.springframework.integration.aggregator.MessageGroupStore . getMessageGroup ( STRING ) ) ; org.springframework.integration.aggregator.MessageGroupStore . completeGroup ( STRING ) ; org.springframework.integration.aggregator.MessageGroupStore = spy ( org.springframework.integration.aggregator.MessageGroupStore ) ; new DirectFieldAccessor ( org.springframework.integration.aggregator.AggregatingMessageHandler ) . setPropertyValue ( STRING , org.springframework.integration.aggregator.MessageGroupStore ) ; java.lang.reflect.Method java.lang.reflect.Method = AbstractCorrelatingMessageHandler .class . java.lang.reflect.Method ( STRING , MessageGroup .class ) ; java.lang.reflect.Method . void ( true ) ; MessageGroup org.springframework.integration.aggregator.MessageGroup = ( MessageGroup ) TestUtils . getPropertyValue ( org.springframework.integration.aggregator.MessageGroupStore , STRING , java.util.Map .class ) . get ( STRING ) ; assertTrue ( org.springframework.integration.aggregator.MessageGroup . isComplete ( ) ) ; assertFalse ( org.springframework.integration.aggregator.MessageGroup . isComplete ( ) ) ; new DirectFieldAccessor ( org.springframework.integration.aggregator.MessageGroup ) . setPropertyValue ( STRING , org.springframework.integration.aggregator.MessageGroup . getLastModified ( ) ) ; java.lang.reflect.Method . java.lang.Object ( org.springframework.integration.aggregator.AggregatingMessageHandler , org.springframework.integration.aggregator.MessageGroup ) ; verify ( org.springframework.integration.aggregator.MessageGroupStore ) . getMessageGroup ( STRING ) ; assertNull ( org.springframework.integration.aggregator.QueueChannel . receive ( NUMBER ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { MessageGroupProcessor org.springframework.integration.aggregator.MessageGroupProcessor = new DefaultAggregatingMessageGroupProcessor ( ) ; AggregatingMessageHandler org.springframework.integration.aggregator.AggregatingMessageHandler = new AggregatingMessageHandler ( org.springframework.integration.aggregator.MessageGroupProcessor ) ; org.springframework.integration.aggregator.AggregatingMessageHandler . setReleaseStrategy ( group -> true ) ; QueueChannel org.springframework.integration.aggregator.QueueChannel = new QueueChannel ( ) ; org.springframework.integration.aggregator.AggregatingMessageHandler . setOutputChannel ( org.springframework.integration.aggregator.QueueChannel ) ; MessageGroupStore org.springframework.integration.aggregator.MessageGroupStore = TestUtils . getPropertyValue ( org.springframework.integration.aggregator.AggregatingMessageHandler , STRING , MessageGroupStore .class ) ; org.springframework.integration.aggregator.MessageGroupStore . addMessagesToGroup ( STRING , new GenericMessage < java.lang.String > ( STRING ) ) ; MessageGroup org.springframework.integration.aggregator.MessageGroup = new SimpleMessageGroup ( org.springframework.integration.aggregator.MessageGroupStore . getMessageGroup ( STRING ) ) ; org.springframework.integration.aggregator.MessageGroupStore = spy ( org.springframework.integration.aggregator.MessageGroupStore ) ; new DirectFieldAccessor ( org.springframework.integration.aggregator.AggregatingMessageHandler ) . setPropertyValue ( STRING , org.springframework.integration.aggregator.MessageGroupStore ) ; java.lang.reflect.Method java.lang.reflect.Method = AbstractCorrelatingMessageHandler .class . java.lang.reflect.Method ( STRING , MessageGroup .class ) ; java.lang.reflect.Method . void ( true ) ; MessageGroup org.springframework.integration.aggregator.MessageGroup = ( MessageGroup ) TestUtils . getPropertyValue ( org.springframework.integration.aggregator.MessageGroupStore , STRING , java.util.Map .class ) . get ( STRING ) ; assertFalse ( org.springframework.integration.aggregator.MessageGroup . isComplete ( ) ) ; assertFalse ( org.springframework.integration.aggregator.MessageGroup . isComplete ( ) ) ; DirectFieldAccessor org.springframework.integration.aggregator.DirectFieldAccessor = new DirectFieldAccessor ( org.springframework.integration.aggregator.MessageGroup ) ; org.springframework.integration.aggregator.DirectFieldAccessor . setPropertyValue ( STRING , org.springframework.integration.aggregator.MessageGroup . getLastModified ( ) ) ; org.springframework.integration.aggregator.DirectFieldAccessor . setPropertyValue ( STRING , org.springframework.integration.aggregator.MessageGroup . getTimestamp ( ) - NUMBER ) ; java.lang.reflect.Method . java.lang.Object ( org.springframework.integration.aggregator.AggregatingMessageHandler , org.springframework.integration.aggregator.MessageGroup ) ; verify ( org.springframework.integration.aggregator.MessageGroupStore ) . getMessageGroup ( STRING ) ; assertNull ( org.springframework.integration.aggregator.QueueChannel . receive ( NUMBER ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.InterruptedException { final AggregatingMessageHandler org.springframework.integration.aggregator.AggregatingMessageHandler = new AggregatingMessageHandler ( new DefaultAggregatingMessageGroupProcessor ( ) ) ; org.springframework.integration.aggregator.AggregatingMessageHandler . setOutputChannel ( new QueueChannel ( ) ) ; QueueChannel org.springframework.integration.aggregator.QueueChannel = new QueueChannel ( ) ; org.springframework.integration.aggregator.AggregatingMessageHandler . setDiscardChannel ( org.springframework.integration.aggregator.QueueChannel ) ; org.springframework.integration.aggregator.AggregatingMessageHandler . setReleaseStrategy ( group -> true ) ; org.springframework.integration.aggregator.AggregatingMessageHandler . setExpireGroupsUponTimeout ( false ) ; SimpleMessageStore org.springframework.integration.aggregator.SimpleMessageStore = new SimpleMessageStore ( ) { @ java.lang.Override public void void ( java.lang.Object java.lang.Object ) { throw new java.lang.RuntimeException ( STRING ) ; } } ; org.springframework.integration.aggregator.AggregatingMessageHandler . setMessageStore ( org.springframework.integration.aggregator.SimpleMessageStore ) ; org.springframework.integration.aggregator.AggregatingMessageHandler . handleMessage ( MessageBuilder . withPayload ( STRING ) . setCorrelationId ( NUMBER ) . setSequenceNumber ( NUMBER ) . setSequenceSize ( NUMBER ) . build ( ) ) ; try { org.springframework.integration.aggregator.SimpleMessageStore . expireMessageGroups ( NUMBER ) ; } catch ( java.lang.Exception java.lang.Exception ) { } java.util.concurrent.ExecutorService java.util.concurrent.ExecutorService = java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) ; java.util.concurrent.ExecutorService . void ( ( ) org.springframework.integration.aggregator.AggregatingMessageHandler . handleMessage ( MessageBuilder . withPayload ( STRING ) . setCorrelationId ( NUMBER ) . setSequenceNumber ( NUMBER ) . setSequenceSize ( NUMBER ) . build ( ) ) ) ; java.util.concurrent.ExecutorService . void ( ) ; assertTrue ( java.util.concurrent.ExecutorService . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; Message < ? > org.springframework.integration.aggregator.Message<?> = org.springframework.integration.aggregator.QueueChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.aggregator.Message<> ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( java.lang.Object java.lang.Object ) { throw new java.lang.RuntimeException ( STRING ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final MessageGroupStore org.springframework.integration.aggregator.MessageGroupStore = new SimpleMessageStore ( ) ; AggregatingMessageHandler org.springframework.integration.aggregator.AggregatingMessageHandler = new AggregatingMessageHandler ( group -> group , org.springframework.integration.aggregator.MessageGroupStore ) ; final java.util.List<org.springframework.integration.aggregator.Message<?>> < Message < ? > > java.util.List<org.springframework.integration.aggregator.Message<?>> = new java.util.ArrayList<org.springframework.integration.aggregator.Message<?>> < Message < ? > > ( ) ; org.springframework.integration.aggregator.AggregatingMessageHandler . setOutputChannel ( ( message , timeout ) -> { outputMessages . add ( message ) ; return true ; } ) ; org.springframework.integration.aggregator.AggregatingMessageHandler . setReleaseStrategy ( group -> group . size ( ) == NUMBER ) ; org.springframework.integration.aggregator.AggregatingMessageHandler . setMinimumTimeoutForEmptyGroups ( NUMBER ) ; ThreadPoolTaskScheduler org.springframework.integration.aggregator.ThreadPoolTaskScheduler = new ThreadPoolTaskScheduler ( ) ; org.springframework.integration.aggregator.ThreadPoolTaskScheduler . afterPropertiesSet ( ) ; org.springframework.integration.aggregator.AggregatingMessageHandler . setTaskScheduler ( org.springframework.integration.aggregator.ThreadPoolTaskScheduler ) ; Message < java.lang.String > org.springframework.integration.aggregator.Message<java.lang.String> = MessageBuilder . withPayload ( STRING ) . setCorrelationId ( STRING ) . build ( ) ; org.springframework.integration.aggregator.AggregatingMessageHandler . handleMessage ( org.springframework.integration.aggregator.Message<java.lang.String> ) ; assertEquals ( NUMBER , java.util.List<org.springframework.integration.aggregator.Message<?>> . size ( ) ) ; assertEquals ( NUMBER , TestUtils . getPropertyValue ( org.springframework.integration.aggregator.AggregatingMessageHandler , STRING , java.util.Map .class ) . size ( ) ) ; java.lang.Thread . void ( NUMBER ) ; int int = NUMBER ; while ( TestUtils . getPropertyValue ( org.springframework.integration.aggregator.AggregatingMessageHandler , STRING , java.util.Map .class ) . size ( ) > NUMBER && int ++ < NUMBER ) { java.lang.Thread . void ( NUMBER ) ; } assertTrue ( int < NUMBER ) ; assertEquals ( NUMBER , TestUtils . getPropertyValue ( org.springframework.integration.aggregator.AggregatingMessageHandler , STRING , java.util.Map .class ) . size ( ) ) ; }  <METHOD_END>
