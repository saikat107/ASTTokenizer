<METHOD_START> @ Test public void void ( ) { DataAccessException org.springframework.cassandra.support.DataAccessException = org.springframework.cassandra.support.CassandraExceptionTranslator . translateExceptionIfPossible ( new AuthenticationException ( java.net.InetSocketAddress , STRING ) ) ; assertThat ( org.springframework.cassandra.support.DataAccessException ) . isInstanceOf ( CassandraAuthenticationException .class ) . hasMessageStartingWith ( STRING ) . hasCauseInstanceOf ( AuthenticationException .class ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { DataAccessException org.springframework.cassandra.support.DataAccessException = org.springframework.cassandra.support.CassandraExceptionTranslator . translateExceptionIfPossible ( new DriverInternalError ( STRING ) ) ; assertThat ( org.springframework.cassandra.support.DataAccessException ) . isInstanceOf ( CassandraInternalException .class ) . hasMessageStartingWith ( STRING ) . hasCauseInstanceOf ( DriverInternalError .class ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { DataAccessException org.springframework.cassandra.support.DataAccessException = org.springframework.cassandra.support.CassandraExceptionTranslator . translateExceptionIfPossible ( new TraceRetrievalException ( STRING ) ) ; assertThat ( org.springframework.cassandra.support.DataAccessException ) . isInstanceOf ( CassandraTraceRetrievalException .class ) . hasMessageStartingWith ( STRING ) . hasCauseInstanceOf ( TraceRetrievalException .class ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { DataAccessException org.springframework.cassandra.support.DataAccessException = org.springframework.cassandra.support.CassandraExceptionTranslator . translateExceptionIfPossible ( new NoHostAvailableException ( java.util.Collections . java.util.Map<java.net.InetSocketAddress,java.lang.IllegalStateException> ( java.net.InetSocketAddress , new java.lang.IllegalStateException ( ) ) ) ) ; assertThat ( org.springframework.cassandra.support.DataAccessException ) . isInstanceOf ( CassandraConnectionFailureException .class ) . hasMessageStartingWith ( STRING ) . hasCauseInstanceOf ( NoHostAvailableException .class ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { DataAccessException org.springframework.cassandra.support.DataAccessException = org.springframework.cassandra.support.CassandraExceptionTranslator . translateExceptionIfPossible ( new InvalidQueryException ( java.net.InetSocketAddress , STRING ) ) ; assertThat ( org.springframework.cassandra.support.DataAccessException ) . isInstanceOf ( CassandraInvalidQueryException .class ) . hasMessageStartingWith ( STRING ) . hasCauseInstanceOf ( InvalidQueryException .class ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { DataAccessException org.springframework.cassandra.support.DataAccessException = org.springframework.cassandra.support.CassandraExceptionTranslator . translateExceptionIfPossible ( new InvalidConfigurationInQueryException ( java.net.InetSocketAddress , STRING ) ) ; assertThat ( org.springframework.cassandra.support.DataAccessException ) . isInstanceOf ( CassandraInvalidConfigurationInQueryException .class ) . hasMessageStartingWith ( STRING ) . hasCauseInstanceOf ( InvalidConfigurationInQueryException .class ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { DataAccessException org.springframework.cassandra.support.DataAccessException = org.springframework.cassandra.support.CassandraExceptionTranslator . translateExceptionIfPossible ( new UnauthorizedException ( java.net.InetSocketAddress , STRING ) ) ; assertThat ( org.springframework.cassandra.support.DataAccessException ) . isInstanceOf ( CassandraUnauthorizedException .class ) . hasMessageStartingWith ( STRING ) . hasCauseInstanceOf ( UnauthorizedException .class ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { DataAccessException org.springframework.cassandra.support.DataAccessException = org.springframework.cassandra.support.CassandraExceptionTranslator . translateExceptionIfPossible ( new SyntaxError ( java.net.InetSocketAddress , STRING ) ) ; assertThat ( org.springframework.cassandra.support.DataAccessException ) . isInstanceOf ( CassandraQuerySyntaxException .class ) . hasMessageStartingWith ( STRING ) . hasCauseInstanceOf ( SyntaxError .class ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { AlreadyExistsException org.springframework.cassandra.support.AlreadyExistsException = new AlreadyExistsException ( STRING , STRING ) ; DataAccessException org.springframework.cassandra.support.DataAccessException = org.springframework.cassandra.support.CassandraExceptionTranslator . translateExceptionIfPossible ( org.springframework.cassandra.support.AlreadyExistsException ) ; assertThat ( org.springframework.cassandra.support.DataAccessException ) . isInstanceOf ( CassandraKeyspaceExistsException .class ) . hasMessageStartingWith ( STRING ) . hasCauseInstanceOf ( AlreadyExistsException .class ) ; CassandraSchemaElementExistsException org.springframework.cassandra.support.CassandraSchemaElementExistsException = ( CassandraSchemaElementExistsException ) org.springframework.cassandra.support.DataAccessException ; assertThat ( org.springframework.cassandra.support.CassandraSchemaElementExistsException . getElementName ( ) ) . isEqualTo ( STRING ) ; assertThat ( org.springframework.cassandra.support.CassandraSchemaElementExistsException . getElementType ( ) ) . isEqualTo ( ElementType . KEYSPACE ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { AlreadyExistsException org.springframework.cassandra.support.AlreadyExistsException = new AlreadyExistsException ( STRING , STRING ) ; DataAccessException org.springframework.cassandra.support.DataAccessException = org.springframework.cassandra.support.CassandraExceptionTranslator . translateExceptionIfPossible ( org.springframework.cassandra.support.AlreadyExistsException ) ; assertThat ( org.springframework.cassandra.support.DataAccessException ) . isInstanceOf ( CassandraTableExistsException .class ) . hasMessageStartingWith ( STRING ) . hasCauseInstanceOf ( AlreadyExistsException .class ) ; CassandraSchemaElementExistsException org.springframework.cassandra.support.CassandraSchemaElementExistsException = ( CassandraSchemaElementExistsException ) org.springframework.cassandra.support.DataAccessException ; assertThat ( org.springframework.cassandra.support.CassandraSchemaElementExistsException . getElementName ( ) ) . isEqualTo ( STRING ) ; assertThat ( org.springframework.cassandra.support.CassandraSchemaElementExistsException . getElementType ( ) ) . isEqualTo ( ElementType . TABLE ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { DataAccessException org.springframework.cassandra.support.DataAccessException = org.springframework.cassandra.support.CassandraExceptionTranslator . translateExceptionIfPossible ( new InvalidTypeException ( STRING ) ) ; assertThat ( org.springframework.cassandra.support.DataAccessException ) . isInstanceOf ( CassandraTypeMismatchException .class ) . hasMessageStartingWith ( STRING ) . hasCauseInstanceOf ( InvalidTypeException .class ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { DataAccessException org.springframework.cassandra.support.DataAccessException = org.springframework.cassandra.support.CassandraExceptionTranslator . translateExceptionIfPossible ( new UnavailableException ( ConsistencyLevel . ALL , NUMBER , NUMBER ) ) ; assertThat ( org.springframework.cassandra.support.DataAccessException ) . isInstanceOf ( CassandraInsufficientReplicasAvailableException .class ) . hasMessageStartingWith ( STRING ) . hasCauseInstanceOf ( UnavailableException .class ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { DataAccessException org.springframework.cassandra.support.DataAccessException = org.springframework.cassandra.support.CassandraExceptionTranslator . translateExceptionIfPossible ( new BootstrappingException ( java.net.InetSocketAddress , STRING ) ) ; assertThat ( org.springframework.cassandra.support.DataAccessException ) . isInstanceOf ( TransientDataAccessResourceException .class ) . hasMessageStartingWith ( STRING ) . hasCauseInstanceOf ( BootstrappingException .class ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { DataAccessException org.springframework.cassandra.support.DataAccessException = org.springframework.cassandra.support.CassandraExceptionTranslator . translateExceptionIfPossible ( new OverloadedException ( java.net.InetSocketAddress , STRING ) ) ; assertThat ( org.springframework.cassandra.support.DataAccessException ) . isInstanceOf ( TransientDataAccessResourceException .class ) . hasMessageStartingWith ( STRING ) . hasCauseInstanceOf ( OverloadedException .class ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { DataAccessException org.springframework.cassandra.support.DataAccessException = org.springframework.cassandra.support.CassandraExceptionTranslator . translateExceptionIfPossible ( new TruncateException ( java.net.InetSocketAddress , STRING ) ) ; assertThat ( org.springframework.cassandra.support.DataAccessException ) . isInstanceOf ( CassandraTruncateException .class ) . hasMessageStartingWith ( STRING ) . hasCauseInstanceOf ( TruncateException .class ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { DataAccessException org.springframework.cassandra.support.DataAccessException = org.springframework.cassandra.support.CassandraExceptionTranslator . translateExceptionIfPossible ( new WriteFailureException ( ConsistencyLevel . ALL , WriteType . BATCH , NUMBER , NUMBER , NUMBER ) ) ; assertThat ( org.springframework.cassandra.support.DataAccessException ) . isInstanceOf ( DataAccessResourceFailureException .class ) . hasMessageStartingWith ( STRING ) . hasCauseInstanceOf ( WriteFailureException .class ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { DataAccessException org.springframework.cassandra.support.DataAccessException = org.springframework.cassandra.support.CassandraExceptionTranslator . translateExceptionIfPossible ( new ReadFailureException ( ConsistencyLevel . ALL , NUMBER , NUMBER , NUMBER , true ) ) ; assertThat ( org.springframework.cassandra.support.DataAccessException ) . isInstanceOf ( DataAccessResourceFailureException .class ) . hasMessageStartingWith ( STRING ) . hasCauseInstanceOf ( ReadFailureException .class ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { DataAccessException org.springframework.cassandra.support.DataAccessException = org.springframework.cassandra.support.CassandraExceptionTranslator . translateExceptionIfPossible ( new WriteTimeoutException ( ConsistencyLevel . ALL , WriteType . BATCH , NUMBER , NUMBER ) ) ; assertThat ( org.springframework.cassandra.support.DataAccessException ) . isInstanceOf ( CassandraWriteTimeoutException .class ) . hasMessageStartingWith ( STRING ) . hasCauseInstanceOf ( WriteTimeoutException .class ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { DataAccessException org.springframework.cassandra.support.DataAccessException = org.springframework.cassandra.support.CassandraExceptionTranslator . translateExceptionIfPossible ( new ReadTimeoutException ( ConsistencyLevel . ALL , NUMBER , NUMBER , true ) ) ; assertThat ( org.springframework.cassandra.support.DataAccessException ) . isInstanceOf ( CassandraReadTimeoutException .class ) . hasMessageStartingWith ( STRING ) . hasCauseInstanceOf ( ReadTimeoutException .class ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { DataAccessException org.springframework.cassandra.support.DataAccessException = org.springframework.cassandra.support.CassandraExceptionTranslator . translateExceptionIfPossible ( new FunctionExecutionException ( java.net.InetSocketAddress , STRING ) ) ; assertThat ( org.springframework.cassandra.support.DataAccessException ) . isInstanceOf ( DataAccessResourceFailureException .class ) . hasMessageStartingWith ( STRING ) . hasCauseInstanceOf ( FunctionExecutionException .class ) ; }  <METHOD_END>
<METHOD_START> @ Test @ java.lang.SuppressWarnings ( STRING ) public void void ( ) java.lang.Exception { assumeTrue ( ClassUtils . isPresent ( STRING , java.lang.Class<? extends org.springframework.cassandra.support.CassandraExceptionTranslatorUnitTests> ( ) . java.lang.ClassLoader ( ) ) ) ; DriverException org.springframework.cassandra.support.DriverException = org.springframework.cassandra.support.DriverException ( STRING , new java.lang.Class [] { java.net.InetSocketAddress .class , java.lang.Integer . java.lang.Class<java.lang.Integer> } , java.net.InetSocketAddress , NUMBER ) ; DataAccessException org.springframework.cassandra.support.DataAccessException = org.springframework.cassandra.support.CassandraExceptionTranslator . translateExceptionIfPossible ( org.springframework.cassandra.support.DriverException ) ; assertThat ( org.springframework.cassandra.support.DataAccessException ) . isInstanceOf ( CassandraConnectionFailureException .class ) . hasMessageContaining ( STRING ) . hasCauseInstanceOf ( org.springframework.cassandra.support.DriverException . getClass ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { DataAccessException org.springframework.cassandra.support.DataAccessException = org.springframework.cassandra.support.CassandraExceptionTranslator . translateExceptionIfPossible ( new ConnectionException ( java.net.InetSocketAddress , STRING ) ) ; assertThat ( org.springframework.cassandra.support.DataAccessException ) . isInstanceOf ( CassandraConnectionFailureException .class ) . hasMessageContaining ( STRING ) . hasCauseInstanceOf ( ConnectionException .class ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { DataAccessException org.springframework.cassandra.support.DataAccessException = org.springframework.cassandra.support.CassandraExceptionTranslator . translateExceptionIfPossible ( new BusyConnectionException ( java.net.InetSocketAddress ) ) ; assertThat ( org.springframework.cassandra.support.DataAccessException ) . isInstanceOf ( CassandraConnectionFailureException .class ) . hasMessageContaining ( STRING ) . hasCauseInstanceOf ( BusyConnectionException .class ) ; }  <METHOD_END>
<METHOD_START> @ Test @ java.lang.SuppressWarnings ( STRING ) public void void ( ) java.lang.Exception { assumeTrue ( ClassUtils . isPresent ( STRING , java.lang.Class<? extends org.springframework.cassandra.support.CassandraExceptionTranslatorUnitTests> ( ) . java.lang.ClassLoader ( ) ) ) ; DriverException org.springframework.cassandra.support.DriverException = org.springframework.cassandra.support.DriverException ( STRING , new java.lang.Class [] { java.lang.Integer . java.lang.Class<java.lang.Integer> } , NUMBER ) ; DataAccessException org.springframework.cassandra.support.DataAccessException = org.springframework.cassandra.support.CassandraExceptionTranslator . translateExceptionIfPossible ( org.springframework.cassandra.support.DriverException ) ; assertThat ( org.springframework.cassandra.support.DataAccessException ) . isInstanceOf ( CassandraUncategorizedException .class ) . hasCauseInstanceOf ( org.springframework.cassandra.support.DriverException . getClass ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { assertThat ( org.springframework.cassandra.support.CassandraExceptionTranslator . translateExceptionIfPossible ( new CodecNotFoundException ( STRING , DataType . ascii ( ) , TypeToken . of ( java.lang.Class .class ) ) ) ) . isInstanceOf ( CassandraUncategorizedException .class ) ; assertThat ( org.springframework.cassandra.support.CassandraExceptionTranslator . translateExceptionIfPossible ( new UnsupportedProtocolVersionException ( java.net.InetSocketAddress , ProtocolVersion . NEWEST_SUPPORTED , ProtocolVersion . V1 ) ) ) . isInstanceOf ( CassandraUncategorizedException .class ) ; assertThat ( org.springframework.cassandra.support.CassandraExceptionTranslator . translateExceptionIfPossible ( new UnpreparedException ( java.net.InetSocketAddress , STRING ) ) ) . isInstanceOf ( CassandraUncategorizedException .class ) ; assertThat ( org.springframework.cassandra.support.CassandraExceptionTranslator . translateExceptionIfPossible ( new PagingStateException ( STRING ) ) ) . isInstanceOf ( CassandraUncategorizedException .class ) ; assertThat ( org.springframework.cassandra.support.CassandraExceptionTranslator . translateExceptionIfPossible ( new UnresolvedUserTypeException ( STRING , STRING ) ) ) . isInstanceOf ( CassandraUncategorizedException .class ) ; assertThat ( org.springframework.cassandra.support.CassandraExceptionTranslator . translateExceptionIfPossible ( new UnsupportedFeatureException ( ProtocolVersion . NEWEST_SUPPORTED , STRING ) ) ) . isInstanceOf ( CassandraUncategorizedException .class ) ; assertThat ( org.springframework.cassandra.support.CassandraExceptionTranslator . translateExceptionIfPossible ( new UnresolvedUserTypeException ( STRING , STRING ) ) ) . isInstanceOf ( CassandraUncategorizedException .class ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { InvalidQueryException org.springframework.cassandra.support.InvalidQueryException = new InvalidConfigurationInQueryException ( null , STRING ) ; DataAccessException org.springframework.cassandra.support.DataAccessException = org.springframework.cassandra.support.CassandraExceptionTranslator . translate ( STRING , STRING , org.springframework.cassandra.support.InvalidQueryException ) ; assertThat ( org.springframework.cassandra.support.DataAccessException ) . hasRootCauseInstanceOf ( InvalidQueryException .class ) . hasMessage ( STRING ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.SuppressWarnings ( STRING ) public < T > T T ( java.lang.String java.lang.String , java.lang.Class<?> < ? > java.lang.Class<?>[] [] , java.lang.Object ... java.lang.Object[] )			throws java.lang.ReflectiveOperationException { java.lang.Class<T> < T > java.lang.Class<T> = ( java.lang.Class ) ClassUtils . forName ( java.lang.String , java.lang.Class<? extends org.springframework.cassandra.support.CassandraExceptionTranslatorUnitTests> ( ) . java.lang.ClassLoader ( ) ) ; java.lang.reflect.Constructor<T> < T > java.lang.reflect.Constructor<T> = java.lang.Class<T> . java.lang.reflect.Constructor<T> ( java.lang.Class<?>[] ) ; return java.lang.reflect.Constructor<T> . T ( java.lang.Object[] ) ; }  <METHOD_END>
