<METHOD_START> public void ( java.nio.channels.SocketChannel java.nio.channels.SocketChannel , boolean boolean , boolean boolean , ApplicationEventPublisher org.springframework.integration.ip.tcp.connection.ApplicationEventPublisher , java.lang.String java.lang.String ) throws java.lang.Exception { super( java.nio.channels.SocketChannel . java.net.Socket ( ) , boolean , boolean , org.springframework.integration.ip.tcp.connection.ApplicationEventPublisher , java.lang.String ); this . java.nio.channels.SocketChannel = java.nio.channels.SocketChannel ; int int = java.nio.channels.SocketChannel . java.net.Socket ( ) . int ( ) ; if ( int <= NUMBER ) { int = this . int ; } this . org.springframework.integration.ip.tcp.connection.TcpNioConnection.ChannelOutputStream = new org.springframework.integration.ip.tcp.connection.TcpNioConnection.ChannelOutputStream ( ) ; }  <METHOD_END>
<METHOD_START> public void void ( long long ) { this . long = long ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ) { this . setNoReadErrorOnClose ( true ) ; void ( ) ; }  <METHOD_END>
<METHOD_START> private void void ( ) { try { this . org.springframework.integration.ip.tcp.connection.TcpNioConnection.ChannelInputStream . void ( ) ; } catch ( java.io.IOException java.io.IOException ) {		} try { this . java.nio.channels.SocketChannel . void ( ) ; } catch ( java.lang.Exception java.lang.Exception ) {		} super. close ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( ) { return this . java.nio.channels.SocketChannel . boolean ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override @ java.lang.SuppressWarnings ( STRING ) public void void ( Message < ? > org.springframework.integration.ip.tcp.connection.Message<?> ) throws java.lang.Exception { synchronized ( this . java.nio.channels.SocketChannel ) { if ( this . java.io.OutputStream == null ) { int int = this . java.nio.channels.SocketChannel . java.net.Socket ( ) . int ( ) ; this . java.io.OutputStream = new java.io.BufferedOutputStream ( this . org.springframework.integration.ip.tcp.connection.TcpNioConnection.ChannelOutputStream ( ) , int > NUMBER ? int : NUMBER ) ; } java.lang.Object java.lang.Object = this . getMapper ( ) . fromMessage ( org.springframework.integration.ip.tcp.connection.Message<> ) ; this . long = java.lang.System . long ( ) ; try { ( ( Serializer < java.lang.Object > ) this . getSerializer ( ) ) . serialize ( java.lang.Object , this . java.io.OutputStream ) ; this . java.io.OutputStream . void ( ) ; } catch ( java.lang.Exception java.lang.Exception ) { this . publishConnectionExceptionEvent ( new MessagingException ( org.springframework.integration.ip.tcp.connection.Message<> , STRING , java.lang.Exception ) ) ; this . closeConnection ( true ) ; throw java.lang.Exception ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( getConnectionId ( ) + STRING + org.springframework.integration.ip.tcp.connection.Message<> ) ; } } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.Object java.lang.Object ( ) java.lang.Exception { return this . getDeserializer ( ) . deserialize ( this . org.springframework.integration.ip.tcp.connection.TcpNioConnection.ChannelInputStream ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public int int ( ) { return this . java.nio.channels.SocketChannel . java.net.Socket ( ) . int ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.Object java.lang.Object ( ) { return this . org.springframework.integration.ip.tcp.connection.TcpNioConnection.ChannelInputStream ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public javax.net.ssl.SSLSession javax.net.ssl.SSLSession ( ) { return null ; }  <METHOD_END>
<METHOD_START> protected java.nio.ByteBuffer java.nio.ByteBuffer ( int int ) { java.nio.ByteBuffer java.nio.ByteBuffer ; if ( this . boolean ) { java.nio.ByteBuffer = java.nio.ByteBuffer . java.nio.ByteBuffer ( int ) ; } else { java.nio.ByteBuffer = java.nio.ByteBuffer . java.nio.ByteBuffer ( int ) ; } return java.nio.ByteBuffer ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ) { if ( logger . isTraceEnabled ( ) ) { logger . trace ( this . getConnectionId ( ) + STRING ) ; } boolean boolean = true ; while ( boolean ) { try { try { if ( boolean ( ) ) { Message < ? > org.springframework.integration.ip.tcp.connection.Message<?> = org.springframework.integration.ip.tcp.connection.Message<?> ( ) ; if ( boolean ( ) ) { this . java.util.concurrent.atomic.AtomicInteger . int ( ) ; try { this . org.springframework.integration.ip.tcp.connection.CompositeExecutor . execute2 ( this ) ; } catch ( java.util.concurrent.RejectedExecutionException java.util.concurrent.RejectedExecutionException ) { this . java.util.concurrent.atomic.AtomicInteger . int ( ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( getConnectionId ( ) + STRING + STRING + this . org.springframework.integration.ip.tcp.connection.TcpNioConnection.ChannelInputStream . int ( ) ) ; } } } this . java.util.concurrent.atomic.AtomicInteger . int ( ) ; if ( org.springframework.integration.ip.tcp.connection.Message<> != null ) { void ( org.springframework.integration.ip.tcp.connection.Message<> ) ; } } else { this . java.util.concurrent.atomic.AtomicInteger . int ( ) ; } } catch ( java.lang.Exception java.lang.Exception ) { if ( logger . isTraceEnabled ( ) ) { logger . error ( STRING + this . getConnectionId ( ) , java.lang.Exception ) ; } else if ( ! this . isNoReadErrorOnClose ( ) ) { logger . error ( STRING + this . getConnectionId ( ) + STRING + java.lang.Exception . java.lang.Class<? extends java.lang.Exception> ( ) . java.lang.String ( ) + STRING + java.lang.Exception . java.lang.Throwable ( ) + STRING + java.lang.Exception . java.lang.String ( ) ) ; } else { if ( logger . isDebugEnabled ( ) ) { logger . debug ( STRING + this . getConnectionId ( ) + STRING + java.lang.Exception . java.lang.Class<? extends java.lang.Exception> ( ) . java.lang.String ( ) + STRING + java.lang.Exception . java.lang.Throwable ( ) + STRING + java.lang.Exception . java.lang.String ( ) ) ; } } this . closeConnection ( true ) ; this . sendExceptionToListener ( java.lang.Exception ) ; return; } } finally { boolean = false ; try { if ( boolean ( ) ) { synchronized ( this . java.util.concurrent.atomic.AtomicInteger ) { if ( this . java.util.concurrent.atomic.AtomicInteger . int ( ) <= NUMBER ) { this . java.util.concurrent.atomic.AtomicInteger . void ( NUMBER ) ; boolean = true ; } else { this . java.util.concurrent.atomic.AtomicInteger . int ( ) ; } } } if ( boolean ) { if ( logger . isTraceEnabled ( ) ) { logger . trace ( this . getConnectionId ( ) + STRING ) ; } } else { if ( logger . isTraceEnabled ( ) ) { logger . trace ( this . getConnectionId ( ) + STRING + this . org.springframework.integration.ip.tcp.connection.TcpNioConnection.ChannelInputStream . int ( ) ) ; } } } catch ( java.io.IOException java.io.IOException ) { logger . error ( STRING , java.io.IOException ) ; } } } }  <METHOD_END>
<METHOD_START> private boolean boolean ( ) java.io.IOException { if ( logger . isTraceEnabled ( ) ) { logger . trace ( getConnectionId ( ) + STRING + this . org.springframework.integration.ip.tcp.connection.TcpNioConnection.ChannelInputStream . int ( ) + STRING + ( this . boolean ) ) ; } return this . boolean || this . org.springframework.integration.ip.tcp.connection.TcpNioConnection.ChannelInputStream . int ( ) > NUMBER ; }  <METHOD_END>
<METHOD_START> private synchronized org.springframework.integration.ip.tcp.connection.Message<?> < ? > org.springframework.integration.ip.tcp.connection.Message<?> ( ) java.lang.Exception { if ( logger . isTraceEnabled ( ) ) { logger . trace ( getConnectionId ( ) + STRING + this . org.springframework.integration.ip.tcp.connection.TcpNioConnection.ChannelInputStream . int ( ) + STRING + ( this . boolean ) ) ; } if ( this . org.springframework.integration.ip.tcp.connection.TcpNioConnection.ChannelInputStream . int ( ) <= NUMBER ) { try { if ( this . java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) { if ( this . org.springframework.integration.ip.tcp.connection.TcpNioConnection.ChannelInputStream . int ( ) <= NUMBER ) { return null ; } } else { throw new java.io.IOException ( STRING ) ; } } catch ( java.lang.InterruptedException java.lang.InterruptedException ) { java.lang.Thread . java.lang.Thread ( ) . void ( ) ; throw new java.io.IOException ( STRING ) ; } } Message < ? > org.springframework.integration.ip.tcp.connection.Message<?> = null ; try { org.springframework.integration.ip.tcp.connection.Message<?> = this . getMapper ( ) . toMessage ( this ) ; } catch ( java.lang.Exception java.lang.Exception ) { this . closeConnection ( true ) ; if ( java.lang.Exception instanceof java.net.SocketTimeoutException ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( STRING + this . getConnectionId ( ) ) ; } } else { if ( ! ( java.lang.Exception instanceof SoftEndOfStreamException ) ) { throw java.lang.Exception ; } } return null ; } return org.springframework.integration.ip.tcp.connection.Message<> ; }  <METHOD_END>
<METHOD_START> private void void ( Message < ? > org.springframework.integration.ip.tcp.connection.Message<?> ) { try { if ( org.springframework.integration.ip.tcp.connection.Message<> != null ) { TcpListener org.springframework.integration.ip.tcp.connection.TcpListener = getListener ( ) ; if ( org.springframework.integration.ip.tcp.connection.TcpListener == null ) { throw new NoListenerException ( STRING ) ; } org.springframework.integration.ip.tcp.connection.TcpListener . onMessage ( org.springframework.integration.ip.tcp.connection.Message<> ) ; } } catch ( java.lang.Exception java.lang.Exception ) { if ( java.lang.Exception instanceof NoListenerException ) { if ( logger . isWarnEnabled ( ) ) { logger . warn ( STRING + getConnectionId ( ) + STRING + org.springframework.integration.ip.tcp.connection.Message<> ) ; } } else { logger . error ( STRING + org.springframework.integration.ip.tcp.connection.Message<> , java.lang.Exception ) ; } } }  <METHOD_END>
<METHOD_START> private void void ( ) java.lang.Exception { if ( this . java.nio.ByteBuffer == null ) { this . java.nio.ByteBuffer = java.nio.ByteBuffer ( this . int ) ; } this . java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; this . boolean = true ; try { if ( this . org.springframework.integration.ip.tcp.connection.CompositeExecutor == null ) { java.util.concurrent.ExecutorService java.util.concurrent.ExecutorService = java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) ; this . org.springframework.integration.ip.tcp.connection.CompositeExecutor = new CompositeExecutor ( java.util.concurrent.ExecutorService , java.util.concurrent.ExecutorService ) ; } void ( ) ; if ( logger . isTraceEnabled ( ) ) { logger . trace ( STRING + this . java.nio.ByteBuffer . int ( ) + STRING + this . java.nio.ByteBuffer . int ( ) ) ; } int int = this . java.nio.channels.SocketChannel . int ( this . java.nio.ByteBuffer ) ; if ( int < NUMBER ) { this . boolean = false ; this . closeConnection ( true ) ; } if ( logger . isTraceEnabled ( ) ) { logger . trace ( STRING + this . java.nio.ByteBuffer . int ( ) + STRING + this . java.nio.ByteBuffer . int ( ) ) ; } this . java.nio.ByteBuffer . java.nio.Buffer ( ) ; if ( logger . isTraceEnabled ( ) ) { logger . trace ( STRING + this . java.nio.ByteBuffer . int ( ) + STRING + this . java.nio.ByteBuffer . int ( ) ) ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( STRING + this . java.nio.ByteBuffer . int ( ) + STRING ) ; } this . void ( this . java.nio.ByteBuffer ) ; } catch ( java.util.concurrent.RejectedExecutionException java.util.concurrent.RejectedExecutionException ) { throw java.util.concurrent.RejectedExecutionException ; } catch ( java.lang.Exception java.lang.Exception ) { this . publishConnectionExceptionEvent ( java.lang.Exception ) ; throw java.lang.Exception ; } finally { this . boolean = false ; this . java.util.concurrent.CountDownLatch . void ( ) ; } }  <METHOD_END>
<METHOD_START> protected void void ( java.nio.ByteBuffer java.nio.ByteBuffer ) throws java.io.IOException { Assert . notNull ( java.nio.ByteBuffer , STRING ) ; if ( logger . isTraceEnabled ( ) ) { logger . trace ( this . getConnectionId ( ) + STRING + java.nio.ByteBuffer . int ( ) + STRING ) ; } this . org.springframework.integration.ip.tcp.connection.TcpNioConnection.ChannelInputStream . void ( java.nio.ByteBuffer ) ; java.nio.ByteBuffer . java.nio.Buffer ( ) ; }  <METHOD_END>
<METHOD_START> private void void ( ) { synchronized ( this . java.util.concurrent.atomic.AtomicInteger ) { if ( this . java.util.concurrent.atomic.AtomicInteger . int ( ) <= NUMBER ) { this . java.util.concurrent.atomic.AtomicInteger . void ( NUMBER ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( this . getConnectionId ( ) + STRING ) ; } try { this . org.springframework.integration.ip.tcp.connection.CompositeExecutor . execute2 ( this ) ; } catch ( java.util.concurrent.RejectedExecutionException java.util.concurrent.RejectedExecutionException ) { this . java.util.concurrent.atomic.AtomicInteger . int ( ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( STRING + STRING ) ; } throw java.util.concurrent.RejectedExecutionException ; } } else { this . java.util.concurrent.atomic.AtomicInteger . int ( ) ; } } }  <METHOD_END>
<METHOD_START> public void void ( ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( this . getConnectionId ( ) + STRING ) ; } try { void ( ) ; } catch ( java.nio.channels.ClosedChannelException java.nio.channels.ClosedChannelException ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( this . getConnectionId ( ) + STRING ) ; } this . closeConnection ( true ) ; } catch ( java.util.concurrent.RejectedExecutionException java.util.concurrent.RejectedExecutionException ) { throw java.util.concurrent.RejectedExecutionException ; } catch ( java.lang.Exception java.lang.Exception ) { logger . error ( STRING + this . getConnectionId ( ) + STRING + java.lang.Exception . java.lang.String ( ) , java.lang.Exception ) ; this . closeConnection ( true ) ; } }  <METHOD_END>
<METHOD_START> void void ( ) { this . boolean = true ; this . closeConnection ( true ) ; }  <METHOD_END>
<METHOD_START> public void void ( java.util.concurrent.Executor java.util.concurrent.Executor ) { if ( java.util.concurrent.Executor instanceof CompositeExecutor ) { this . org.springframework.integration.ip.tcp.connection.CompositeExecutor = ( CompositeExecutor ) java.util.concurrent.Executor ; } else { this . org.springframework.integration.ip.tcp.connection.CompositeExecutor = new CompositeExecutor ( java.util.concurrent.Executor , java.util.concurrent.Executor ) ; } }  <METHOD_END>
<METHOD_START> public void void ( boolean boolean ) { this . boolean = boolean ; }  <METHOD_END>
<METHOD_START> protected boolean boolean ( ) { return this . boolean ; }  <METHOD_END>
<METHOD_START> protected org.springframework.integration.ip.tcp.connection.TcpNioConnection.ChannelOutputStream org.springframework.integration.ip.tcp.connection.TcpNioConnection.ChannelOutputStream ( ) { return this . org.springframework.integration.ip.tcp.connection.TcpNioConnection.ChannelOutputStream ; }  <METHOD_END>
<METHOD_START> public long long ( ) { return this . long ; }  <METHOD_END>
<METHOD_START> public void void ( long long ) { this . long = long ; }  <METHOD_END>
<METHOD_START> public long long ( ) { return this . long ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( int int ) throws java.io.IOException { byte [] byte[] = new byte [ NUMBER ] ; byte[] [ NUMBER ] = ( byte ) int ; java.nio.ByteBuffer java.nio.ByteBuffer = java.nio.ByteBuffer . java.nio.ByteBuffer ( byte[] ) ; void ( java.nio.ByteBuffer ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ) java.io.IOException { void ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ) java.io.IOException {		}  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( byte [] byte[] , int int , int int ) throws java.io.IOException { java.nio.ByteBuffer java.nio.ByteBuffer = java.nio.ByteBuffer . java.nio.ByteBuffer ( byte[] , int , int ) ; void ( java.nio.ByteBuffer ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( byte [] byte[] ) throws java.io.IOException { java.nio.ByteBuffer java.nio.ByteBuffer = java.nio.ByteBuffer . java.nio.ByteBuffer ( byte[] ) ; void ( java.nio.ByteBuffer ) ; }  <METHOD_END>
<METHOD_START> protected synchronized void void ( java.nio.ByteBuffer java.nio.ByteBuffer ) throws java.io.IOException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( getConnectionId ( ) + STRING + java.nio.ByteBuffer . int ( ) ) ; } org.springframework.integration.ip.tcp.connection.TcpNioConnection .this . java.nio.channels.SocketChannel . int ( java.nio.ByteBuffer ) ; int int = java.nio.ByteBuffer . int ( ) ; if ( int == NUMBER ) { return; } if ( this . java.nio.channels.Selector == null ) { this . java.nio.channels.Selector = java.nio.channels.Selector . java.nio.channels.Selector ( ) ; this . int = org.springframework.integration.ip.tcp.connection.TcpNioConnection .this . java.nio.channels.SocketChannel . java.net.Socket ( ) . int ( ) ; } org.springframework.integration.ip.tcp.connection.TcpNioConnection .this . java.nio.channels.SocketChannel . java.nio.channels.SelectionKey ( this . java.nio.channels.Selector , java.nio.channels.SelectionKey . int ) ; while ( int > NUMBER ) { int int = this . java.nio.channels.Selector . int ( this . int ) ; if ( int == NUMBER ) { throw new java.net.SocketTimeoutException ( STRING ) ; } this . java.nio.channels.Selector . java.util.Set<java.nio.channels.SelectionKey> ( ) . void ( ) ; org.springframework.integration.ip.tcp.connection.TcpNioConnection .this . java.nio.channels.SocketChannel . int ( java.nio.ByteBuffer ) ; int = java.nio.ByteBuffer . int ( ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public int int ( byte [] byte[] , int int , int int ) throws java.io.IOException { Assert . notNull ( byte[] , STRING ) ; if ( int < NUMBER || int < NUMBER || int > byte[] . int - int ) { throw new java.lang.IndexOutOfBoundsException ( ) ; } else if ( int == NUMBER ) { return NUMBER ; } int int = NUMBER ; while ( ( this . java.util.concurrent.atomic.AtomicInteger . int ( ) > NUMBER || int == NUMBER ) && int < int ) { int int = int ( ) ; if ( int < NUMBER ) { if ( int == NUMBER ) { return - NUMBER ; } else { return int ; } } byte[] [ int + int ++ ] = ( byte ) int ; } return int ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public synchronized int int ( ) java.io.IOException { if ( this . boolean && this . java.util.concurrent.atomic.AtomicInteger . int ( ) == NUMBER ) { if ( org.springframework.integration.ip.tcp.connection.TcpNioConnection .this . boolean ) { throw new java.net.SocketTimeoutException ( STRING ) ; } return - NUMBER ; } if ( this . byte[] == null ) { this . byte[] = byte[] ( ) ; this . int = NUMBER ; if ( this . byte[] == null ) { if ( org.springframework.integration.ip.tcp.connection.TcpNioConnection .this . boolean ) { throw new java.net.SocketTimeoutException ( STRING ) ; } return - NUMBER ; } } int int ; int = this . byte[] [ this . int ++ ] & NUMBER ; this . java.util.concurrent.atomic.AtomicInteger . int ( ) ; if ( this . int >= this . byte[] . int ) { this . byte[] = null ; } return int ; }  <METHOD_END>
<METHOD_START> private byte [] byte[] ( ) java.io.IOException { byte [] byte[] = null ; while ( byte[] == null ) { try { byte[] = this . java.util.concurrent.BlockingQueue<byte[]> . byte[] ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ; if ( byte[] == null && this . boolean ) { return null ; } } catch ( java.lang.InterruptedException java.lang.InterruptedException ) { java.lang.Thread . java.lang.Thread ( ) . void ( ) ; throw new java.io.IOException ( STRING , java.lang.InterruptedException ) ; } } return byte[] ; }  <METHOD_END>
<METHOD_START> public void void ( java.nio.ByteBuffer java.nio.ByteBuffer ) throws java.io.IOException { int int = java.nio.ByteBuffer . int ( ) - java.nio.ByteBuffer . int ( ) ; if ( int > NUMBER ) { byte [] byte[] = new byte [ int ] ; java.nio.ByteBuffer . java.nio.ByteBuffer ( byte[] ) ; this . java.util.concurrent.atomic.AtomicInteger . int ( int ) ; if ( org.springframework.integration.ip.tcp.connection.TcpNioConnection .this . java.util.concurrent.CountDownLatch != null ) { org.springframework.integration.ip.tcp.connection.TcpNioConnection .this . java.util.concurrent.CountDownLatch . void ( ) ; } try { if ( ! this . java.util.concurrent.BlockingQueue<byte[]> . boolean ( byte[] , org.springframework.integration.ip.tcp.connection.TcpNioConnection .this . long , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) { throw new java.io.IOException ( STRING ) ; } } catch ( java.lang.InterruptedException java.lang.InterruptedException ) { java.lang.Thread . java.lang.Thread ( ) . void ( ) ; throw new java.io.IOException ( STRING , java.lang.InterruptedException ) ; } org.springframework.integration.ip.tcp.connection.TcpNioConnection .this . java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ) java.io.IOException { super. void ( ) ; this . boolean = true ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public int int ( ) java.io.IOException { return this . java.util.concurrent.atomic.AtomicInteger . int ( ) ; }  <METHOD_END>
