<METHOD_START> public void ( RepositoryMetadata org.springframework.data.repository.core.support.RepositoryMetadata , java.lang.Class<?> < ? > java.lang.Class<?> , java.util.Optional<java.lang.Class<?>> < java.lang.Class<?> < ? > > java.util.Optional<java.lang.Class<?>> ) { Assert . notNull ( metadata , STRING ) ; Assert . notNull ( repositoryBaseClass , STRING ) ; Assert . notNull ( customImplementationClass , STRING ) ; this . metadata = metadata ; this . repositoryBaseClass = repositoryBaseClass ; this . customImplementationClass = customImplementationClass ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.Class<?> < ? > java.lang.Class<?> ( ) { return metadata . getDomainType ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.Class<? extends java.io.Serializable> < ? extends java.io.Serializable > java.lang.Class<? extends java.io.Serializable> ( ) { return metadata . getIdType ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.Class<?> < ? > java.lang.Class<?> ( ) { return this . repositoryBaseClass ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.reflect.Method java.lang.reflect.Method ( java.lang.reflect.Method java.lang.reflect.Method ) { if ( methodCache . containsKey ( method ) ) { return methodCache . get ( method ) ; } Method result = getTargetClassMethod ( method , customImplementationClass ) ; if ( ! result . equals ( method ) ) { return cacheAndReturn ( method , result ) ; } return cacheAndReturn ( method , getTargetClassMethod ( method , Optional . of ( repositoryBaseClass ) ) ) ; }  <METHOD_END>
<METHOD_START> private java.lang.reflect.Method java.lang.reflect.Method ( java.lang.reflect.Method java.lang.reflect.Method , java.lang.reflect.Method java.lang.reflect.Method ) { if ( value != null ) { makeAccessible ( value ) ; } methodCache . put ( key , value ) ; return value ; }  <METHOD_END>
<METHOD_START> private boolean boolean ( java.lang.reflect.Method java.lang.reflect.Method , java.util.Optional<java.lang.Class<?>> < java.lang.Class<?> < ? > > java.util.Optional<java.lang.Class<?>> ) { Assert . notNull ( method , STRING ) ; return targetType . map ( it -> method . getDeclaringClass ( ) . isAssignableFrom ( it ) || ! method . equals ( getTargetClassMethod ( method , targetType ) ) ) . orElse ( false ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public Streamable < java.lang.reflect.Method > org.springframework.data.repository.core.support.Streamable<java.lang.reflect.Method> ( ) { Set < Method > result = new HashSet <> ( ) ; for ( Method method : getRepositoryInterface ( ) . getMethods ( ) ) { method = ClassUtils . getMostSpecificMethod ( method , getRepositoryInterface ( ) ) ; if ( isQueryMethodCandidate ( method ) ) { result . add ( method ) ; } } return Streamable . of ( Collections . unmodifiableSet ( result ) ) ; }  <METHOD_END>
<METHOD_START> private boolean boolean ( java.lang.reflect.Method java.lang.reflect.Method ) { return ! method . isBridge ( ) && ! method . isDefault ( ) && ! Modifier . isStatic ( method . getModifiers ( ) ) && ( isQueryAnnotationPresentOn ( method ) || ! isCustomMethod ( method ) && ! isBaseClassMethod ( method ) ) ; }  <METHOD_END>
<METHOD_START> private boolean boolean ( java.lang.reflect.Method java.lang.reflect.Method ) { return AnnotationUtils . findAnnotation ( method , QueryAnnotation .class ) != null ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( java.lang.reflect.Method java.lang.reflect.Method ) { return isTargetClassMethod ( method , customImplementationClass ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( java.lang.reflect.Method java.lang.reflect.Method ) { return getQueryMethods ( ) . stream ( ) . anyMatch ( it -> it . equals ( method ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( java.lang.reflect.Method java.lang.reflect.Method ) { Assert . notNull ( method , STRING ) ; return isTargetClassMethod ( method , Optional . of ( repositoryBaseClass ) ) ; }  <METHOD_END>
<METHOD_START> java.lang.reflect.Method java.lang.reflect.Method ( java.lang.reflect.Method java.lang.reflect.Method , java.util.Optional<java.lang.Class<?>> < java.lang.Class<?> < ? > > java.util.Optional<java.lang.Class<?>> ) { Supplier < Optional < Method > > directMatch = ( ) baseClass . map ( it -> findMethod ( it , method . getName ( ) , method . getParameterTypes ( ) ) ) ; Supplier < Optional < Method > > detailedComparison = ( ) baseClass . flatMap ( it -> Arrays . stream ( it . getMethods ( ) ) . filter ( baseClassMethod -> method . getName ( ) . equals ( baseClassMethod . getName ( ) ) ) . filter ( baseClassMethod -> method . getParameterCount ( ) == baseClassMethod . getParameterCount ( ) ) . filter ( baseClassMethod -> parametersMatch ( method , baseClassMethod ) ) . findFirst ( ) ) ; return Optionals . firstNonEmpty ( directMatch , detailedComparison ) . orElse ( method ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( ) { Class < ? > repositoryInterface = getRepositoryInterface ( ) ; if ( isGenericRepositoryInterface ( repositoryInterface ) ) { return false ; } for ( Method method : repositoryInterface . getMethods ( ) ) { if ( isCustomMethod ( method ) && ! isBaseClassMethod ( method ) ) { return true ; } } return false ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.Class<?> < ? > java.lang.Class<?> ( ) { return metadata . getRepositoryInterface ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.Class<?> < ? > java.lang.Class<?> ( java.lang.reflect.Method java.lang.reflect.Method ) { return metadata . getReturnedDomainClass ( method ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public CrudMethods org.springframework.data.repository.core.support.CrudMethods ( ) { return metadata . getCrudMethods ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( ) { return metadata . isPagingRepository ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.util.Set<java.lang.Class<?>> < java.lang.Class<?> < ? > > java.util.Set<java.lang.Class<?>> ( ) { return metadata . getAlternativeDomainTypes ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( ) { return metadata . isReactiveRepository ( ) ; }  <METHOD_END>
<METHOD_START> protected boolean boolean ( java.lang.reflect.TypeVariable<?> < ? > java.lang.reflect.TypeVariable<?> , ResolvableType org.springframework.data.repository.core.support.ResolvableType ) { GenericDeclaration declaration = variable . getGenericDeclaration ( ) ; if ( declaration instanceof Class ) { ResolvableType entityType = ResolvableType . forClass ( getDomainType ( ) ) ; ResolvableType idClass = ResolvableType . forClass ( getIdType ( ) ) ; if ( ID_TYPE_NAME . equals ( variable . getName ( ) ) && parameterType . isAssignableFrom ( idClass ) ) { return true ; } Type boundType = variable . getBounds ( ) [ NUMBER ] ; String referenceName = boundType instanceof TypeVariable ? boundType . toString ( ) : variable . toString ( ) ; return DOMAIN_TYPE_NAME . equals ( referenceName ) && parameterType . isAssignableFrom ( entityType ) ; } for ( Type type : variable . getBounds ( ) ) { if ( ResolvableType . forType ( type ) . isAssignableFrom ( parameterType ) ) { return true ; } } return false ; }  <METHOD_END>
<METHOD_START> private boolean boolean ( java.lang.reflect.Method java.lang.reflect.Method , java.lang.reflect.Method java.lang.reflect.Method ) { Class < ? > [] methodParameterTypes = method . getParameterTypes ( ) ; Type [] genericTypes = baseClassMethod . getGenericParameterTypes ( ) ; Class < ? > [] types = baseClassMethod . getParameterTypes ( ) ; for ( int i = NUMBER ; i < genericTypes . length ; i ++ ) { Type genericType = genericTypes [ i ] ; Class < ? > type = types [ i ] ; MethodParameter parameter = new MethodParameter ( method , i ) ; Class < ? > parameterType = resolveParameterType ( parameter , metadata . getRepositoryInterface ( ) ) ; if ( genericType instanceof TypeVariable < ? > ) { if ( ! matchesGenericType ( ( TypeVariable < ? > ) genericType , ResolvableType . forMethodParameter ( parameter ) ) ) { return false ; } continue; } if ( types [ i ] . equals ( parameterType ) ) { continue; } if ( ! type . isAssignableFrom ( parameterType ) || ! type . equals ( methodParameterTypes [ i ] ) ) { return false ; } } return true ; }  <METHOD_END>
