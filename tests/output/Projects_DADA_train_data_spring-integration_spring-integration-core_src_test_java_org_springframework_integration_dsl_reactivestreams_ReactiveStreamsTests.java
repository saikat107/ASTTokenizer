<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.util.List<java.lang.String> < java.lang.String > java.util.List<java.lang.String> = new java.util.ArrayList<java.lang.String> <> ( ) ; java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; Flux . from ( this . org.springframework.integration.dsl.reactivestreams.Publisher<org.springframework.integration.dsl.reactivestreams.Message<java.lang.String>> ) . map ( m -> m . getPayload ( ) . toUpperCase ( ) ) . subscribe ( p -> { results . add ( p ) ; latch . countDown ( ) ; } ) ; this . org.springframework.integration.dsl.reactivestreams.Lifecycle . start ( ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; java.lang.String [] java.lang.String[] = java.util.List<java.lang.String> . java.lang.String[] ( new java.lang.String [ java.util.List<java.lang.String> . int ( ) ] ) ; assertArrayEquals ( new java.lang.String [] { STRING , STRING , STRING , STRING , STRING , STRING } , java.lang.String[] ) ; this . org.springframework.integration.dsl.reactivestreams.Lifecycle . stop ( ) ; }  <METHOD_END>
<METHOD_START> @ Test @ Repeat ( NUMBER ) public void void ( ) java.lang.Exception { this . org.springframework.integration.dsl.reactivestreams.MessageChannel . send ( new GenericMessage <> ( STRING ) ) ; java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; Flux . from ( this . org.springframework.integration.dsl.reactivestreams.Publisher<org.springframework.integration.dsl.reactivestreams.Message<java.lang.Integer>> ) . take ( NUMBER ) . filter ( m -> m . getHeaders ( ) . containsKey ( IntegrationMessageHeaderAccessor . SEQUENCE_NUMBER ) ) . log ( STRING ) . doOnNext ( p -> latch . countDown ( ) ) . subscribe ( ) ; java.util.concurrent.Future<java.util.List<java.lang.Integer>> < java.util.List<java.lang.Integer> < java.lang.Integer > > java.util.concurrent.Future<java.util.List<java.lang.Integer>> = java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . java.util.concurrent.Future<?> ( ( ) Flux . just ( STRING ) . map ( v -> v . split ( STRING ) ) . flatMapIterable ( java.util.Arrays :: asList ) . map ( java.lang.Integer :: parseInt ) .< Message < java.lang.Integer > > map ( GenericMessage < java.lang.Integer > ::new ) . concatWith ( this . org.springframework.integration.dsl.reactivestreams.Publisher<org.springframework.integration.dsl.reactivestreams.Message<java.lang.Integer>> ) . take ( NUMBER ) . map ( Message :: getPayload ) . log ( STRING ) . collectList ( ) . block ( java.time.Duration . java.time.Duration ( NUMBER ) ) ) ; this . org.springframework.integration.dsl.reactivestreams.MessageChannel . send ( new GenericMessage <> ( STRING ) ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; java.util.List<java.lang.Integer> < java.lang.Integer > java.util.List<java.lang.Integer> = java.util.concurrent.Future<java.util.List<java.lang.Integer>> . java.util.List<java.lang.Integer> ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ; assertNotNull ( java.util.List<java.lang.Integer> ) ; assertEquals ( NUMBER , java.util.List<java.lang.Integer> . int ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { Flux < Message < ? > > org.springframework.integration.dsl.reactivestreams.Flux<org.springframework.integration.dsl.reactivestreams.Message<?>> = Flux . just ( STRING ) . map ( v -> v . split ( STRING ) ) . flatMapIterable ( java.util.Arrays :: asList ) . map ( java.lang.Integer :: parseInt ) . log ( STRING ) . map ( GenericMessage < java.lang.Integer > ::new ) ; QueueChannel org.springframework.integration.dsl.reactivestreams.QueueChannel = new QueueChannel ( ) ; IntegrationFlow org.springframework.integration.dsl.reactivestreams.IntegrationFlow = IntegrationFlows . from ( org.springframework.integration.dsl.reactivestreams.Flux<org.springframework.integration.dsl.reactivestreams.Message<?>> ) . log ( STRING ) .< java.lang.Integer , java.lang.Integer > transform ( p -> p * NUMBER ) . channel ( org.springframework.integration.dsl.reactivestreams.QueueChannel ) . get ( ) ; this . org.springframework.integration.dsl.reactivestreams.IntegrationFlowContext . registration ( org.springframework.integration.dsl.reactivestreams.IntegrationFlow ) . register ( ) ; for ( int int = NUMBER ; int < NUMBER ; int ++ ) { Message < ? > org.springframework.integration.dsl.reactivestreams.Message<?> = org.springframework.integration.dsl.reactivestreams.QueueChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.dsl.reactivestreams.Message<> ) ; assertEquals ( ( int + NUMBER ) * NUMBER , org.springframework.integration.dsl.reactivestreams.Message<> . getPayload ( ) ) ; } }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.integration.dsl.reactivestreams.Publisher<org.springframework.integration.dsl.reactivestreams.Message<java.lang.String>> < Message < java.lang.String > > org.springframework.integration.dsl.reactivestreams.Publisher<org.springframework.integration.dsl.reactivestreams.Message<java.lang.String>> ( ) { return IntegrationFlows . from ( ( ) new GenericMessage <> ( STRING ) , e -> e . poller ( p -> p . trigger ( ctx -> this . invoked . getAndSet ( true ) ? null : new Date ( ) ) ) . autoStartup ( false ) . id ( STRING ) ) . split ( java.lang.String .class , p -> p . split ( STRING ) ) . toReactivePublisher ( ) ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.integration.dsl.reactivestreams.Publisher<org.springframework.integration.dsl.reactivestreams.Message<java.lang.Integer>> < Message < java.lang.Integer > > org.springframework.integration.dsl.reactivestreams.Publisher<org.springframework.integration.dsl.reactivestreams.Message<java.lang.Integer>> ( ) { return IntegrationFlows . from ( STRING ) . split ( s -> s . delimiters ( STRING ) ) .< java.lang.String , java.lang.Integer > transform ( java.lang.Integer :: parseInt ) . channel ( MessageChannels . queue ( ) ) . toReactivePublisher ( ) ; }  <METHOD_END>
