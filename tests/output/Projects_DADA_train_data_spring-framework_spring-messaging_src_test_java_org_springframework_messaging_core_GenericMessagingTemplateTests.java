<METHOD_START> @ Before public void void ( ) { this . org.springframework.messaging.core.StubMessageChannel = new StubMessageChannel ( ) ; this . org.springframework.messaging.core.GenericMessagingTemplate = new GenericMessagingTemplate ( ) ; this . org.springframework.messaging.core.GenericMessagingTemplate . setDefaultDestination ( this . org.springframework.messaging.core.StubMessageChannel ) ; this . org.springframework.messaging.core.GenericMessagingTemplate . setDestinationResolver ( new org.springframework.messaging.core.GenericMessagingTemplateTests.TestDestinationResolver ( ) ) ; this . org.springframework.messaging.core.ThreadPoolTaskExecutor = new ThreadPoolTaskExecutor ( ) ; this . org.springframework.messaging.core.ThreadPoolTaskExecutor . afterPropertiesSet ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { SubscribableChannel org.springframework.messaging.core.SubscribableChannel = new ExecutorSubscribableChannel ( this . org.springframework.messaging.core.ThreadPoolTaskExecutor ) ; org.springframework.messaging.core.SubscribableChannel . subscribe ( new MessageHandler ( ) { @ java.lang.Override public void void ( Message < ? > org.springframework.messaging.core.Message<?> ) throws org.springframework.messaging.core.MessagingException { MessageChannel org.springframework.messaging.core.MessageChannel = ( MessageChannel ) org.springframework.messaging.core.Message<> . getHeaders ( ) . getReplyChannel ( ) ; org.springframework.messaging.core.MessageChannel . send ( new GenericMessage <> ( STRING ) ) ; } } ) ; java.lang.String java.lang.String = this . org.springframework.messaging.core.GenericMessagingTemplate . convertSendAndReceive ( org.springframework.messaging.core.SubscribableChannel , STRING , java.lang.String .class ) ; assertEquals ( STRING , java.lang.String ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( Message < ? > org.springframework.messaging.core.Message<?> ) throws org.springframework.messaging.core.MessagingException { MessageChannel org.springframework.messaging.core.MessageChannel = ( MessageChannel ) org.springframework.messaging.core.Message<> . getHeaders ( ) . getReplyChannel ( ) ; org.springframework.messaging.core.MessageChannel . send ( new GenericMessage <> ( STRING ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.InterruptedException { final java.util.concurrent.atomic.AtomicReference<java.lang.Throwable> < java.lang.Throwable > java.util.concurrent.atomic.AtomicReference<java.lang.Throwable> = new java.util.concurrent.atomic.AtomicReference<java.lang.Throwable> < java.lang.Throwable > ( ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; this . org.springframework.messaging.core.GenericMessagingTemplate . setReceiveTimeout ( NUMBER ) ; this . org.springframework.messaging.core.GenericMessagingTemplate . setThrowExceptionOnLateReply ( true ) ; SubscribableChannel org.springframework.messaging.core.SubscribableChannel = new ExecutorSubscribableChannel ( this . org.springframework.messaging.core.ThreadPoolTaskExecutor ) ; org.springframework.messaging.core.SubscribableChannel . subscribe ( new MessageHandler ( ) { @ java.lang.Override public void void ( Message < ? > org.springframework.messaging.core.Message<?> ) throws org.springframework.messaging.core.MessagingException { try { java.lang.Thread . void ( NUMBER ) ; MessageChannel org.springframework.messaging.core.MessageChannel = ( MessageChannel ) org.springframework.messaging.core.Message<> . getHeaders ( ) . getReplyChannel ( ) ; org.springframework.messaging.core.MessageChannel . send ( new GenericMessage <> ( STRING ) ) ; java.util.concurrent.atomic.AtomicReference<java.lang.Throwable> . void ( new java.lang.IllegalStateException ( STRING ) ) ; } catch ( java.lang.InterruptedException java.lang.InterruptedException ) { java.util.concurrent.atomic.AtomicReference<java.lang.Throwable> . void ( java.lang.InterruptedException ) ; } catch ( MessageDeliveryException org.springframework.messaging.core.MessageDeliveryException ) { java.lang.String java.lang.String = STRING ; java.lang.String java.lang.String = org.springframework.messaging.core.MessageDeliveryException . getMessage ( ) ; if ( ! java.lang.String . boolean ( java.lang.String ) ) { java.util.concurrent.atomic.AtomicReference<java.lang.Throwable> . void ( new java.lang.IllegalStateException ( STRING + java.lang.String + STRING ) ) ; } } finally { java.util.concurrent.CountDownLatch . void ( ) ; } } } ) ; assertNull ( this . org.springframework.messaging.core.GenericMessagingTemplate . convertSendAndReceive ( org.springframework.messaging.core.SubscribableChannel , STRING , java.lang.String .class ) ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; java.lang.Throwable java.lang.Throwable = java.util.concurrent.atomic.AtomicReference<java.lang.Throwable> . java.lang.Throwable ( ) ; if ( java.lang.Throwable != null ) { throw new java.lang.AssertionError ( java.lang.Throwable ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( Message < ? > org.springframework.messaging.core.Message<?> ) throws org.springframework.messaging.core.MessagingException { try { java.lang.Thread . void ( NUMBER ) ; MessageChannel org.springframework.messaging.core.MessageChannel = ( MessageChannel ) org.springframework.messaging.core.Message<> . getHeaders ( ) . getReplyChannel ( ) ; org.springframework.messaging.core.MessageChannel . send ( new GenericMessage <> ( STRING ) ) ; java.util.concurrent.atomic.AtomicReference<java.lang.Throwable> . void ( new java.lang.IllegalStateException ( STRING ) ) ; } catch ( java.lang.InterruptedException java.lang.InterruptedException ) { java.util.concurrent.atomic.AtomicReference<java.lang.Throwable> . void ( java.lang.InterruptedException ) ; } catch ( MessageDeliveryException org.springframework.messaging.core.MessageDeliveryException ) { java.lang.String java.lang.String = STRING ; java.lang.String java.lang.String = org.springframework.messaging.core.MessageDeliveryException . getMessage ( ) ; if ( ! java.lang.String . boolean ( java.lang.String ) ) { java.util.concurrent.atomic.AtomicReference<java.lang.Throwable> . void ( new java.lang.IllegalStateException ( STRING + java.lang.String + STRING ) ) ; } } finally { java.util.concurrent.CountDownLatch . void ( ) ; } }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { MessageHeaderAccessor org.springframework.messaging.core.MessageHeaderAccessor = new MessageHeaderAccessor ( ) ; org.springframework.messaging.core.MessageHeaderAccessor . setHeader ( STRING , STRING ) ; org.springframework.messaging.core.MessageHeaderAccessor . setLeaveMutable ( true ) ; MessageHeaders org.springframework.messaging.core.MessageHeaders = org.springframework.messaging.core.MessageHeaderAccessor . getMessageHeaders ( ) ; this . org.springframework.messaging.core.GenericMessagingTemplate . convertAndSend ( STRING , STRING , org.springframework.messaging.core.MessageHeaders ) ; java.util.List<org.springframework.messaging.core.Message<byte[]>> < Message < byte [] > > java.util.List<org.springframework.messaging.core.Message<byte[]>> = this . org.springframework.messaging.core.StubMessageChannel . getMessages ( ) ; Message < byte [] > org.springframework.messaging.core.Message<byte[]> = java.util.List<org.springframework.messaging.core.Message<byte[]>> . get ( NUMBER ) ; assertSame ( org.springframework.messaging.core.MessageHeaders , org.springframework.messaging.core.Message<byte[]> . getHeaders ( ) ) ; assertFalse ( org.springframework.messaging.core.MessageHeaderAccessor . isMutable ( ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.messaging.core.MessageChannel org.springframework.messaging.core.MessageChannel ( java.lang.String java.lang.String ) throws org.springframework.messaging.core.DestinationResolutionException { return org.springframework.messaging.core.StubMessageChannel ; }  <METHOD_END>
