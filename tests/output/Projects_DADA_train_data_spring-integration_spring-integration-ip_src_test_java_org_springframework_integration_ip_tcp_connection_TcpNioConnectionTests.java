<METHOD_START> @ Test public void void ( ) java.lang.Exception { final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; final java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> < java.net.ServerSocket > java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> = new java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> < java.net.ServerSocket > ( ) ; java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . void ( ( ) { try { java.net.ServerSocket java.net.ServerSocket = javax.net.ServerSocketFactory . javax.net.ServerSocketFactory ( ) . java.net.ServerSocket ( NUMBER ) ; org.springframework.integration.ip.tcp.connection.Log . debug ( org.springframework.integration.ip.tcp.connection.TestName . getMethodName ( ) + STRING + java.net.ServerSocket . int ( ) ) ; java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . void ( java.net.ServerSocket ) ; java.util.concurrent.CountDownLatch . void ( ) ; java.net.Socket java.net.Socket = java.net.ServerSocket . java.net.Socket ( ) ; java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ; } catch ( java.lang.Exception java.lang.Exception ) { java.lang.Exception . void ( ) ; } } ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; TcpNioClientConnectionFactory org.springframework.integration.ip.tcp.connection.TcpNioClientConnectionFactory = new TcpNioClientConnectionFactory ( STRING , java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . java.net.ServerSocket ( ) . int ( ) ) ; org.springframework.integration.ip.tcp.connection.TcpNioClientConnectionFactory . setApplicationEventPublisher ( org.springframework.integration.ip.tcp.connection.ApplicationEventPublisher ) ; org.springframework.integration.ip.tcp.connection.TcpNioClientConnectionFactory . setSoTimeout ( NUMBER ) ; org.springframework.integration.ip.tcp.connection.TcpNioClientConnectionFactory . start ( ) ; try { TcpConnection org.springframework.integration.ip.tcp.connection.TcpConnection = org.springframework.integration.ip.tcp.connection.TcpNioClientConnectionFactory . getConnection ( ) ; org.springframework.integration.ip.tcp.connection.TcpConnection . send ( MessageBuilder . withPayload ( new byte [ NUMBER ] ) . build ( ) ) ; } catch ( java.lang.Exception java.lang.Exception ) { assertTrue ( STRING + java.lang.Exception . java.lang.Class<? extends java.lang.Exception> ( ) . java.lang.String ( ) + STRING + java.lang.Exception . java.lang.String ( ) , java.lang.Exception instanceof java.net.SocketTimeoutException ) ; } java.util.concurrent.CountDownLatch . void ( ) ; java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . java.net.ServerSocket ( ) . void ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; final java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> < java.net.ServerSocket > java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> = new java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> < java.net.ServerSocket > ( ) ; java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . void ( ( ) { try { java.net.ServerSocket java.net.ServerSocket = javax.net.ServerSocketFactory . javax.net.ServerSocketFactory ( ) . java.net.ServerSocket ( NUMBER ) ; org.springframework.integration.ip.tcp.connection.Log . debug ( org.springframework.integration.ip.tcp.connection.TestName . getMethodName ( ) + STRING + java.net.ServerSocket . int ( ) ) ; java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . void ( java.net.ServerSocket ) ; java.util.concurrent.CountDownLatch . void ( ) ; java.net.Socket java.net.Socket = java.net.ServerSocket . java.net.Socket ( ) ; byte [] byte[] = new byte [ NUMBER ] ; void ( java.net.Socket . java.io.InputStream ( ) , byte[] ) ; java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ; } catch ( java.lang.Exception java.lang.Exception ) { java.lang.Exception . void ( ) ; } } ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; TcpNioClientConnectionFactory org.springframework.integration.ip.tcp.connection.TcpNioClientConnectionFactory = new TcpNioClientConnectionFactory ( STRING , java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . java.net.ServerSocket ( ) . int ( ) ) ; org.springframework.integration.ip.tcp.connection.TcpNioClientConnectionFactory . setApplicationEventPublisher ( org.springframework.integration.ip.tcp.connection.ApplicationEventPublisher ) ; org.springframework.integration.ip.tcp.connection.TcpNioClientConnectionFactory . setSoTimeout ( NUMBER ) ; org.springframework.integration.ip.tcp.connection.TcpNioClientConnectionFactory . start ( ) ; try { TcpConnection org.springframework.integration.ip.tcp.connection.TcpConnection = org.springframework.integration.ip.tcp.connection.TcpNioClientConnectionFactory . getConnection ( ) ; org.springframework.integration.ip.tcp.connection.TcpConnection . send ( MessageBuilder . withPayload ( STRING ) . build ( ) ) ; int int = NUMBER ; while ( org.springframework.integration.ip.tcp.connection.TcpConnection . isOpen ( ) ) { java.lang.Thread . void ( NUMBER ) ; if ( int ++ > NUMBER ) { break; } } assertTrue ( ! org.springframework.integration.ip.tcp.connection.TcpConnection . isOpen ( ) ) ; } catch ( java.lang.Exception java.lang.Exception ) { fail ( STRING + java.lang.Exception ) ; } java.util.concurrent.CountDownLatch . void ( ) ; java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . java.net.ServerSocket ( ) . void ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; final java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> < java.net.ServerSocket > java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> = new java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> < java.net.ServerSocket > ( ) ; java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . void ( ( ) { try { java.net.ServerSocket java.net.ServerSocket = javax.net.ServerSocketFactory . javax.net.ServerSocketFactory ( ) . java.net.ServerSocket ( NUMBER ) ; org.springframework.integration.ip.tcp.connection.Log . debug ( org.springframework.integration.ip.tcp.connection.TestName . getMethodName ( ) + STRING + java.net.ServerSocket . int ( ) ) ; java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . void ( java.net.ServerSocket ) ; java.util.concurrent.CountDownLatch . void ( ) ; java.net.Socket java.net.Socket = java.net.ServerSocket . java.net.Socket ( ) ; byte [] byte[] = new byte [ NUMBER ] ; void ( java.net.Socket . java.io.InputStream ( ) , byte[] ) ; } catch ( java.lang.Exception java.lang.Exception ) { java.lang.Exception . void ( ) ; } } ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; TcpNioClientConnectionFactory org.springframework.integration.ip.tcp.connection.TcpNioClientConnectionFactory = new TcpNioClientConnectionFactory ( STRING , java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . java.net.ServerSocket ( ) . int ( ) ) ; org.springframework.integration.ip.tcp.connection.TcpNioClientConnectionFactory . setApplicationEventPublisher ( org.springframework.integration.ip.tcp.connection.ApplicationEventPublisher ) ; org.springframework.integration.ip.tcp.connection.TcpNioClientConnectionFactory . setNioHarvestInterval ( NUMBER ) ; org.springframework.integration.ip.tcp.connection.TcpNioClientConnectionFactory . start ( ) ; try { TcpConnection org.springframework.integration.ip.tcp.connection.TcpConnection = org.springframework.integration.ip.tcp.connection.TcpNioClientConnectionFactory . getConnection ( ) ; java.util.Map<java.nio.channels.SocketChannel,org.springframework.integration.ip.tcp.connection.TcpNioConnection> < java.nio.channels.SocketChannel , TcpNioConnection > java.util.Map<java.nio.channels.SocketChannel,org.springframework.integration.ip.tcp.connection.TcpNioConnection> = org.springframework.integration.ip.tcp.connection.TcpNioClientConnectionFactory . getConnections ( ) ; assertEquals ( NUMBER , java.util.Map<java.nio.channels.SocketChannel,org.springframework.integration.ip.tcp.connection.TcpNioConnection> . size ( ) ) ; org.springframework.integration.ip.tcp.connection.TcpConnection . close ( ) ; assertTrue ( ! org.springframework.integration.ip.tcp.connection.TcpConnection . isOpen ( ) ) ; TestUtils . getPropertyValue ( org.springframework.integration.ip.tcp.connection.TcpNioClientConnectionFactory , STRING , java.nio.channels.Selector .class ) . wakeup ( ) ; int int = NUMBER ; while ( java.util.Map<java.nio.channels.SocketChannel,org.springframework.integration.ip.tcp.connection.TcpNioConnection> . size ( ) > NUMBER ) { java.lang.Thread . void ( NUMBER ) ; if ( int ++ > NUMBER ) { break; } } assertEquals ( NUMBER , java.util.Map<java.nio.channels.SocketChannel,org.springframework.integration.ip.tcp.connection.TcpNioConnection> . size ( ) ) ; } catch ( java.lang.Exception java.lang.Exception ) { java.lang.Exception . void ( ) ; fail ( STRING + java.lang.Exception ) ; } org.springframework.integration.ip.tcp.connection.TcpNioClientConnectionFactory . stop ( ) ; java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . java.net.ServerSocket ( ) . void ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { TcpNioClientConnectionFactory org.springframework.integration.ip.tcp.connection.TcpNioClientConnectionFactory = new TcpNioClientConnectionFactory ( STRING , NUMBER ) ; org.springframework.integration.ip.tcp.connection.TcpNioClientConnectionFactory . setApplicationEventPublisher ( org.springframework.integration.ip.tcp.connection.ApplicationEventPublisher ) ; org.springframework.integration.ip.tcp.connection.TcpNioClientConnectionFactory . setNioHarvestInterval ( NUMBER ) ; java.util.Map<java.nio.channels.SocketChannel,org.springframework.integration.ip.tcp.connection.TcpNioConnection> < java.nio.channels.SocketChannel , TcpNioConnection > java.util.Map<java.nio.channels.SocketChannel,org.springframework.integration.ip.tcp.connection.TcpNioConnection> = new java.util.HashMap<java.nio.channels.SocketChannel,org.springframework.integration.ip.tcp.connection.TcpNioConnection> < java.nio.channels.SocketChannel , TcpNioConnection > ( ) ; java.nio.channels.SocketChannel java.nio.channels.SocketChannel = mock ( java.nio.channels.SocketChannel .class ) ; java.nio.channels.SocketChannel java.nio.channels.SocketChannel = mock ( java.nio.channels.SocketChannel .class ) ; java.nio.channels.SocketChannel java.nio.channels.SocketChannel = mock ( java.nio.channels.SocketChannel .class ) ; TcpNioConnection org.springframework.integration.ip.tcp.connection.TcpNioConnection = mock ( TcpNioConnection .class ) ; TcpNioConnection org.springframework.integration.ip.tcp.connection.TcpNioConnection = mock ( TcpNioConnection .class ) ; TcpNioConnection org.springframework.integration.ip.tcp.connection.TcpNioConnection = mock ( TcpNioConnection .class ) ; java.util.Map<java.nio.channels.SocketChannel,org.springframework.integration.ip.tcp.connection.TcpNioConnection> . put ( java.nio.channels.SocketChannel , org.springframework.integration.ip.tcp.connection.TcpNioConnection ) ; java.util.Map<java.nio.channels.SocketChannel,org.springframework.integration.ip.tcp.connection.TcpNioConnection> . put ( java.nio.channels.SocketChannel , org.springframework.integration.ip.tcp.connection.TcpNioConnection ) ; java.util.Map<java.nio.channels.SocketChannel,org.springframework.integration.ip.tcp.connection.TcpNioConnection> . put ( java.nio.channels.SocketChannel , org.springframework.integration.ip.tcp.connection.TcpNioConnection ) ; final java.util.List<java.lang.reflect.Field> < java.lang.reflect.Field > java.util.List<java.lang.reflect.Field> = new java.util.ArrayList<java.lang.reflect.Field> < java.lang.reflect.Field > ( ) ; ReflectionUtils . doWithFields ( java.nio.channels.SocketChannel .class , field -> { field . setAccessible ( true ) ; fields . add ( field ) ; } , field -> field . getName ( ) . equals ( STRING ) ) ; java.lang.reflect.Field java.lang.reflect.Field = java.util.List<java.lang.reflect.Field> . java.lang.reflect.Field ( NUMBER ) ; ReflectionUtils . setField ( java.lang.reflect.Field , java.nio.channels.SocketChannel , true ) ; ReflectionUtils . setField ( java.lang.reflect.Field , java.nio.channels.SocketChannel , true ) ; ReflectionUtils . setField ( java.lang.reflect.Field , java.nio.channels.SocketChannel , true ) ; java.nio.channels.Selector java.nio.channels.Selector = mock ( java.nio.channels.Selector .class ) ; java.util.HashSet<java.nio.channels.SelectionKey> < java.nio.channels.SelectionKey > java.util.HashSet<java.nio.channels.SelectionKey> = new java.util.HashSet<java.nio.channels.SelectionKey> < java.nio.channels.SelectionKey > ( ) ; when ( java.nio.channels.Selector . java.util.Set<java.nio.channels.SelectionKey> ( ) ) . thenReturn ( java.util.HashSet<java.nio.channels.SelectionKey> ) ; org.springframework.integration.ip.tcp.connection.TcpNioClientConnectionFactory . processNioSelections ( NUMBER , java.nio.channels.Selector , null , java.util.Map<java.nio.channels.SocketChannel,org.springframework.integration.ip.tcp.connection.TcpNioConnection> ) ; assertEquals ( NUMBER , java.util.Map<java.nio.channels.SocketChannel,org.springframework.integration.ip.tcp.connection.TcpNioConnection> . size ( ) ) ; ReflectionUtils . setField ( java.lang.reflect.Field , java.nio.channels.SocketChannel , false ) ; org.springframework.integration.ip.tcp.connection.TcpNioClientConnectionFactory . processNioSelections ( NUMBER , java.nio.channels.Selector , null , java.util.Map<java.nio.channels.SocketChannel,org.springframework.integration.ip.tcp.connection.TcpNioConnection> ) ; assertEquals ( NUMBER , java.util.Map<java.nio.channels.SocketChannel,org.springframework.integration.ip.tcp.connection.TcpNioConnection> . size ( ) ) ; java.lang.Thread . void ( NUMBER ) ; org.springframework.integration.ip.tcp.connection.TcpNioClientConnectionFactory . processNioSelections ( NUMBER , java.nio.channels.Selector , null , java.util.Map<java.nio.channels.SocketChannel,org.springframework.integration.ip.tcp.connection.TcpNioConnection> ) ; assertEquals ( NUMBER , java.util.Map<java.nio.channels.SocketChannel,org.springframework.integration.ip.tcp.connection.TcpNioConnection> . size ( ) ) ; ReflectionUtils . setField ( java.lang.reflect.Field , java.nio.channels.SocketChannel , false ) ; org.springframework.integration.ip.tcp.connection.TcpNioClientConnectionFactory . processNioSelections ( NUMBER , java.nio.channels.Selector , null , java.util.Map<java.nio.channels.SocketChannel,org.springframework.integration.ip.tcp.connection.TcpNioConnection> ) ; assertEquals ( NUMBER , java.util.Map<java.nio.channels.SocketChannel,org.springframework.integration.ip.tcp.connection.TcpNioConnection> . size ( ) ) ; java.lang.Thread . void ( NUMBER ) ; org.springframework.integration.ip.tcp.connection.TcpNioClientConnectionFactory . processNioSelections ( NUMBER , java.nio.channels.Selector , null , java.util.Map<java.nio.channels.SocketChannel,org.springframework.integration.ip.tcp.connection.TcpNioConnection> ) ; assertEquals ( NUMBER , java.util.Map<java.nio.channels.SocketChannel,org.springframework.integration.ip.tcp.connection.TcpNioConnection> . size ( ) ) ; ReflectionUtils . setField ( java.lang.reflect.Field , java.nio.channels.SocketChannel , false ) ; org.springframework.integration.ip.tcp.connection.TcpNioClientConnectionFactory . processNioSelections ( NUMBER , java.nio.channels.Selector , null , java.util.Map<java.nio.channels.SocketChannel,org.springframework.integration.ip.tcp.connection.TcpNioConnection> ) ; assertEquals ( NUMBER , java.util.Map<java.nio.channels.SocketChannel,org.springframework.integration.ip.tcp.connection.TcpNioConnection> . size ( ) ) ; java.lang.Thread . void ( NUMBER ) ; org.springframework.integration.ip.tcp.connection.TcpNioClientConnectionFactory . processNioSelections ( NUMBER , java.nio.channels.Selector , null , java.util.Map<java.nio.channels.SocketChannel,org.springframework.integration.ip.tcp.connection.TcpNioConnection> ) ; assertEquals ( NUMBER , java.util.Map<java.nio.channels.SocketChannel,org.springframework.integration.ip.tcp.connection.TcpNioConnection> . size ( ) ) ; assertEquals ( NUMBER , TestUtils . getPropertyValue ( org.springframework.integration.ip.tcp.connection.TcpNioClientConnectionFactory , STRING , java.util.Map .class ) . size ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final java.util.concurrent.ExecutorService java.util.concurrent.ExecutorService = java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( NUMBER ) ; java.util.concurrent.Future<java.lang.Object> < java.lang.Object > java.util.concurrent.Future<java.lang.Object> = java.util.concurrent.ExecutorService . java.util.concurrent.Future<java.lang.Object> ( ( ) { java.nio.channels.SocketChannel java.nio.channels.SocketChannel = mock ( java.nio.channels.SocketChannel .class ) ; java.net.Socket java.net.Socket = mock ( java.net.Socket .class ) ; Mockito . when ( java.nio.channels.SocketChannel . java.net.Socket ( ) ) . thenReturn ( java.net.Socket ) ; doAnswer ( invocation -> { ByteBuffer buffer = invocation . getArgument ( NUMBER ) ; buffer . position ( NUMBER ) ; return NUMBER ; } ) . when ( java.nio.channels.SocketChannel ) . read ( Mockito . any ( java.nio.ByteBuffer .class ) ) ; when ( java.net.Socket . int ( ) ) . thenReturn ( NUMBER ) ; final TcpNioConnection org.springframework.integration.ip.tcp.connection.TcpNioConnection = new TcpNioConnection ( java.nio.channels.SocketChannel , false , false , org.springframework.integration.ip.tcp.connection.ApplicationEventPublisher , null ) ; org.springframework.integration.ip.tcp.connection.TcpNioConnection . setTaskExecutor ( java.util.concurrent.ExecutorService ) ; org.springframework.integration.ip.tcp.connection.TcpNioConnection . setPipeTimeout ( NUMBER ) ; java.lang.reflect.Method java.lang.reflect.Method = TcpNioConnection .class . java.lang.reflect.Method ( STRING ) ; java.lang.reflect.Method . void ( true ) ; try { for ( int int = NUMBER ; int < NUMBER ; int ++ ) { java.lang.reflect.Method . java.lang.Object ( org.springframework.integration.ip.tcp.connection.TcpNioConnection ) ; } } catch ( java.lang.Exception java.lang.Exception ) { java.lang.Exception . void ( ) ; throw ( java.lang.Exception ) java.lang.Exception . java.lang.Throwable ( ) ; } return null ; } ) ; try { java.lang.Object java.lang.Object = java.util.concurrent.Future<java.lang.Object> . java.lang.Object ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ; fail ( STRING + java.lang.Object ) ; } catch ( java.util.concurrent.ExecutionException java.util.concurrent.ExecutionException ) { assertEquals ( STRING , java.util.concurrent.ExecutionException . java.lang.Throwable ( ) . java.lang.String ( ) ) ; } }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final java.util.concurrent.ExecutorService java.util.concurrent.ExecutorService = java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( NUMBER ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; java.util.concurrent.Future<java.lang.Object> < java.lang.Object > java.util.concurrent.Future<java.lang.Object> = java.util.concurrent.ExecutorService . java.util.concurrent.Future<java.lang.Object> ( ( ) { java.nio.channels.SocketChannel java.nio.channels.SocketChannel = mock ( java.nio.channels.SocketChannel .class ) ; java.net.Socket java.net.Socket = mock ( java.net.Socket .class ) ; Mockito . when ( java.nio.channels.SocketChannel . java.net.Socket ( ) ) . thenReturn ( java.net.Socket ) ; doAnswer ( invocation -> { ByteBuffer buffer = invocation . getArgument ( NUMBER ) ; buffer . position ( NUMBER ) ; buffer . put ( ( byte ) '\r' ) ; buffer . put ( ( byte ) '\n' ) ; return NUMBER ; } ) . when ( java.nio.channels.SocketChannel ) . read ( Mockito . any ( java.nio.ByteBuffer .class ) ) ; final TcpNioConnection org.springframework.integration.ip.tcp.connection.TcpNioConnection = new TcpNioConnection ( java.nio.channels.SocketChannel , false , false , null , null ) ; org.springframework.integration.ip.tcp.connection.TcpNioConnection . setTaskExecutor ( java.util.concurrent.ExecutorService ) ; org.springframework.integration.ip.tcp.connection.TcpNioConnection . registerListener ( message -> { messageLatch . countDown ( ) ; return false ; } ) ; org.springframework.integration.ip.tcp.connection.TcpNioConnection . setMapper ( new TcpMessageMapper ( ) ) ; org.springframework.integration.ip.tcp.connection.TcpNioConnection . setDeserializer ( new ByteArrayCrLfSerializer ( ) ) ; java.lang.reflect.Method java.lang.reflect.Method = TcpNioConnection .class . java.lang.reflect.Method ( STRING ) ; java.lang.reflect.Method . void ( true ) ; try { for ( int int = NUMBER ; int < NUMBER ; int ++ ) { java.lang.reflect.Method . java.lang.Object ( org.springframework.integration.ip.tcp.connection.TcpNioConnection ) ; } } catch ( java.lang.Exception java.lang.Exception ) { java.lang.Exception . void ( ) ; throw ( java.lang.Exception ) java.lang.Exception . java.lang.Throwable ( ) ; } return null ; } ) ; java.util.concurrent.Future<java.lang.Object> . java.lang.Object ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.nio.channels.SocketChannel java.nio.channels.SocketChannel = mock ( java.nio.channels.SocketChannel .class ) ; java.net.Socket java.net.Socket = mock ( java.net.Socket .class ) ; when ( java.nio.channels.SocketChannel . java.net.Socket ( ) ) . thenReturn ( java.net.Socket ) ; TcpNioConnection org.springframework.integration.ip.tcp.connection.TcpNioConnection = new TcpNioConnection ( java.nio.channels.SocketChannel , false , false , null , null ) ; TcpNioConnection . TcpNioConnection TcpNioConnection.ChannelInputStream = ( ChannelInputStream ) new DirectFieldAccessor ( org.springframework.integration.ip.tcp.connection.TcpNioConnection ) . getPropertyValue ( STRING ) ; TcpNioConnection.ChannelInputStream . write ( java.nio.ByteBuffer . java.nio.ByteBuffer ( STRING . byte[] ( ) ) ) ; byte [] byte[] = new byte [ NUMBER ] ; int int = TcpNioConnection.ChannelInputStream . read ( byte[] ) ; assertEquals ( NUMBER , int ) ; assertEquals ( STRING , new java.lang.String ( byte[] ) ) ; byte[] = new byte [ NUMBER ] ; int = TcpNioConnection.ChannelInputStream . read ( byte[] ) ; assertEquals ( NUMBER , int ) ; assertEquals ( STRING , new java.lang.String ( byte[] ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.nio.channels.SocketChannel java.nio.channels.SocketChannel = mock ( java.nio.channels.SocketChannel .class ) ; java.net.Socket java.net.Socket = mock ( java.net.Socket .class ) ; when ( java.nio.channels.SocketChannel . java.net.Socket ( ) ) . thenReturn ( java.net.Socket ) ; TcpNioConnection org.springframework.integration.ip.tcp.connection.TcpNioConnection = new TcpNioConnection ( java.nio.channels.SocketChannel , false , false , null , null ) ; TcpNioConnection . TcpNioConnection TcpNioConnection.ChannelInputStream = ( ChannelInputStream ) new DirectFieldAccessor ( org.springframework.integration.ip.tcp.connection.TcpNioConnection ) . getPropertyValue ( STRING ) ; TcpNioConnection.ChannelInputStream . write ( java.nio.ByteBuffer . java.nio.ByteBuffer ( STRING . byte[] ( ) ) ) ; TcpNioConnection.ChannelInputStream . write ( java.nio.ByteBuffer . java.nio.ByteBuffer ( STRING . byte[] ( ) ) ) ; byte [] byte[] = new byte [ NUMBER ] ; int int = TcpNioConnection.ChannelInputStream . read ( byte[] ) ; assertEquals ( NUMBER , int ) ; assertEquals ( STRING , new java.lang.String ( byte[] ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.nio.channels.SocketChannel java.nio.channels.SocketChannel = mock ( java.nio.channels.SocketChannel .class ) ; java.net.Socket java.net.Socket = mock ( java.net.Socket .class ) ; when ( java.nio.channels.SocketChannel . java.net.Socket ( ) ) . thenReturn ( java.net.Socket ) ; TcpNioConnection org.springframework.integration.ip.tcp.connection.TcpNioConnection = new TcpNioConnection ( java.nio.channels.SocketChannel , false , false , null , null ) ; TcpNioConnection . TcpNioConnection TcpNioConnection.ChannelInputStream = ( ChannelInputStream ) new DirectFieldAccessor ( org.springframework.integration.ip.tcp.connection.TcpNioConnection ) . getPropertyValue ( STRING ) ; TcpNioConnection.ChannelInputStream . write ( java.nio.ByteBuffer . java.nio.ByteBuffer ( STRING . byte[] ( ) ) ) ; byte [] byte[] = new byte [ NUMBER ] ; int int = TcpNioConnection.ChannelInputStream . read ( byte[] , NUMBER , NUMBER ) ; assertEquals ( NUMBER , int ) ; assertEquals ( STRING , new java.lang.String ( byte[] ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.nio.channels.SocketChannel java.nio.channels.SocketChannel = mock ( java.nio.channels.SocketChannel .class ) ; java.net.Socket java.net.Socket = mock ( java.net.Socket .class ) ; when ( java.nio.channels.SocketChannel . java.net.Socket ( ) ) . thenReturn ( java.net.Socket ) ; TcpNioConnection org.springframework.integration.ip.tcp.connection.TcpNioConnection = new TcpNioConnection ( java.nio.channels.SocketChannel , false , false , null , null ) ; TcpNioConnection . TcpNioConnection TcpNioConnection.ChannelInputStream = ( ChannelInputStream ) new DirectFieldAccessor ( org.springframework.integration.ip.tcp.connection.TcpNioConnection ) . getPropertyValue ( STRING ) ; TcpNioConnection.ChannelInputStream . write ( java.nio.ByteBuffer . java.nio.ByteBuffer ( STRING . byte[] ( ) ) ) ; byte [] byte[] = new byte [ NUMBER ] ; try { TcpNioConnection.ChannelInputStream . read ( byte[] , NUMBER , NUMBER ) ; fail ( STRING ) ; } catch ( java.lang.IndexOutOfBoundsException java.lang.IndexOutOfBoundsException ) {		} try { TcpNioConnection.ChannelInputStream . read ( null , NUMBER , NUMBER ) ; fail ( STRING ) ; } catch ( java.lang.IllegalArgumentException java.lang.IllegalArgumentException ) {		} assertEquals ( NUMBER , TcpNioConnection.ChannelInputStream . read ( byte[] , NUMBER , NUMBER ) ) ; assertEquals ( NUMBER , TcpNioConnection.ChannelInputStream . read ( byte[] ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.nio.channels.SocketChannel java.nio.channels.SocketChannel = mock ( java.nio.channels.SocketChannel .class ) ; java.net.Socket java.net.Socket = mock ( java.net.Socket .class ) ; when ( java.nio.channels.SocketChannel . java.net.Socket ( ) ) . thenReturn ( java.net.Socket ) ; TcpNioConnection org.springframework.integration.ip.tcp.connection.TcpNioConnection = new TcpNioConnection ( java.nio.channels.SocketChannel , false , false , null , null ) ; final TcpNioConnection . TcpNioConnection TcpNioConnection.ChannelInputStream = ( ChannelInputStream ) new DirectFieldAccessor ( org.springframework.integration.ip.tcp.connection.TcpNioConnection ) . getPropertyValue ( STRING ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; final byte [] byte[] = new byte [ NUMBER ] ; java.util.concurrent.ExecutorService java.util.concurrent.ExecutorService = java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) ; java.util.concurrent.ExecutorService . void ( new java.lang.Runnable ( ) { @ java.lang.Override public void void ( ) { try { TcpNioConnection.ChannelInputStream . read ( byte[] ) ; } catch ( java.io.IOException java.io.IOException ) { java.io.IOException . void ( ) ; } java.util.concurrent.CountDownLatch . void ( ) ; } } ) ; java.lang.Thread . void ( NUMBER ) ; assertEquals ( NUMBER , byte[] [ NUMBER ] ) ; TcpNioConnection.ChannelInputStream . write ( java.nio.ByteBuffer . java.nio.ByteBuffer ( STRING . byte[] ( ) ) ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; assertEquals ( STRING , new java.lang.String ( byte[] ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ) { try { TcpNioConnection.ChannelInputStream . read ( byte[] ) ; } catch ( java.io.IOException java.io.IOException ) { java.io.IOException . void ( ) ; } java.util.concurrent.CountDownLatch . void ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.net.Socket java.net.Socket = mock ( java.net.Socket .class ) ; java.nio.channels.SocketChannel java.nio.channels.SocketChannel = mock ( java.nio.channels.SocketChannel .class ) ; when ( java.nio.channels.SocketChannel . java.net.Socket ( ) ) . thenReturn ( java.net.Socket ) ; TcpNioConnection org.springframework.integration.ip.tcp.connection.TcpNioConnection = new TcpNioConnection ( java.nio.channels.SocketChannel , true , false , org.springframework.integration.ip.tcp.connection.ApplicationEventPublisher , null ) ; org.springframework.integration.ip.tcp.connection.TcpNioConnection . setDeserializer ( new MapJsonSerializer ( ) ) ; MapMessageConverter org.springframework.integration.ip.tcp.connection.MapMessageConverter = new MapMessageConverter ( ) ; MessageConvertingTcpMessageMapper org.springframework.integration.ip.tcp.connection.MessageConvertingTcpMessageMapper = new MessageConvertingTcpMessageMapper ( org.springframework.integration.ip.tcp.connection.MapMessageConverter ) ; org.springframework.integration.ip.tcp.connection.TcpNioConnection . setMapper ( org.springframework.integration.ip.tcp.connection.MessageConvertingTcpMessageMapper ) ; final java.io.ByteArrayOutputStream java.io.ByteArrayOutputStream = new java.io.ByteArrayOutputStream ( ) ; doAnswer ( new Answer < java.lang.Integer > ( ) { @ java.lang.Override public java.lang.Integer java.lang.Integer ( InvocationOnMock org.springframework.integration.ip.tcp.connection.InvocationOnMock ) throws java.lang.Throwable { java.nio.ByteBuffer java.nio.ByteBuffer = org.springframework.integration.ip.tcp.connection.InvocationOnMock . getArgument ( NUMBER ) ; byte [] byte[] = java.io.ByteArrayOutputStream . byte[] ( ) ; java.nio.ByteBuffer . java.nio.ByteBuffer ( byte[] ) ; return byte[] . int ; } } ) . when ( java.nio.channels.SocketChannel ) . read ( any ( java.nio.ByteBuffer .class ) ) ; java.net.Socket java.net.Socket = mock ( java.net.Socket .class ) ; java.nio.channels.SocketChannel java.nio.channels.SocketChannel = mock ( java.nio.channels.SocketChannel .class ) ; when ( java.nio.channels.SocketChannel . java.net.Socket ( ) ) . thenReturn ( java.net.Socket ) ; TcpNioConnection org.springframework.integration.ip.tcp.connection.TcpNioConnection = new TcpNioConnection ( java.nio.channels.SocketChannel , true , false , org.springframework.integration.ip.tcp.connection.ApplicationEventPublisher , null ) ; doAnswer ( new Answer < java.lang.Object > ( ) { @ java.lang.Override public java.lang.Object java.lang.Object ( InvocationOnMock org.springframework.integration.ip.tcp.connection.InvocationOnMock ) throws java.lang.Throwable { java.nio.ByteBuffer java.nio.ByteBuffer = org.springframework.integration.ip.tcp.connection.InvocationOnMock . getArgument ( NUMBER ) ; byte [] byte[] = new byte [ java.nio.ByteBuffer . int ( ) ] ; java.nio.ByteBuffer . java.nio.ByteBuffer ( byte[] ) ; java.io.ByteArrayOutputStream . void ( byte[] ) ; return null ; } } ) . when ( java.nio.channels.SocketChannel ) . write ( any ( java.nio.ByteBuffer .class ) ) ; MapMessageConverter org.springframework.integration.ip.tcp.connection.MapMessageConverter = new MapMessageConverter ( ) ; org.springframework.integration.ip.tcp.connection.MapMessageConverter . setHeaderNames ( STRING ) ; MessageConvertingTcpMessageMapper org.springframework.integration.ip.tcp.connection.MessageConvertingTcpMessageMapper = new MessageConvertingTcpMessageMapper ( org.springframework.integration.ip.tcp.connection.MapMessageConverter ) ; org.springframework.integration.ip.tcp.connection.TcpNioConnection . setMapper ( org.springframework.integration.ip.tcp.connection.MessageConvertingTcpMessageMapper ) ; org.springframework.integration.ip.tcp.connection.TcpNioConnection . setSerializer ( new MapJsonSerializer ( ) ) ; Message < java.lang.String > org.springframework.integration.ip.tcp.connection.Message<java.lang.String> = MessageBuilder . withPayload ( STRING ) . setHeader ( STRING , STRING ) . build ( ) ; org.springframework.integration.ip.tcp.connection.TcpNioConnection . send ( org.springframework.integration.ip.tcp.connection.Message<java.lang.String> ) ; final java.util.concurrent.atomic.AtomicReference<org.springframework.integration.ip.tcp.connection.Message<?>> < Message < ? > > java.util.concurrent.atomic.AtomicReference<org.springframework.integration.ip.tcp.connection.Message<?>> = new java.util.concurrent.atomic.AtomicReference<org.springframework.integration.ip.tcp.connection.Message<?>> < Message < ? > > ( ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; TcpListener org.springframework.integration.ip.tcp.connection.TcpListener = new TcpListener ( ) { @ java.lang.Override public boolean boolean ( Message < ? > org.springframework.integration.ip.tcp.connection.Message<?> ) { java.util.concurrent.atomic.AtomicReference<org.springframework.integration.ip.tcp.connection.Message<?>> . set ( org.springframework.integration.ip.tcp.connection.Message<> ) ; java.util.concurrent.CountDownLatch . void ( ) ; return false ; } } ; org.springframework.integration.ip.tcp.connection.TcpNioConnection . registerListener ( org.springframework.integration.ip.tcp.connection.TcpListener ) ; org.springframework.integration.ip.tcp.connection.TcpNioConnection . readPacket ( ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; assertNotNull ( java.util.concurrent.atomic.AtomicReference<org.springframework.integration.ip.tcp.connection.Message<?>> . get ( ) ) ; assertEquals ( STRING , java.util.concurrent.atomic.AtomicReference<org.springframework.integration.ip.tcp.connection.Message<?>> . get ( ) . getPayload ( ) ) ; assertEquals ( STRING , java.util.concurrent.atomic.AtomicReference<org.springframework.integration.ip.tcp.connection.Message<?>> . get ( ) . getHeaders ( ) . get ( STRING ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.Integer java.lang.Integer ( InvocationOnMock org.springframework.integration.ip.tcp.connection.InvocationOnMock ) throws java.lang.Throwable { java.nio.ByteBuffer java.nio.ByteBuffer = org.springframework.integration.ip.tcp.connection.InvocationOnMock . getArgument ( NUMBER ) ; byte [] byte[] = java.io.ByteArrayOutputStream . byte[] ( ) ; java.nio.ByteBuffer . java.nio.ByteBuffer ( byte[] ) ; return byte[] . int ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.Object java.lang.Object ( InvocationOnMock org.springframework.integration.ip.tcp.connection.InvocationOnMock ) throws java.lang.Throwable { java.nio.ByteBuffer java.nio.ByteBuffer = org.springframework.integration.ip.tcp.connection.InvocationOnMock . getArgument ( NUMBER ) ; byte [] byte[] = new byte [ java.nio.ByteBuffer . int ( ) ] ; java.nio.ByteBuffer . java.nio.ByteBuffer ( byte[] ) ; java.io.ByteArrayOutputStream . void ( byte[] ) ; return null ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( Message < ? > org.springframework.integration.ip.tcp.connection.Message<?> ) { java.util.concurrent.atomic.AtomicReference<org.springframework.integration.ip.tcp.connection.Message<?>> . set ( org.springframework.integration.ip.tcp.connection.Message<> ) ; java.util.concurrent.CountDownLatch . void ( ) ; return false ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { TcpNioServerConnectionFactory org.springframework.integration.ip.tcp.connection.TcpNioServerConnectionFactory = new TcpNioServerConnectionFactory ( NUMBER ) ; org.springframework.integration.ip.tcp.connection.TcpNioServerConnectionFactory . setApplicationEventPublisher ( org.springframework.integration.ip.tcp.connection.ApplicationEventPublisher ) ; CompositeExecutor org.springframework.integration.ip.tcp.connection.CompositeExecutor = org.springframework.integration.ip.tcp.connection.CompositeExecutor ( ) ; org.springframework.integration.ip.tcp.connection.TcpNioServerConnectionFactory . setSoTimeout ( NUMBER ) ; org.springframework.integration.ip.tcp.connection.TcpNioServerConnectionFactory . setTaskExecutor ( org.springframework.integration.ip.tcp.connection.CompositeExecutor ) ; final java.util.concurrent.atomic.AtomicReference<java.lang.String> < java.lang.String > java.util.concurrent.atomic.AtomicReference<java.lang.String> = new java.util.concurrent.atomic.AtomicReference<java.lang.String> < java.lang.String > ( ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; org.springframework.integration.ip.tcp.connection.TcpNioServerConnectionFactory . registerListener ( new TcpListener ( ) { @ java.lang.Override public boolean boolean ( Message < ? > org.springframework.integration.ip.tcp.connection.Message<?> ) { if ( ! ( org.springframework.integration.ip.tcp.connection.Message<> instanceof ErrorMessage ) ) { java.util.concurrent.atomic.AtomicReference<java.lang.String> . void ( java.lang.Thread . java.lang.Thread ( ) . java.lang.String ( ) ) ; java.util.concurrent.CountDownLatch . void ( ) ; } return false ; } } ) ; org.springframework.integration.ip.tcp.connection.TcpNioServerConnectionFactory . start ( ) ; TestingUtilities . waitListening ( org.springframework.integration.ip.tcp.connection.TcpNioServerConnectionFactory , null ) ; int int = org.springframework.integration.ip.tcp.connection.TcpNioServerConnectionFactory . getPort ( ) ; java.net.Socket java.net.Socket = null ; int int = NUMBER ; while ( int ++ < NUMBER ) { try { java.net.Socket = javax.net.SocketFactory . javax.net.SocketFactory ( ) . java.net.Socket ( STRING , int ) ; break; } catch ( java.net.ConnectException java.net.ConnectException ) {			} java.lang.Thread . void ( NUMBER ) ; } assertTrue ( STRING + int , int < NUMBER ) ; java.net.Socket . java.io.OutputStream ( ) . void ( STRING . byte[] ( ) ) ; java.net.Socket . void ( ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; assertThat ( java.util.concurrent.atomic.AtomicReference<java.lang.String> . java.lang.String ( ) , containsString ( STRING ) ) ; org.springframework.integration.ip.tcp.connection.TcpNioServerConnectionFactory . stop ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( Message < ? > org.springframework.integration.ip.tcp.connection.Message<?> ) { if ( ! ( org.springframework.integration.ip.tcp.connection.Message<> instanceof ErrorMessage ) ) { java.util.concurrent.atomic.AtomicReference<java.lang.String> . void ( java.lang.Thread . java.lang.Thread ( ) . java.lang.String ( ) ) ; java.util.concurrent.CountDownLatch . void ( ) ; } return false ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final int int = NUMBER ; TcpNioServerConnectionFactory org.springframework.integration.ip.tcp.connection.TcpNioServerConnectionFactory = new TcpNioServerConnectionFactory ( NUMBER ) ; org.springframework.integration.ip.tcp.connection.TcpNioServerConnectionFactory . setApplicationEventPublisher ( org.springframework.integration.ip.tcp.connection.ApplicationEventPublisher ) ; CompositeExecutor org.springframework.integration.ip.tcp.connection.CompositeExecutor = org.springframework.integration.ip.tcp.connection.CompositeExecutor ( ) ; org.springframework.integration.ip.tcp.connection.TcpNioServerConnectionFactory . setTaskExecutor ( org.springframework.integration.ip.tcp.connection.CompositeExecutor ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( int * NUMBER ) ; org.springframework.integration.ip.tcp.connection.TcpNioServerConnectionFactory . registerListener ( new TcpListener ( ) { @ java.lang.Override public boolean boolean ( Message < ? > org.springframework.integration.ip.tcp.connection.Message<?> ) { if ( ! ( org.springframework.integration.ip.tcp.connection.Message<> instanceof ErrorMessage ) ) { java.util.concurrent.CountDownLatch . void ( ) ; } return false ; } } ) ; org.springframework.integration.ip.tcp.connection.TcpNioServerConnectionFactory . start ( ) ; TestingUtilities . waitListening ( org.springframework.integration.ip.tcp.connection.TcpNioServerConnectionFactory , null ) ; int int = org.springframework.integration.ip.tcp.connection.TcpNioServerConnectionFactory . getPort ( ) ; java.net.Socket [] java.net.Socket[] = new java.net.Socket [ int ] ; for ( int int = NUMBER ; int < int ; int ++ ) { java.net.Socket java.net.Socket = null ; int int = NUMBER ; while ( int ++ < NUMBER ) { try { java.net.Socket = javax.net.SocketFactory . javax.net.SocketFactory ( ) . java.net.Socket ( STRING , int ) ; break; } catch ( java.net.ConnectException java.net.ConnectException ) {				} java.lang.Thread . void ( NUMBER ) ; } assertTrue ( STRING + int , int < NUMBER ) ; java.net.Socket[] [ int ] = java.net.Socket ; } for ( int int = NUMBER ; int < int ; int ++ ) { java.net.Socket[] [ int ] . java.io.OutputStream ( ) . void ( STRING . byte[] ( ) ) ; java.net.Socket[] [ int ] . java.io.OutputStream ( ) . void ( ) ; } java.lang.Thread . void ( NUMBER ) ; for ( int int = NUMBER ; int < int ; int ++ ) { java.net.Socket[] [ int ] . java.io.OutputStream ( ) . void ( ( STRING ) . byte[] ( ) ) ; java.net.Socket[] [ int ] . java.io.OutputStream ( ) . void ( ) ; } for ( int int = NUMBER ; int < int ; int ++ ) { java.net.Socket[] [ int ] . java.io.OutputStream ( ) . void ( ( STRING ) . byte[] ( ) ) ; java.net.Socket[] [ int ] . java.io.OutputStream ( ) . void ( ) ; } for ( int int = NUMBER ; int < int ; int ++ ) { java.net.Socket[] [ int ] . java.io.OutputStream ( ) . void ( STRING . byte[] ( ) ) ; java.net.Socket[] [ int ] . java.io.OutputStream ( ) . void ( ) ; } java.lang.Thread . void ( NUMBER ) ; for ( int int = NUMBER ; int < int ; int ++ ) { java.net.Socket[] [ int ] . java.io.OutputStream ( ) . void ( ( STRING ) . byte[] ( ) ) ; java.net.Socket[] [ int ] . java.io.OutputStream ( ) . void ( ) ; } for ( int int = NUMBER ; int < int ; int ++ ) { java.net.Socket[] [ int ] . java.io.OutputStream ( ) . void ( ( STRING ) . byte[] ( ) ) ; java.net.Socket[] [ int ] . void ( ) ; } assertTrue ( STRING + java.util.concurrent.CountDownLatch . long ( ) , java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; org.springframework.integration.ip.tcp.connection.TcpNioServerConnectionFactory . stop ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( Message < ? > org.springframework.integration.ip.tcp.connection.Message<?> ) { if ( ! ( org.springframework.integration.ip.tcp.connection.Message<> instanceof ErrorMessage ) ) { java.util.concurrent.CountDownLatch . void ( ) ; } return false ; }  <METHOD_END>
<METHOD_START> private org.springframework.integration.ip.tcp.connection.CompositeExecutor org.springframework.integration.ip.tcp.connection.CompositeExecutor ( ) { ThreadPoolTaskExecutor org.springframework.integration.ip.tcp.connection.ThreadPoolTaskExecutor = new ThreadPoolTaskExecutor ( ) ; org.springframework.integration.ip.tcp.connection.ThreadPoolTaskExecutor . setCorePoolSize ( NUMBER ) ; org.springframework.integration.ip.tcp.connection.ThreadPoolTaskExecutor . setMaxPoolSize ( NUMBER ) ; org.springframework.integration.ip.tcp.connection.ThreadPoolTaskExecutor . setQueueCapacity ( NUMBER ) ; org.springframework.integration.ip.tcp.connection.ThreadPoolTaskExecutor . setThreadNamePrefix ( STRING ) ; org.springframework.integration.ip.tcp.connection.ThreadPoolTaskExecutor . setRejectedExecutionHandler ( new java.util.concurrent.ThreadPoolExecutor.AbortPolicy ( ) ) ; org.springframework.integration.ip.tcp.connection.ThreadPoolTaskExecutor . initialize ( ) ; ThreadPoolTaskExecutor org.springframework.integration.ip.tcp.connection.ThreadPoolTaskExecutor = new ThreadPoolTaskExecutor ( ) ; org.springframework.integration.ip.tcp.connection.ThreadPoolTaskExecutor . setCorePoolSize ( NUMBER ) ; org.springframework.integration.ip.tcp.connection.ThreadPoolTaskExecutor . setMaxPoolSize ( NUMBER ) ; org.springframework.integration.ip.tcp.connection.ThreadPoolTaskExecutor . setQueueCapacity ( NUMBER ) ; org.springframework.integration.ip.tcp.connection.ThreadPoolTaskExecutor . setThreadNamePrefix ( STRING ) ; org.springframework.integration.ip.tcp.connection.ThreadPoolTaskExecutor . setRejectedExecutionHandler ( new java.util.concurrent.ThreadPoolExecutor.AbortPolicy ( ) ) ; org.springframework.integration.ip.tcp.connection.ThreadPoolTaskExecutor . initialize ( ) ; return new CompositeExecutor ( org.springframework.integration.ip.tcp.connection.ThreadPoolTaskExecutor , org.springframework.integration.ip.tcp.connection.ThreadPoolTaskExecutor ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { TcpNioServerConnectionFactory org.springframework.integration.ip.tcp.connection.TcpNioServerConnectionFactory = new TcpNioServerConnectionFactory ( NUMBER ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; org.springframework.integration.ip.tcp.connection.TcpNioServerConnectionFactory . setApplicationEventPublisher ( new ApplicationEventPublisher ( ) { @ java.lang.Override public void void ( ApplicationEvent org.springframework.integration.ip.tcp.connection.ApplicationEvent ) { if ( org.springframework.integration.ip.tcp.connection.ApplicationEvent instanceof TcpConnectionOpenEvent ) { java.util.concurrent.CountDownLatch . void ( ) ; } } @ java.lang.Override public void void ( java.lang.Object java.lang.Object ) {			} } ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; final java.util.concurrent.atomic.AtomicReference<java.lang.Thread> < java.lang.Thread > java.util.concurrent.atomic.AtomicReference<java.lang.Thread> = new java.util.concurrent.atomic.AtomicReference<java.lang.Thread> < java.lang.Thread > ( ) ; org.springframework.integration.ip.tcp.connection.TcpNioServerConnectionFactory . registerListener ( new TcpListener ( ) { @ java.lang.Override public boolean boolean ( Message < ? > org.springframework.integration.ip.tcp.connection.Message<?> ) { if ( ! ( org.springframework.integration.ip.tcp.connection.Message<> instanceof ErrorMessage ) ) { java.util.concurrent.atomic.AtomicReference<java.lang.Thread> . void ( java.lang.Thread . java.lang.Thread ( ) ) ; java.util.concurrent.CountDownLatch . void ( ) ; } return false ; } } ) ; ThreadPoolTaskExecutor org.springframework.integration.ip.tcp.connection.ThreadPoolTaskExecutor = new ThreadPoolTaskExecutor ( ) ; org.springframework.integration.ip.tcp.connection.ThreadPoolTaskExecutor . setCorePoolSize ( NUMBER ) ; org.springframework.integration.ip.tcp.connection.ThreadPoolTaskExecutor . setMaxPoolSize ( NUMBER ) ; org.springframework.integration.ip.tcp.connection.ThreadPoolTaskExecutor . setQueueCapacity ( NUMBER ) ; org.springframework.integration.ip.tcp.connection.ThreadPoolTaskExecutor . initialize ( ) ; org.springframework.integration.ip.tcp.connection.TcpNioServerConnectionFactory . setTaskExecutor ( org.springframework.integration.ip.tcp.connection.ThreadPoolTaskExecutor ) ; org.springframework.integration.ip.tcp.connection.TcpNioServerConnectionFactory . start ( ) ; TestingUtilities . waitListening ( org.springframework.integration.ip.tcp.connection.TcpNioServerConnectionFactory , NUMBER ) ; int int = org.springframework.integration.ip.tcp.connection.TcpNioServerConnectionFactory . getPort ( ) ; java.net.Socket java.net.Socket = javax.net.SocketFactory . javax.net.SocketFactory ( ) . java.net.Socket ( STRING , int ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; TcpNioConnection org.springframework.integration.ip.tcp.connection.TcpNioConnection = ( TcpNioConnection ) TestUtils . getPropertyValue ( org.springframework.integration.ip.tcp.connection.TcpNioServerConnectionFactory , STRING , java.util.Map .class ) . values ( ) . iterator ( ) . next ( ) ; Log org.springframework.integration.ip.tcp.connection.Log = spy ( TestUtils . getPropertyValue ( org.springframework.integration.ip.tcp.connection.TcpNioConnection , STRING , Log .class ) ) ; DirectFieldAccessor org.springframework.integration.ip.tcp.connection.DirectFieldAccessor = new DirectFieldAccessor ( org.springframework.integration.ip.tcp.connection.TcpNioConnection ) ; org.springframework.integration.ip.tcp.connection.DirectFieldAccessor . setPropertyValue ( STRING , org.springframework.integration.ip.tcp.connection.Log ) ; ChannelInputStream org.springframework.integration.ip.tcp.connection.ChannelInputStream = spy ( TestUtils . getPropertyValue ( org.springframework.integration.ip.tcp.connection.TcpNioConnection , STRING , ChannelInputStream .class ) ) ; org.springframework.integration.ip.tcp.connection.DirectFieldAccessor . setPropertyValue ( STRING , org.springframework.integration.ip.tcp.connection.ChannelInputStream ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; doAnswer ( new Answer < java.lang.Void > ( ) { @ java.lang.Override public java.lang.Void java.lang.Void ( InvocationOnMock org.springframework.integration.ip.tcp.connection.InvocationOnMock ) throws java.lang.Throwable { org.springframework.integration.ip.tcp.connection.InvocationOnMock . callRealMethod ( ) ; java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ; java.lang.Thread . void ( NUMBER ) ; java.util.concurrent.CountDownLatch . void ( ) ; return null ; } } ) . when ( org.springframework.integration.ip.tcp.connection.ChannelInputStream ) . write ( any ( java.nio.ByteBuffer .class ) ) ; doReturn ( true ) . when ( org.springframework.integration.ip.tcp.connection.Log ) . isTraceEnabled ( ) ; doAnswer ( new Answer < java.lang.Void > ( ) { @ java.lang.Override public java.lang.Void java.lang.Void ( InvocationOnMock org.springframework.integration.ip.tcp.connection.InvocationOnMock ) throws java.lang.Throwable { org.springframework.integration.ip.tcp.connection.InvocationOnMock . callRealMethod ( ) ; java.util.concurrent.CountDownLatch . void ( ) ; return null ; } } ) . when ( org.springframework.integration.ip.tcp.connection.Log ) . trace ( contains ( STRING ) ) ; doAnswer ( new Answer < java.lang.Void > ( ) { @ java.lang.Override public java.lang.Void java.lang.Void ( InvocationOnMock org.springframework.integration.ip.tcp.connection.InvocationOnMock ) throws java.lang.Throwable { org.springframework.integration.ip.tcp.connection.InvocationOnMock . callRealMethod ( ) ; java.util.concurrent.CountDownLatch . void ( ) ; return null ; } } ) . when ( org.springframework.integration.ip.tcp.connection.Log ) . trace ( contains ( STRING ) ) ; java.net.Socket . java.io.OutputStream ( ) . void ( STRING . byte[] ( ) ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; java.lang.StackTraceElement [] java.lang.StackTraceElement[] = java.util.concurrent.atomic.AtomicReference<java.lang.Thread> . java.lang.Thread ( ) . java.lang.StackTraceElement[] ( ) ; assertThat ( java.util.Arrays . java.util.List<java.lang.StackTraceElement> ( java.lang.StackTraceElement[] ) . java.lang.String ( ) , not ( containsString ( STRING ) ) ) ; java.net.Socket . void ( ) ; org.springframework.integration.ip.tcp.connection.TcpNioServerConnectionFactory . stop ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ApplicationEvent org.springframework.integration.ip.tcp.connection.ApplicationEvent ) { if ( org.springframework.integration.ip.tcp.connection.ApplicationEvent instanceof TcpConnectionOpenEvent ) { java.util.concurrent.CountDownLatch . void ( ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( java.lang.Object java.lang.Object ) {			}  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( Message < ? > org.springframework.integration.ip.tcp.connection.Message<?> ) { if ( ! ( org.springframework.integration.ip.tcp.connection.Message<> instanceof ErrorMessage ) ) { java.util.concurrent.atomic.AtomicReference<java.lang.Thread> . void ( java.lang.Thread . java.lang.Thread ( ) ) ; java.util.concurrent.CountDownLatch . void ( ) ; } return false ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.Void java.lang.Void ( InvocationOnMock org.springframework.integration.ip.tcp.connection.InvocationOnMock ) throws java.lang.Throwable { org.springframework.integration.ip.tcp.connection.InvocationOnMock . callRealMethod ( ) ; java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ; java.lang.Thread . void ( NUMBER ) ; java.util.concurrent.CountDownLatch . void ( ) ; return null ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.Void java.lang.Void ( InvocationOnMock org.springframework.integration.ip.tcp.connection.InvocationOnMock ) throws java.lang.Throwable { org.springframework.integration.ip.tcp.connection.InvocationOnMock . callRealMethod ( ) ; java.util.concurrent.CountDownLatch . void ( ) ; return null ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.Void java.lang.Void ( InvocationOnMock org.springframework.integration.ip.tcp.connection.InvocationOnMock ) throws java.lang.Throwable { org.springframework.integration.ip.tcp.connection.InvocationOnMock . callRealMethod ( ) ; java.util.concurrent.CountDownLatch . void ( ) ; return null ; }  <METHOD_END>
<METHOD_START> private void void ( java.io.InputStream java.io.InputStream , byte [] byte[] ) throws java.io.IOException { for ( int int = NUMBER ; int < byte[] . int ; int ++ ) { byte[] [ int ] = ( byte ) java.io.InputStream . int ( ) ; } }  <METHOD_END>
