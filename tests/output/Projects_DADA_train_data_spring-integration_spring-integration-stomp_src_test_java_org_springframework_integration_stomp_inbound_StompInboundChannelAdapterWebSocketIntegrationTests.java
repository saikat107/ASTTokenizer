<METHOD_START> public void ( ) { super( STRING , STRING ); }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { Message < ? > org.springframework.integration.stomp.inbound.Message<?> = this . org.springframework.integration.stomp.inbound.PollableChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.stomp.inbound.Message<> ) ; assertThat ( org.springframework.integration.stomp.inbound.Message<> . getPayload ( ) , instanceOf ( StompSessionConnectedEvent .class ) ) ; Message < ? > org.springframework.integration.stomp.inbound.Message<?> = this . org.springframework.integration.stomp.inbound.PollableChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.stomp.inbound.Message<> ) ; assertThat ( org.springframework.integration.stomp.inbound.Message<> . getPayload ( ) , instanceOf ( StompReceiptEvent .class ) ) ; StompReceiptEvent org.springframework.integration.stomp.inbound.StompReceiptEvent = ( StompReceiptEvent ) org.springframework.integration.stomp.inbound.Message<> . getPayload ( ) ; assertEquals ( StompCommand . SUBSCRIBE , org.springframework.integration.stomp.inbound.StompReceiptEvent . getStompCommand ( ) ) ; assertEquals ( STRING , org.springframework.integration.stomp.inbound.StompReceiptEvent . getDestination ( ) ) ; void ( STRING ) ; SimpMessagingTemplate org.springframework.integration.stomp.inbound.SimpMessagingTemplate = this . org.springframework.integration.stomp.inbound.ConfigurableApplicationContext . getBean ( STRING , SimpMessagingTemplate .class ) ; StompHeaderAccessor org.springframework.integration.stomp.inbound.StompHeaderAccessor = StompHeaderAccessor . create ( StompCommand . MESSAGE ) ; org.springframework.integration.stomp.inbound.StompHeaderAccessor . setContentType ( MediaType . APPLICATION_JSON ) ; org.springframework.integration.stomp.inbound.StompHeaderAccessor . updateStompCommandAsServerMessage ( ) ; org.springframework.integration.stomp.inbound.StompHeaderAccessor . setLeaveMutable ( true ) ; org.springframework.integration.stomp.inbound.SimpMessagingTemplate . send ( STRING , MessageBuilder . createMessage ( STRING . byte[] ( ) , org.springframework.integration.stomp.inbound.StompHeaderAccessor . getMessageHeaders ( ) ) ) ; org.springframework.integration.stomp.inbound.Message<?> = this . org.springframework.integration.stomp.inbound.PollableChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.stomp.inbound.Message<> ) ; assertThat ( org.springframework.integration.stomp.inbound.Message<> . getPayload ( ) , instanceOf ( java.util.Map .class ) ) ; @ java.lang.SuppressWarnings ( STRING ) java.util.Map<java.lang.String,java.lang.String> < java.lang.String , java.lang.String > java.util.Map<java.lang.String,java.lang.String> = ( java.util.Map<java.lang.String,java.lang.String> < java.lang.String , java.lang.String > ) org.springframework.integration.stomp.inbound.Message<> . getPayload ( ) ; java.lang.String java.lang.String = java.util.Map<java.lang.String,java.lang.String> . java.lang.String ( STRING ) ; assertNotNull ( java.lang.String ) ; assertEquals ( STRING , java.lang.String ) ; this . org.springframework.integration.stomp.inbound.StompInboundChannelAdapter . removeDestination ( STRING ) ; void ( STRING ) ; org.springframework.integration.stomp.inbound.SimpMessagingTemplate . convertAndSend ( STRING , STRING ) ; org.springframework.integration.stomp.inbound.Message<?> = this . org.springframework.integration.stomp.inbound.PollableChannel . receive ( NUMBER ) ; assertNull ( org.springframework.integration.stomp.inbound.Message<> ) ; this . org.springframework.integration.stomp.inbound.StompInboundChannelAdapter . addDestination ( STRING ) ; org.springframework.integration.stomp.inbound.Message<?> = this . org.springframework.integration.stomp.inbound.PollableChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.stomp.inbound.Message<> ) ; void ( STRING ) ; org.springframework.integration.stomp.inbound.SimpMessagingTemplate . convertAndSend ( STRING , STRING ) ; org.springframework.integration.stomp.inbound.Message<?> = this . org.springframework.integration.stomp.inbound.PollableChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.stomp.inbound.Message<> ) ; assertThat ( org.springframework.integration.stomp.inbound.Message<> , instanceOf ( ErrorMessage .class ) ) ; ErrorMessage org.springframework.integration.stomp.inbound.ErrorMessage = ( ErrorMessage ) org.springframework.integration.stomp.inbound.Message<> ; java.lang.Throwable java.lang.Throwable = org.springframework.integration.stomp.inbound.ErrorMessage . getPayload ( ) ; assertThat ( java.lang.Throwable , instanceOf ( MessageHandlingException .class ) ) ; assertThat ( java.lang.Throwable . java.lang.Throwable ( ) , instanceOf ( MessageConversionException .class ) ) ; assertThat ( java.lang.Throwable . java.lang.String ( ) , containsString ( STRING ) ) ; this . org.springframework.integration.stomp.inbound.ConfigurableApplicationContext . close ( ) ; org.springframework.integration.stomp.inbound.Message<?> = this . org.springframework.integration.stomp.inbound.PollableChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.stomp.inbound.Message<> ) ; assertThat ( org.springframework.integration.stomp.inbound.Message<> . getPayload ( ) , instanceOf ( StompConnectionFailedEvent .class ) ) ; this . org.springframework.integration.stomp.inbound.ConfigurableApplicationContext . refresh ( ) ; do { org.springframework.integration.stomp.inbound.Message<?> = this . org.springframework.integration.stomp.inbound.PollableChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.stomp.inbound.Message<> ) ; } while ( ! ( org.springframework.integration.stomp.inbound.Message<> . getPayload ( ) instanceof StompSessionConnectedEvent ) ); void ( STRING ) ; org.springframework.integration.stomp.inbound.SimpMessagingTemplate = this . org.springframework.integration.stomp.inbound.ConfigurableApplicationContext . getBean ( STRING , SimpMessagingTemplate .class ) ; org.springframework.integration.stomp.inbound.SimpMessagingTemplate . convertAndSend ( STRING , STRING ) ; org.springframework.integration.stomp.inbound.Message<?> = this . org.springframework.integration.stomp.inbound.PollableChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.stomp.inbound.Message<> ) ; assertEquals ( NUMBER , ( ( QueueChannel ) this . org.springframework.integration.stomp.inbound.PollableChannel ) . getQueueSize ( ) ) ; }  <METHOD_END>
<METHOD_START> private void void ( java.lang.String java.lang.String ) throws java.lang.InterruptedException { SimpleBrokerMessageHandler org.springframework.integration.stomp.inbound.SimpleBrokerMessageHandler = this . org.springframework.integration.stomp.inbound.ConfigurableApplicationContext . getBean ( STRING , SimpleBrokerMessageHandler .class ) ; SubscriptionRegistry org.springframework.integration.stomp.inbound.SubscriptionRegistry = org.springframework.integration.stomp.inbound.SimpleBrokerMessageHandler . getSubscriptionRegistry ( ) ; int int = NUMBER ; while ( ! boolean ( java.lang.String , org.springframework.integration.stomp.inbound.SubscriptionRegistry ) && int ++ < NUMBER ) { java.lang.Thread . void ( NUMBER ) ; } assertTrue ( STRING + java.lang.String + STRING , int < NUMBER ) ; }  <METHOD_END>
<METHOD_START> private void void ( java.lang.String java.lang.String ) throws java.lang.InterruptedException { SimpleBrokerMessageHandler org.springframework.integration.stomp.inbound.SimpleBrokerMessageHandler = this . org.springframework.integration.stomp.inbound.ConfigurableApplicationContext . getBean ( STRING , SimpleBrokerMessageHandler .class ) ; SubscriptionRegistry org.springframework.integration.stomp.inbound.SubscriptionRegistry = org.springframework.integration.stomp.inbound.SimpleBrokerMessageHandler . getSubscriptionRegistry ( ) ; int int = NUMBER ; while ( boolean ( java.lang.String , org.springframework.integration.stomp.inbound.SubscriptionRegistry ) && int ++ < NUMBER ) { java.lang.Thread . void ( NUMBER ) ; } assertTrue ( STRING + java.lang.String + STRING , int < NUMBER ) ; }  <METHOD_END>
<METHOD_START> private boolean boolean ( java.lang.String java.lang.String , SubscriptionRegistry org.springframework.integration.stomp.inbound.SubscriptionRegistry ) { StompHeaderAccessor org.springframework.integration.stomp.inbound.StompHeaderAccessor = StompHeaderAccessor . create ( StompCommand . MESSAGE ) ; org.springframework.integration.stomp.inbound.StompHeaderAccessor . setDestination ( java.lang.String ) ; Message < byte [] > org.springframework.integration.stomp.inbound.Message<byte[]> = MessageBuilder . createMessage ( new byte [ NUMBER ] , org.springframework.integration.stomp.inbound.StompHeaderAccessor . toMessageHeaders ( ) ) ; MultiValueMap < java.lang.String , java.lang.String > org.springframework.integration.stomp.inbound.MultiValueMap<java.lang.String,java.lang.String> = org.springframework.integration.stomp.inbound.SubscriptionRegistry . findSubscriptions ( org.springframework.integration.stomp.inbound.Message<byte[]> ) ; return ! org.springframework.integration.stomp.inbound.MultiValueMap<java.lang.String,java.lang.String> . isEmpty ( ) ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.integration.stomp.inbound.TomcatWebSocketTestServer org.springframework.integration.stomp.inbound.TomcatWebSocketTestServer ( ) { return new TomcatWebSocketTestServer ( org.springframework.integration.stomp.inbound.StompInboundChannelAdapterWebSocketIntegrationTests.ServerConfig .class ) ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.integration.stomp.inbound.WebSocketClient org.springframework.integration.stomp.inbound.WebSocketClient ( ) { return new SockJsClient ( java.util.Collections .< Transport > java.util.List<org.springframework.integration.stomp.inbound.Transport> ( new WebSocketTransport ( new StandardWebSocketClient ( ) ) ) ) ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.integration.stomp.inbound.WebSocketStompClient org.springframework.integration.stomp.inbound.WebSocketStompClient ( TaskScheduler org.springframework.integration.stomp.inbound.TaskScheduler ) { WebSocketStompClient org.springframework.integration.stomp.inbound.WebSocketStompClient = new WebSocketStompClient ( org.springframework.integration.stomp.inbound.WebSocketClient ( ) ) ; org.springframework.integration.stomp.inbound.WebSocketStompClient . setMessageConverter ( new MappingJackson2MessageConverter ( ) ) ; org.springframework.integration.stomp.inbound.WebSocketStompClient . setTaskScheduler ( org.springframework.integration.stomp.inbound.TaskScheduler ) ; return org.springframework.integration.stomp.inbound.WebSocketStompClient ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.integration.stomp.inbound.StompSessionManager org.springframework.integration.stomp.inbound.StompSessionManager ( WebSocketStompClient org.springframework.integration.stomp.inbound.WebSocketStompClient ) { WebSocketStompSessionManager org.springframework.integration.stomp.inbound.WebSocketStompSessionManager = new WebSocketStompSessionManager ( org.springframework.integration.stomp.inbound.WebSocketStompClient , org.springframework.integration.stomp.inbound.TomcatWebSocketTestServer ( ) . getWsBaseUrl ( ) + STRING ) ; org.springframework.integration.stomp.inbound.WebSocketStompSessionManager . setAutoReceipt ( true ) ; org.springframework.integration.stomp.inbound.WebSocketStompSessionManager . setRecoveryInterval ( NUMBER ) ; WebSocketHttpHeaders org.springframework.integration.stomp.inbound.WebSocketHttpHeaders = new WebSocketHttpHeaders ( ) ; org.springframework.integration.stomp.inbound.WebSocketHttpHeaders . setOrigin ( STRING ) ; org.springframework.integration.stomp.inbound.WebSocketStompSessionManager . setHandshakeHeaders ( org.springframework.integration.stomp.inbound.WebSocketHttpHeaders ) ; StompHeaders org.springframework.integration.stomp.inbound.StompHeaders = new StompHeaders ( ) ; org.springframework.integration.stomp.inbound.StompHeaders . setHeartbeat ( new long [] { NUMBER , NUMBER } ) ; org.springframework.integration.stomp.inbound.WebSocketStompSessionManager . setConnectHeaders ( org.springframework.integration.stomp.inbound.StompHeaders ) ; return org.springframework.integration.stomp.inbound.WebSocketStompSessionManager ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.integration.stomp.inbound.PollableChannel org.springframework.integration.stomp.inbound.PollableChannel ( ) { return new QueueChannel ( ) ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.integration.stomp.inbound.PollableChannel org.springframework.integration.stomp.inbound.PollableChannel ( ) { return new QueueChannel ( ) ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.integration.stomp.inbound.StompInboundChannelAdapter org.springframework.integration.stomp.inbound.StompInboundChannelAdapter ( StompSessionManager org.springframework.integration.stomp.inbound.StompSessionManager ) { StompInboundChannelAdapter org.springframework.integration.stomp.inbound.StompInboundChannelAdapter = new StompInboundChannelAdapter ( org.springframework.integration.stomp.inbound.StompSessionManager , STRING ) ; org.springframework.integration.stomp.inbound.StompInboundChannelAdapter . setPayloadType ( java.util.Map .class ) ; org.springframework.integration.stomp.inbound.StompInboundChannelAdapter . setOutputChannel ( org.springframework.integration.stomp.inbound.PollableChannel ( ) ) ; org.springframework.integration.stomp.inbound.StompInboundChannelAdapter . setErrorChannel ( org.springframework.integration.stomp.inbound.PollableChannel ( ) ) ; return org.springframework.integration.stomp.inbound.StompInboundChannelAdapter ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.integration.stomp.inbound.PollableChannel org.springframework.integration.stomp.inbound.PollableChannel ( ) { return new QueueChannel ( ) ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.integration.stomp.inbound.ApplicationListener<org.springframework.integration.stomp.inbound.ApplicationEvent> < ApplicationEvent > org.springframework.integration.stomp.inbound.ApplicationListener<org.springframework.integration.stomp.inbound.ApplicationEvent> ( ) { ApplicationEventListeningMessageProducer org.springframework.integration.stomp.inbound.ApplicationEventListeningMessageProducer = new ApplicationEventListeningMessageProducer ( ) ; org.springframework.integration.stomp.inbound.ApplicationEventListeningMessageProducer . setEventTypes ( StompIntegrationEvent .class ) ; org.springframework.integration.stomp.inbound.ApplicationEventListeningMessageProducer . setOutputChannel ( org.springframework.integration.stomp.inbound.PollableChannel ( ) ) ; return org.springframework.integration.stomp.inbound.ApplicationEventListeningMessageProducer ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.integration.stomp.inbound.DefaultHandshakeHandler org.springframework.integration.stomp.inbound.DefaultHandshakeHandler ( ) { return new DefaultHandshakeHandler ( new TomcatRequestUpgradeStrategy ( ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( StompEndpointRegistry org.springframework.integration.stomp.inbound.StompEndpointRegistry ) { org.springframework.integration.stomp.inbound.StompEndpointRegistry . addEndpoint ( STRING ) . setHandshakeHandler ( org.springframework.integration.stomp.inbound.DefaultHandshakeHandler ( ) ) . setAllowedOrigins ( STRING ) . addInterceptors ( new HandshakeInterceptor ( ) { @ java.lang.Override public boolean boolean ( ServerHttpRequest org.springframework.integration.stomp.inbound.ServerHttpRequest , ServerHttpResponse org.springframework.integration.stomp.inbound.ServerHttpResponse , WebSocketHandler org.springframework.integration.stomp.inbound.WebSocketHandler , java.util.Map<java.lang.String,java.lang.Object> < java.lang.String , java.lang.Object > java.util.Map<java.lang.String,java.lang.Object> ) throws java.lang.Exception { return org.springframework.integration.stomp.inbound.ServerHttpRequest . getHeaders ( ) . getOrigin ( ) != null ; } @ java.lang.Override public void void ( ServerHttpRequest org.springframework.integration.stomp.inbound.ServerHttpRequest , ServerHttpResponse org.springframework.integration.stomp.inbound.ServerHttpResponse , WebSocketHandler org.springframework.integration.stomp.inbound.WebSocketHandler , java.lang.Exception java.lang.Exception ) {						} } ) . withSockJS ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( ServerHttpRequest org.springframework.integration.stomp.inbound.ServerHttpRequest , ServerHttpResponse org.springframework.integration.stomp.inbound.ServerHttpResponse , WebSocketHandler org.springframework.integration.stomp.inbound.WebSocketHandler , java.util.Map<java.lang.String,java.lang.Object> < java.lang.String , java.lang.Object > java.util.Map<java.lang.String,java.lang.Object> ) throws java.lang.Exception { return org.springframework.integration.stomp.inbound.ServerHttpRequest . getHeaders ( ) . getOrigin ( ) != null ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ServerHttpRequest org.springframework.integration.stomp.inbound.ServerHttpRequest , ServerHttpResponse org.springframework.integration.stomp.inbound.ServerHttpResponse , WebSocketHandler org.springframework.integration.stomp.inbound.WebSocketHandler , java.lang.Exception java.lang.Exception ) {						}  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( MessageBrokerRegistry org.springframework.integration.stomp.inbound.MessageBrokerRegistry ) { org.springframework.integration.stomp.inbound.MessageBrokerRegistry . setApplicationDestinationPrefixes ( STRING ) . enableSimpleBroker ( STRING , STRING ) ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.integration.stomp.inbound.ApplicationListener<org.springframework.integration.stomp.inbound.SessionSubscribeEvent> < SessionSubscribeEvent > org.springframework.integration.stomp.inbound.ApplicationListener<org.springframework.integration.stomp.inbound.SessionSubscribeEvent> ( final AbstractSubscribableChannel org.springframework.integration.stomp.inbound.AbstractSubscribableChannel ) { return event -> { Message < byte [] > message = event . getMessage ( ) ; StompHeaderAccessor stompHeaderAccessor = StompHeaderAccessor . wrap ( message ) ; if ( stompHeaderAccessor . getReceipt ( ) != null ) { stompHeaderAccessor . setHeader ( STRING , StompCommand . RECEIPT ) ; stompHeaderAccessor . setReceiptId ( stompHeaderAccessor . getReceipt ( ) ) ; clientOutboundChannel . send ( MessageBuilder . createMessage ( new byte [ NUMBER ] , stompHeaderAccessor . getMessageHeaders ( ) ) ) ; } } ; }  <METHOD_END>
