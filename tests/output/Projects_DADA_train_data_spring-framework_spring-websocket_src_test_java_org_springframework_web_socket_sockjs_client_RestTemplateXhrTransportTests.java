<METHOD_START> @ Before public void void ( ) java.lang.Exception { this . org.springframework.web.socket.sockjs.client.WebSocketHandler = mock ( WebSocketHandler .class ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.lang.String java.lang.String = STRING + STRING + STRING ; ClientHttpResponse org.springframework.web.socket.sockjs.client.ClientHttpResponse = org.springframework.web.socket.sockjs.client.ClientHttpResponse ( HttpStatus . OK , java.lang.String ) ; org.springframework.web.socket.sockjs.client.ListenableFuture<org.springframework.web.socket.sockjs.client.WebSocketSession> ( org.springframework.web.socket.sockjs.client.ClientHttpResponse ) ; verify ( this . org.springframework.web.socket.sockjs.client.WebSocketHandler ) . afterConnectionEstablished ( any ( ) ) ; verify ( this . org.springframework.web.socket.sockjs.client.WebSocketHandler ) . handleMessage ( any ( ) , eq ( new TextMessage ( STRING ) ) ) ; verify ( this . org.springframework.web.socket.sockjs.client.WebSocketHandler ) . afterConnectionClosed ( any ( ) , eq ( new CloseStatus ( NUMBER , STRING ) ) ) ; verifyNoMoreInteractions ( this . org.springframework.web.socket.sockjs.client.WebSocketHandler ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.lang.StringBuilder java.lang.StringBuilder = new java.lang.StringBuilder ( NUMBER ) ; for ( int int = NUMBER ; int < NUMBER ; int ++ ) { java.lang.StringBuilder . java.lang.StringBuilder ( 'h' ) ; } java.lang.String java.lang.String = java.lang.StringBuilder . java.lang.String ( ) + STRING + STRING + STRING + STRING ; ClientHttpResponse org.springframework.web.socket.sockjs.client.ClientHttpResponse = org.springframework.web.socket.sockjs.client.ClientHttpResponse ( HttpStatus . OK , java.lang.String ) ; org.springframework.web.socket.sockjs.client.ListenableFuture<org.springframework.web.socket.sockjs.client.WebSocketSession> ( org.springframework.web.socket.sockjs.client.ClientHttpResponse ) ; verify ( this . org.springframework.web.socket.sockjs.client.WebSocketHandler ) . afterConnectionEstablished ( any ( ) ) ; verify ( this . org.springframework.web.socket.sockjs.client.WebSocketHandler ) . handleMessage ( any ( ) , eq ( new TextMessage ( STRING ) ) ) ; verify ( this . org.springframework.web.socket.sockjs.client.WebSocketHandler ) . afterConnectionClosed ( any ( ) , eq ( new CloseStatus ( NUMBER , STRING ) ) ) ; verifyNoMoreInteractions ( this . org.springframework.web.socket.sockjs.client.WebSocketHandler ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { StompHeaderAccessor org.springframework.web.socket.sockjs.client.StompHeaderAccessor = StompHeaderAccessor . create ( StompCommand . SEND ) ; org.springframework.web.socket.sockjs.client.StompHeaderAccessor . setDestination ( STRING ) ; MessageHeaders org.springframework.web.socket.sockjs.client.MessageHeaders = org.springframework.web.socket.sockjs.client.StompHeaderAccessor . getMessageHeaders ( ) ; Message < byte [] > org.springframework.web.socket.sockjs.client.Message<byte[]> = MessageBuilder . createMessage ( STRING . byte[] ( java.nio.charset.StandardCharsets . java.nio.charset.Charset ) , org.springframework.web.socket.sockjs.client.MessageHeaders ) ; byte [] byte[] = new StompEncoder ( ) . encode ( org.springframework.web.socket.sockjs.client.Message<byte[]> ) ; TextMessage org.springframework.web.socket.sockjs.client.TextMessage = new TextMessage ( byte[] ) ; SockJsFrame org.springframework.web.socket.sockjs.client.SockJsFrame = SockJsFrame . messageFrame ( new Jackson2SockJsMessageCodec ( ) , org.springframework.web.socket.sockjs.client.TextMessage . getPayload ( ) ) ; java.lang.String java.lang.String = STRING + org.springframework.web.socket.sockjs.client.SockJsFrame . getContent ( ) + STRING + STRING ; ClientHttpResponse org.springframework.web.socket.sockjs.client.ClientHttpResponse = org.springframework.web.socket.sockjs.client.ClientHttpResponse ( HttpStatus . OK , java.lang.String ) ; org.springframework.web.socket.sockjs.client.ListenableFuture<org.springframework.web.socket.sockjs.client.WebSocketSession> ( org.springframework.web.socket.sockjs.client.ClientHttpResponse ) ; verify ( this . org.springframework.web.socket.sockjs.client.WebSocketHandler ) . afterConnectionEstablished ( any ( ) ) ; verify ( this . org.springframework.web.socket.sockjs.client.WebSocketHandler ) . handleMessage ( any ( ) , eq ( org.springframework.web.socket.sockjs.client.TextMessage ) ) ; verify ( this . org.springframework.web.socket.sockjs.client.WebSocketHandler ) . afterConnectionClosed ( any ( ) , eq ( new CloseStatus ( NUMBER , STRING ) ) ) ; verifyNoMoreInteractions ( this . org.springframework.web.socket.sockjs.client.WebSocketHandler ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final HttpServerErrorException org.springframework.web.socket.sockjs.client.HttpServerErrorException = new HttpServerErrorException ( HttpStatus . INTERNAL_SERVER_ERROR ) ; RestOperations org.springframework.web.socket.sockjs.client.RestOperations = mock ( RestOperations .class ) ; given ( org.springframework.web.socket.sockjs.client.RestOperations . execute ( ( java.net.URI ) any ( ) , eq ( HttpMethod . POST ) , any ( ) , any ( ) ) ) . willThrow ( org.springframework.web.socket.sockjs.client.HttpServerErrorException ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; org.springframework.web.socket.sockjs.client.ListenableFuture<org.springframework.web.socket.sockjs.client.WebSocketSession> ( org.springframework.web.socket.sockjs.client.RestOperations ) . addCallback ( new ListenableFutureCallback < WebSocketSession > ( ) { @ java.lang.Override public void void ( WebSocketSession org.springframework.web.socket.sockjs.client.WebSocketSession ) {					} @ java.lang.Override public void void ( java.lang.Throwable java.lang.Throwable ) { if ( java.lang.Throwable == org.springframework.web.socket.sockjs.client.HttpServerErrorException ) { java.util.concurrent.CountDownLatch . void ( ) ; } } } ) ; verifyNoMoreInteractions ( this . org.springframework.web.socket.sockjs.client.WebSocketHandler ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( WebSocketSession org.springframework.web.socket.sockjs.client.WebSocketSession ) {					}  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( java.lang.Throwable java.lang.Throwable ) { if ( java.lang.Throwable == org.springframework.web.socket.sockjs.client.HttpServerErrorException ) { java.util.concurrent.CountDownLatch . void ( ) ; } }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { org.springframework.web.socket.sockjs.client.ListenableFuture<org.springframework.web.socket.sockjs.client.WebSocketSession> ( org.springframework.web.socket.sockjs.client.ClientHttpResponse ( HttpStatus . OK , STRING ) , org.springframework.web.socket.sockjs.client.ClientHttpResponse ( HttpStatus . INTERNAL_SERVER_ERROR , STRING ) ) ; verify ( this . org.springframework.web.socket.sockjs.client.WebSocketHandler ) . afterConnectionEstablished ( any ( ) ) ; verify ( this . org.springframework.web.socket.sockjs.client.WebSocketHandler ) . handleTransportError ( any ( ) , any ( ) ) ; verify ( this . org.springframework.web.socket.sockjs.client.WebSocketHandler ) . afterConnectionClosed ( any ( ) , any ( ) ) ; verifyNoMoreInteractions ( this . org.springframework.web.socket.sockjs.client.WebSocketHandler ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.lang.String java.lang.String = STRING + STRING + STRING ; ClientHttpResponse org.springframework.web.socket.sockjs.client.ClientHttpResponse = org.springframework.web.socket.sockjs.client.ClientHttpResponse ( HttpStatus . OK , java.lang.String ) ; org.springframework.web.socket.sockjs.client.ListenableFuture<org.springframework.web.socket.sockjs.client.WebSocketSession> ( org.springframework.web.socket.sockjs.client.ClientHttpResponse ) ; verify ( this . org.springframework.web.socket.sockjs.client.WebSocketHandler ) . afterConnectionEstablished ( any ( ) ) ; verify ( this . org.springframework.web.socket.sockjs.client.WebSocketHandler ) . afterConnectionClosed ( any ( ) , any ( ) ) ; verifyNoMoreInteractions ( this . org.springframework.web.socket.sockjs.client.WebSocketHandler ) ; verify ( org.springframework.web.socket.sockjs.client.ClientHttpResponse ) . close ( ) ; }  <METHOD_END>
<METHOD_START> private org.springframework.web.socket.sockjs.client.ListenableFuture<org.springframework.web.socket.sockjs.client.WebSocketSession> < WebSocketSession > org.springframework.web.socket.sockjs.client.ListenableFuture<org.springframework.web.socket.sockjs.client.WebSocketSession> ( ClientHttpResponse ... org.springframework.web.socket.sockjs.client.ClientHttpResponse[] ) throws java.lang.Exception { return org.springframework.web.socket.sockjs.client.ListenableFuture<org.springframework.web.socket.sockjs.client.WebSocketSession> ( new org.springframework.web.socket.sockjs.client.RestTemplateXhrTransportTests.TestRestTemplate ( org.springframework.web.socket.sockjs.client.ClientHttpResponse[] ) ) ; }  <METHOD_END>
<METHOD_START> private org.springframework.web.socket.sockjs.client.ListenableFuture<org.springframework.web.socket.sockjs.client.WebSocketSession> < WebSocketSession > org.springframework.web.socket.sockjs.client.ListenableFuture<org.springframework.web.socket.sockjs.client.WebSocketSession> ( RestOperations org.springframework.web.socket.sockjs.client.RestOperations , ClientHttpResponse ... org.springframework.web.socket.sockjs.client.ClientHttpResponse[] )			throws java.lang.Exception { RestTemplateXhrTransport org.springframework.web.socket.sockjs.client.RestTemplateXhrTransport = new RestTemplateXhrTransport ( org.springframework.web.socket.sockjs.client.RestOperations ) ; org.springframework.web.socket.sockjs.client.RestTemplateXhrTransport . setTaskExecutor ( new SyncTaskExecutor ( ) ) ; SockJsUrlInfo org.springframework.web.socket.sockjs.client.SockJsUrlInfo = new SockJsUrlInfo ( new java.net.URI ( STRING ) ) ; HttpHeaders org.springframework.web.socket.sockjs.client.HttpHeaders = new HttpHeaders ( ) ; org.springframework.web.socket.sockjs.client.HttpHeaders . add ( STRING , STRING ) ; TransportRequest org.springframework.web.socket.sockjs.client.TransportRequest = new DefaultTransportRequest ( org.springframework.web.socket.sockjs.client.SockJsUrlInfo , org.springframework.web.socket.sockjs.client.HttpHeaders , org.springframework.web.socket.sockjs.client.HttpHeaders , org.springframework.web.socket.sockjs.client.RestTemplateXhrTransport , TransportType . XHR , org.springframework.web.socket.sockjs.client.Jackson2SockJsMessageCodec ) ; return org.springframework.web.socket.sockjs.client.RestTemplateXhrTransport . connect ( org.springframework.web.socket.sockjs.client.TransportRequest , this . org.springframework.web.socket.sockjs.client.WebSocketHandler ) ; }  <METHOD_END>
<METHOD_START> private org.springframework.web.socket.sockjs.client.ClientHttpResponse org.springframework.web.socket.sockjs.client.ClientHttpResponse ( HttpStatus org.springframework.web.socket.sockjs.client.HttpStatus , java.lang.String java.lang.String ) throws java.io.IOException { ClientHttpResponse org.springframework.web.socket.sockjs.client.ClientHttpResponse = mock ( ClientHttpResponse .class ) ; java.io.InputStream java.io.InputStream = java.io.InputStream ( java.lang.String ) ; given ( org.springframework.web.socket.sockjs.client.ClientHttpResponse . getStatusCode ( ) ) . willReturn ( org.springframework.web.socket.sockjs.client.HttpStatus ) ; given ( org.springframework.web.socket.sockjs.client.ClientHttpResponse . getBody ( ) ) . willReturn ( java.io.InputStream ) ; return org.springframework.web.socket.sockjs.client.ClientHttpResponse ; }  <METHOD_END>
<METHOD_START> private java.io.InputStream java.io.InputStream ( java.lang.String java.lang.String ) { byte [] byte[] = java.lang.String . byte[] ( java.nio.charset.StandardCharsets . java.nio.charset.Charset ) ; return new java.io.ByteArrayInputStream ( byte[] ) ; }  <METHOD_END>
<METHOD_START> private void ( ClientHttpResponse ... org.springframework.web.socket.sockjs.client.ClientHttpResponse[] ) { this . java.util.Queue<org.springframework.web.socket.sockjs.client.ClientHttpResponse> . addAll ( java.util.Arrays . java.util.List ( org.springframework.web.socket.sockjs.client.ClientHttpResponse[] ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public < T > T T ( java.net.URI java.net.URI , HttpMethod org.springframework.web.socket.sockjs.client.HttpMethod , RequestCallback org.springframework.web.socket.sockjs.client.RequestCallback , ResponseExtractor < T > org.springframework.web.socket.sockjs.client.ResponseExtractor<T> ) throws org.springframework.web.socket.sockjs.client.RestClientException { try { org.springframework.web.socket.sockjs.client.ResponseExtractor<T> . extractData ( this . java.util.Queue<org.springframework.web.socket.sockjs.client.ClientHttpResponse> . remove ( ) ) ; } catch ( java.lang.Throwable java.lang.Throwable ) { throw new RestClientException ( STRING , java.lang.Throwable ) ; } return null ; }  <METHOD_END>
