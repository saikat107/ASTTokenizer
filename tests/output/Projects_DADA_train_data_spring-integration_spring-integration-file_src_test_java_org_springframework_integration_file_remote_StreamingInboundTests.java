<METHOD_START> @ java.lang.SuppressWarnings ( STRING ) @ Test public void void ( ) java.lang.Exception { org.springframework.integration.file.remote.StreamingInboundTests.StringSessionFactory org.springframework.integration.file.remote.StreamingInboundTests.StringSessionFactory = new org.springframework.integration.file.remote.StreamingInboundTests.StringSessionFactory ( ) ; org.springframework.integration.file.remote.StreamingInboundTests.Streamer org.springframework.integration.file.remote.StreamingInboundTests.Streamer = new org.springframework.integration.file.remote.StreamingInboundTests.Streamer ( new org.springframework.integration.file.remote.StreamingInboundTests.StringRemoteFileTemplate ( org.springframework.integration.file.remote.StreamingInboundTests.StringSessionFactory ) , null ) ; org.springframework.integration.file.remote.StreamingInboundTests.Streamer . setBeanFactory ( mock ( BeanFactory .class ) ) ; org.springframework.integration.file.remote.StreamingInboundTests.Streamer . setRemoteDirectory ( STRING ) ; org.springframework.integration.file.remote.StreamingInboundTests.Streamer . afterPropertiesSet ( ) ; Message < byte [] > org.springframework.integration.file.remote.Message<byte[]> = ( Message < byte [] > ) this . org.springframework.integration.file.remote.StreamTransformer . transform ( org.springframework.integration.file.remote.StreamingInboundTests.Streamer . receive ( ) ) ; assertEquals ( STRING , new java.lang.String ( org.springframework.integration.file.remote.Message<byte[]> . getPayload ( ) ) ) ; assertEquals ( STRING , org.springframework.integration.file.remote.Message<byte[]> . getHeaders ( ) . get ( FileHeaders . REMOTE_DIRECTORY ) ) ; assertEquals ( STRING , org.springframework.integration.file.remote.Message<byte[]> . getHeaders ( ) . get ( FileHeaders . REMOTE_FILE ) ) ; java.lang.String java.lang.String = ( java.lang.String ) org.springframework.integration.file.remote.Message<byte[]> . getHeaders ( ) . get ( FileHeaders . REMOTE_FILE_INFO ) ; assertThat ( java.lang.String , containsString ( STRING ) ) ; assertThat ( java.lang.String , containsString ( STRING ) ) ; assertThat ( java.lang.String , containsString ( STRING ) ) ; assertThat ( java.lang.String , containsString ( STRING ) ) ; assertThat ( java.lang.String , containsString ( STRING ) ) ; assertThat ( java.lang.String , containsString ( STRING ) ) ; assertThat ( java.lang.String , containsString ( STRING ) ) ; verify ( new IntegrationMessageHeaderAccessor ( org.springframework.integration.file.remote.Message<byte[]> ) . getCloseableResource ( ) , times ( NUMBER ) ) . close ( ) ; org.springframework.integration.file.remote.Message<byte[]> = ( Message < byte [] > ) this . org.springframework.integration.file.remote.StreamTransformer . transform ( org.springframework.integration.file.remote.StreamingInboundTests.Streamer . receive ( ) ) ; assertEquals ( STRING , new java.lang.String ( org.springframework.integration.file.remote.Message<byte[]> . getPayload ( ) ) ) ; assertEquals ( STRING , org.springframework.integration.file.remote.Message<byte[]> . getHeaders ( ) . get ( FileHeaders . REMOTE_DIRECTORY ) ) ; assertEquals ( STRING , org.springframework.integration.file.remote.Message<byte[]> . getHeaders ( ) . get ( FileHeaders . REMOTE_FILE ) ) ; java.lang.String = ( java.lang.String ) org.springframework.integration.file.remote.Message<byte[]> . getHeaders ( ) . get ( FileHeaders . REMOTE_FILE_INFO ) ; assertThat ( java.lang.String , containsString ( STRING ) ) ; assertThat ( java.lang.String , containsString ( STRING ) ) ; assertThat ( java.lang.String , containsString ( STRING ) ) ; assertThat ( java.lang.String , containsString ( STRING ) ) ; assertThat ( java.lang.String , containsString ( STRING ) ) ; assertThat ( java.lang.String , containsString ( STRING ) ) ; assertThat ( java.lang.String , containsString ( STRING ) ) ; verify ( new IntegrationMessageHeaderAccessor ( org.springframework.integration.file.remote.Message<byte[]> ) . getCloseableResource ( ) , times ( NUMBER ) ) . close ( ) ; verify ( org.springframework.integration.file.remote.StreamingInboundTests.StringSessionFactory . org.springframework.integration.file.remote.Session<java.lang.String> ( ) ) . list ( STRING ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.SuppressWarnings ( STRING ) @ Test public void void ( ) java.lang.Exception { org.springframework.integration.file.remote.StreamingInboundTests.StringSessionFactory org.springframework.integration.file.remote.StreamingInboundTests.StringSessionFactory = new org.springframework.integration.file.remote.StreamingInboundTests.StringSessionFactory ( ) ; org.springframework.integration.file.remote.StreamingInboundTests.Streamer org.springframework.integration.file.remote.StreamingInboundTests.Streamer = new org.springframework.integration.file.remote.StreamingInboundTests.Streamer ( new org.springframework.integration.file.remote.StreamingInboundTests.StringRemoteFileTemplate ( org.springframework.integration.file.remote.StreamingInboundTests.StringSessionFactory ) , null ) ; org.springframework.integration.file.remote.StreamingInboundTests.Streamer . setBeanFactory ( mock ( BeanFactory .class ) ) ; org.springframework.integration.file.remote.StreamingInboundTests.Streamer . setRemoteDirectory ( STRING ) ; org.springframework.integration.file.remote.StreamingInboundTests.Streamer . setMaxFetchSize ( NUMBER ) ; org.springframework.integration.file.remote.StreamingInboundTests.Streamer . setFilter ( new AcceptOnceFileListFilter <> ( ) ) ; org.springframework.integration.file.remote.StreamingInboundTests.Streamer . afterPropertiesSet ( ) ; Message < byte [] > org.springframework.integration.file.remote.Message<byte[]> = ( Message < byte [] > ) this . org.springframework.integration.file.remote.StreamTransformer . transform ( org.springframework.integration.file.remote.StreamingInboundTests.Streamer . receive ( ) ) ; assertEquals ( STRING , new java.lang.String ( org.springframework.integration.file.remote.Message<byte[]> . getPayload ( ) ) ) ; assertEquals ( STRING , org.springframework.integration.file.remote.Message<byte[]> . getHeaders ( ) . get ( FileHeaders . REMOTE_DIRECTORY ) ) ; assertEquals ( STRING , org.springframework.integration.file.remote.Message<byte[]> . getHeaders ( ) . get ( FileHeaders . REMOTE_FILE ) ) ; verify ( new IntegrationMessageHeaderAccessor ( org.springframework.integration.file.remote.Message<byte[]> ) . getCloseableResource ( ) , times ( NUMBER ) ) . close ( ) ; org.springframework.integration.file.remote.Message<byte[]> = ( Message < byte [] > ) this . org.springframework.integration.file.remote.StreamTransformer . transform ( org.springframework.integration.file.remote.StreamingInboundTests.Streamer . receive ( ) ) ; assertEquals ( STRING , new java.lang.String ( org.springframework.integration.file.remote.Message<byte[]> . getPayload ( ) ) ) ; assertEquals ( STRING , org.springframework.integration.file.remote.Message<byte[]> . getHeaders ( ) . get ( FileHeaders . REMOTE_DIRECTORY ) ) ; assertEquals ( STRING , org.springframework.integration.file.remote.Message<byte[]> . getHeaders ( ) . get ( FileHeaders . REMOTE_FILE ) ) ; verify ( new IntegrationMessageHeaderAccessor ( org.springframework.integration.file.remote.Message<byte[]> ) . getCloseableResource ( ) , times ( NUMBER ) ) . close ( ) ; verify ( org.springframework.integration.file.remote.StreamingInboundTests.StringSessionFactory . org.springframework.integration.file.remote.Session<java.lang.String> ( ) , times ( NUMBER ) ) . list ( STRING ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { org.springframework.integration.file.remote.ExpectedException . expect ( MessagingException .class ) ; org.springframework.integration.file.remote.StreamingInboundTests.StringSessionFactory org.springframework.integration.file.remote.StreamingInboundTests.StringSessionFactory = new org.springframework.integration.file.remote.StreamingInboundTests.StringSessionFactory ( ) ; org.springframework.integration.file.remote.StreamingInboundTests.Streamer org.springframework.integration.file.remote.StreamingInboundTests.Streamer = new org.springframework.integration.file.remote.StreamingInboundTests.Streamer ( new org.springframework.integration.file.remote.StreamingInboundTests.StringRemoteFileTemplate ( org.springframework.integration.file.remote.StreamingInboundTests.StringSessionFactory ) , null ) ; org.springframework.integration.file.remote.StreamingInboundTests.Streamer . setBeanFactory ( mock ( BeanFactory .class ) ) ; org.springframework.integration.file.remote.StreamingInboundTests.Streamer . setRemoteDirectory ( STRING ) ; org.springframework.integration.file.remote.StreamingInboundTests.Streamer . afterPropertiesSet ( ) ; org.springframework.integration.file.remote.StreamingInboundTests.Streamer . receive ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.SuppressWarnings ( STRING ) @ Test public void void ( ) java.lang.Exception { org.springframework.integration.file.remote.StreamingInboundTests.Streamer org.springframework.integration.file.remote.StreamingInboundTests.Streamer = new org.springframework.integration.file.remote.StreamingInboundTests.Streamer ( new org.springframework.integration.file.remote.StreamingInboundTests.StringRemoteFileTemplate ( new org.springframework.integration.file.remote.StreamingInboundTests.StringSessionFactory ( ) ) , null ) ; org.springframework.integration.file.remote.StreamingInboundTests.Streamer . setBeanFactory ( mock ( BeanFactory .class ) ) ; org.springframework.integration.file.remote.StreamingInboundTests.Streamer . setRemoteDirectory ( STRING ) ; org.springframework.integration.file.remote.StreamingInboundTests.Streamer . afterPropertiesSet ( ) ; QueueChannel org.springframework.integration.file.remote.QueueChannel = new QueueChannel ( ) ; FileSplitter org.springframework.integration.file.remote.FileSplitter = new FileSplitter ( ) ; org.springframework.integration.file.remote.FileSplitter . setBeanFactory ( mock ( BeanFactory .class ) ) ; org.springframework.integration.file.remote.FileSplitter . setOutputChannel ( org.springframework.integration.file.remote.QueueChannel ) ; org.springframework.integration.file.remote.FileSplitter . afterPropertiesSet ( ) ; Message < java.io.InputStream > org.springframework.integration.file.remote.Message<java.io.InputStream> = org.springframework.integration.file.remote.StreamingInboundTests.Streamer . receive ( ) ; org.springframework.integration.file.remote.FileSplitter . handleMessage ( org.springframework.integration.file.remote.Message<java.io.InputStream> ) ; Message < byte [] > org.springframework.integration.file.remote.Message<byte[]> = ( Message < byte [] > ) org.springframework.integration.file.remote.QueueChannel . receive ( NUMBER ) ; assertEquals ( STRING , org.springframework.integration.file.remote.Message<byte[]> . getPayload ( ) ) ; assertEquals ( STRING , org.springframework.integration.file.remote.Message<byte[]> . getHeaders ( ) . get ( FileHeaders . REMOTE_DIRECTORY ) ) ; assertEquals ( STRING , org.springframework.integration.file.remote.Message<byte[]> . getHeaders ( ) . get ( FileHeaders . REMOTE_FILE ) ) ; org.springframework.integration.file.remote.Message<byte[]> = ( Message < byte [] > ) org.springframework.integration.file.remote.QueueChannel . receive ( NUMBER ) ; assertEquals ( STRING , org.springframework.integration.file.remote.Message<byte[]> . getPayload ( ) ) ; assertEquals ( STRING , org.springframework.integration.file.remote.Message<byte[]> . getHeaders ( ) . get ( FileHeaders . REMOTE_DIRECTORY ) ) ; assertEquals ( STRING , org.springframework.integration.file.remote.Message<byte[]> . getHeaders ( ) . get ( FileHeaders . REMOTE_FILE ) ) ; assertNull ( org.springframework.integration.file.remote.QueueChannel . receive ( NUMBER ) ) ; verify ( new IntegrationMessageHeaderAccessor ( org.springframework.integration.file.remote.Message<java.io.InputStream> ) . getCloseableResource ( ) , times ( NUMBER ) ) . close ( ) ; org.springframework.integration.file.remote.Message<java.io.InputStream> = org.springframework.integration.file.remote.StreamingInboundTests.Streamer . receive ( ) ; org.springframework.integration.file.remote.FileSplitter . handleMessage ( org.springframework.integration.file.remote.Message<java.io.InputStream> ) ; org.springframework.integration.file.remote.Message<byte[]> = ( Message < byte [] > ) org.springframework.integration.file.remote.QueueChannel . receive ( NUMBER ) ; assertEquals ( STRING , org.springframework.integration.file.remote.Message<byte[]> . getPayload ( ) ) ; assertEquals ( STRING , org.springframework.integration.file.remote.Message<byte[]> . getHeaders ( ) . get ( FileHeaders . REMOTE_DIRECTORY ) ) ; assertEquals ( STRING , org.springframework.integration.file.remote.Message<byte[]> . getHeaders ( ) . get ( FileHeaders . REMOTE_FILE ) ) ; org.springframework.integration.file.remote.Message<byte[]> = ( Message < byte [] > ) org.springframework.integration.file.remote.QueueChannel . receive ( NUMBER ) ; assertEquals ( STRING , org.springframework.integration.file.remote.Message<byte[]> . getPayload ( ) ) ; assertEquals ( STRING , org.springframework.integration.file.remote.Message<byte[]> . getHeaders ( ) . get ( FileHeaders . REMOTE_DIRECTORY ) ) ; assertEquals ( STRING , org.springframework.integration.file.remote.Message<byte[]> . getHeaders ( ) . get ( FileHeaders . REMOTE_FILE ) ) ; assertNull ( org.springframework.integration.file.remote.QueueChannel . receive ( NUMBER ) ) ; verify ( new IntegrationMessageHeaderAccessor ( org.springframework.integration.file.remote.Message<java.io.InputStream> ) . getCloseableResource ( ) , times ( NUMBER ) ) . close ( ) ; }  <METHOD_END>
<METHOD_START> protected void ( RemoteFileTemplate < java.lang.String > org.springframework.integration.file.remote.RemoteFileTemplate<java.lang.String> , java.util.Comparator<org.springframework.integration.file.remote.AbstractFileInfo<java.lang.String>> < AbstractFileInfo < java.lang.String > > java.util.Comparator<org.springframework.integration.file.remote.AbstractFileInfo<java.lang.String>> ) { super( org.springframework.integration.file.remote.RemoteFileTemplate<java.lang.String> , java.util.Comparator<org.springframework.integration.file.remote.AbstractFileInfo<java.lang.String>> ); }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.String java.lang.String ( ) { return STRING ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected java.util.List<org.springframework.integration.file.remote.AbstractFileInfo<java.lang.String>> < AbstractFileInfo < java.lang.String > > java.util.List<org.springframework.integration.file.remote.AbstractFileInfo<java.lang.String>> ( java.util.Collection<java.lang.String> < java.lang.String > java.util.Collection<java.lang.String> ) { java.util.List<org.springframework.integration.file.remote.AbstractFileInfo<java.lang.String>> < AbstractFileInfo < java.lang.String > > java.util.List<org.springframework.integration.file.remote.AbstractFileInfo<java.lang.String>> = new java.util.ArrayList<org.springframework.integration.file.remote.AbstractFileInfo<java.lang.String>> < AbstractFileInfo < java.lang.String > > ( ) ; for ( java.lang.String java.lang.String : java.util.Collection<java.lang.String> ) { java.util.List<org.springframework.integration.file.remote.AbstractFileInfo<java.lang.String>> . add ( new org.springframework.integration.file.remote.StreamingInboundTests.StringFileInfo ( java.lang.String ) ) ; } return java.util.List<org.springframework.integration.file.remote.AbstractFileInfo<java.lang.String>> ; }  <METHOD_END>
<METHOD_START> private void ( java.lang.String java.lang.String ) { this . java.lang.String = java.lang.String ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( ) { return false ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( ) { return false ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public long long ( ) { return NUMBER ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public long long ( ) { return NUMBER ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.String java.lang.String ( ) { return this . java.lang.String . java.lang.String ( this . java.lang.String . int ( STRING ) + NUMBER ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.String java.lang.String ( ) { return STRING ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.String java.lang.String ( ) { return java.lang.String ( ) ; }  <METHOD_END>
<METHOD_START> private java.lang.String java.lang.String ( ) { return STRING + this . java.lang.String + STRING ; }  <METHOD_END>
<METHOD_START> public void ( SessionFactory < java.lang.String > org.springframework.integration.file.remote.SessionFactory<java.lang.String> ) { super( org.springframework.integration.file.remote.SessionFactory<java.lang.String> ); }  <METHOD_END>
<METHOD_START> @ java.lang.SuppressWarnings ( STRING ) @ java.lang.Override public org.springframework.integration.file.remote.Session<java.lang.String> < java.lang.String > org.springframework.integration.file.remote.Session<java.lang.String> ( ) { if ( this . org.springframework.integration.file.remote.Session<java.lang.String> != null ) { return this . org.springframework.integration.file.remote.Session<java.lang.String> ; } try { Session < java.lang.String > org.springframework.integration.file.remote.Session<java.lang.String> = mock ( Session .class ) ; willReturn ( new java.lang.String [] { STRING , STRING } ) . given ( org.springframework.integration.file.remote.Session<java.lang.String> ) . list ( STRING ) ; java.io.ByteArrayInputStream java.io.ByteArrayInputStream = new java.io.ByteArrayInputStream ( STRING . byte[] ( ) ) ; java.io.ByteArrayInputStream java.io.ByteArrayInputStream = new java.io.ByteArrayInputStream ( STRING . byte[] ( ) ) ; willReturn ( java.io.ByteArrayInputStream ) . given ( org.springframework.integration.file.remote.Session<java.lang.String> ) . readRaw ( STRING ) ; willReturn ( java.io.ByteArrayInputStream ) . given ( org.springframework.integration.file.remote.Session<java.lang.String> ) . readRaw ( STRING ) ; willReturn ( new java.lang.String [] { STRING , STRING } ) . given ( org.springframework.integration.file.remote.Session<java.lang.String> ) . list ( STRING ) ; java.io.ByteArrayInputStream java.io.ByteArrayInputStream = new java.io.ByteArrayInputStream ( STRING . byte[] ( ) ) ; java.io.ByteArrayInputStream java.io.ByteArrayInputStream = new java.io.ByteArrayInputStream ( STRING . byte[] ( ) ) ; willReturn ( java.io.ByteArrayInputStream ) . given ( org.springframework.integration.file.remote.Session<java.lang.String> ) . readRaw ( STRING ) ; willReturn ( java.io.ByteArrayInputStream ) . given ( org.springframework.integration.file.remote.Session<java.lang.String> ) . readRaw ( STRING ) ; willReturn ( new java.lang.String [] { STRING } ) . given ( org.springframework.integration.file.remote.Session<java.lang.String> ) . list ( STRING ) ; willThrow ( new java.io.IOException ( STRING ) ) . given ( org.springframework.integration.file.remote.Session<java.lang.String> ) . readRaw ( STRING ) ; given ( org.springframework.integration.file.remote.Session<java.lang.String> . finalizeRaw ( ) ) . willReturn ( true ) ; this . org.springframework.integration.file.remote.Session<java.lang.String> = org.springframework.integration.file.remote.Session<java.lang.String> ; return org.springframework.integration.file.remote.Session<java.lang.String> ; } catch ( java.lang.Exception java.lang.Exception ) { throw new java.lang.RuntimeException ( STRING , java.lang.Exception ) ; } }  <METHOD_END>
