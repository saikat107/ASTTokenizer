<METHOD_START> public void ( ) {}  <METHOD_END>
<METHOD_START> public void ( ReactiveSession org.springframework.cassandra.core.ReactiveSession ) { Assert . notNull ( org.springframework.cassandra.core.ReactiveSession , STRING ) ; setSessionFactory ( new DefaultReactiveSessionFactory ( org.springframework.cassandra.core.ReactiveSession ) ) ; afterPropertiesSet ( ) ; }  <METHOD_END>
<METHOD_START> public void ( ReactiveSessionFactory org.springframework.cassandra.core.ReactiveSessionFactory ) { setSessionFactory ( org.springframework.cassandra.core.ReactiveSessionFactory ) ; afterPropertiesSet ( ) ; }  <METHOD_END>
<METHOD_START> public void void ( ConsistencyLevel org.springframework.cassandra.core.ConsistencyLevel ) { this . com.datastax.driver.core.ConsistencyLevel = org.springframework.cassandra.core.ConsistencyLevel ; }  <METHOD_END>
<METHOD_START> public org.springframework.cassandra.core.ConsistencyLevel org.springframework.cassandra.core.ConsistencyLevel ( ) { return com.datastax.driver.core.ConsistencyLevel ; }  <METHOD_END>
<METHOD_START> public void void ( int int ) { this . int = int ; }  <METHOD_END>
<METHOD_START> public int int ( ) { return this . int ; }  <METHOD_END>
<METHOD_START> public void void ( RetryPolicy org.springframework.cassandra.core.RetryPolicy ) { this . org.springframework.cassandra.core.RetryPolicy = org.springframework.cassandra.core.RetryPolicy ; }  <METHOD_END>
<METHOD_START> public org.springframework.cassandra.core.RetryPolicy org.springframework.cassandra.core.RetryPolicy ( ) { return org.springframework.cassandra.core.RetryPolicy ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public < T > org.springframework.cassandra.core.Flux<T> < T > org.springframework.cassandra.core.Flux<T> ( ReactiveSessionCallback < T > org.springframework.cassandra.core.ReactiveSessionCallback<T> ) throws org.springframework.cassandra.core.DataAccessException { Assert . notNull ( org.springframework.cassandra.core.ReactiveSessionCallback<T> , STRING ) ; return org.springframework.cassandra.core.Flux ( org.springframework.cassandra.core.ReactiveSessionCallback<T> ) . onErrorResumeWith ( java.util.function.Function ( STRING , java.lang.String ( org.springframework.cassandra.core.ReactiveSessionCallback<T> ) ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.cassandra.core.Mono<java.lang.Boolean> < java.lang.Boolean > org.springframework.cassandra.core.Mono<java.lang.Boolean> ( java.lang.String java.lang.String ) throws org.springframework.cassandra.core.DataAccessException { Assert . hasText ( java.lang.String , STRING ) ; return org.springframework.cassandra.core.Mono<org.springframework.cassandra.core.ReactiveResultSet> ( java.lang.String ) . map ( ReactiveResultSet :: wasApplied ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public < T > org.springframework.cassandra.core.Flux<T> < T > org.springframework.cassandra.core.Flux<T> ( java.lang.String java.lang.String , ReactiveResultSetExtractor < T > org.springframework.cassandra.core.ReactiveResultSetExtractor<T> ) throws org.springframework.cassandra.core.DataAccessException { Assert . hasText ( java.lang.String , STRING ) ; Assert . notNull ( org.springframework.cassandra.core.ReactiveResultSetExtractor<T> , STRING ) ; return org.springframework.cassandra.core.Flux ( new SimpleStatement ( java.lang.String ) , ( session , stmt ) -> { if ( logger . isDebugEnabled ( ) ) { logger . debug ( STRING , cql ) ; } return session . execute ( stmt ) . flatMap ( resultSetExtractor :: extractData ) ; } ) . onErrorResumeWith ( java.util.function.Function<java.lang.Throwable,org.springframework.cassandra.core.Mono<? extends java.lang.Object>> ( STRING , java.lang.String ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public < T > org.springframework.cassandra.core.Flux<T> < T > org.springframework.cassandra.core.Flux<T> ( java.lang.String java.lang.String , RowMapper < T > org.springframework.cassandra.core.RowMapper<T> ) throws org.springframework.cassandra.core.DataAccessException { return org.springframework.cassandra.core.Flux ( java.lang.String , new ReactiveRowMapperResultSetExtractor <> ( org.springframework.cassandra.core.RowMapper<T> ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public < T > org.springframework.cassandra.core.Mono<T> < T > org.springframework.cassandra.core.Mono<T> ( java.lang.String java.lang.String , RowMapper < T > org.springframework.cassandra.core.RowMapper<T> ) throws org.springframework.cassandra.core.DataAccessException { return org.springframework.cassandra.core.Flux ( java.lang.String , org.springframework.cassandra.core.RowMapper<T> ) . buffer ( NUMBER ) . flatMap ( list -> Mono . just ( DataAccessUtils . requiredSingleResult ( list ) ) ) . next ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public < T > org.springframework.cassandra.core.Mono<T> < T > org.springframework.cassandra.core.Mono<T> ( java.lang.String java.lang.String , java.lang.Class<T> < T > java.lang.Class<T> ) throws org.springframework.cassandra.core.DataAccessException { return org.springframework.cassandra.core.Mono<T> ( java.lang.String , org.springframework.cassandra.core.RowMapper<T> ( java.lang.Class<T> ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.cassandra.core.Mono<java.util.Map<java.lang.String,java.lang.Object>> < java.util.Map<java.lang.String,java.lang.Object> < java.lang.String , java.lang.Object > > org.springframework.cassandra.core.Mono<java.util.Map<java.lang.String,java.lang.Object>> ( java.lang.String java.lang.String ) throws org.springframework.cassandra.core.DataAccessException { return org.springframework.cassandra.core.Mono ( java.lang.String , org.springframework.cassandra.core.RowMapper<java.util.Map<java.lang.String,java.lang.Object>> ( ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public < T > org.springframework.cassandra.core.Flux<T> < T > org.springframework.cassandra.core.Flux<T> ( java.lang.String java.lang.String , java.lang.Class<T> < T > java.lang.Class<T> ) throws org.springframework.cassandra.core.DataAccessException { return org.springframework.cassandra.core.Flux<T> ( java.lang.String , org.springframework.cassandra.core.RowMapper<T> ( java.lang.Class<T> ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.cassandra.core.Flux<java.util.Map<java.lang.String,java.lang.Object>> < java.util.Map<java.lang.String,java.lang.Object> < java.lang.String , java.lang.Object > > org.springframework.cassandra.core.Flux<java.util.Map<java.lang.String,java.lang.Object>> ( java.lang.String java.lang.String ) throws org.springframework.cassandra.core.DataAccessException { return org.springframework.cassandra.core.Flux ( java.lang.String , org.springframework.cassandra.core.RowMapper<java.util.Map<java.lang.String,java.lang.Object>> ( ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.cassandra.core.Mono<org.springframework.cassandra.core.ReactiveResultSet> < ReactiveResultSet > org.springframework.cassandra.core.Mono<org.springframework.cassandra.core.ReactiveResultSet> ( java.lang.String java.lang.String ) throws org.springframework.cassandra.core.DataAccessException { Assert . hasText ( java.lang.String , STRING ) ; return org.springframework.cassandra.core.Mono ( new SimpleStatement ( java.lang.String ) , ( session , statement ) -> { if ( logger . isDebugEnabled ( ) ) { logger . debug ( STRING , cql ) ; } return session . execute ( statement ) ; } ) . otherwise ( java.util.function.Function<java.lang.Throwable,org.springframework.cassandra.core.Mono<? extends java.lang.Object>> ( STRING , java.lang.String ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.cassandra.core.Flux<org.springframework.cassandra.core.Row> < Row > org.springframework.cassandra.core.Flux<org.springframework.cassandra.core.Row> ( java.lang.String java.lang.String ) throws org.springframework.cassandra.core.DataAccessException { return org.springframework.cassandra.core.Mono<org.springframework.cassandra.core.ReactiveResultSet> ( java.lang.String ) . flatMap ( ReactiveResultSet :: rows ) . onErrorResumeWith ( java.util.function.Function<java.lang.Throwable,org.springframework.cassandra.core.Mono<? extends java.lang.Object>> ( STRING , java.lang.String ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.cassandra.core.Flux<java.lang.Boolean> < java.lang.Boolean > org.springframework.cassandra.core.Flux<java.lang.Boolean> ( Publisher < java.lang.String > org.springframework.cassandra.core.Publisher<java.lang.String> ) throws org.springframework.cassandra.core.DataAccessException { Assert . notNull ( org.springframework.cassandra.core.Publisher<java.lang.String> , STRING ) ; return Flux . from ( org.springframework.cassandra.core.Publisher<java.lang.String> ) . flatMap ( this :: execute ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.cassandra.core.Mono<java.lang.Boolean> < java.lang.Boolean > org.springframework.cassandra.core.Mono<java.lang.Boolean> ( Statement org.springframework.cassandra.core.Statement ) throws org.springframework.cassandra.core.DataAccessException { Assert . notNull ( org.springframework.cassandra.core.Statement , STRING ) ; return org.springframework.cassandra.core.Mono<org.springframework.cassandra.core.ReactiveResultSet> ( org.springframework.cassandra.core.Statement ) . map ( ReactiveResultSet :: wasApplied ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public < T > org.springframework.cassandra.core.Flux<T> < T > org.springframework.cassandra.core.Flux<T> ( Statement org.springframework.cassandra.core.Statement , ReactiveResultSetExtractor < T > org.springframework.cassandra.core.ReactiveResultSetExtractor<T> ) throws org.springframework.cassandra.core.DataAccessException { Assert . notNull ( org.springframework.cassandra.core.Statement , STRING ) ; Assert . notNull ( org.springframework.cassandra.core.ReactiveResultSetExtractor<T> , STRING ) ; return org.springframework.cassandra.core.Flux ( org.springframework.cassandra.core.Statement , ( session , stmt ) -> { if ( logger . isDebugEnabled ( ) ) { logger . debug ( STRING , statement ) ; } return session . execute ( stmt ) . flatMap ( rse :: extractData ) ; } ) . onErrorResumeWith ( java.util.function.Function ( STRING , org.springframework.cassandra.core.Statement . toString ( ) ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public < T > org.springframework.cassandra.core.Flux<T> < T > org.springframework.cassandra.core.Flux<T> ( Statement org.springframework.cassandra.core.Statement , RowMapper < T > org.springframework.cassandra.core.RowMapper<T> ) throws org.springframework.cassandra.core.DataAccessException { return org.springframework.cassandra.core.Flux<T> ( org.springframework.cassandra.core.Statement , new ReactiveRowMapperResultSetExtractor <> ( org.springframework.cassandra.core.RowMapper<T> ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public < T > org.springframework.cassandra.core.Mono<T> < T > org.springframework.cassandra.core.Mono<T> ( Statement org.springframework.cassandra.core.Statement , RowMapper < T > org.springframework.cassandra.core.RowMapper<T> ) throws org.springframework.cassandra.core.DataAccessException { return org.springframework.cassandra.core.Flux ( org.springframework.cassandra.core.Statement , org.springframework.cassandra.core.RowMapper<T> ) . buffer ( NUMBER ) . flatMap ( list -> Mono . just ( DataAccessUtils . requiredSingleResult ( list ) ) ) . next ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public < T > org.springframework.cassandra.core.Mono<T> < T > org.springframework.cassandra.core.Mono<T> ( Statement org.springframework.cassandra.core.Statement , java.lang.Class<T> < T > java.lang.Class<T> ) throws org.springframework.cassandra.core.DataAccessException { return org.springframework.cassandra.core.Mono ( org.springframework.cassandra.core.Statement , org.springframework.cassandra.core.RowMapper<T> ( java.lang.Class<T> ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.cassandra.core.Mono<java.util.Map<java.lang.String,java.lang.Object>> < java.util.Map<java.lang.String,java.lang.Object> < java.lang.String , java.lang.Object > > org.springframework.cassandra.core.Mono<java.util.Map<java.lang.String,java.lang.Object>> ( Statement org.springframework.cassandra.core.Statement ) throws org.springframework.cassandra.core.DataAccessException { return org.springframework.cassandra.core.Mono ( org.springframework.cassandra.core.Statement , org.springframework.cassandra.core.RowMapper<java.util.Map<java.lang.String,java.lang.Object>> ( ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public < T > org.springframework.cassandra.core.Flux<T> < T > org.springframework.cassandra.core.Flux<T> ( Statement org.springframework.cassandra.core.Statement , java.lang.Class<T> < T > java.lang.Class<T> ) throws org.springframework.cassandra.core.DataAccessException { return org.springframework.cassandra.core.Flux ( org.springframework.cassandra.core.Statement , org.springframework.cassandra.core.RowMapper<T> ( java.lang.Class<T> ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.cassandra.core.Flux<java.util.Map<java.lang.String,java.lang.Object>> < java.util.Map<java.lang.String,java.lang.Object> < java.lang.String , java.lang.Object > > org.springframework.cassandra.core.Flux<java.util.Map<java.lang.String,java.lang.Object>> ( Statement org.springframework.cassandra.core.Statement ) throws org.springframework.cassandra.core.DataAccessException { return org.springframework.cassandra.core.Flux ( org.springframework.cassandra.core.Statement , org.springframework.cassandra.core.RowMapper<java.util.Map<java.lang.String,java.lang.Object>> ( ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.cassandra.core.Mono<org.springframework.cassandra.core.ReactiveResultSet> < ReactiveResultSet > org.springframework.cassandra.core.Mono<org.springframework.cassandra.core.ReactiveResultSet> ( Statement org.springframework.cassandra.core.Statement ) throws org.springframework.cassandra.core.DataAccessException { Assert . notNull ( org.springframework.cassandra.core.Statement , STRING ) ; return org.springframework.cassandra.core.Mono ( org.springframework.cassandra.core.Statement , ( session , executedStatement ) -> { if ( logger . isDebugEnabled ( ) ) { logger . debug ( STRING , executedStatement ) ; } return session . execute ( executedStatement ) ; } ) . otherwise ( java.util.function.Function ( STRING , org.springframework.cassandra.core.Statement . toString ( ) ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.cassandra.core.Flux<org.springframework.cassandra.core.Row> < Row > org.springframework.cassandra.core.Flux<org.springframework.cassandra.core.Row> ( Statement org.springframework.cassandra.core.Statement ) throws org.springframework.cassandra.core.DataAccessException { return org.springframework.cassandra.core.Mono<org.springframework.cassandra.core.ReactiveResultSet> ( org.springframework.cassandra.core.Statement ) . flatMap ( ReactiveResultSet :: rows ) . onErrorResumeWith ( java.util.function.Function ( STRING , org.springframework.cassandra.core.Statement . toString ( ) ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public < T > org.springframework.cassandra.core.Flux<T> < T > org.springframework.cassandra.core.Flux<T> ( ReactivePreparedStatementCreator org.springframework.cassandra.core.ReactivePreparedStatementCreator , ReactivePreparedStatementCallback < T > org.springframework.cassandra.core.ReactivePreparedStatementCallback<T> )			throws org.springframework.cassandra.core.DataAccessException { Assert . notNull ( org.springframework.cassandra.core.ReactivePreparedStatementCreator , STRING ) ; Assert . notNull ( org.springframework.cassandra.core.ReactivePreparedStatementCallback<T> , STRING ) ; return org.springframework.cassandra.core.Flux<T> ( session -> { logger . debug ( STRING , getCql ( psc ) , psc ) ; return psc . createPreparedStatement ( session ) . doOnNext ( this :: applyStatementSettings ) . flatMap ( ps -> action . doInPreparedStatement ( session , ps ) ) ; } ) . onErrorResumeWith ( java.util.function.Function ( STRING , java.lang.String ( org.springframework.cassandra.core.ReactivePreparedStatementCreator ) ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public < T > org.springframework.cassandra.core.Flux<T> < T > org.springframework.cassandra.core.Flux<T> ( java.lang.String java.lang.String , ReactivePreparedStatementCallback < T > org.springframework.cassandra.core.ReactivePreparedStatementCallback<T> ) throws org.springframework.cassandra.core.DataAccessException { return org.springframework.cassandra.core.Flux ( new org.springframework.cassandra.core.ReactiveCqlTemplate.SimpleReactivePreparedStatementCreator ( java.lang.String ) , org.springframework.cassandra.core.ReactivePreparedStatementCallback<T> ) ; }  <METHOD_END>
<METHOD_START> public < T > org.springframework.cassandra.core.Flux<T> < T > org.springframework.cassandra.core.Flux<T> ( ReactivePreparedStatementCreator org.springframework.cassandra.core.ReactivePreparedStatementCreator , PreparedStatementBinder org.springframework.cassandra.core.PreparedStatementBinder , ReactiveResultSetExtractor < T > org.springframework.cassandra.core.ReactiveResultSetExtractor<T> ) throws org.springframework.cassandra.core.DataAccessException { Assert . notNull ( org.springframework.cassandra.core.ReactivePreparedStatementCreator , STRING ) ; Assert . notNull ( org.springframework.cassandra.core.ReactiveResultSetExtractor<T> , STRING ) ; return org.springframework.cassandra.core.Flux ( org.springframework.cassandra.core.ReactivePreparedStatementCreator , ( session , ps ) -> Mono . just ( ps ) . flatMap ( pps -> { if ( logger . isDebugEnabled ( ) ) { logger . debug ( STRING , ps . getQueryString ( ) ) ; } BoundStatement boundStatement = ( preparedStatementBinder != null ? preparedStatementBinder . bindValues ( ps ) : ps . bind ( ) ) ; applyStatementSettings ( boundStatement ) ; return session . execute ( boundStatement ) ; } ) . flatMap ( rse :: extractData ) ) . onErrorResumeWith ( java.util.function.Function ( STRING , java.lang.String ( org.springframework.cassandra.core.ReactivePreparedStatementCreator ) ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public < T > org.springframework.cassandra.core.Flux<T> < T > org.springframework.cassandra.core.Flux<T> ( ReactivePreparedStatementCreator org.springframework.cassandra.core.ReactivePreparedStatementCreator , ReactiveResultSetExtractor < T > org.springframework.cassandra.core.ReactiveResultSetExtractor<T> )			throws org.springframework.cassandra.core.DataAccessException { return org.springframework.cassandra.core.Flux ( org.springframework.cassandra.core.ReactivePreparedStatementCreator , null , org.springframework.cassandra.core.ReactiveResultSetExtractor<T> ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public < T > org.springframework.cassandra.core.Flux<T> < T > org.springframework.cassandra.core.Flux<T> ( java.lang.String java.lang.String , PreparedStatementBinder org.springframework.cassandra.core.PreparedStatementBinder , ReactiveResultSetExtractor < T > org.springframework.cassandra.core.ReactiveResultSetExtractor<T> )			throws org.springframework.cassandra.core.DataAccessException { return org.springframework.cassandra.core.Flux ( new org.springframework.cassandra.core.ReactiveCqlTemplate.SimpleReactivePreparedStatementCreator ( java.lang.String ) , org.springframework.cassandra.core.PreparedStatementBinder , org.springframework.cassandra.core.ReactiveResultSetExtractor<T> ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public < T > org.springframework.cassandra.core.Flux<T> < T > org.springframework.cassandra.core.Flux<T> ( java.lang.String java.lang.String , ReactiveResultSetExtractor < T > org.springframework.cassandra.core.ReactiveResultSetExtractor<T> , java.lang.Object ... java.lang.Object[] ) throws org.springframework.cassandra.core.DataAccessException { return org.springframework.cassandra.core.Flux ( new org.springframework.cassandra.core.ReactiveCqlTemplate.SimpleReactivePreparedStatementCreator ( java.lang.String ) , org.springframework.cassandra.core.PreparedStatementBinder ( java.lang.Object[] ) , org.springframework.cassandra.core.ReactiveResultSetExtractor<T> ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public < T > org.springframework.cassandra.core.Flux<T> < T > org.springframework.cassandra.core.Flux<T> ( ReactivePreparedStatementCreator org.springframework.cassandra.core.ReactivePreparedStatementCreator , RowMapper < T > org.springframework.cassandra.core.RowMapper<T> ) throws org.springframework.cassandra.core.DataAccessException { return org.springframework.cassandra.core.Flux ( org.springframework.cassandra.core.ReactivePreparedStatementCreator , null , new ReactiveRowMapperResultSetExtractor <> ( org.springframework.cassandra.core.RowMapper<T> ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public < T > org.springframework.cassandra.core.Flux<T> < T > org.springframework.cassandra.core.Flux<T> ( java.lang.String java.lang.String , PreparedStatementBinder org.springframework.cassandra.core.PreparedStatementBinder , RowMapper < T > org.springframework.cassandra.core.RowMapper<T> ) throws org.springframework.cassandra.core.DataAccessException { return org.springframework.cassandra.core.Flux<T> ( java.lang.String , org.springframework.cassandra.core.PreparedStatementBinder , new ReactiveRowMapperResultSetExtractor <> ( org.springframework.cassandra.core.RowMapper<T> ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public < T > org.springframework.cassandra.core.Flux<T> < T > org.springframework.cassandra.core.Flux<T> ( ReactivePreparedStatementCreator org.springframework.cassandra.core.ReactivePreparedStatementCreator , PreparedStatementBinder org.springframework.cassandra.core.PreparedStatementBinder , RowMapper < T > org.springframework.cassandra.core.RowMapper<T> )			throws org.springframework.cassandra.core.DataAccessException { return org.springframework.cassandra.core.Flux<T> ( org.springframework.cassandra.core.ReactivePreparedStatementCreator , org.springframework.cassandra.core.PreparedStatementBinder , new ReactiveRowMapperResultSetExtractor <> ( org.springframework.cassandra.core.RowMapper<T> ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public < T > org.springframework.cassandra.core.Flux<T> < T > org.springframework.cassandra.core.Flux<T> ( java.lang.String java.lang.String , RowMapper < T > org.springframework.cassandra.core.RowMapper<T> , java.lang.Object ... java.lang.Object[] ) throws org.springframework.cassandra.core.DataAccessException { return org.springframework.cassandra.core.Flux ( java.lang.String , org.springframework.cassandra.core.PreparedStatementBinder ( java.lang.Object[] ) , org.springframework.cassandra.core.RowMapper<T> ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public < T > org.springframework.cassandra.core.Mono<T> < T > org.springframework.cassandra.core.Mono<T> ( java.lang.String java.lang.String , RowMapper < T > org.springframework.cassandra.core.RowMapper<T> , java.lang.Object ... java.lang.Object[] ) throws org.springframework.cassandra.core.DataAccessException { return org.springframework.cassandra.core.Flux ( java.lang.String , org.springframework.cassandra.core.RowMapper<T> , java.lang.Object[] ) . buffer ( NUMBER ) . flatMap ( list -> Mono . just ( DataAccessUtils . requiredSingleResult ( list ) ) ) . next ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public < T > org.springframework.cassandra.core.Mono<T> < T > org.springframework.cassandra.core.Mono<T> ( java.lang.String java.lang.String , java.lang.Class<T> < T > java.lang.Class<T> , java.lang.Object ... java.lang.Object[] ) throws org.springframework.cassandra.core.DataAccessException { return org.springframework.cassandra.core.Mono<T> ( java.lang.String , org.springframework.cassandra.core.RowMapper<T> ( java.lang.Class<T> ) , java.lang.Object[] ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.cassandra.core.Mono<java.util.Map<java.lang.String,java.lang.Object>> < java.util.Map<java.lang.String,java.lang.Object> < java.lang.String , java.lang.Object > > org.springframework.cassandra.core.Mono<java.util.Map<java.lang.String,java.lang.Object>> ( java.lang.String java.lang.String , java.lang.Object ... java.lang.Object[] ) throws org.springframework.cassandra.core.DataAccessException { return org.springframework.cassandra.core.Mono ( java.lang.String , org.springframework.cassandra.core.RowMapper<java.util.Map<java.lang.String,java.lang.Object>> ( ) , java.lang.Object[] ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public < T > org.springframework.cassandra.core.Flux<T> < T > org.springframework.cassandra.core.Flux<T> ( java.lang.String java.lang.String , java.lang.Class<T> < T > java.lang.Class<T> , java.lang.Object ... java.lang.Object[] ) throws org.springframework.cassandra.core.DataAccessException { return org.springframework.cassandra.core.Flux<T> ( java.lang.String , org.springframework.cassandra.core.RowMapper<T> ( java.lang.Class<T> ) , java.lang.Object[] ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.cassandra.core.Flux<java.util.Map<java.lang.String,java.lang.Object>> < java.util.Map<java.lang.String,java.lang.Object> < java.lang.String , java.lang.Object > > org.springframework.cassandra.core.Flux<java.util.Map<java.lang.String,java.lang.Object>> ( java.lang.String java.lang.String , java.lang.Object ... java.lang.Object[] ) throws org.springframework.cassandra.core.DataAccessException { return org.springframework.cassandra.core.Flux ( java.lang.String , org.springframework.cassandra.core.RowMapper<java.util.Map<java.lang.String,java.lang.Object>> ( ) , java.lang.Object[] ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.cassandra.core.Mono<org.springframework.cassandra.core.ReactiveResultSet> < ReactiveResultSet > org.springframework.cassandra.core.Mono<org.springframework.cassandra.core.ReactiveResultSet> ( java.lang.String java.lang.String , java.lang.Object ... java.lang.Object[] ) throws org.springframework.cassandra.core.DataAccessException { Assert . hasText ( java.lang.String , STRING ) ; return org.springframework.cassandra.core.Flux ( new org.springframework.cassandra.core.ReactiveCqlTemplate.SimpleReactivePreparedStatementCreator ( java.lang.String ) , org.springframework.cassandra.core.PreparedStatementBinder ( java.lang.Object[] ) , Mono :: just ) . next ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.cassandra.core.Flux<org.springframework.cassandra.core.Row> < Row > org.springframework.cassandra.core.Flux<org.springframework.cassandra.core.Row> ( java.lang.String java.lang.String , java.lang.Object ... java.lang.Object[] ) throws org.springframework.cassandra.core.DataAccessException { return org.springframework.cassandra.core.Mono<org.springframework.cassandra.core.ReactiveResultSet> ( java.lang.String , java.lang.Object[] ) . flatMap ( ReactiveResultSet :: rows ) . onErrorResumeWith ( java.util.function.Function<java.lang.Throwable,org.springframework.cassandra.core.Mono<? extends java.lang.Object>> ( STRING , java.lang.String ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.cassandra.core.Mono<java.lang.Boolean> < java.lang.Boolean > org.springframework.cassandra.core.Mono<java.lang.Boolean> ( ReactivePreparedStatementCreator org.springframework.cassandra.core.ReactivePreparedStatementCreator ) throws org.springframework.cassandra.core.DataAccessException { return org.springframework.cassandra.core.Flux ( org.springframework.cassandra.core.ReactivePreparedStatementCreator , resultSet -> Mono . just ( resultSet . wasApplied ( ) ) ) . last ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.cassandra.core.Mono<java.lang.Boolean> < java.lang.Boolean > org.springframework.cassandra.core.Mono<java.lang.Boolean> ( java.lang.String java.lang.String , PreparedStatementBinder org.springframework.cassandra.core.PreparedStatementBinder ) throws org.springframework.cassandra.core.DataAccessException { return org.springframework.cassandra.core.Flux ( new org.springframework.cassandra.core.ReactiveCqlTemplate.SimpleReactivePreparedStatementCreator ( java.lang.String ) , org.springframework.cassandra.core.PreparedStatementBinder , resultSet -> Mono . just ( resultSet . wasApplied ( ) ) ) . next ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.cassandra.core.Mono<java.lang.Boolean> < java.lang.Boolean > org.springframework.cassandra.core.Mono<java.lang.Boolean> ( java.lang.String java.lang.String , java.lang.Object ... java.lang.Object[] ) throws org.springframework.cassandra.core.DataAccessException { return org.springframework.cassandra.core.Mono<java.lang.Boolean> ( java.lang.String , org.springframework.cassandra.core.PreparedStatementBinder ( java.lang.Object[] ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.cassandra.core.Flux<java.lang.Boolean> < java.lang.Boolean > org.springframework.cassandra.core.Flux<java.lang.Boolean> ( java.lang.String java.lang.String , Publisher < java.lang.Object [] > org.springframework.cassandra.core.Publisher<java.lang.Object[]> ) throws org.springframework.cassandra.core.DataAccessException { Assert . notNull ( org.springframework.cassandra.core.Publisher<java.lang.Object[]> , STRING ) ; org.springframework.cassandra.core.ReactiveCqlTemplate.SimpleReactivePreparedStatementCreator org.springframework.cassandra.core.ReactiveCqlTemplate.SimpleReactivePreparedStatementCreator = new org.springframework.cassandra.core.ReactiveCqlTemplate.SimpleReactivePreparedStatementCreator ( java.lang.String ) ; return org.springframework.cassandra.core.Flux<T> ( org.springframework.cassandra.core.ReactiveCqlTemplate.SimpleReactivePreparedStatementCreator , ( session , ps ) -> Flux . from ( args ) . flatMap ( objects -> { if ( logger . isDebugEnabled ( ) ) { logger . debug ( STRING , cql ) ; } BoundStatement boundStatement = newArgPreparedStatementBinder ( objects ) . bindValues ( ps ) ; applyStatementSettings ( boundStatement ) ; return session . execute ( boundStatement ) ; } ) . map ( ReactiveResultSet :: wasApplied ) ) ; }  <METHOD_END>
<METHOD_START> protected < T > org.springframework.cassandra.core.Flux<T> < T > org.springframework.cassandra.core.Flux<T> ( Statement org.springframework.cassandra.core.Statement , ReactiveStatementCallback < T > org.springframework.cassandra.core.ReactiveStatementCallback<T> ) { Assert . notNull ( org.springframework.cassandra.core.ReactiveStatementCallback<T> , STRING ) ; void ( org.springframework.cassandra.core.Statement ) ; ReactiveSession org.springframework.cassandra.core.ReactiveSession = org.springframework.cassandra.core.ReactiveSession ( ) ; return Flux . defer ( ( ) callback . doInStatement ( session , statement ) ) ; }  <METHOD_END>
<METHOD_START> protected < T > org.springframework.cassandra.core.Mono<T> < T > org.springframework.cassandra.core.Mono<T> ( Statement org.springframework.cassandra.core.Statement , ReactiveStatementCallback < T > org.springframework.cassandra.core.ReactiveStatementCallback<T> ) { Assert . notNull ( org.springframework.cassandra.core.ReactiveStatementCallback<T> , STRING ) ; void ( org.springframework.cassandra.core.Statement ) ; ReactiveSession org.springframework.cassandra.core.ReactiveSession = org.springframework.cassandra.core.ReactiveSession ( ) ; return Mono . defer ( ( ) Mono . from ( callback . doInStatement ( session , statement ) ) ) ; }  <METHOD_END>
<METHOD_START> protected < T > org.springframework.cassandra.core.Flux<T> < T > org.springframework.cassandra.core.Flux<T> ( ReactiveSessionCallback < T > org.springframework.cassandra.core.ReactiveSessionCallback<T> ) { Assert . notNull ( org.springframework.cassandra.core.ReactiveSessionCallback<T> , STRING ) ; ReactiveSession org.springframework.cassandra.core.ReactiveSession = org.springframework.cassandra.core.ReactiveSession ( ) ; return Flux . defer ( ( ) callback . doInSession ( session ) ) ; }  <METHOD_END>
<METHOD_START> protected < T > java.util.function.Function<java.lang.Throwable,org.springframework.cassandra.core.Mono<? extends T>> < java.lang.Throwable , Mono < ? extends T > > java.util.function.Function<java.lang.Throwable,org.springframework.cassandra.core.Mono<? extends T>> ( ) { return java.lang.Throwable -> Mono . error ( java.lang.Throwable instanceof DriverException ? translateExceptionIfPossible ( ( DriverException ) java.lang.Throwable ) : java.lang.Throwable ) ; }  <METHOD_END>
<METHOD_START> protected < T > java.util.function.Function<java.lang.Throwable,org.springframework.cassandra.core.Mono<? extends T>> < java.lang.Throwable , Mono < ? extends T > > java.util.function.Function<java.lang.Throwable,org.springframework.cassandra.core.Mono<? extends T>> ( java.lang.String java.lang.String , java.lang.String java.lang.String ) { return java.lang.Throwable -> Mono . error ( java.lang.Throwable instanceof DriverException ? translate ( java.lang.String , java.lang.String , ( DriverException ) java.lang.Throwable ) : java.lang.Throwable ) ; }  <METHOD_END>
<METHOD_START> protected org.springframework.cassandra.core.RowMapper<java.util.Map<java.lang.String,java.lang.Object>> < java.util.Map<java.lang.String,java.lang.Object> < java.lang.String , java.lang.Object > > org.springframework.cassandra.core.RowMapper<java.util.Map<java.lang.String,java.lang.Object>> ( ) { return new ColumnMapRowMapper ( ) ; }  <METHOD_END>
<METHOD_START> protected < T > org.springframework.cassandra.core.RowMapper<T> < T > org.springframework.cassandra.core.RowMapper<T> ( java.lang.Class<T> < T > java.lang.Class<T> ) { return SingleColumnRowMapper . newInstance ( java.lang.Class<T> ) ; }  <METHOD_END>
<METHOD_START> protected void void ( Statement org.springframework.cassandra.core.Statement ) { ConsistencyLevel org.springframework.cassandra.core.ConsistencyLevel = org.springframework.cassandra.core.ConsistencyLevel ( ) ; if ( org.springframework.cassandra.core.ConsistencyLevel != null && org.springframework.cassandra.core.Statement . getConsistencyLevel ( ) == org.springframework.cassandra.core.Statement . getConsistencyLevel ( ) ) { org.springframework.cassandra.core.Statement . setConsistencyLevel ( org.springframework.cassandra.core.ConsistencyLevel ) ; } int int = int ( ) ; if ( int != - NUMBER && org.springframework.cassandra.core.Statement . getFetchSize ( ) == org.springframework.cassandra.core.Statement . getFetchSize ( ) ) { org.springframework.cassandra.core.Statement . setFetchSize ( int ) ; } RetryPolicy org.springframework.cassandra.core.RetryPolicy = org.springframework.cassandra.core.RetryPolicy ( ) ; if ( org.springframework.cassandra.core.RetryPolicy != null && org.springframework.cassandra.core.Statement . getRetryPolicy ( ) == org.springframework.cassandra.core.Statement . getRetryPolicy ( ) ) { org.springframework.cassandra.core.Statement . setRetryPolicy ( org.springframework.cassandra.core.RetryPolicy ) ; } }  <METHOD_END>
<METHOD_START> protected void void ( PreparedStatement org.springframework.cassandra.core.PreparedStatement ) { ConsistencyLevel org.springframework.cassandra.core.ConsistencyLevel = org.springframework.cassandra.core.ConsistencyLevel ( ) ; if ( org.springframework.cassandra.core.ConsistencyLevel != null ) { org.springframework.cassandra.core.PreparedStatement . setConsistencyLevel ( org.springframework.cassandra.core.ConsistencyLevel ) ; } RetryPolicy org.springframework.cassandra.core.RetryPolicy = org.springframework.cassandra.core.RetryPolicy ( ) ; if ( org.springframework.cassandra.core.RetryPolicy != null ) { org.springframework.cassandra.core.PreparedStatement . setRetryPolicy ( org.springframework.cassandra.core.RetryPolicy ) ; } }  <METHOD_END>
<METHOD_START> protected org.springframework.cassandra.core.PreparedStatementBinder org.springframework.cassandra.core.PreparedStatementBinder ( java.lang.Object [] java.lang.Object[] ) { return new ArgumentPreparedStatementBinder ( java.lang.Object[] ) ; }  <METHOD_END>
<METHOD_START> private org.springframework.cassandra.core.ReactiveSession org.springframework.cassandra.core.ReactiveSession ( ) { return getSessionFactory ( ) . getSession ( ) ; }  <METHOD_END>
<METHOD_START> private static java.lang.String java.lang.String ( java.lang.Object java.lang.Object ) { return java.util.Optional . java.util.Optional<java.lang.Object> ( java.lang.Object ) . java.util.Optional<java.lang.Object> ( java.lang.Object -> java.lang.Object instanceof CqlProvider ) . java.util.Optional<java.lang.Object> ( java.lang.Object -> ( CqlProvider ) java.lang.Object ) . map ( CqlProvider :: getCql ) . orElse ( null ) ; }  <METHOD_END>
<METHOD_START> void ( java.lang.String java.lang.String ) { Assert . notNull ( java.lang.String , STRING ) ; this . java.lang.String = java.lang.String ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.cassandra.core.Mono<org.springframework.cassandra.core.PreparedStatement> < PreparedStatement > org.springframework.cassandra.core.Mono<org.springframework.cassandra.core.PreparedStatement> ( ReactiveSession org.springframework.cassandra.core.ReactiveSession ) throws org.springframework.cassandra.core.DriverException { return org.springframework.cassandra.core.ReactiveSession . prepare ( java.lang.String ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.String java.lang.String ( ) { return java.lang.String ; }  <METHOD_END>
