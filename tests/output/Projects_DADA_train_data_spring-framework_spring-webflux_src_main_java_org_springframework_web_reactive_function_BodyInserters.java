<METHOD_START> @ java.lang.SuppressWarnings ( STRING ) public static < T > org.springframework.web.reactive.function.BodyInserter<T,org.springframework.web.reactive.function.ReactiveHttpOutputMessage> < T , ReactiveHttpOutputMessage > org.springframework.web.reactive.function.BodyInserter<T,org.springframework.web.reactive.function.ReactiveHttpOutputMessage> ( ) { return ( BodyInserter < T , ReactiveHttpOutputMessage > ) org.springframework.web.reactive.function.BodyInserter<java.lang.Void,org.springframework.web.reactive.function.ReactiveHttpOutputMessage> ; }  <METHOD_END>
<METHOD_START> public static < T > org.springframework.web.reactive.function.BodyInserter<T,org.springframework.web.reactive.function.ReactiveHttpOutputMessage> < T , ReactiveHttpOutputMessage > org.springframework.web.reactive.function.BodyInserter<T,org.springframework.web.reactive.function.ReactiveHttpOutputMessage> ( T T ) { Assert . notNull ( T , STRING ) ; return org.springframework.web.reactive.function.BodyInserter ( Mono . just ( T ) , ResolvableType . forInstance ( T ) ) ; }  <METHOD_END>
<METHOD_START> public static < T , P extends org.springframework.web.reactive.function.Publisher<T> < T > > org.springframework.web.reactive.function.BodyInserter<P,org.springframework.web.reactive.function.ReactiveHttpOutputMessage> < P , ReactiveHttpOutputMessage > org.springframework.web.reactive.function.BodyInserter<P,org.springframework.web.reactive.function.ReactiveHttpOutputMessage> ( P P , java.lang.Class<T> < T > java.lang.Class<T> ) { Assert . notNull ( P , STRING ) ; Assert . notNull ( java.lang.Class<T> , STRING ) ; return org.springframework.web.reactive.function.BodyInserter ( P , ResolvableType . forClass ( java.lang.Class<T> ) ) ; }  <METHOD_END>
<METHOD_START> public static < T , P extends org.springframework.web.reactive.function.Publisher<T> < T > > org.springframework.web.reactive.function.BodyInserter<P,org.springframework.web.reactive.function.ReactiveHttpOutputMessage> < P , ReactiveHttpOutputMessage > org.springframework.web.reactive.function.BodyInserter<P,org.springframework.web.reactive.function.ReactiveHttpOutputMessage> ( P P , ResolvableType org.springframework.web.reactive.function.ResolvableType ) { Assert . notNull ( P , STRING ) ; Assert . notNull ( org.springframework.web.reactive.function.ResolvableType , STRING ) ; return org.springframework.web.reactive.function.BodyInserter ( P , org.springframework.web.reactive.function.ResolvableType ) ; }  <METHOD_END>
<METHOD_START> public static < T extends org.springframework.web.reactive.function.Resource > org.springframework.web.reactive.function.BodyInserter<T,org.springframework.web.reactive.function.ReactiveHttpOutputMessage> < T , ReactiveHttpOutputMessage > org.springframework.web.reactive.function.BodyInserter<T,org.springframework.web.reactive.function.ReactiveHttpOutputMessage> ( T T ) { Assert . notNull ( T , STRING ) ; return ( outputMessage , context ) -> { Mono < T > inputStream = Mono . just ( resource ) ; HttpMessageWriter < Resource > messageWriter = resourceHttpMessageWriter ( context ) ; Optional < ServerHttpRequest > serverRequest = context . serverRequest ( ) ; if ( serverRequest . isPresent ( ) && outputMessage instanceof ServerHttpResponse ) { return messageWriter . write ( inputStream , RESOURCE_TYPE , RESOURCE_TYPE , null , serverRequest . get ( ) , ( ServerHttpResponse ) outputMessage , context . hints ( ) ) ; } else { return messageWriter . write ( inputStream , RESOURCE_TYPE , null , outputMessage , context . hints ( ) ) ; } } ; }  <METHOD_END>
<METHOD_START> private static org.springframework.web.reactive.function.HttpMessageWriter<org.springframework.web.reactive.function.Resource> < Resource > org.springframework.web.reactive.function.HttpMessageWriter<org.springframework.web.reactive.function.Resource> ( BodyInserter . BodyInserter BodyInserter.Context ) { return BodyInserter.Context . messageWriters ( ) . get ( ) . filter ( messageWriter -> messageWriter . canWrite ( RESOURCE_TYPE , null ) ) . findFirst ( ) . map ( org.springframework.web.reactive.function.BodyInserters ::< Resource > org.springframework.web.reactive.function.HttpMessageWriter<org.springframework.web.reactive.function.Resource> ) . orElseThrow ( ( ) new IllegalStateException ( STRING ) ) ; }  <METHOD_END>
<METHOD_START> public static < T , S extends org.springframework.web.reactive.function.Publisher<org.springframework.web.reactive.function.ServerSentEvent<T>> < ServerSentEvent < T > > > org.springframework.web.reactive.function.BodyInserter<S,org.springframework.web.reactive.function.ServerHttpResponse> < S , ServerHttpResponse > org.springframework.web.reactive.function.BodyInserter<S,org.springframework.web.reactive.function.ServerHttpResponse> ( S S ) { Assert . notNull ( S , STRING ) ; return ( serverResponse , context ) -> { HttpMessageWriter < ServerSentEvent < T > > messageWriter = findMessageWriter ( context , SERVER_SIDE_EVENT_TYPE , MediaType . TEXT_EVENT_STREAM ) ; return context . serverRequest ( ) . map ( serverRequest -> messageWriter . write ( eventsPublisher , SERVER_SIDE_EVENT_TYPE , SERVER_SIDE_EVENT_TYPE , MediaType . TEXT_EVENT_STREAM , serverRequest , serverResponse , context . hints ( ) ) ) . orElseGet ( ( ) messageWriter . write ( eventsPublisher , SERVER_SIDE_EVENT_TYPE , MediaType . TEXT_EVENT_STREAM , serverResponse , context . hints ( ) ) ) ; } ; }  <METHOD_END>
<METHOD_START> public static < T , S extends org.springframework.web.reactive.function.Publisher<T> < T > > org.springframework.web.reactive.function.BodyInserter<S,org.springframework.web.reactive.function.ServerHttpResponse> < S , ServerHttpResponse > org.springframework.web.reactive.function.BodyInserter<S,org.springframework.web.reactive.function.ServerHttpResponse> ( S S , java.lang.Class<T> < T > java.lang.Class<T> ) { Assert . notNull ( S , STRING ) ; Assert . notNull ( java.lang.Class<T> , STRING ) ; return org.springframework.web.reactive.function.BodyInserter ( S , ResolvableType . forClass ( java.lang.Class<T> ) ) ; }  <METHOD_END>
<METHOD_START> public static < T , S extends org.springframework.web.reactive.function.Publisher<T> < T > > org.springframework.web.reactive.function.BodyInserter<S,org.springframework.web.reactive.function.ServerHttpResponse> < S , ServerHttpResponse > org.springframework.web.reactive.function.BodyInserter<S,org.springframework.web.reactive.function.ServerHttpResponse> ( S S , ResolvableType org.springframework.web.reactive.function.ResolvableType ) { Assert . notNull ( S , STRING ) ; Assert . notNull ( org.springframework.web.reactive.function.ResolvableType , STRING ) ; return ( serverResponse , context ) -> { HttpMessageWriter < T > messageWriter = findMessageWriter ( context , SERVER_SIDE_EVENT_TYPE , MediaType . TEXT_EVENT_STREAM ) ; return context . serverRequest ( ) . map ( serverRequest -> messageWriter . write ( eventsPublisher , eventType , eventType , MediaType . TEXT_EVENT_STREAM , serverRequest , serverResponse , context . hints ( ) ) ) . orElseGet ( ( ) messageWriter . write ( eventsPublisher , eventType , MediaType . TEXT_EVENT_STREAM , serverResponse , context . hints ( ) ) ) ; } ; }  <METHOD_END>
<METHOD_START> public static org.springframework.web.reactive.function.BodyInserter<org.springframework.web.reactive.function.MultiValueMap<java.lang.String,java.lang.String>,org.springframework.web.reactive.function.ClientHttpRequest> < MultiValueMap < java.lang.String , java.lang.String > , ClientHttpRequest > org.springframework.web.reactive.function.BodyInserter<org.springframework.web.reactive.function.MultiValueMap<java.lang.String,java.lang.String>,org.springframework.web.reactive.function.ClientHttpRequest> ( MultiValueMap < java.lang.String , java.lang.String > org.springframework.web.reactive.function.MultiValueMap<java.lang.String,java.lang.String> ) { Assert . notNull ( org.springframework.web.reactive.function.MultiValueMap<java.lang.String,java.lang.String> , STRING ) ; return ( outputMessage , context ) -> { HttpMessageWriter < MultiValueMap < String , String > > messageWriter = findMessageWriter ( context , FORM_TYPE , MediaType . APPLICATION_FORM_URLENCODED ) ; return messageWriter . write ( Mono . just ( formData ) , FORM_TYPE , MediaType . APPLICATION_FORM_URLENCODED , outputMessage , context . hints ( ) ) ; } ; }  <METHOD_END>
<METHOD_START> public static < T extends org.springframework.web.reactive.function.Publisher<org.springframework.web.reactive.function.DataBuffer> < DataBuffer > > org.springframework.web.reactive.function.BodyInserter<T,org.springframework.web.reactive.function.ReactiveHttpOutputMessage> < T , ReactiveHttpOutputMessage > org.springframework.web.reactive.function.BodyInserter<T,org.springframework.web.reactive.function.ReactiveHttpOutputMessage> ( T T ) { Assert . notNull ( T , STRING ) ; return ( outputMessage , context ) -> outputMessage . writeWith ( publisher ) ; }  <METHOD_END>
<METHOD_START> private static < T , P extends org.springframework.web.reactive.function.Publisher<?> < ? > , M extends org.springframework.web.reactive.function.ReactiveHttpOutputMessage > org.springframework.web.reactive.function.BodyInserter<T,M> < T , M > org.springframework.web.reactive.function.BodyInserter<T,M> ( P P , ResolvableType org.springframework.web.reactive.function.ResolvableType ) { return ( outputMessage , context ) -> { MediaType contentType = outputMessage . getHeaders ( ) . getContentType ( ) ; Supplier < Stream < HttpMessageWriter < ? > > > messageWriters = context . messageWriters ( ) ; return messageWriters . get ( ) . filter ( messageWriter -> messageWriter . canWrite ( bodyType , contentType ) ) . findFirst ( ) . map ( BodyInserters :: cast ) . map ( messageWriter -> { Optional < ServerHttpRequest > serverRequest = context . serverRequest ( ) ; if ( serverRequest . isPresent ( ) && outputMessage instanceof ServerHttpResponse ) { return messageWriter . write ( body , bodyType , bodyType , contentType , serverRequest . get ( ) , ( ServerHttpResponse ) outputMessage , context . hints ( ) ) ; } else { return messageWriter . write ( body , bodyType , contentType , outputMessage , context . hints ( ) ) ; } } ) . orElseGet ( ( ) { List < MediaType > supportedMediaTypes = messageWriters . get ( ) . flatMap ( reader -> reader . getWritableMediaTypes ( ) . stream ( ) ) . collect ( Collectors . toList ( ) ) ; UnsupportedMediaTypeException error = new UnsupportedMediaTypeException ( contentType , supportedMediaTypes ) ; return Mono . error ( error ) ; } ) ; } ; }  <METHOD_END>
<METHOD_START> private static < T > org.springframework.web.reactive.function.HttpMessageWriter<T> < T > org.springframework.web.reactive.function.HttpMessageWriter<T> ( BodyInserter . BodyInserter BodyInserter.Context , ResolvableType org.springframework.web.reactive.function.ResolvableType , MediaType org.springframework.web.reactive.function.MediaType ) { return BodyInserter.Context . messageWriters ( ) . get ( ) . filter ( messageWriter -> messageWriter . canWrite ( type , mediaType ) ) . findFirst ( ) . map ( org.springframework.web.reactive.function.BodyInserters ::< T > org.springframework.web.reactive.function.HttpMessageWriter<T> ) . orElseThrow ( ( ) new IllegalStateException ( STRING + mediaType ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.SuppressWarnings ( STRING ) private static < T > org.springframework.web.reactive.function.HttpMessageWriter<T> < T > org.springframework.web.reactive.function.HttpMessageWriter<T> ( HttpMessageWriter < ? > org.springframework.web.reactive.function.HttpMessageWriter<?> ) { return ( HttpMessageWriter < T > ) org.springframework.web.reactive.function.HttpMessageWriter<> ; }  <METHOD_END>
