<METHOD_START> @ Before public void void ( ) { Assume . group ( TestGroup . PERFORMANCE ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { AnnotationConfigApplicationContext org.springframework.scheduling.annotation.AnnotationConfigApplicationContext = new AnnotationConfigApplicationContext ( ) ; org.springframework.scheduling.annotation.AnnotationConfigApplicationContext . register ( org.springframework.scheduling.annotation.ScheduledAndTransactionalAnnotationIntegrationTests.Config .class , org.springframework.scheduling.annotation.ScheduledAndTransactionalAnnotationIntegrationTests.JdkProxyTxConfig .class , org.springframework.scheduling.annotation.ScheduledAndTransactionalAnnotationIntegrationTests.RepoConfigA .class ) ; try { org.springframework.scheduling.annotation.AnnotationConfigApplicationContext . refresh ( ) ; fail ( STRING ) ; } catch ( BeanCreationException org.springframework.scheduling.annotation.BeanCreationException ) { assertTrue ( org.springframework.scheduling.annotation.BeanCreationException . getRootCause ( ) instanceof java.lang.IllegalStateException ) ; } }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.InterruptedException { AnnotationConfigApplicationContext org.springframework.scheduling.annotation.AnnotationConfigApplicationContext = new AnnotationConfigApplicationContext ( ) ; org.springframework.scheduling.annotation.AnnotationConfigApplicationContext . register ( org.springframework.scheduling.annotation.ScheduledAndTransactionalAnnotationIntegrationTests.Config .class , org.springframework.scheduling.annotation.ScheduledAndTransactionalAnnotationIntegrationTests.SubclassProxyTxConfig .class , org.springframework.scheduling.annotation.ScheduledAndTransactionalAnnotationIntegrationTests.RepoConfigA .class ) ; org.springframework.scheduling.annotation.AnnotationConfigApplicationContext . refresh ( ) ; java.lang.Thread . void ( NUMBER ) ; org.springframework.scheduling.annotation.ScheduledAndTransactionalAnnotationIntegrationTests.MyRepository org.springframework.scheduling.annotation.ScheduledAndTransactionalAnnotationIntegrationTests.MyRepository = org.springframework.scheduling.annotation.AnnotationConfigApplicationContext . getBean ( org.springframework.scheduling.annotation.ScheduledAndTransactionalAnnotationIntegrationTests.MyRepository .class ) ; CallCountingTransactionManager org.springframework.scheduling.annotation.CallCountingTransactionManager = org.springframework.scheduling.annotation.AnnotationConfigApplicationContext . getBean ( CallCountingTransactionManager .class ) ; assertThat ( STRING , AopUtils . isCglibProxy ( org.springframework.scheduling.annotation.ScheduledAndTransactionalAnnotationIntegrationTests.MyRepository ) , equalTo ( true ) ) ; assertThat ( STRING , org.springframework.scheduling.annotation.ScheduledAndTransactionalAnnotationIntegrationTests.MyRepository . int ( ) , greaterThan ( NUMBER ) ) ; assertThat ( STRING , txManager . commits , greaterThan ( NUMBER ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.InterruptedException { AnnotationConfigApplicationContext org.springframework.scheduling.annotation.AnnotationConfigApplicationContext = new AnnotationConfigApplicationContext ( ) ; org.springframework.scheduling.annotation.AnnotationConfigApplicationContext . register ( org.springframework.scheduling.annotation.ScheduledAndTransactionalAnnotationIntegrationTests.Config .class , org.springframework.scheduling.annotation.ScheduledAndTransactionalAnnotationIntegrationTests.JdkProxyTxConfig .class , org.springframework.scheduling.annotation.ScheduledAndTransactionalAnnotationIntegrationTests.RepoConfigB .class ) ; org.springframework.scheduling.annotation.AnnotationConfigApplicationContext . refresh ( ) ; java.lang.Thread . void ( NUMBER ) ; org.springframework.scheduling.annotation.ScheduledAndTransactionalAnnotationIntegrationTests.MyRepositoryWithScheduledMethod org.springframework.scheduling.annotation.ScheduledAndTransactionalAnnotationIntegrationTests.MyRepositoryWithScheduledMethod = org.springframework.scheduling.annotation.AnnotationConfigApplicationContext . getBean ( org.springframework.scheduling.annotation.ScheduledAndTransactionalAnnotationIntegrationTests.MyRepositoryWithScheduledMethod .class ) ; CallCountingTransactionManager org.springframework.scheduling.annotation.CallCountingTransactionManager = org.springframework.scheduling.annotation.AnnotationConfigApplicationContext . getBean ( CallCountingTransactionManager .class ) ; assertThat ( STRING , AopUtils . isJdkDynamicProxy ( org.springframework.scheduling.annotation.ScheduledAndTransactionalAnnotationIntegrationTests.MyRepositoryWithScheduledMethod ) , is ( true ) ) ; assertThat ( STRING , org.springframework.scheduling.annotation.ScheduledAndTransactionalAnnotationIntegrationTests.MyRepositoryWithScheduledMethod . int ( ) , greaterThan ( NUMBER ) ) ; assertThat ( STRING , txManager . commits , greaterThan ( NUMBER ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.InterruptedException { AnnotationConfigApplicationContext org.springframework.scheduling.annotation.AnnotationConfigApplicationContext = new AnnotationConfigApplicationContext ( ) ; org.springframework.scheduling.annotation.AnnotationConfigApplicationContext . register ( org.springframework.scheduling.annotation.ScheduledAndTransactionalAnnotationIntegrationTests.AspectConfig .class , org.springframework.scheduling.annotation.ScheduledAndTransactionalAnnotationIntegrationTests.MyRepositoryWithScheduledMethodImpl .class ) ; org.springframework.scheduling.annotation.AnnotationConfigApplicationContext . refresh ( ) ; java.lang.Thread . void ( NUMBER ) ; org.springframework.scheduling.annotation.ScheduledAndTransactionalAnnotationIntegrationTests.MyRepositoryWithScheduledMethod org.springframework.scheduling.annotation.ScheduledAndTransactionalAnnotationIntegrationTests.MyRepositoryWithScheduledMethod = org.springframework.scheduling.annotation.AnnotationConfigApplicationContext . getBean ( org.springframework.scheduling.annotation.ScheduledAndTransactionalAnnotationIntegrationTests.MyRepositoryWithScheduledMethod .class ) ; assertThat ( STRING , AopUtils . isCglibProxy ( org.springframework.scheduling.annotation.ScheduledAndTransactionalAnnotationIntegrationTests.MyRepositoryWithScheduledMethod ) , is ( true ) ) ; assertThat ( STRING , org.springframework.scheduling.annotation.ScheduledAndTransactionalAnnotationIntegrationTests.MyRepositoryWithScheduledMethod . int ( ) , greaterThan ( NUMBER ) ) ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.scheduling.annotation.ScheduledAndTransactionalAnnotationIntegrationTests.MyRepository org.springframework.scheduling.annotation.ScheduledAndTransactionalAnnotationIntegrationTests.MyRepository ( ) { return new org.springframework.scheduling.annotation.ScheduledAndTransactionalAnnotationIntegrationTests.MyRepositoryImpl ( ) ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.scheduling.annotation.ScheduledAndTransactionalAnnotationIntegrationTests.MyRepositoryWithScheduledMethod org.springframework.scheduling.annotation.ScheduledAndTransactionalAnnotationIntegrationTests.MyRepositoryWithScheduledMethod ( ) { return new org.springframework.scheduling.annotation.ScheduledAndTransactionalAnnotationIntegrationTests.MyRepositoryWithScheduledMethodImpl ( ) ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.scheduling.annotation.PlatformTransactionManager org.springframework.scheduling.annotation.PlatformTransactionManager ( ) { return new CallCountingTransactionManager ( ) ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.scheduling.annotation.PersistenceExceptionTranslator org.springframework.scheduling.annotation.PersistenceExceptionTranslator ( ) { return mock ( PersistenceExceptionTranslator .class ) ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.scheduling.annotation.PersistenceExceptionTranslationPostProcessor org.springframework.scheduling.annotation.PersistenceExceptionTranslationPostProcessor ( ) { return new PersistenceExceptionTranslationPostProcessor ( ) ; }  <METHOD_END>
<METHOD_START> @ Bean public static org.springframework.scheduling.annotation.AnnotationAwareAspectJAutoProxyCreator org.springframework.scheduling.annotation.AnnotationAwareAspectJAutoProxyCreator ( ) { AnnotationAwareAspectJAutoProxyCreator org.springframework.scheduling.annotation.AnnotationAwareAspectJAutoProxyCreator = new AnnotationAwareAspectJAutoProxyCreator ( ) ; org.springframework.scheduling.annotation.AnnotationAwareAspectJAutoProxyCreator . setProxyTargetClass ( true ) ; return org.springframework.scheduling.annotation.AnnotationAwareAspectJAutoProxyCreator ; }  <METHOD_END>
<METHOD_START> @ Bean public static org.springframework.scheduling.annotation.ScheduledAndTransactionalAnnotationIntegrationTests.MyAspect org.springframework.scheduling.annotation.ScheduledAndTransactionalAnnotationIntegrationTests.MyAspect ( ) { return new org.springframework.scheduling.annotation.ScheduledAndTransactionalAnnotationIntegrationTests.MyAspect ( ) ; }  <METHOD_END>
<METHOD_START> @ org . org.aspectj . org.aspectj . org.aspectj . org.aspectj ( STRING ) public void void ( ) { this . java.util.concurrent.atomic.AtomicInteger . int ( ) ; }  <METHOD_END>
<METHOD_START> int int ( )  <METHOD_END>
<METHOD_START> @ Transactional @ Scheduled ( fixedDelay = NUMBER ) public void void ( ) { this . java.util.concurrent.atomic.AtomicInteger . int ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public int int ( ) { return this . java.util.concurrent.atomic.AtomicInteger . int ( ) ; }  <METHOD_END>
<METHOD_START> int int ( )  <METHOD_END>
<METHOD_START> void void ( )  <METHOD_END>
<METHOD_START> @ java.lang.Override @ Transactional @ Scheduled ( fixedDelay = NUMBER ) public void void ( ) { this . java.util.concurrent.atomic.AtomicInteger . int ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public int int ( ) { if ( this . org.springframework.scheduling.annotation.ScheduledAndTransactionalAnnotationIntegrationTests.MyAspect != null ) { assertEquals ( this . java.util.concurrent.atomic.AtomicInteger . int ( ) , this . org.springframework.scheduling.annotation.ScheduledAndTransactionalAnnotationIntegrationTests.MyAspect . java.util.concurrent.atomic.AtomicInteger . int ( ) ) ; } return this . java.util.concurrent.atomic.AtomicInteger . int ( ) ; }  <METHOD_END>
