<METHOD_START> @ java.lang.SuppressWarnings ( STRING ) public void ( java.lang.Class<? extends java.lang.annotation.Annotation> < ? extends java.lang.annotation.Annotation > ... java.lang.Class<? extends java.lang.annotation.Annotation>[] ) { this . java.util.Set<java.lang.Class<? extends java.lang.annotation.Annotation>> = new java.util.HashSet<java.lang.Class<? extends java.lang.annotation.Annotation>> < java.lang.Class<? extends java.lang.annotation.Annotation> < ? extends java.lang.annotation.Annotation > > ( java.util.Arrays . java.util.List<java.lang.Class<? extends java.lang.annotation.Annotation>> ( java.lang.Class<? extends java.lang.annotation.Annotation>[] ) ) ; PublisherMetadataSource org.springframework.integration.aop.PublisherMetadataSource = new MethodAnnotationPublisherMetadataSource ( this . java.util.Set<java.lang.Class<? extends java.lang.annotation.Annotation>> ) ; this . org.springframework.integration.aop.MessagePublishingInterceptor = new MessagePublishingInterceptor ( org.springframework.integration.aop.PublisherMetadataSource ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.SuppressWarnings ( STRING ) public void ( ) { this( Publisher .class ); }  <METHOD_END>
<METHOD_START> public void void ( java.lang.String java.lang.String ) { this . org.springframework.integration.aop.MessagePublishingInterceptor . setDefaultChannelName ( java.lang.String ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( BeanFactory org.springframework.integration.aop.BeanFactory ) { this . org.springframework.integration.aop.MessagePublishingInterceptor . setChannelResolver ( new BeanFactoryChannelResolver ( org.springframework.integration.aop.BeanFactory ) ) ; this . org.springframework.integration.aop.MessagePublishingInterceptor . setBeanFactory ( org.springframework.integration.aop.BeanFactory ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.integration.aop.Advice org.springframework.integration.aop.Advice ( ) { return this . org.springframework.integration.aop.MessagePublishingInterceptor ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.integration.aop.Pointcut org.springframework.integration.aop.Pointcut ( ) { return this . org.springframework.integration.aop.Pointcut ( ) ; }  <METHOD_END>
<METHOD_START> private org.springframework.integration.aop.Pointcut org.springframework.integration.aop.Pointcut ( ) { ComposablePointcut org.springframework.integration.aop.ComposablePointcut = null ; for ( java.lang.Class<? extends java.lang.annotation.Annotation> < ? extends java.lang.annotation.Annotation > java.lang.Class<? extends java.lang.annotation.Annotation> : this . java.util.Set<java.lang.Class<? extends java.lang.annotation.Annotation>> ) { Pointcut org.springframework.integration.aop.Pointcut = new org.springframework.integration.aop.PublisherAnnotationAdvisor.MetaAnnotationMatchingPointcut ( java.lang.Class<> , true ) ; Pointcut org.springframework.integration.aop.Pointcut = new org.springframework.integration.aop.PublisherAnnotationAdvisor.MetaAnnotationMatchingPointcut ( null , java.lang.Class<> ) ; if ( org.springframework.integration.aop.ComposablePointcut == null ) { org.springframework.integration.aop.ComposablePointcut = new ComposablePointcut ( org.springframework.integration.aop.Pointcut ) . union ( org.springframework.integration.aop.Pointcut ) ; } else { org.springframework.integration.aop.ComposablePointcut . union ( org.springframework.integration.aop.Pointcut ) . union ( org.springframework.integration.aop.Pointcut ) ; } } return org.springframework.integration.aop.ComposablePointcut ; }  <METHOD_END>
<METHOD_START> void ( java.lang.Class<? extends java.lang.annotation.Annotation> < ? extends java.lang.annotation.Annotation > java.lang.Class<? extends java.lang.annotation.Annotation> , boolean boolean ) { this . org.springframework.integration.aop.ClassFilter = new AnnotationClassFilter ( java.lang.Class<> , boolean ) ; this . org.springframework.integration.aop.MethodMatcher = MethodMatcher . TRUE ; }  <METHOD_END>
<METHOD_START> void ( java.lang.Class<? extends java.lang.annotation.Annotation> < ? extends java.lang.annotation.Annotation > java.lang.Class<? extends java.lang.annotation.Annotation> , java.lang.Class<? extends java.lang.annotation.Annotation> < ? extends java.lang.annotation.Annotation > java.lang.Class<? extends java.lang.annotation.Annotation> ) { Assert . isTrue ( ( java.lang.Class<> != null || java.lang.Class<> != null ) , STRING ) ; if ( java.lang.Class<> != null ) { this . org.springframework.integration.aop.ClassFilter = new AnnotationClassFilter ( java.lang.Class<> ) ; } else { this . org.springframework.integration.aop.ClassFilter = ClassFilter . TRUE ; } if ( java.lang.Class<> != null ) { this . org.springframework.integration.aop.MethodMatcher = new org.springframework.integration.aop.PublisherAnnotationAdvisor.MetaAnnotationMethodMatcher ( java.lang.Class<> ) ; } else { this . org.springframework.integration.aop.MethodMatcher = MethodMatcher . TRUE ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.integration.aop.ClassFilter org.springframework.integration.aop.ClassFilter ( ) { return this . org.springframework.integration.aop.ClassFilter ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.integration.aop.MethodMatcher org.springframework.integration.aop.MethodMatcher ( ) { return this . org.springframework.integration.aop.MethodMatcher ; }  <METHOD_END>
<METHOD_START> void ( java.lang.Class<? extends java.lang.annotation.Annotation> < ? extends java.lang.annotation.Annotation > java.lang.Class<? extends java.lang.annotation.Annotation> ) { super( java.lang.Class<> ); this . java.lang.Class<? extends java.lang.annotation.Annotation> = java.lang.Class<> ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override @ java.lang.SuppressWarnings ( STRING ) public boolean boolean ( java.lang.reflect.Method java.lang.reflect.Method , java.lang.Class java.lang.Class ) { if ( AnnotationUtils . getAnnotation ( java.lang.reflect.Method , this . java.lang.Class<> ) != null ) { return true ; } java.lang.reflect.Method java.lang.reflect.Method = AopUtils . getMostSpecificMethod ( java.lang.reflect.Method , java.lang.Class ) ; return ( java.lang.reflect.Method != java.lang.reflect.Method && ( AnnotationUtils . getAnnotation ( java.lang.reflect.Method , this . java.lang.Class<> ) != null ) ) ; }  <METHOD_END>
