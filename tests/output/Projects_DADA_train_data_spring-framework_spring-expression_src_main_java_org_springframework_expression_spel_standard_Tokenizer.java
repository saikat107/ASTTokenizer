<METHOD_START> public void ( java.lang.String java.lang.String ) { this . java.lang.String = java.lang.String ; this . char[] = ( java.lang.String + STRING ) . char[] ( ) ; this . int = this . char[] . int ; this . int = NUMBER ; void ( ) ; }  <METHOD_END>
<METHOD_START> public void void ( ) { while ( this . int < this . int ) { char char = this . char[] [ this . int ] ; if ( boolean ( char ) ) { void ( ) ; } else { switch ( char ) { case '+' : if ( boolean ( TokenKind . INC ) ) { void ( TokenKind . INC ) ; } else { void ( TokenKind . PLUS ) ; } break; case '_' : void ( ) ; break; case '-' : if ( boolean ( TokenKind . DEC ) ) { void ( TokenKind . DEC ) ; } else { void ( TokenKind . MINUS ) ; } break; case ':' : void ( TokenKind . COLON ) ; break; case '.' : void ( TokenKind . DOT ) ; break; case ',' : void ( TokenKind . COMMA ) ; break; case '*' : void ( TokenKind . STAR ) ; break; case '/' : void ( TokenKind . DIV ) ; break; case '%' : void ( TokenKind . MOD ) ; break; case '(' : void ( TokenKind . LPAREN ) ; break; case ')' : void ( TokenKind . RPAREN ) ; break; case '[' : void ( TokenKind . LSQUARE ) ; break; case '#' : void ( TokenKind . HASH ) ; break; case ']' : void ( TokenKind . RSQUARE ) ; break; case '{' : void ( TokenKind . LCURLY ) ; break; case '}' : void ( TokenKind . RCURLY ) ; break; case '@' : void ( TokenKind . BEAN_REF ) ; break; case '^' : if ( boolean ( TokenKind . SELECT_FIRST ) ) { void ( TokenKind . SELECT_FIRST ) ; } else { void ( TokenKind . POWER ) ; } break; case '!' : if ( boolean ( TokenKind . NE ) ) { void ( TokenKind . NE ) ; } else if ( boolean ( TokenKind . PROJECT ) ) { void ( TokenKind . PROJECT ) ; } else { void ( TokenKind . NOT ) ; } break; case '=' : if ( boolean ( TokenKind . EQ ) ) { void ( TokenKind . EQ ) ; } else { void ( TokenKind . ASSIGN ) ; } break; case '&' : if ( boolean ( TokenKind . SYMBOLIC_AND ) ) { void ( TokenKind . SYMBOLIC_AND ) ; } else { void ( TokenKind . FACTORY_BEAN_REF ) ; } break; case '|' : if ( ! boolean ( TokenKind . SYMBOLIC_OR ) ) { throw new InternalParseException ( new SpelParseException ( this . java.lang.String , this . int , SpelMessage . MISSING_CHARACTER , STRING ) ) ; } void ( TokenKind . SYMBOLIC_OR ) ; break; case '?' : if ( boolean ( TokenKind . SELECT ) ) { void ( TokenKind . SELECT ) ; } else if ( boolean ( TokenKind . ELVIS ) ) { void ( TokenKind . ELVIS ) ; } else if ( boolean ( TokenKind . SAFE_NAVI ) ) { void ( TokenKind . SAFE_NAVI ) ; } else { void ( TokenKind . QMARK ) ; } break; case '$' : if ( boolean ( TokenKind . SELECT_LAST ) ) { void ( TokenKind . SELECT_LAST ) ; } else { void ( ) ; } break; case '>' : if ( boolean ( TokenKind . GE ) ) { void ( TokenKind . GE ) ; } else { void ( TokenKind . GT ) ; } break; case '<' : if ( boolean ( TokenKind . LE ) ) { void ( TokenKind . LE ) ; } else { void ( TokenKind . LT ) ; } break; case '0' : case '1' : case '2' : case '3' : case '4' : case '5' : case '6' : case '7' : case '8' : case '9' : void ( char == '0' ) ; break; case ' ' : case '\t' : case '\r' : case '\n' : this . int ++ ; break; case '\'' : void ( ) ; break; case '"' : void ( ) ; break; case NUMBER : this . int ++ ; break; case '\\' : throw new InternalParseException ( new SpelParseException ( this . java.lang.String , this . int , SpelMessage . UNEXPECTED_ESCAPE_CHAR ) ) ; default: throw new java.lang.IllegalStateException ( STRING + java.lang.Integer . java.lang.Integer ( char ) + STRING + char + STRING ) ; } } } }  <METHOD_END>
<METHOD_START> public java.util.List<org.springframework.expression.spel.standard.Token> < Token > java.util.List<org.springframework.expression.spel.standard.Token> ( ) { return this . java.util.List<org.springframework.expression.spel.standard.Token> ; }  <METHOD_END>
<METHOD_START> private void void ( ) { int int = this . int ; boolean boolean = false ; while ( ! boolean ) { this . int ++ ; char char = this . char[] [ this . int ] ; if ( char == '\'' ) { if ( this . char[] [ this . int + NUMBER ] == '\'' ) { this . int ++ ; } else { boolean = true ; } } if ( char == NUMBER ) { throw new InternalParseException ( new SpelParseException ( this . java.lang.String , int , SpelMessage . NON_TERMINATING_QUOTED_STRING ) ) ; } } this . int ++ ; this . java.util.List<org.springframework.expression.spel.standard.Token> . add ( new Token ( TokenKind . LITERAL_STRING , char[] ( int , this . int ) , int , this . int ) ) ; }  <METHOD_END>
<METHOD_START> private void void ( ) { int int = this . int ; boolean boolean = false ; while ( ! boolean ) { this . int ++ ; char char = this . char[] [ this . int ] ; if ( char == '"' ) { if ( this . char[] [ this . int + NUMBER ] == '"' ) { this . int ++ ; } else { boolean = true ; } } if ( char == NUMBER ) { throw new InternalParseException ( new SpelParseException ( this . java.lang.String , int , SpelMessage . NON_TERMINATING_DOUBLE_QUOTED_STRING ) ) ; } } this . int ++ ; this . java.util.List<org.springframework.expression.spel.standard.Token> . add ( new Token ( TokenKind . LITERAL_STRING , char[] ( int , this . int ) , int , this . int ) ) ; }  <METHOD_END>
<METHOD_START> private void void ( boolean boolean ) { boolean boolean = false ; int int = this . int ; char char = this . char[] [ this . int + NUMBER ] ; boolean boolean = char == 'x' || char == 'X' ; if ( boolean && boolean ) { this . int = this . int + NUMBER ; do { this . int ++ ; } while ( boolean ( this . char[] [ this . int ] ) ); if ( boolean ( 'L' , 'l' ) ) { void ( char[] ( int + NUMBER , this . int ) , true , int , this . int ) ; this . int ++ ; } else { void ( char[] ( int + NUMBER , this . int ) , false , int , this . int ) ; } return; } do { this . int ++ ; } while ( boolean ( this . char[] [ this . int ] ) ); char = this . char[] [ this . int ] ; if ( char == '.' ) { boolean = true ; int int = this . int ; do { this . int ++ ; } while ( boolean ( this . char[] [ this . int ] ) ); if ( this . int == int + NUMBER ) { this . int = int ; void ( char[] ( int , this . int ) , false , int , this . int ) ; return; } } int int = this . int ; if ( boolean ( 'L' , 'l' ) ) { if ( boolean ) { throw new InternalParseException ( new SpelParseException ( this . java.lang.String , int , SpelMessage . REAL_CANNOT_BE_LONG ) ) ; } void ( char[] ( int , int ) , true , int , int ) ; this . int ++ ; } else if ( boolean ( this . char[] [ this . int ] ) ) { boolean = true ; this . int ++ ; char char = this . char[] [ this . int ] ; if ( boolean ( char ) ) { this . int ++ ; } do { this . int ++ ; } while ( boolean ( this . char[] [ this . int ] ) ); boolean boolean = false ; if ( boolean ( this . char[] [ this . int ] ) ) { boolean = true ; int = ++ this . int ; } else if ( boolean ( this . char[] [ this . int ] ) ) { int = ++ this . int ; } void ( char[] ( int , this . int ) , boolean , int , this . int ) ; } else { char = this . char[] [ this . int ] ; boolean boolean = false ; if ( boolean ( char ) ) { boolean = true ; boolean = true ; int = ++ this . int ; } else if ( boolean ( char ) ) { boolean = true ; int = ++ this . int ; } if ( boolean ) { void ( char[] ( int , int ) , boolean , int , int ) ; } else { void ( char[] ( int , int ) , false , int , int ) ; } } }  <METHOD_END>
<METHOD_START> private void void ( ) { int int = this . int ; do { this . int ++ ; } while ( boolean ( this . char[] [ this . int ] ) ); char [] char[] = char[] ( int , this . int ) ; if ( ( this . int - int ) == NUMBER || ( this . int - int ) == NUMBER ) { java.lang.String java.lang.String = new java.lang.String ( char[] ) . java.lang.String ( ) ; int int = java.util.Arrays . int ( java.lang.String[] , java.lang.String ) ; if ( int >= NUMBER ) { void ( TokenKind . valueOf ( java.lang.String ) , int , char[] ) ; return; } } this . java.util.List<org.springframework.expression.spel.standard.Token> . add ( new Token ( TokenKind . IDENTIFIER , char[] , int , this . int ) ) ; }  <METHOD_END>
<METHOD_START> private void void ( char [] char[] , boolean boolean , int int , int int ) { if ( boolean ) { this . java.util.List<org.springframework.expression.spel.standard.Token> . add ( new Token ( TokenKind . LITERAL_LONG , char[] , int , int ) ) ; } else { this . java.util.List<org.springframework.expression.spel.standard.Token> . add ( new Token ( TokenKind . LITERAL_INT , char[] , int , int ) ) ; } }  <METHOD_END>
<METHOD_START> private void void ( char [] char[] , boolean boolean , int int , int int ) { if ( char[] . int == NUMBER ) { if ( boolean ) { throw new InternalParseException ( new SpelParseException ( this . java.lang.String , int , SpelMessage . NOT_A_LONG , this . java.lang.String . java.lang.String ( int , int + NUMBER ) ) ) ; } else { throw new InternalParseException ( new SpelParseException ( this . java.lang.String , int , SpelMessage . NOT_AN_INTEGER , this . java.lang.String . java.lang.String ( int , int ) ) ) ; } } if ( boolean ) { this . java.util.List<org.springframework.expression.spel.standard.Token> . add ( new Token ( TokenKind . LITERAL_HEXLONG , char[] , int , int ) ) ; } else { this . java.util.List<org.springframework.expression.spel.standard.Token> . add ( new Token ( TokenKind . LITERAL_HEXINT , char[] , int , int ) ) ; } }  <METHOD_END>
<METHOD_START> private void void ( char [] char[] , boolean boolean , int int , int int ) { if ( boolean ) { this . java.util.List<org.springframework.expression.spel.standard.Token> . add ( new Token ( TokenKind . LITERAL_REAL_FLOAT , char[] , int , int ) ) ; } else { this . java.util.List<org.springframework.expression.spel.standard.Token> . add ( new Token ( TokenKind . LITERAL_REAL , char[] , int , int ) ) ; } }  <METHOD_END>
<METHOD_START> private char [] char[] ( int int , int int ) { char [] char[] = new char [ int - int ] ; java.lang.System . void ( this . char[] , int , char[] , NUMBER , int - int ) ; return char[] ; }  <METHOD_END>
<METHOD_START> private boolean boolean ( TokenKind org.springframework.expression.spel.standard.TokenKind ) { return ( kind . tokenChars . length == NUMBER && this . char[] [ this . int ] == kind . tokenChars [ NUMBER ] && this . char[] [ this . int + NUMBER ] == kind . tokenChars [ NUMBER ] ) ; }  <METHOD_END>
<METHOD_START> private void void ( TokenKind org.springframework.expression.spel.standard.TokenKind ) { this . java.util.List<org.springframework.expression.spel.standard.Token> . add ( new Token ( org.springframework.expression.spel.standard.TokenKind , this . int , this . int + NUMBER ) ) ; this . int ++ ; }  <METHOD_END>
<METHOD_START> private void void ( TokenKind org.springframework.expression.spel.standard.TokenKind ) { this . java.util.List<org.springframework.expression.spel.standard.Token> . add ( new Token ( org.springframework.expression.spel.standard.TokenKind , this . int , this . int + NUMBER ) ) ; this . int += NUMBER ; }  <METHOD_END>
<METHOD_START> private void void ( TokenKind org.springframework.expression.spel.standard.TokenKind , int int , char [] char[] ) { this . java.util.List<org.springframework.expression.spel.standard.Token> . add ( new Token ( org.springframework.expression.spel.standard.TokenKind , char[] , int , int + org.springframework.expression.spel.standard.TokenKind . getLength ( ) ) ) ; }  <METHOD_END>
<METHOD_START> private boolean boolean ( char char ) { return boolean ( char ) || boolean ( char ) || char == '_' || char == '$' ; }  <METHOD_END>
<METHOD_START> private boolean boolean ( char char , char char ) { char char = this . char[] [ this . int ] ; return char == char || char == char ; }  <METHOD_END>
<METHOD_START> private boolean boolean ( char char ) { return char == 'e' || char == 'E' ; }  <METHOD_END>
<METHOD_START> private boolean boolean ( char char ) { return char == 'f' || char == 'F' ; }  <METHOD_END>
<METHOD_START> private boolean boolean ( char char ) { return char == 'd' || char == 'D' ; }  <METHOD_END>
<METHOD_START> private boolean boolean ( char char ) { return char == '+' || char == '-' ; }  <METHOD_END>
<METHOD_START> private boolean boolean ( char char ) { if ( char > NUMBER ) { return false ; } return ( byte[] [ char ] & byte ) != NUMBER ; }  <METHOD_END>
<METHOD_START> private boolean boolean ( char char ) { if ( char > NUMBER ) { return false ; } return ( byte[] [ char ] & byte ) != NUMBER ; }  <METHOD_END>
<METHOD_START> private boolean boolean ( char char ) { if ( char > NUMBER ) { return false ; } return ( byte[] [ char ] & byte ) != NUMBER ; }  <METHOD_END>
