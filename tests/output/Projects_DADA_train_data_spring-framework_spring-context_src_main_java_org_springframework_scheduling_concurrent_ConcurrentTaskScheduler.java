<METHOD_START> public void ( ) { super(); void ( null ) ; }  <METHOD_END>
<METHOD_START> public void ( java.util.concurrent.ScheduledExecutorService java.util.concurrent.ScheduledExecutorService ) { super( java.util.concurrent.ScheduledExecutorService ); void ( java.util.concurrent.ScheduledExecutorService ) ; }  <METHOD_END>
<METHOD_START> public void ( java.util.concurrent.Executor java.util.concurrent.Executor , java.util.concurrent.ScheduledExecutorService java.util.concurrent.ScheduledExecutorService ) { super( java.util.concurrent.Executor ); void ( java.util.concurrent.ScheduledExecutorService ) ; }  <METHOD_END>
<METHOD_START> public final void void ( java.util.concurrent.ScheduledExecutorService java.util.concurrent.ScheduledExecutorService ) { if ( java.util.concurrent.ScheduledExecutorService != null ) { this . java.util.concurrent.ScheduledExecutorService = java.util.concurrent.ScheduledExecutorService ; this . boolean = ( java.lang.Class<> != null && java.lang.Class<> . boolean ( java.util.concurrent.ScheduledExecutorService ) ) ; } else { this . java.util.concurrent.ScheduledExecutorService = java.util.concurrent.Executors . java.util.concurrent.ScheduledExecutorService ( ) ; this . boolean = false ; } }  <METHOD_END>
<METHOD_START> public void void ( ErrorHandler org.springframework.scheduling.concurrent.ErrorHandler ) { Assert . notNull ( org.springframework.scheduling.concurrent.ErrorHandler , STRING ) ; this . org.springframework.scheduling.concurrent.ErrorHandler = org.springframework.scheduling.concurrent.ErrorHandler ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.util.concurrent.ScheduledFuture<?> < ? > java.util.concurrent.ScheduledFuture<?> ( java.lang.Runnable java.lang.Runnable , Trigger org.springframework.scheduling.concurrent.Trigger ) { try { if ( this . boolean ) { return new org.springframework.scheduling.concurrent.ConcurrentTaskScheduler.EnterpriseConcurrentTriggerScheduler ( ) . java.util.concurrent.ScheduledFuture<?> ( java.lang.Runnable ( java.lang.Runnable , true ) , org.springframework.scheduling.concurrent.Trigger ) ; } else { ErrorHandler org.springframework.scheduling.concurrent.ErrorHandler = ( this . org.springframework.scheduling.concurrent.ErrorHandler != null ? this . org.springframework.scheduling.concurrent.ErrorHandler : TaskUtils . getDefaultErrorHandler ( true ) ) ; return new ReschedulingRunnable ( java.lang.Runnable , org.springframework.scheduling.concurrent.Trigger , this . java.util.concurrent.ScheduledExecutorService , org.springframework.scheduling.concurrent.ErrorHandler ) . schedule ( ) ; } } catch ( java.util.concurrent.RejectedExecutionException java.util.concurrent.RejectedExecutionException ) { throw new TaskRejectedException ( STRING + this . java.util.concurrent.ScheduledExecutorService + STRING + java.lang.Runnable , java.util.concurrent.RejectedExecutionException ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.util.concurrent.ScheduledFuture<?> < ? > java.util.concurrent.ScheduledFuture<?> ( java.lang.Runnable java.lang.Runnable , java.util.Date java.util.Date ) { long long = java.util.Date . long ( ) - java.lang.System . long ( ) ; try { return this . java.util.concurrent.ScheduledExecutorService . java.util.concurrent.ScheduledFuture<?> ( java.lang.Runnable ( java.lang.Runnable , false ) , long , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ; } catch ( java.util.concurrent.RejectedExecutionException java.util.concurrent.RejectedExecutionException ) { throw new TaskRejectedException ( STRING + this . java.util.concurrent.ScheduledExecutorService + STRING + java.lang.Runnable , java.util.concurrent.RejectedExecutionException ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.util.concurrent.ScheduledFuture<?> < ? > java.util.concurrent.ScheduledFuture<?> ( java.lang.Runnable java.lang.Runnable , java.util.Date java.util.Date , long long ) { long long = java.util.Date . long ( ) - java.lang.System . long ( ) ; try { return this . java.util.concurrent.ScheduledExecutorService . java.util.concurrent.ScheduledFuture<?> ( java.lang.Runnable ( java.lang.Runnable , true ) , long , long , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ; } catch ( java.util.concurrent.RejectedExecutionException java.util.concurrent.RejectedExecutionException ) { throw new TaskRejectedException ( STRING + this . java.util.concurrent.ScheduledExecutorService + STRING + java.lang.Runnable , java.util.concurrent.RejectedExecutionException ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.util.concurrent.ScheduledFuture<?> < ? > java.util.concurrent.ScheduledFuture<?> ( java.lang.Runnable java.lang.Runnable , long long ) { try { return this . java.util.concurrent.ScheduledExecutorService . java.util.concurrent.ScheduledFuture<?> ( java.lang.Runnable ( java.lang.Runnable , true ) , NUMBER , long , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ; } catch ( java.util.concurrent.RejectedExecutionException java.util.concurrent.RejectedExecutionException ) { throw new TaskRejectedException ( STRING + this . java.util.concurrent.ScheduledExecutorService + STRING + java.lang.Runnable , java.util.concurrent.RejectedExecutionException ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.util.concurrent.ScheduledFuture<?> < ? > java.util.concurrent.ScheduledFuture<?> ( java.lang.Runnable java.lang.Runnable , java.util.Date java.util.Date , long long ) { long long = java.util.Date . long ( ) - java.lang.System . long ( ) ; try { return this . java.util.concurrent.ScheduledExecutorService . java.util.concurrent.ScheduledFuture<?> ( java.lang.Runnable ( java.lang.Runnable , true ) , long , long , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ; } catch ( java.util.concurrent.RejectedExecutionException java.util.concurrent.RejectedExecutionException ) { throw new TaskRejectedException ( STRING + this . java.util.concurrent.ScheduledExecutorService + STRING + java.lang.Runnable , java.util.concurrent.RejectedExecutionException ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.util.concurrent.ScheduledFuture<?> < ? > java.util.concurrent.ScheduledFuture<?> ( java.lang.Runnable java.lang.Runnable , long long ) { try { return this . java.util.concurrent.ScheduledExecutorService . java.util.concurrent.ScheduledFuture<?> ( java.lang.Runnable ( java.lang.Runnable , true ) , NUMBER , long , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ; } catch ( java.util.concurrent.RejectedExecutionException java.util.concurrent.RejectedExecutionException ) { throw new TaskRejectedException ( STRING + this . java.util.concurrent.ScheduledExecutorService + STRING + java.lang.Runnable , java.util.concurrent.RejectedExecutionException ) ; } }  <METHOD_END>
<METHOD_START> private java.lang.Runnable java.lang.Runnable ( java.lang.Runnable java.lang.Runnable , boolean boolean ) { java.lang.Runnable java.lang.Runnable = TaskUtils . decorateTaskWithErrorHandler ( java.lang.Runnable , this . org.springframework.scheduling.concurrent.ErrorHandler , boolean ) ; if ( this . boolean ) { java.lang.Runnable = ManagedTaskBuilder . buildManagedTask ( java.lang.Runnable , java.lang.Runnable . java.lang.String ( ) ) ; } return java.lang.Runnable ; }  <METHOD_END>
<METHOD_START> public java.util.concurrent.ScheduledFuture<?> < ? > java.util.concurrent.ScheduledFuture<?> ( java.lang.Runnable java.lang.Runnable , final Trigger org.springframework.scheduling.concurrent.Trigger ) { ManagedScheduledExecutorService org.springframework.scheduling.concurrent.ManagedScheduledExecutorService = ( ManagedScheduledExecutorService ) java.util.concurrent.ScheduledExecutorService ; return org.springframework.scheduling.concurrent.ManagedScheduledExecutorService . schedule ( java.lang.Runnable , new javax . javax.enterprise . javax.enterprise . javax.enterprise ( ) { @ java.lang.Override public java.util.Date java.util.Date ( LastExecution org.springframework.scheduling.concurrent.LastExecution , java.util.Date java.util.Date ) { return org.springframework.scheduling.concurrent.Trigger . nextExecutionTime ( org.springframework.scheduling.concurrent.LastExecution != null ? new SimpleTriggerContext ( org.springframework.scheduling.concurrent.LastExecution . getScheduledStart ( ) , org.springframework.scheduling.concurrent.LastExecution . getRunStart ( ) , org.springframework.scheduling.concurrent.LastExecution . getRunEnd ( ) ) : new SimpleTriggerContext ( ) ) ; } @ java.lang.Override public boolean boolean ( LastExecution org.springframework.scheduling.concurrent.LastExecution , java.util.Date java.util.Date ) { return false ; } } ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.util.Date java.util.Date ( LastExecution org.springframework.scheduling.concurrent.LastExecution , java.util.Date java.util.Date ) { return org.springframework.scheduling.concurrent.Trigger . nextExecutionTime ( org.springframework.scheduling.concurrent.LastExecution != null ? new SimpleTriggerContext ( org.springframework.scheduling.concurrent.LastExecution . getScheduledStart ( ) , org.springframework.scheduling.concurrent.LastExecution . getRunStart ( ) , org.springframework.scheduling.concurrent.LastExecution . getRunEnd ( ) ) : new SimpleTriggerContext ( ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( LastExecution org.springframework.scheduling.concurrent.LastExecution , java.util.Date java.util.Date ) { return false ; }  <METHOD_END>
