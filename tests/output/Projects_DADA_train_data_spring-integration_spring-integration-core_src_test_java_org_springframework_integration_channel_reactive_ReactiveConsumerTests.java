<METHOD_START> @ Test public void void ( ) java.lang.InterruptedException { ReactiveChannel org.springframework.integration.channel.reactive.ReactiveChannel = new ReactiveChannel ( EmitterProcessor . create ( false ) ) ; java.util.List<org.springframework.integration.channel.reactive.Message<?>> < Message < ? > > java.util.List<org.springframework.integration.channel.reactive.Message<?>> = new java.util.LinkedList<org.springframework.integration.channel.reactive.Message<?>> <> ( ) ; java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; MessageHandler org.springframework.integration.channel.reactive.MessageHandler = m -> { result . add ( m ) ; stopLatch . countDown ( ) ; } ; MessageHandler org.springframework.integration.channel.reactive.MessageHandler = new MethodInvokingMessageHandler ( org.springframework.integration.channel.reactive.MessageHandler , ( java.lang.String ) null ) ; ReactiveConsumer org.springframework.integration.channel.reactive.ReactiveConsumer = new ReactiveConsumer ( org.springframework.integration.channel.reactive.ReactiveChannel , org.springframework.integration.channel.reactive.MessageHandler ) ; org.springframework.integration.channel.reactive.ReactiveConsumer . setBeanFactory ( mock ( BeanFactory .class ) ) ; org.springframework.integration.channel.reactive.ReactiveConsumer . afterPropertiesSet ( ) ; org.springframework.integration.channel.reactive.ReactiveConsumer . start ( ) ; Message < ? > org.springframework.integration.channel.reactive.Message<?> = new GenericMessage <> ( STRING ) ; org.springframework.integration.channel.reactive.ReactiveChannel . send ( org.springframework.integration.channel.reactive.Message<> ) ; org.springframework.integration.channel.reactive.ReactiveConsumer . stop ( ) ; org.springframework.integration.channel.reactive.ReactiveChannel . send ( org.springframework.integration.channel.reactive.Message<> ) ; org.springframework.integration.channel.reactive.ReactiveConsumer . start ( ) ; Message < ? > org.springframework.integration.channel.reactive.Message<?> = new GenericMessage <> ( STRING ) ; org.springframework.integration.channel.reactive.ReactiveChannel . send ( org.springframework.integration.channel.reactive.Message<> ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; assertThat ( java.util.List<org.springframework.integration.channel.reactive.Message<?>> , Matchers .< Message < ? > > contains ( org.springframework.integration.channel.reactive.Message<> , org.springframework.integration.channel.reactive.Message<> ) ) ; }  <METHOD_END>
<METHOD_START> @ Test @ java.lang.SuppressWarnings ( STRING ) public void void ( ) java.lang.InterruptedException { DirectChannel org.springframework.integration.channel.reactive.DirectChannel = new DirectChannel ( ) ; Subscriber < Message < ? > > org.springframework.integration.channel.reactive.Subscriber<org.springframework.integration.channel.reactive.Message<?>> = ( Subscriber < Message < ? > > ) Mockito . mock ( Subscriber .class ) ; java.util.concurrent.BlockingQueue<org.springframework.integration.channel.reactive.Message<?>> < Message < ? > > java.util.concurrent.BlockingQueue<org.springframework.integration.channel.reactive.Message<?>> = new java.util.concurrent.LinkedBlockingQueue<org.springframework.integration.channel.reactive.Message<?>> <> ( ) ; willAnswer ( i -> { messages . put ( i . getArgument ( NUMBER ) ) ; return null ; } ) . given ( org.springframework.integration.channel.reactive.Subscriber<org.springframework.integration.channel.reactive.Message<?>> ) . onNext ( any ( Message .class ) ) ; ReactiveConsumer org.springframework.integration.channel.reactive.ReactiveConsumer = new ReactiveConsumer ( org.springframework.integration.channel.reactive.DirectChannel , org.springframework.integration.channel.reactive.Subscriber<org.springframework.integration.channel.reactive.Message<?>> ) ; org.springframework.integration.channel.reactive.ReactiveConsumer . setBeanFactory ( mock ( BeanFactory .class ) ) ; org.springframework.integration.channel.reactive.ReactiveConsumer . afterPropertiesSet ( ) ; org.springframework.integration.channel.reactive.ReactiveConsumer . start ( ) ; Message < ? > org.springframework.integration.channel.reactive.Message<?> = new GenericMessage <> ( STRING ) ; org.springframework.integration.channel.reactive.DirectChannel . send ( org.springframework.integration.channel.reactive.Message<> ) ; ArgumentCaptor < Subscription > org.springframework.integration.channel.reactive.ArgumentCaptor<org.springframework.integration.channel.reactive.Subscription> = ArgumentCaptor . forClass ( Subscription .class ) ; verify ( org.springframework.integration.channel.reactive.Subscriber<org.springframework.integration.channel.reactive.Message<?>> ) . onSubscribe ( org.springframework.integration.channel.reactive.ArgumentCaptor<org.springframework.integration.channel.reactive.Subscription> . capture ( ) ) ; Subscription org.springframework.integration.channel.reactive.Subscription = org.springframework.integration.channel.reactive.ArgumentCaptor<org.springframework.integration.channel.reactive.Subscription> . getValue ( ) ; org.springframework.integration.channel.reactive.Subscription . request ( NUMBER ) ; Message < ? > org.springframework.integration.channel.reactive.Message<?> = java.util.concurrent.BlockingQueue<org.springframework.integration.channel.reactive.Message<?>> . poll ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ; assertSame ( org.springframework.integration.channel.reactive.Message<> , org.springframework.integration.channel.reactive.Message<> ) ; org.springframework.integration.channel.reactive.ReactiveConsumer . stop ( ) ; try { org.springframework.integration.channel.reactive.DirectChannel . send ( org.springframework.integration.channel.reactive.Message<> ) ; fail ( STRING ) ; } catch ( java.lang.Exception java.lang.Exception ) { assertThat ( java.lang.Exception , instanceOf ( MessageDeliveryException .class ) ) ; } org.springframework.integration.channel.reactive.ReactiveConsumer . start ( ) ; org.springframework.integration.channel.reactive.Subscription . request ( NUMBER ) ; org.springframework.integration.channel.reactive.Message<?> = new GenericMessage <> ( STRING ) ; org.springframework.integration.channel.reactive.DirectChannel . send ( org.springframework.integration.channel.reactive.Message<> ) ; org.springframework.integration.channel.reactive.Message<?> = java.util.concurrent.BlockingQueue<org.springframework.integration.channel.reactive.Message<?>> . poll ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ; assertSame ( org.springframework.integration.channel.reactive.Message<> , org.springframework.integration.channel.reactive.Message<> ) ; verify ( org.springframework.integration.channel.reactive.Subscriber<org.springframework.integration.channel.reactive.Message<?>> , never ( ) ) . onError ( any ( java.lang.Throwable .class ) ) ; verify ( org.springframework.integration.channel.reactive.Subscriber<org.springframework.integration.channel.reactive.Message<?>> , never ( ) ) . onComplete ( ) ; assertTrue ( java.util.concurrent.BlockingQueue<org.springframework.integration.channel.reactive.Message<?>> . isEmpty ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test @ java.lang.SuppressWarnings ( STRING ) public void void ( ) java.lang.InterruptedException { QueueChannel org.springframework.integration.channel.reactive.QueueChannel = new QueueChannel ( ) ; Subscriber < Message < ? > > org.springframework.integration.channel.reactive.Subscriber<org.springframework.integration.channel.reactive.Message<?>> = ( Subscriber < Message < ? > > ) Mockito . mock ( Subscriber .class ) ; java.util.concurrent.BlockingQueue<org.springframework.integration.channel.reactive.Message<?>> < Message < ? > > java.util.concurrent.BlockingQueue<org.springframework.integration.channel.reactive.Message<?>> = new java.util.concurrent.LinkedBlockingQueue<org.springframework.integration.channel.reactive.Message<?>> <> ( ) ; willAnswer ( i -> { messages . put ( i . getArgument ( NUMBER ) ) ; return null ; } ) . given ( org.springframework.integration.channel.reactive.Subscriber<org.springframework.integration.channel.reactive.Message<?>> ) . onNext ( any ( Message .class ) ) ; ReactiveConsumer org.springframework.integration.channel.reactive.ReactiveConsumer = new ReactiveConsumer ( org.springframework.integration.channel.reactive.QueueChannel , org.springframework.integration.channel.reactive.Subscriber<org.springframework.integration.channel.reactive.Message<?>> ) ; org.springframework.integration.channel.reactive.ReactiveConsumer . setBeanFactory ( mock ( BeanFactory .class ) ) ; org.springframework.integration.channel.reactive.ReactiveConsumer . afterPropertiesSet ( ) ; org.springframework.integration.channel.reactive.ReactiveConsumer . start ( ) ; Message < ? > org.springframework.integration.channel.reactive.Message<?> = new GenericMessage <> ( STRING ) ; org.springframework.integration.channel.reactive.QueueChannel . send ( org.springframework.integration.channel.reactive.Message<> ) ; ArgumentCaptor < Subscription > org.springframework.integration.channel.reactive.ArgumentCaptor<org.springframework.integration.channel.reactive.Subscription> = ArgumentCaptor . forClass ( Subscription .class ) ; verify ( org.springframework.integration.channel.reactive.Subscriber<org.springframework.integration.channel.reactive.Message<?>> ) . onSubscribe ( org.springframework.integration.channel.reactive.ArgumentCaptor<org.springframework.integration.channel.reactive.Subscription> . capture ( ) ) ; Subscription org.springframework.integration.channel.reactive.Subscription = org.springframework.integration.channel.reactive.ArgumentCaptor<org.springframework.integration.channel.reactive.Subscription> . getValue ( ) ; org.springframework.integration.channel.reactive.Subscription . request ( NUMBER ) ; Message < ? > org.springframework.integration.channel.reactive.Message<?> = java.util.concurrent.BlockingQueue<org.springframework.integration.channel.reactive.Message<?>> . poll ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ; assertSame ( org.springframework.integration.channel.reactive.Message<> , org.springframework.integration.channel.reactive.Message<> ) ; org.springframework.integration.channel.reactive.ReactiveConsumer . stop ( ) ; org.springframework.integration.channel.reactive.QueueChannel . send ( org.springframework.integration.channel.reactive.Message<> ) ; org.springframework.integration.channel.reactive.ReactiveConsumer . start ( ) ; verify ( org.springframework.integration.channel.reactive.Subscriber<org.springframework.integration.channel.reactive.Message<?>> , times ( NUMBER ) ) . onSubscribe ( org.springframework.integration.channel.reactive.ArgumentCaptor<org.springframework.integration.channel.reactive.Subscription> . capture ( ) ) ; org.springframework.integration.channel.reactive.Subscription = org.springframework.integration.channel.reactive.ArgumentCaptor<org.springframework.integration.channel.reactive.Subscription> . getValue ( ) ; org.springframework.integration.channel.reactive.Subscription . request ( NUMBER ) ; Message < ? > org.springframework.integration.channel.reactive.Message<?> = new GenericMessage <> ( STRING ) ; org.springframework.integration.channel.reactive.QueueChannel . send ( org.springframework.integration.channel.reactive.Message<> ) ; org.springframework.integration.channel.reactive.Message<?> = java.util.concurrent.BlockingQueue<org.springframework.integration.channel.reactive.Message<?>> . poll ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ; assertSame ( org.springframework.integration.channel.reactive.Message<> , org.springframework.integration.channel.reactive.Message<> ) ; org.springframework.integration.channel.reactive.Message<?> = java.util.concurrent.BlockingQueue<org.springframework.integration.channel.reactive.Message<?>> . poll ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ; assertSame ( org.springframework.integration.channel.reactive.Message<> , org.springframework.integration.channel.reactive.Message<> ) ; verify ( org.springframework.integration.channel.reactive.Subscriber<org.springframework.integration.channel.reactive.Message<?>> , never ( ) ) . onError ( any ( java.lang.Throwable .class ) ) ; verify ( org.springframework.integration.channel.reactive.Subscriber<org.springframework.integration.channel.reactive.Message<?>> , never ( ) ) . onComplete ( ) ; assertTrue ( java.util.concurrent.BlockingQueue<org.springframework.integration.channel.reactive.Message<?>> . isEmpty ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { ReactiveChannel org.springframework.integration.channel.reactive.ReactiveChannel = new ReactiveChannel ( ) ; java.util.List<org.springframework.integration.channel.reactive.Message<?>> < Message < ? > > java.util.List<org.springframework.integration.channel.reactive.Message<?>> = new java.util.LinkedList<org.springframework.integration.channel.reactive.Message<?>> <> ( ) ; java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; MessageHandler org.springframework.integration.channel.reactive.MessageHandler = m -> { result . add ( m ) ; stopLatch . countDown ( ) ; } ; ConsumerEndpointFactoryBean org.springframework.integration.channel.reactive.ConsumerEndpointFactoryBean = new ConsumerEndpointFactoryBean ( ) ; org.springframework.integration.channel.reactive.ConsumerEndpointFactoryBean . setBeanFactory ( mock ( ConfigurableBeanFactory .class ) ) ; org.springframework.integration.channel.reactive.ConsumerEndpointFactoryBean . setInputChannel ( org.springframework.integration.channel.reactive.ReactiveChannel ) ; org.springframework.integration.channel.reactive.ConsumerEndpointFactoryBean . setHandler ( org.springframework.integration.channel.reactive.MessageHandler ) ; org.springframework.integration.channel.reactive.ConsumerEndpointFactoryBean . setBeanName ( STRING ) ; org.springframework.integration.channel.reactive.ConsumerEndpointFactoryBean . afterPropertiesSet ( ) ; org.springframework.integration.channel.reactive.ConsumerEndpointFactoryBean . start ( ) ; Message < ? > org.springframework.integration.channel.reactive.Message<?> = new GenericMessage <> ( STRING ) ; org.springframework.integration.channel.reactive.ReactiveChannel . send ( org.springframework.integration.channel.reactive.Message<> ) ; org.springframework.integration.channel.reactive.ConsumerEndpointFactoryBean . stop ( ) ; org.springframework.integration.channel.reactive.ReactiveChannel . send ( org.springframework.integration.channel.reactive.Message<> ) ; org.springframework.integration.channel.reactive.ConsumerEndpointFactoryBean . start ( ) ; Message < ? > org.springframework.integration.channel.reactive.Message<?> = new GenericMessage <> ( STRING ) ; org.springframework.integration.channel.reactive.ReactiveChannel . send ( org.springframework.integration.channel.reactive.Message<> ) ; org.springframework.integration.channel.reactive.ReactiveChannel . send ( org.springframework.integration.channel.reactive.Message<> ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; assertThat ( java.util.List<org.springframework.integration.channel.reactive.Message<?>> . size ( ) , equalTo ( NUMBER ) ) ; assertThat ( java.util.List<org.springframework.integration.channel.reactive.Message<?>> , Matchers .< Message < ? > > contains ( org.springframework.integration.channel.reactive.Message<> , org.springframework.integration.channel.reactive.Message<> , org.springframework.integration.channel.reactive.Message<> ) ) ; }  <METHOD_END>
