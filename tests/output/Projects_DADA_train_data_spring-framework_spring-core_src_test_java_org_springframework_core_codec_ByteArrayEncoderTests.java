<METHOD_START> @ Before public void void ( ) { this . org.springframework.core.codec.ByteArrayEncoder = new ByteArrayEncoder ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { assertTrue ( this . org.springframework.core.codec.ByteArrayEncoder . canEncode ( ResolvableType . forClass ( byte [] .class ) , MimeTypeUtils . TEXT_PLAIN ) ) ; assertFalse ( this . org.springframework.core.codec.ByteArrayEncoder . canEncode ( ResolvableType . forClass ( java.lang.Integer .class ) , MimeTypeUtils . TEXT_PLAIN ) ) ; assertTrue ( this . org.springframework.core.codec.ByteArrayEncoder . canEncode ( ResolvableType . forClass ( byte [] .class ) , MimeTypeUtils . APPLICATION_JSON ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { byte [] byte[] = STRING . byte[] ( java.nio.charset.StandardCharsets . java.nio.charset.Charset ) ; byte [] byte[] = STRING . byte[] ( java.nio.charset.StandardCharsets . java.nio.charset.Charset ) ; Flux < byte [] > org.springframework.core.codec.Flux<byte[]> = Flux . just ( byte[] , byte[] ) ; Flux < DataBuffer > org.springframework.core.codec.Flux<org.springframework.core.codec.DataBuffer> = this . org.springframework.core.codec.ByteArrayEncoder . encode ( org.springframework.core.codec.Flux<byte[]> , this . bufferFactory , ResolvableType . forClassWithGenerics ( Publisher .class , java.nio.ByteBuffer .class ) , null , java.util.Collections . java.util.Map<java.lang.Object,java.lang.Object> ( ) ) ; StepVerifier . create ( org.springframework.core.codec.Flux<org.springframework.core.codec.DataBuffer> ) . consumeNextWith ( b -> { byte [] buf = new byte [ NUMBER ] ; b . read ( buf ) ; assertArrayEquals ( fooBytes , buf ) ; } ) . consumeNextWith ( b -> { byte [] buf = new byte [ NUMBER ] ; b . read ( buf ) ; assertArrayEquals ( barBytes , buf ) ; } ) . expectComplete ( ) . verify ( ) ; }  <METHOD_END>
