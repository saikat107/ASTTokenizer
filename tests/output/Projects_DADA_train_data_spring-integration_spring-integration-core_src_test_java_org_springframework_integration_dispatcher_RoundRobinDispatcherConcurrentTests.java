<METHOD_START> @ Before public void void ( ) java.lang.Exception { org.springframework.integration.dispatcher.UnicastingDispatcher . setLoadBalancingStrategy ( new RoundRobinLoadBalancingStrategy ( ) ) ; org.springframework.integration.dispatcher.ThreadPoolTaskExecutor . setCorePoolSize ( NUMBER ) ; org.springframework.integration.dispatcher.ThreadPoolTaskExecutor . setMaxPoolSize ( NUMBER ) ; org.springframework.integration.dispatcher.ThreadPoolTaskExecutor . initialize ( ) ; }  <METHOD_END>
<METHOD_START> @ Test ( timeout = NUMBER ) public void void ( ) java.lang.Exception { org.springframework.integration.dispatcher.UnicastingDispatcher . addHandler ( org.springframework.integration.dispatcher.MessageHandler ) ; org.springframework.integration.dispatcher.UnicastingDispatcher . addHandler ( org.springframework.integration.dispatcher.MessageHandler ) ; org.springframework.integration.dispatcher.UnicastingDispatcher . addHandler ( org.springframework.integration.dispatcher.MessageHandler ) ; org.springframework.integration.dispatcher.UnicastingDispatcher . addHandler ( org.springframework.integration.dispatcher.MessageHandler ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( int ) ; final Message < ? > org.springframework.integration.dispatcher.Message<?> = this . org.springframework.integration.dispatcher.Message<> ; final java.util.concurrent.atomic.AtomicBoolean java.util.concurrent.atomic.AtomicBoolean = new java.util.concurrent.atomic.AtomicBoolean ( false ) ; java.lang.Runnable java.lang.Runnable = ( ) { try { java.util.concurrent.CountDownLatch . void ( ) ; } catch ( java.lang.InterruptedException java.lang.InterruptedException ) { java.lang.Thread . java.lang.Thread ( ) . void ( ) ; } if ( ! org.springframework.integration.dispatcher.UnicastingDispatcher . dispatch ( org.springframework.integration.dispatcher.Message<> ) ) { java.util.concurrent.atomic.AtomicBoolean . void ( true ) ; } java.util.concurrent.CountDownLatch . void ( ) ; } ; for ( int int = NUMBER ; int < int ; int ++ ) { org.springframework.integration.dispatcher.ThreadPoolTaskExecutor . execute ( java.lang.Runnable ) ; } java.util.concurrent.CountDownLatch . void ( ) ; java.util.concurrent.CountDownLatch . void ( ) ; assertFalse ( STRING , java.util.concurrent.atomic.AtomicBoolean . boolean ( ) ) ; verify ( org.springframework.integration.dispatcher.MessageHandler , times ( int / NUMBER ) ) . handleMessage ( org.springframework.integration.dispatcher.Message<> ) ; verify ( org.springframework.integration.dispatcher.MessageHandler , times ( int / NUMBER ) ) . handleMessage ( org.springframework.integration.dispatcher.Message<> ) ; verify ( org.springframework.integration.dispatcher.MessageHandler , times ( int / NUMBER ) ) . handleMessage ( org.springframework.integration.dispatcher.Message<> ) ; verify ( org.springframework.integration.dispatcher.MessageHandler , times ( int / NUMBER ) ) . handleMessage ( org.springframework.integration.dispatcher.Message<> ) ; }  <METHOD_END>
<METHOD_START> @ Test ( timeout = NUMBER ) public void void ( ) java.lang.Exception { final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( int ) ; final Message < ? > org.springframework.integration.dispatcher.Message<?> = this . org.springframework.integration.dispatcher.Message<> ; java.lang.Runnable java.lang.Runnable = ( ) { try { java.util.concurrent.CountDownLatch . void ( ) ; } catch ( java.lang.InterruptedException java.lang.InterruptedException ) { java.lang.Thread . java.lang.Thread ( ) . void ( ) ; } try { org.springframework.integration.dispatcher.UnicastingDispatcher . dispatch ( org.springframework.integration.dispatcher.Message<> ) ; fail ( STRING ) ; } catch ( MessagingException org.springframework.integration.dispatcher.MessagingException ) { } java.util.concurrent.CountDownLatch . void ( ) ; } ; for ( int int = NUMBER ; int < int ; int ++ ) { org.springframework.integration.dispatcher.ThreadPoolTaskExecutor . execute ( java.lang.Runnable ) ; } java.util.concurrent.CountDownLatch . void ( ) ; java.util.concurrent.CountDownLatch . void ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { org.springframework.integration.dispatcher.UnicastingDispatcher . addHandler ( org.springframework.integration.dispatcher.MessageHandler ) ; org.springframework.integration.dispatcher.UnicastingDispatcher . addHandler ( org.springframework.integration.dispatcher.MessageHandler ) ; doThrow ( new MessageRejectedException ( org.springframework.integration.dispatcher.Message<> , null ) ) . when ( org.springframework.integration.dispatcher.MessageHandler ) . handleMessage ( org.springframework.integration.dispatcher.Message<> ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( int ) ; final Message < ? > org.springframework.integration.dispatcher.Message<?> = this . org.springframework.integration.dispatcher.Message<> ; final java.util.concurrent.atomic.AtomicBoolean java.util.concurrent.atomic.AtomicBoolean = new java.util.concurrent.atomic.AtomicBoolean ( false ) ; java.lang.Runnable java.lang.Runnable = new java.lang.Runnable ( ) { @ java.lang.Override public void void ( ) { try { java.util.concurrent.CountDownLatch . void ( ) ; } catch ( java.lang.InterruptedException java.lang.InterruptedException ) { java.lang.Thread . java.lang.Thread ( ) . void ( ) ; } if ( ! org.springframework.integration.dispatcher.UnicastingDispatcher . dispatch ( org.springframework.integration.dispatcher.Message<> ) ) { java.util.concurrent.atomic.AtomicBoolean . void ( true ) ; } else { java.util.concurrent.CountDownLatch . void ( ) ; } } } ; for ( int int = NUMBER ; int < int ; int ++ ) { org.springframework.integration.dispatcher.ThreadPoolTaskExecutor . execute ( java.lang.Runnable ) ; } java.util.concurrent.CountDownLatch . void ( ) ; java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ; assertFalse ( STRING , java.util.concurrent.atomic.AtomicBoolean . boolean ( ) ) ; verify ( org.springframework.integration.dispatcher.MessageHandler , times ( int / NUMBER ) ) . handleMessage ( org.springframework.integration.dispatcher.Message<> ) ; verify ( org.springframework.integration.dispatcher.MessageHandler , times ( int ) ) . handleMessage ( org.springframework.integration.dispatcher.Message<> ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ) { try { java.util.concurrent.CountDownLatch . void ( ) ; } catch ( java.lang.InterruptedException java.lang.InterruptedException ) { java.lang.Thread . java.lang.Thread ( ) . void ( ) ; } if ( ! org.springframework.integration.dispatcher.UnicastingDispatcher . dispatch ( org.springframework.integration.dispatcher.Message<> ) ) { java.util.concurrent.atomic.AtomicBoolean . void ( true ) ; } else { java.util.concurrent.CountDownLatch . void ( ) ; } }  <METHOD_END>
