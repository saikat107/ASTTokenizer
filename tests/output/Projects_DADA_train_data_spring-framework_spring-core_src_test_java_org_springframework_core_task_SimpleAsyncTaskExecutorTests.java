<METHOD_START> @ Ignore ( STRING ) @ Test public void void ( ) java.lang.Exception { SimpleAsyncTaskExecutor org.springframework.core.task.SimpleAsyncTaskExecutor = new SimpleAsyncTaskExecutor ( ) ; org.springframework.core.task.SimpleAsyncTaskExecutor . setConcurrencyLimit ( ConcurrencyThrottleSupport . NO_CONCURRENCY ) ; assertFalse ( org.springframework.core.task.SimpleAsyncTaskExecutor . isThrottleActive ( ) ) ; org.springframework.core.task.ExpectedException . expect ( java.lang.IllegalStateException .class ) ; org.springframework.core.task.SimpleAsyncTaskExecutor . execute ( new org.springframework.core.task.SimpleAsyncTaskExecutorTests.NoOpRunnable ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { SimpleAsyncTaskExecutor org.springframework.core.task.SimpleAsyncTaskExecutor = new SimpleAsyncTaskExecutor ( ) ; assertFalse ( STRING , org.springframework.core.task.SimpleAsyncTaskExecutor . isThrottleActive ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final java.lang.String java.lang.String = STRING ; final java.lang.Object java.lang.Object = new java.lang.Object ( ) ; SimpleAsyncTaskExecutor org.springframework.core.task.SimpleAsyncTaskExecutor = new SimpleAsyncTaskExecutor ( java.lang.String ) ; org.springframework.core.task.SimpleAsyncTaskExecutorTests.ThreadNameHarvester org.springframework.core.task.SimpleAsyncTaskExecutorTests.ThreadNameHarvester = new org.springframework.core.task.SimpleAsyncTaskExecutorTests.ThreadNameHarvester ( java.lang.Object ) ; void ( org.springframework.core.task.SimpleAsyncTaskExecutor , org.springframework.core.task.SimpleAsyncTaskExecutorTests.ThreadNameHarvester , java.lang.Object ) ; assertThat ( org.springframework.core.task.SimpleAsyncTaskExecutorTests.ThreadNameHarvester . java.lang.String ( ) , startsWith ( java.lang.String ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final java.lang.Object java.lang.Object = new java.lang.Object ( ) ; SimpleAsyncTaskExecutor org.springframework.core.task.SimpleAsyncTaskExecutor = new SimpleAsyncTaskExecutor ( new java.util.concurrent.ThreadFactory ( ) { @ java.lang.Override public java.lang.Thread java.lang.Thread ( java.lang.Runnable java.lang.Runnable ) { return new java.lang.Thread ( java.lang.Runnable , STRING ) ; } } ) ; org.springframework.core.task.SimpleAsyncTaskExecutorTests.ThreadNameHarvester org.springframework.core.task.SimpleAsyncTaskExecutorTests.ThreadNameHarvester = new org.springframework.core.task.SimpleAsyncTaskExecutorTests.ThreadNameHarvester ( java.lang.Object ) ; void ( org.springframework.core.task.SimpleAsyncTaskExecutor , org.springframework.core.task.SimpleAsyncTaskExecutorTests.ThreadNameHarvester , java.lang.Object ) ; assertEquals ( STRING , org.springframework.core.task.SimpleAsyncTaskExecutorTests.ThreadNameHarvester . java.lang.String ( ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.Thread java.lang.Thread ( java.lang.Runnable java.lang.Runnable ) { return new java.lang.Thread ( java.lang.Runnable , STRING ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { org.springframework.core.task.ExpectedException . expect ( java.lang.IllegalArgumentException .class ) ; new SimpleAsyncTaskExecutor ( ) . execute ( null ) ; }  <METHOD_END>
<METHOD_START> private void void ( SimpleAsyncTaskExecutor org.springframework.core.task.SimpleAsyncTaskExecutor , java.lang.Runnable java.lang.Runnable , java.lang.Object java.lang.Object ) { synchronized ( java.lang.Object ) { org.springframework.core.task.SimpleAsyncTaskExecutor . execute ( java.lang.Runnable ) ; try { java.lang.Object . void ( ) ; } catch ( java.lang.InterruptedException java.lang.InterruptedException ) {			} } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ) { }  <METHOD_END>
<METHOD_START> protected void ( java.lang.Object java.lang.Object ) { this . java.lang.Object = java.lang.Object ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public final void void ( ) { synchronized ( this . java.lang.Object ) { try { void ( ) ; } finally { this . java.lang.Object . void ( ) ; } } }  <METHOD_END>
<METHOD_START> protected abstract void void ( )  <METHOD_END>
<METHOD_START> protected void ( java.lang.Object java.lang.Object ) { super( java.lang.Object ); }  <METHOD_END>
<METHOD_START> public java.lang.String java.lang.String ( ) { return this . java.lang.String ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( ) { this . java.lang.String = java.lang.Thread . java.lang.Thread ( ) . java.lang.String ( ) ; }  <METHOD_END>
