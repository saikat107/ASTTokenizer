<METHOD_START> @ Before public void void ( ) java.lang.Exception { assumeFalse ( this . server instanceof RxNettyHttpServer ) ; super. setup ( ) ; this . org.springframework.web.reactive.WebClient = WebClient . create ( STRING + this . port ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { Mono < java.lang.String > org.springframework.web.reactive.Mono<java.lang.String> = this . org.springframework.web.reactive.WebClient . get ( ) . uri ( STRING ) . exchange ( ) . flatMap ( response -> response . body ( BodyExtractors . toFlux ( String .class ) ) ) . takeUntil ( s -> s . endsWith ( STRING ) ) . reduce ( ( s1 , s2 ) -> s1 + s2 ) ; StepVerifier . create ( org.springframework.web.reactive.Mono<java.lang.String> ) . expectNext ( STRING ) . expectComplete ( ) . verify ( java.time.Duration . java.time.Duration ( NUMBER ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { Mono < java.lang.String > org.springframework.web.reactive.Mono<java.lang.String> = this . org.springframework.web.reactive.WebClient . get ( ) . uri ( STRING ) . exchange ( ) . flatMap ( response -> response . bodyToFlux ( String .class ) ) . reduce ( ( s1 , s2 ) -> s1 + s2 ) ; StepVerifier . create ( org.springframework.web.reactive.Mono<java.lang.String> ) . consumeNextWith ( value -> assertTrue ( value . length ( ) == NUMBER ) ) . expectComplete ( ) . verify ( java.time.Duration . java.time.Duration ( NUMBER ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { Flux < java.lang.String > org.springframework.web.reactive.Flux<java.lang.String> = this . org.springframework.web.reactive.WebClient . get ( ) . uri ( STRING ) . exchange ( ) . flatMap ( response -> response . bodyToFlux ( String .class ) ) ; StepVerifier . create ( org.springframework.web.reactive.Flux<java.lang.String> ) . expectNextMatches ( s -> s . startsWith ( STRING ) ) . thenCancel ( ) . verify ( java.time.Duration . java.time.Duration ( NUMBER ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected org.springframework.web.reactive.HttpHandler org.springframework.web.reactive.HttpHandler ( ) { return new org.springframework.web.reactive.FlushingIntegrationTests.FlushingHandler ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.web.reactive.Mono<java.lang.Void> < java.lang.Void > org.springframework.web.reactive.Mono<java.lang.Void> ( ServerHttpRequest org.springframework.web.reactive.ServerHttpRequest , ServerHttpResponse org.springframework.web.reactive.ServerHttpResponse ) { java.lang.String java.lang.String = org.springframework.web.reactive.ServerHttpRequest . getURI ( ) . getPath ( ) ; if ( java.lang.String . boolean ( STRING ) ) { Flux < Publisher < DataBuffer > > org.springframework.web.reactive.Flux<org.springframework.web.reactive.Publisher<org.springframework.web.reactive.DataBuffer>> = Flux . interval ( java.time.Duration . java.time.Duration ( NUMBER ) ) . map ( l -> toDataBuffer ( STRING + l , response . bufferFactory ( ) ) ) . take ( NUMBER ) . map ( Flux :: just ) ; org.springframework.web.reactive.Flux<org.springframework.web.reactive.Publisher<org.springframework.web.reactive.DataBuffer>> = org.springframework.web.reactive.Flux<org.springframework.web.reactive.Publisher<org.springframework.web.reactive.DataBuffer>> . concatWith ( Flux . never ( ) ) ; return org.springframework.web.reactive.ServerHttpResponse . writeAndFlushWith ( org.springframework.web.reactive.Flux<org.springframework.web.reactive.Publisher<org.springframework.web.reactive.DataBuffer>> ) ; } else if ( java.lang.String . boolean ( STRING ) ) { Flux < DataBuffer > org.springframework.web.reactive.Flux<org.springframework.web.reactive.DataBuffer> = Flux . just ( STRING ) . repeat ( NUMBER ) . map ( value -> toDataBuffer ( value , response . bufferFactory ( ) ) ) ; return org.springframework.web.reactive.ServerHttpResponse . writeWith ( org.springframework.web.reactive.Flux<org.springframework.web.reactive.DataBuffer> ) ; } else if ( java.lang.String . boolean ( STRING ) ) { Flux < DataBuffer > org.springframework.web.reactive.Flux<org.springframework.web.reactive.DataBuffer> = Flux . just ( STRING ) . repeat ( NUMBER ) . map ( value -> toDataBuffer ( value , response . bufferFactory ( ) ) ) . mergeWith ( Flux . never ( ) ) ; return org.springframework.web.reactive.ServerHttpResponse . writeWith ( org.springframework.web.reactive.Flux<org.springframework.web.reactive.DataBuffer> ) ; } return org.springframework.web.reactive.ServerHttpResponse . writeWith ( Flux . empty ( ) ) ; }  <METHOD_END>
<METHOD_START> private org.springframework.web.reactive.DataBuffer org.springframework.web.reactive.DataBuffer ( java.lang.String java.lang.String , DataBufferFactory org.springframework.web.reactive.DataBufferFactory ) { byte [] byte[] = ( java.lang.String ) . byte[] ( java.nio.charset.StandardCharsets . java.nio.charset.Charset ) ; DataBuffer org.springframework.web.reactive.DataBuffer = org.springframework.web.reactive.DataBufferFactory . allocateBuffer ( byte[] . int ) ; org.springframework.web.reactive.DataBuffer . write ( byte[] ) ; return org.springframework.web.reactive.DataBuffer ; }  <METHOD_END>
