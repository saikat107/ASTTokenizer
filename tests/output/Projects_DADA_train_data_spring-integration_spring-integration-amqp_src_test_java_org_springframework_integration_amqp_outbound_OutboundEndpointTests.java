<METHOD_START> @ Test public void void ( ) { ConnectionFactory org.springframework.integration.amqp.outbound.ConnectionFactory = mock ( ConnectionFactory .class ) ; RabbitTemplate org.springframework.integration.amqp.outbound.RabbitTemplate = spy ( new RabbitTemplate ( org.springframework.integration.amqp.outbound.ConnectionFactory ) ) ; AmqpOutboundEndpoint org.springframework.integration.amqp.outbound.AmqpOutboundEndpoint = new AmqpOutboundEndpoint ( org.springframework.integration.amqp.outbound.RabbitTemplate ) ; willDoNothing ( ) . given ( org.springframework.integration.amqp.outbound.RabbitTemplate ) . send ( anyString ( ) , anyString ( ) , any ( Message .class ) , isNull ( ) ) ; willAnswer ( invocation -> invocation . getArgument ( NUMBER ) ) . given ( org.springframework.integration.amqp.outbound.RabbitTemplate ) . sendAndReceive ( anyString ( ) , anyString ( ) , any ( Message .class ) , isNull ( ) ) ; org.springframework.integration.amqp.outbound.AmqpOutboundEndpoint . setExchangeName ( STRING ) ; org.springframework.integration.amqp.outbound.AmqpOutboundEndpoint . setRoutingKey ( STRING ) ; org.springframework.integration.amqp.outbound.AmqpOutboundEndpoint . setDelayExpressionString ( STRING ) ; org.springframework.integration.amqp.outbound.AmqpOutboundEndpoint . setBeanFactory ( mock ( BeanFactory .class ) ) ; org.springframework.integration.amqp.outbound.AmqpOutboundEndpoint . afterPropertiesSet ( ) ; org.springframework.integration.amqp.outbound.AmqpOutboundEndpoint . handleMessage ( new GenericMessage <> ( STRING ) ) ; ArgumentCaptor < Message > org.springframework.integration.amqp.outbound.ArgumentCaptor<org.springframework.integration.amqp.outbound.Message> = ArgumentCaptor . forClass ( Message .class ) ; verify ( org.springframework.integration.amqp.outbound.RabbitTemplate ) . send ( eq ( STRING ) , eq ( STRING ) , org.springframework.integration.amqp.outbound.ArgumentCaptor<org.springframework.integration.amqp.outbound.Message> . capture ( ) , isNull ( ) ) ; assertThat ( org.springframework.integration.amqp.outbound.ArgumentCaptor<org.springframework.integration.amqp.outbound.Message> . getValue ( ) . getMessageProperties ( ) . getDelay ( ) , equalTo ( NUMBER ) ) ; org.springframework.integration.amqp.outbound.AmqpOutboundEndpoint . setExpectReply ( true ) ; org.springframework.integration.amqp.outbound.AmqpOutboundEndpoint . setOutputChannel ( new NullChannel ( ) ) ; org.springframework.integration.amqp.outbound.AmqpOutboundEndpoint . handleMessage ( new GenericMessage <> ( STRING ) ) ; verify ( org.springframework.integration.amqp.outbound.RabbitTemplate ) . sendAndReceive ( eq ( STRING ) , eq ( STRING ) , org.springframework.integration.amqp.outbound.ArgumentCaptor<org.springframework.integration.amqp.outbound.Message> . capture ( ) , isNull ( ) ) ; assertThat ( org.springframework.integration.amqp.outbound.ArgumentCaptor<org.springframework.integration.amqp.outbound.Message> . getValue ( ) . getMessageProperties ( ) . getDelay ( ) , equalTo ( NUMBER ) ) ; org.springframework.integration.amqp.outbound.AmqpOutboundEndpoint . setDelay ( NUMBER ) ; org.springframework.integration.amqp.outbound.AmqpOutboundEndpoint . setRoutingKey ( STRING ) ; org.springframework.integration.amqp.outbound.AmqpOutboundEndpoint . afterPropertiesSet ( ) ; org.springframework.integration.amqp.outbound.AmqpOutboundEndpoint . handleMessage ( new GenericMessage <> ( STRING ) ) ; verify ( org.springframework.integration.amqp.outbound.RabbitTemplate ) . sendAndReceive ( eq ( STRING ) , eq ( STRING ) , org.springframework.integration.amqp.outbound.ArgumentCaptor<org.springframework.integration.amqp.outbound.Message> . capture ( ) , isNull ( ) ) ; assertThat ( org.springframework.integration.amqp.outbound.ArgumentCaptor<org.springframework.integration.amqp.outbound.Message> . getValue ( ) . getMessageProperties ( ) . getDelay ( ) , equalTo ( NUMBER ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { ConnectionFactory org.springframework.integration.amqp.outbound.ConnectionFactory = mock ( ConnectionFactory .class ) ; AsyncRabbitTemplate org.springframework.integration.amqp.outbound.AsyncRabbitTemplate = spy ( new AsyncRabbitTemplate ( new RabbitTemplate ( org.springframework.integration.amqp.outbound.ConnectionFactory ) , new SimpleMessageListenerContainer ( org.springframework.integration.amqp.outbound.ConnectionFactory ) , STRING ) ) ; org.springframework.integration.amqp.outbound.AsyncRabbitTemplate . setTaskScheduler ( mock ( TaskScheduler .class ) ) ; AsyncAmqpOutboundGateway org.springframework.integration.amqp.outbound.AsyncAmqpOutboundGateway = new AsyncAmqpOutboundGateway ( org.springframework.integration.amqp.outbound.AsyncRabbitTemplate ) ; willAnswer ( invocation -> amqpTemplate .new RabbitMessageFuture ( STRING , invocation . getArgument ( NUMBER ) ) ) . given ( org.springframework.integration.amqp.outbound.AsyncRabbitTemplate ) . sendAndReceive ( anyString ( ) , anyString ( ) , any ( Message .class ) ) ; org.springframework.integration.amqp.outbound.AsyncAmqpOutboundGateway . setExchangeName ( STRING ) ; org.springframework.integration.amqp.outbound.AsyncAmqpOutboundGateway . setRoutingKey ( STRING ) ; org.springframework.integration.amqp.outbound.AsyncAmqpOutboundGateway . setDelayExpressionString ( STRING ) ; org.springframework.integration.amqp.outbound.AsyncAmqpOutboundGateway . setBeanFactory ( mock ( BeanFactory .class ) ) ; org.springframework.integration.amqp.outbound.AsyncAmqpOutboundGateway . setOutputChannel ( new NullChannel ( ) ) ; org.springframework.integration.amqp.outbound.AsyncAmqpOutboundGateway . afterPropertiesSet ( ) ; org.springframework.integration.amqp.outbound.AsyncAmqpOutboundGateway . start ( ) ; ArgumentCaptor < Message > org.springframework.integration.amqp.outbound.ArgumentCaptor<org.springframework.integration.amqp.outbound.Message> = ArgumentCaptor . forClass ( Message .class ) ; org.springframework.integration.amqp.outbound.AsyncAmqpOutboundGateway . handleMessage ( new GenericMessage <> ( STRING ) ) ; verify ( org.springframework.integration.amqp.outbound.AsyncRabbitTemplate ) . sendAndReceive ( eq ( STRING ) , eq ( STRING ) , org.springframework.integration.amqp.outbound.ArgumentCaptor<org.springframework.integration.amqp.outbound.Message> . capture ( ) ) ; assertThat ( org.springframework.integration.amqp.outbound.ArgumentCaptor<org.springframework.integration.amqp.outbound.Message> . getValue ( ) . getMessageProperties ( ) . getDelay ( ) , equalTo ( NUMBER ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { ConnectionFactory org.springframework.integration.amqp.outbound.ConnectionFactory = mock ( ConnectionFactory .class ) ; RabbitTemplate org.springframework.integration.amqp.outbound.RabbitTemplate = spy ( new RabbitTemplate ( org.springframework.integration.amqp.outbound.ConnectionFactory ) ) ; AmqpOutboundEndpoint org.springframework.integration.amqp.outbound.AmqpOutboundEndpoint = new AmqpOutboundEndpoint ( org.springframework.integration.amqp.outbound.RabbitTemplate ) ; org.springframework.integration.amqp.outbound.AmqpOutboundEndpoint . setHeadersMappedLast ( true ) ; final java.util.concurrent.atomic.AtomicReference<org.springframework.integration.amqp.outbound.Message> < Message > java.util.concurrent.atomic.AtomicReference<org.springframework.integration.amqp.outbound.Message> = new java.util.concurrent.atomic.AtomicReference<org.springframework.integration.amqp.outbound.Message> < Message > ( ) ; willAnswer ( invocation -> { amqpMessage . set ( invocation . getArgument ( NUMBER ) ) ; return null ; } ) . given ( org.springframework.integration.amqp.outbound.RabbitTemplate ) . send ( isNull ( ) , isNull ( ) , any ( Message .class ) , isNull ( ) ) ; org . springframework . org.springframework.messaging . org.springframework.messaging < ? > message = MessageBuilder . withPayload ( STRING ) . setHeader ( MessageHeaders . CONTENT_TYPE , STRING ) . build ( ) ; org.springframework.integration.amqp.outbound.AmqpOutboundEndpoint . handleMessage ( message ) ; assertNotNull ( java.util.concurrent.atomic.AtomicReference<org.springframework.integration.amqp.outbound.Message> . get ( ) ) ; assertEquals ( STRING , java.util.concurrent.atomic.AtomicReference<org.springframework.integration.amqp.outbound.Message> . get ( ) . getMessageProperties ( ) . getContentType ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { ConnectionFactory org.springframework.integration.amqp.outbound.ConnectionFactory = mock ( ConnectionFactory .class ) ; org.springframework.integration.amqp.outbound.OutboundEndpointTests.TestRabbitTemplate org.springframework.integration.amqp.outbound.OutboundEndpointTests.TestRabbitTemplate = spy ( new org.springframework.integration.amqp.outbound.OutboundEndpointTests.TestRabbitTemplate ( org.springframework.integration.amqp.outbound.ConnectionFactory ) ) ; AmqpOutboundEndpoint org.springframework.integration.amqp.outbound.AmqpOutboundEndpoint = new AmqpOutboundEndpoint ( org.springframework.integration.amqp.outbound.OutboundEndpointTests.TestRabbitTemplate ) ; org.springframework.integration.amqp.outbound.AmqpOutboundEndpoint . setHeadersMappedLast ( true ) ; org.springframework.integration.amqp.outbound.AmqpOutboundEndpoint . setExpectReply ( true ) ; DefaultAmqpHeaderMapper org.springframework.integration.amqp.outbound.DefaultAmqpHeaderMapper = DefaultAmqpHeaderMapper . inboundMapper ( ) ; org.springframework.integration.amqp.outbound.DefaultAmqpHeaderMapper . setRequestHeaderNames ( STRING ) ; org.springframework.integration.amqp.outbound.AmqpOutboundEndpoint . setHeaderMapper ( org.springframework.integration.amqp.outbound.DefaultAmqpHeaderMapper ) ; final java.util.concurrent.atomic.AtomicReference<org.springframework.integration.amqp.outbound.Message> < Message > java.util.concurrent.atomic.AtomicReference<org.springframework.integration.amqp.outbound.Message> = new java.util.concurrent.atomic.AtomicReference<org.springframework.integration.amqp.outbound.Message> < Message > ( ) ; willAnswer ( invocation -> { amqpMessage . set ( invocation . getArgument ( NUMBER ) ) ; return null ; } ) . given ( org.springframework.integration.amqp.outbound.OutboundEndpointTests.TestRabbitTemplate ) . doSendAndReceiveWithTemporary ( isNull ( ) , isNull ( ) , any ( Message .class ) , isNull ( ) ) ; org . springframework . org.springframework.messaging . org.springframework.messaging < ? > message = MessageBuilder . withPayload ( STRING ) . setHeader ( MessageHeaders . CONTENT_TYPE , STRING ) . setReplyChannel ( new QueueChannel ( ) ) . build ( ) ; org.springframework.integration.amqp.outbound.AmqpOutboundEndpoint . handleMessage ( message ) ; assertNotNull ( java.util.concurrent.atomic.AtomicReference<org.springframework.integration.amqp.outbound.Message> . get ( ) ) ; assertEquals ( STRING , java.util.concurrent.atomic.AtomicReference<org.springframework.integration.amqp.outbound.Message> . get ( ) . getMessageProperties ( ) . getContentType ( ) ) ; assertNull ( java.util.concurrent.atomic.AtomicReference<org.springframework.integration.amqp.outbound.Message> . get ( ) . getMessageProperties ( ) . getHeaders ( ) . get ( MessageHeaders . REPLY_CHANNEL ) ) ; }  <METHOD_END>
<METHOD_START> private void ( ConnectionFactory org.springframework.integration.amqp.outbound.ConnectionFactory ) { super( org.springframework.integration.amqp.outbound.ConnectionFactory ); }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org . springframework . org.springframework.amqp . org.springframework.amqp . org.springframework.amqp.core.Message org.springframework.amqp.core.Message ( java.lang.String java.lang.String , java.lang.String java.lang.String , org . springframework . org.springframework.amqp . org.springframework.amqp . org.springframework.amqp org.springframework.amqp.core.Message , CorrelationData org.springframework.integration.amqp.outbound.CorrelationData ) { return super. doSendAndReceiveWithTemporary ( java.lang.String , java.lang.String , org.springframework.amqp.core.Message , org.springframework.integration.amqp.outbound.CorrelationData ) ; }  <METHOD_END>
