<METHOD_START> @ Test public void void ( ) java.io.IOException { TestWebSocketSession org.springframework.web.socket.handler.TestWebSocketSession = new TestWebSocketSession ( ) ; org.springframework.web.socket.handler.TestWebSocketSession . setOpen ( true ) ; ConcurrentWebSocketSessionDecorator org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecorator = new ConcurrentWebSocketSessionDecorator ( org.springframework.web.socket.handler.TestWebSocketSession , NUMBER , NUMBER ) ; TextMessage org.springframework.web.socket.handler.TextMessage = new TextMessage ( STRING ) ; org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecorator . sendMessage ( org.springframework.web.socket.handler.TextMessage ) ; assertEquals ( NUMBER , org.springframework.web.socket.handler.TestWebSocketSession . getSentMessages ( ) . size ( ) ) ; assertEquals ( org.springframework.web.socket.handler.TextMessage , org.springframework.web.socket.handler.TestWebSocketSession . getSentMessages ( ) . get ( NUMBER ) ) ; assertEquals ( NUMBER , org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecorator . getBufferSize ( ) ) ; assertEquals ( NUMBER , org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecorator . getTimeSinceSendStarted ( ) ) ; assertTrue ( org.springframework.web.socket.handler.TestWebSocketSession . isOpen ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.io.IOException , java.lang.InterruptedException { org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecoratorTests.BlockingSession org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecoratorTests.BlockingSession = new org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecoratorTests.BlockingSession ( ) ; org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecoratorTests.BlockingSession . setOpen ( true ) ; java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecoratorTests.BlockingSession . java.util.concurrent.CountDownLatch ( ) ; final ConcurrentWebSocketSessionDecorator org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecorator = new ConcurrentWebSocketSessionDecorator ( org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecoratorTests.BlockingSession , NUMBER * NUMBER , NUMBER ) ; java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . java.util.concurrent.Future<?> ( ( java.lang.Runnable ) ( ) { TextMessage org.springframework.web.socket.handler.TextMessage = new TextMessage ( STRING ) ; try { org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecorator . sendMessage ( org.springframework.web.socket.handler.TextMessage ) ; } catch ( java.io.IOException java.io.IOException ) { java.io.IOException . void ( ) ; } } ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; java.lang.Thread . void ( NUMBER ) ; assertTrue ( org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecorator . getTimeSinceSendStarted ( ) > NUMBER ) ; TextMessage org.springframework.web.socket.handler.TextMessage = new TextMessage ( STRING ) ; for ( int int = NUMBER ; int < NUMBER ; int ++ ) { org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecorator . sendMessage ( org.springframework.web.socket.handler.TextMessage ) ; } assertTrue ( org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecorator . getTimeSinceSendStarted ( ) > NUMBER ) ; assertEquals ( NUMBER * org.springframework.web.socket.handler.TextMessage . getPayloadLength ( ) , org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecorator . getBufferSize ( ) ) ; assertTrue ( org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecoratorTests.BlockingSession . isOpen ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.io.IOException , java.lang.InterruptedException { org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecoratorTests.BlockingSession org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecoratorTests.BlockingSession = new org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecoratorTests.BlockingSession ( ) ; org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecoratorTests.BlockingSession . setId ( STRING ) ; org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecoratorTests.BlockingSession . setOpen ( true ) ; java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecoratorTests.BlockingSession . java.util.concurrent.CountDownLatch ( ) ; int int = NUMBER ; int int = NUMBER ; final ConcurrentWebSocketSessionDecorator org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecorator = new ConcurrentWebSocketSessionDecorator ( org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecoratorTests.BlockingSession , int , int ) ; java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . java.util.concurrent.Future<?> ( ( java.lang.Runnable ) ( ) { TextMessage org.springframework.web.socket.handler.TextMessage = new TextMessage ( STRING ) ; try { org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecorator . sendMessage ( org.springframework.web.socket.handler.TextMessage ) ; } catch ( java.io.IOException java.io.IOException ) { java.io.IOException . void ( ) ; } } ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; java.lang.Thread . void ( int + NUMBER ) ; try { TextMessage org.springframework.web.socket.handler.TextMessage = new TextMessage ( STRING ) ; org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecorator . sendMessage ( org.springframework.web.socket.handler.TextMessage ) ; fail ( STRING ) ; } catch ( SessionLimitExceededException org.springframework.web.socket.handler.SessionLimitExceededException ) { java.lang.String java.lang.String = org.springframework.web.socket.handler.SessionLimitExceededException . getMessage ( ) ; java.lang.String java.lang.String = STRING ; assertTrue ( STRING + java.lang.String , java.lang.String . boolean ( java.lang.String ) ) ; assertEquals ( CloseStatus . SESSION_NOT_RELIABLE , org.springframework.web.socket.handler.SessionLimitExceededException . getStatus ( ) ) ; } }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.io.IOException , java.lang.InterruptedException { org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecoratorTests.BlockingSession org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecoratorTests.BlockingSession = new org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecoratorTests.BlockingSession ( ) ; org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecoratorTests.BlockingSession . setId ( STRING ) ; org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecoratorTests.BlockingSession . setOpen ( true ) ; java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecoratorTests.BlockingSession . java.util.concurrent.CountDownLatch ( ) ; int int = NUMBER * NUMBER ; int int = NUMBER ; final ConcurrentWebSocketSessionDecorator org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecorator = new ConcurrentWebSocketSessionDecorator ( org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecoratorTests.BlockingSession , int , int ) ; java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . java.util.concurrent.Future<?> ( ( java.lang.Runnable ) ( ) { TextMessage org.springframework.web.socket.handler.TextMessage = new TextMessage ( STRING ) ; try { org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecorator . sendMessage ( org.springframework.web.socket.handler.TextMessage ) ; } catch ( java.io.IOException java.io.IOException ) { java.io.IOException . void ( ) ; } } ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; java.lang.StringBuilder java.lang.StringBuilder = new java.lang.StringBuilder ( ) ; for ( int int = NUMBER ; int < NUMBER ; int ++ ) { java.lang.StringBuilder . java.lang.StringBuilder ( STRING ) ; } TextMessage org.springframework.web.socket.handler.TextMessage = new TextMessage ( java.lang.StringBuilder . java.lang.String ( ) ) ; org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecorator . sendMessage ( org.springframework.web.socket.handler.TextMessage ) ; assertEquals ( NUMBER , org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecorator . getBufferSize ( ) ) ; assertTrue ( org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecoratorTests.BlockingSession . isOpen ( ) ) ; try { org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecorator . sendMessage ( org.springframework.web.socket.handler.TextMessage ) ; fail ( STRING ) ; } catch ( SessionLimitExceededException org.springframework.web.socket.handler.SessionLimitExceededException ) { java.lang.String java.lang.String = org.springframework.web.socket.handler.SessionLimitExceededException . getMessage ( ) ; java.lang.String java.lang.String = STRING ; assertTrue ( STRING + java.lang.String , java.lang.String . boolean ( java.lang.String ) ) ; assertEquals ( CloseStatus . SESSION_NOT_RELIABLE , org.springframework.web.socket.handler.SessionLimitExceededException . getStatus ( ) ) ; } }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecoratorTests.BlockingSession org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecoratorTests.BlockingSession = new org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecoratorTests.BlockingSession ( ) ; org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecoratorTests.BlockingSession . setOpen ( true ) ; WebSocketSession org.springframework.web.socket.handler.WebSocketSession = new ConcurrentWebSocketSessionDecorator ( org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecoratorTests.BlockingSession , NUMBER * NUMBER , NUMBER ) ; org.springframework.web.socket.handler.WebSocketSession . close ( CloseStatus . PROTOCOL_ERROR ) ; assertEquals ( CloseStatus . PROTOCOL_ERROR , org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecoratorTests.BlockingSession . getCloseStatus ( ) ) ; org.springframework.web.socket.handler.WebSocketSession . close ( CloseStatus . SERVER_ERROR ) ; assertEquals ( STRING , CloseStatus . PROTOCOL_ERROR , org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecoratorTests.BlockingSession . getCloseStatus ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecoratorTests.BlockingSession org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecoratorTests.BlockingSession = new org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecoratorTests.BlockingSession ( ) ; org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecoratorTests.BlockingSession . setId ( STRING ) ; org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecoratorTests.BlockingSession . setOpen ( true ) ; java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecoratorTests.BlockingSession . java.util.concurrent.CountDownLatch ( ) ; int int = NUMBER ; int int = NUMBER ; final ConcurrentWebSocketSessionDecorator org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecorator = new ConcurrentWebSocketSessionDecorator ( org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecoratorTests.BlockingSession , int , int ) ; java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . java.util.concurrent.Future<?> ( ( java.lang.Runnable ) ( ) { TextMessage org.springframework.web.socket.handler.TextMessage = new TextMessage ( STRING ) ; try { org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecorator . sendMessage ( org.springframework.web.socket.handler.TextMessage ) ; } catch ( java.io.IOException java.io.IOException ) { java.io.IOException . void ( ) ; } } ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; java.lang.Thread . void ( int + NUMBER ) ; org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecorator . close ( CloseStatus . PROTOCOL_ERROR ) ; assertEquals ( STRING , CloseStatus . SESSION_NOT_RELIABLE , org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecoratorTests.BlockingSession . getCloseStatus ( ) ) ; }  <METHOD_END>
<METHOD_START> public java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch ( ) { this . java.util.concurrent.atomic.AtomicReference<java.util.concurrent.CountDownLatch> . void ( new java.util.concurrent.CountDownLatch ( NUMBER ) ) ; return this . java.util.concurrent.atomic.AtomicReference<java.util.concurrent.CountDownLatch> . java.util.concurrent.CountDownLatch ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( WebSocketMessage < ? > org.springframework.web.socket.handler.WebSocketMessage<?> ) throws java.io.IOException { super. sendMessage ( org.springframework.web.socket.handler.WebSocketMessage<> ) ; if ( this . java.util.concurrent.atomic.AtomicReference<java.util.concurrent.CountDownLatch> != null ) { this . java.util.concurrent.atomic.AtomicReference<java.util.concurrent.CountDownLatch> . java.util.concurrent.CountDownLatch ( ) . void ( ) ; } void ( ) ; }  <METHOD_END>
<METHOD_START> private void void ( ) { try { this . java.util.concurrent.atomic.AtomicReference<java.util.concurrent.CountDownLatch> . void ( new java.util.concurrent.CountDownLatch ( NUMBER ) ) ; this . java.util.concurrent.atomic.AtomicReference<java.util.concurrent.CountDownLatch> . java.util.concurrent.CountDownLatch ( ) . void ( ) ; } catch ( java.lang.InterruptedException java.lang.InterruptedException ) { java.lang.InterruptedException . void ( ) ; } }  <METHOD_END>
