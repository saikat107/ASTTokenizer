<METHOD_START> @ Before public void void ( ) { org.springframework.format.support.FormattingConversionService = new FormattingConversionService ( ) ; DefaultConversionService . addDefaultConverters ( org.springframework.format.support.FormattingConversionService ) ; LocaleContextHolder . setLocale ( java.util.Locale . java.util.Locale ) ; }  <METHOD_END>
<METHOD_START> @ After public void void ( ) { LocaleContextHolder . setLocale ( null ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.text.ParseException { org.springframework.format.support.FormattingConversionService . addFormatterForFieldType ( java.lang.Number .class , new NumberStyleFormatter ( ) ) ; java.lang.String java.lang.String = org.springframework.format.support.FormattingConversionService . convert ( NUMBER , java.lang.String .class ) ; assertEquals ( STRING , java.lang.String ) ; java.lang.Integer java.lang.Integer = org.springframework.format.support.FormattingConversionService . convert ( STRING , java.lang.Integer .class ) ; assertEquals ( new java.lang.Integer ( NUMBER ) , java.lang.Integer ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.text.ParseException { org.springframework.format.support.FormattingConversionService . addConverter ( new Converter < DateTime , LocalDate > ( ) { @ java.lang.Override public org.springframework.format.support.LocalDate org.springframework.format.support.LocalDate ( DateTime org.springframework.format.support.DateTime ) { return org.springframework.format.support.DateTime . toLocalDate ( ) ; } } ) ; org.springframework.format.support.FormattingConversionService . addFormatterForFieldType ( LocalDate .class , new ReadablePartialPrinter ( DateTimeFormat . shortDate ( ) ) , new DateTimeParser ( DateTimeFormat . shortDate ( ) ) ) ; java.lang.String java.lang.String = org.springframework.format.support.FormattingConversionService . convert ( new LocalDate ( NUMBER , NUMBER , NUMBER ) , java.lang.String .class ) ; assertEquals ( STRING , java.lang.String ) ; LocalDate org.springframework.format.support.LocalDate = org.springframework.format.support.FormattingConversionService . convert ( STRING , LocalDate .class ) ; assertEquals ( new LocalDate ( NUMBER , NUMBER , NUMBER ) , org.springframework.format.support.LocalDate ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.format.support.LocalDate org.springframework.format.support.LocalDate ( DateTime org.springframework.format.support.DateTime ) { return org.springframework.format.support.DateTime . toLocalDate ( ) ; }  <METHOD_END>
<METHOD_START> @ Test @ java.lang.SuppressWarnings ( STRING ) public void void ( ) { AnnotationConfigApplicationContext org.springframework.format.support.AnnotationConfigApplicationContext = new AnnotationConfigApplicationContext ( ) ; org.springframework.format.support.AnnotationConfigApplicationContext . registerBeanDefinition ( STRING , new RootBeanDefinition ( org.springframework.format.support.FormattingConversionServiceTests.ValueBean .class ) ) ; org.springframework.format.support.AnnotationConfigApplicationContext . registerBeanDefinition ( STRING , new RootBeanDefinition ( FormattingConversionServiceFactoryBean .class ) ) ; org.springframework.format.support.AnnotationConfigApplicationContext . refresh ( ) ; org.springframework.format.support.FormattingConversionServiceTests.ValueBean org.springframework.format.support.FormattingConversionServiceTests.ValueBean = org.springframework.format.support.AnnotationConfigApplicationContext . getBean ( org.springframework.format.support.FormattingConversionServiceTests.ValueBean .class ) ; assertEquals ( new LocalDate ( NUMBER , NUMBER , NUMBER ) , new LocalDate ( org.springframework.format.support.FormattingConversionServiceTests.ValueBean . java.util.Date ) ) ; }  <METHOD_END>
<METHOD_START> @ Test @ java.lang.SuppressWarnings ( STRING ) public void void ( ) { AnnotationConfigApplicationContext org.springframework.format.support.AnnotationConfigApplicationContext = new AnnotationConfigApplicationContext ( ) ; RootBeanDefinition org.springframework.format.support.RootBeanDefinition = new RootBeanDefinition ( org.springframework.format.support.FormattingConversionServiceTests.MetaValueBean .class ) ; org.springframework.format.support.RootBeanDefinition . setScope ( BeanDefinition . SCOPE_PROTOTYPE ) ; org.springframework.format.support.AnnotationConfigApplicationContext . registerBeanDefinition ( STRING , org.springframework.format.support.RootBeanDefinition ) ; org.springframework.format.support.AnnotationConfigApplicationContext . registerBeanDefinition ( STRING , new RootBeanDefinition ( FormattingConversionServiceFactoryBean .class ) ) ; org.springframework.format.support.AnnotationConfigApplicationContext . registerBeanDefinition ( STRING , new RootBeanDefinition ( PropertyPlaceholderConfigurer .class ) ) ; org.springframework.format.support.AnnotationConfigApplicationContext . refresh ( ) ; java.lang.System . java.lang.String ( STRING , STRING ) ; java.lang.System . java.lang.String ( STRING , STRING ) ; try { org.springframework.format.support.FormattingConversionServiceTests.MetaValueBean org.springframework.format.support.FormattingConversionServiceTests.MetaValueBean = org.springframework.format.support.AnnotationConfigApplicationContext . getBean ( org.springframework.format.support.FormattingConversionServiceTests.MetaValueBean .class ) ; assertEquals ( new LocalDate ( NUMBER , NUMBER , NUMBER ) , new LocalDate ( org.springframework.format.support.FormattingConversionServiceTests.MetaValueBean . java.util.Date ) ) ; assertEquals ( java.lang.Double . java.lang.Double ( NUMBER ) , org.springframework.format.support.FormattingConversionServiceTests.MetaValueBean . java.lang.Double ) ; } finally { java.lang.System . java.lang.String ( STRING ) ; java.lang.System . java.lang.String ( STRING ) ; } }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { org.springframework.format.support.FormattingConversionService . addFormatterForFieldAnnotation ( new JodaDateTimeFormatAnnotationFormatterFactory ( ) ) ; void ( org.springframework.format.support.FormattingConversionServiceTests.Model .class , false ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { org.springframework.format.support.FormattingConversionService . addFormatterForFieldAnnotation ( new JodaDateTimeFormatAnnotationFormatterFactory ( ) ) ; void ( org.springframework.format.support.FormattingConversionServiceTests.Model .class , true ) ; }  <METHOD_END>
<METHOD_START> @ Test @ java.lang.SuppressWarnings ( STRING ) public void void ( ) java.lang.Exception { GenericApplicationContext org.springframework.format.support.GenericApplicationContext = new GenericApplicationContext ( ) ; PropertyPlaceholderConfigurer org.springframework.format.support.PropertyPlaceholderConfigurer = new PropertyPlaceholderConfigurer ( ) ; java.util.Properties java.util.Properties = new java.util.Properties ( ) ; java.util.Properties . java.lang.Object ( STRING , STRING ) ; java.util.Properties . java.lang.Object ( STRING , STRING ) ; org.springframework.format.support.PropertyPlaceholderConfigurer . setProperties ( java.util.Properties ) ; org.springframework.format.support.GenericApplicationContext . getBeanFactory ( ) . registerSingleton ( STRING , org.springframework.format.support.PropertyPlaceholderConfigurer ) ; org.springframework.format.support.GenericApplicationContext . refresh ( ) ; org.springframework.format.support.GenericApplicationContext . getBeanFactory ( ) . initializeBean ( org.springframework.format.support.FormattingConversionService , STRING ) ; org.springframework.format.support.FormattingConversionService . addFormatterForFieldAnnotation ( new JodaDateTimeFormatAnnotationFormatterFactory ( ) ) ; void ( org.springframework.format.support.FormattingConversionServiceTests.ModelWithPlaceholders .class , false ) ; }  <METHOD_END>
<METHOD_START> @ Test @ java.lang.SuppressWarnings ( STRING ) public void void ( ) java.lang.Exception { GenericApplicationContext org.springframework.format.support.GenericApplicationContext = new GenericApplicationContext ( ) ; PropertyPlaceholderConfigurer org.springframework.format.support.PropertyPlaceholderConfigurer = new PropertyPlaceholderConfigurer ( ) ; java.util.Properties java.util.Properties = new java.util.Properties ( ) ; java.util.Properties . java.lang.Object ( STRING , STRING ) ; java.util.Properties . java.lang.Object ( STRING , STRING ) ; org.springframework.format.support.PropertyPlaceholderConfigurer . setProperties ( java.util.Properties ) ; org.springframework.format.support.GenericApplicationContext . registerBeanDefinition ( STRING , new RootBeanDefinition ( FormattingConversionServiceFactoryBean .class ) ) ; org.springframework.format.support.GenericApplicationContext . getBeanFactory ( ) . registerSingleton ( STRING , org.springframework.format.support.PropertyPlaceholderConfigurer ) ; org.springframework.format.support.GenericApplicationContext . refresh ( ) ; org.springframework.format.support.FormattingConversionService = org.springframework.format.support.GenericApplicationContext . getBean ( STRING , FormattingConversionService .class ) ; void ( org.springframework.format.support.FormattingConversionServiceTests.ModelWithPlaceholders .class , false ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.SuppressWarnings ( STRING ) private void void ( java.lang.Class<?> < ? > java.lang.Class<?> , boolean boolean ) throws java.lang.Exception { org.springframework.format.support.FormattingConversionService . addConverter ( new Converter < java.util.Date , java.lang.Long > ( ) { @ java.lang.Override public java.lang.Long java.lang.Long ( java.util.Date java.util.Date ) { return java.util.Date . long ( ) ; } } ) ; org.springframework.format.support.FormattingConversionService . addConverter ( new Converter < DateTime , java.util.Date > ( ) { @ java.lang.Override public java.util.Date java.util.Date ( DateTime org.springframework.format.support.DateTime ) { return org.springframework.format.support.DateTime . toDate ( ) ; } } ) ; java.lang.String java.lang.String = ( java.lang.String ) org.springframework.format.support.FormattingConversionService . convert ( new LocalDate ( NUMBER , NUMBER , NUMBER ) . toDateTimeAtCurrentTime ( ) . toDate ( ) , new TypeDescriptor ( java.lang.Class<> . java.lang.reflect.Field ( STRING ) ) , TypeDescriptor . valueOf ( java.lang.String .class ) ) ; assertEquals ( STRING , java.lang.String ) ; LocalDate org.springframework.format.support.LocalDate = new LocalDate ( org.springframework.format.support.FormattingConversionService . convert ( STRING , TypeDescriptor . valueOf ( java.lang.String .class ) , new TypeDescriptor ( java.lang.Class<> . java.lang.reflect.Field ( STRING ) ) ) ) ; assertEquals ( new LocalDate ( NUMBER , NUMBER , NUMBER ) , org.springframework.format.support.LocalDate ) ; java.util.List<java.util.Date> < java.util.Date > java.util.List<java.util.Date> = new java.util.ArrayList<java.util.Date> <> ( ) ; java.util.List<java.util.Date> . boolean ( new LocalDate ( NUMBER , NUMBER , NUMBER ) . toDateTimeAtCurrentTime ( ) . toDate ( ) ) ; java.util.List<java.util.Date> . boolean ( new LocalDate ( NUMBER , NUMBER , NUMBER ) . toDateTimeAtCurrentTime ( ) . toDate ( ) ) ; java.util.List<java.util.Date> . boolean ( new LocalDate ( NUMBER , NUMBER , NUMBER ) . toDateTimeAtCurrentTime ( ) . toDate ( ) ) ; java.lang.String = ( java.lang.String ) org.springframework.format.support.FormattingConversionService . convert ( java.util.List<java.util.Date> , new TypeDescriptor ( java.lang.Class<> . java.lang.reflect.Field ( STRING ) ) , TypeDescriptor . valueOf ( java.lang.String .class ) ) ; assertEquals ( STRING , java.lang.String ) ; java.util.List<java.util.Date> = ( java.util.List<java.util.Date> < java.util.Date > ) org.springframework.format.support.FormattingConversionService . convert ( STRING , TypeDescriptor . valueOf ( java.lang.String .class ) , new TypeDescriptor ( java.lang.Class<> . java.lang.reflect.Field ( STRING ) ) ) ; assertEquals ( new LocalDate ( NUMBER , NUMBER , NUMBER ) , new LocalDate ( java.util.List<java.util.Date> . java.util.Date ( NUMBER ) ) ) ; assertEquals ( new LocalDate ( NUMBER , NUMBER , NUMBER ) , new LocalDate ( java.util.List<java.util.Date> . java.util.Date ( NUMBER ) ) ) ; assertEquals ( new LocalDate ( NUMBER , NUMBER , NUMBER ) , new LocalDate ( java.util.List<java.util.Date> . java.util.Date ( NUMBER ) ) ) ; java.lang.Object java.lang.Object = java.lang.Class<> . newInstance ( ) ; ConfigurablePropertyAccessor org.springframework.format.support.ConfigurablePropertyAccessor = boolean ? PropertyAccessorFactory . forDirectFieldAccess ( java.lang.Object ) : PropertyAccessorFactory . forBeanPropertyAccess ( java.lang.Object ) ; org.springframework.format.support.ConfigurablePropertyAccessor . setConversionService ( org.springframework.format.support.FormattingConversionService ) ; org.springframework.format.support.ConfigurablePropertyAccessor . setPropertyValue ( STRING , STRING ) ; java.util.List<java.util.Date> = ( java.util.List<java.util.Date> < java.util.Date > ) org.springframework.format.support.ConfigurablePropertyAccessor . getPropertyValue ( STRING ) ; assertEquals ( new LocalDate ( NUMBER , NUMBER , NUMBER ) , new LocalDate ( java.util.List<java.util.Date> . java.util.Date ( NUMBER ) ) ) ; assertEquals ( new LocalDate ( NUMBER , NUMBER , NUMBER ) , new LocalDate ( java.util.List<java.util.Date> . java.util.Date ( NUMBER ) ) ) ; assertEquals ( new LocalDate ( NUMBER , NUMBER , NUMBER ) , new LocalDate ( java.util.List<java.util.Date> . java.util.Date ( NUMBER ) ) ) ; if ( ! boolean ) { org.springframework.format.support.ConfigurablePropertyAccessor . setPropertyValue ( STRING , STRING ) ; org.springframework.format.support.ConfigurablePropertyAccessor . setPropertyValue ( STRING , STRING ) ; org.springframework.format.support.ConfigurablePropertyAccessor . setPropertyValue ( STRING , STRING ) ; java.util.List<java.util.Date> = ( java.util.List<java.util.Date> < java.util.Date > ) org.springframework.format.support.ConfigurablePropertyAccessor . getPropertyValue ( STRING ) ; assertEquals ( new LocalDate ( NUMBER , NUMBER , NUMBER ) , new LocalDate ( java.util.List<java.util.Date> . java.util.Date ( NUMBER ) ) ) ; assertEquals ( new LocalDate ( NUMBER , NUMBER , NUMBER ) , new LocalDate ( java.util.List<java.util.Date> . java.util.Date ( NUMBER ) ) ) ; assertEquals ( new LocalDate ( NUMBER , NUMBER , NUMBER ) , new LocalDate ( java.util.List<java.util.Date> . java.util.Date ( NUMBER ) ) ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.Long java.lang.Long ( java.util.Date java.util.Date ) { return java.util.Date . long ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.util.Date java.util.Date ( DateTime org.springframework.format.support.DateTime ) { return org.springframework.format.support.DateTime . toDate ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.text.ParseException { org.springframework.format.support.FormattingConversionService . addFormatterForFieldType ( java.lang.Number .class , new NumberStyleFormatter ( ) ) ; assertEquals ( STRING , org.springframework.format.support.FormattingConversionService . convert ( null , TypeDescriptor . valueOf ( java.lang.Integer .class ) , TypeDescriptor . valueOf ( java.lang.String .class ) ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.text.ParseException { org.springframework.format.support.FormattingConversionService . addFormatterForFieldType ( java.lang.Number .class , new NumberStyleFormatter ( ) ) ; assertNull ( org.springframework.format.support.FormattingConversionService . convert ( null , TypeDescriptor . valueOf ( java.lang.String .class ) , TypeDescriptor . valueOf ( java.lang.Integer .class ) ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.text.ParseException { org.springframework.format.support.FormattingConversionService . addFormatterForFieldType ( java.lang.Number .class , new NumberStyleFormatter ( ) ) ; assertNull ( org.springframework.format.support.FormattingConversionService . convert ( STRING , TypeDescriptor . valueOf ( java.lang.String .class ) , TypeDescriptor . valueOf ( java.lang.Integer .class ) ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.text.ParseException { org.springframework.format.support.FormattingConversionService . addFormatterForFieldType ( java.lang.Number .class , new NumberStyleFormatter ( ) ) ; assertNull ( org.springframework.format.support.FormattingConversionService . convert ( STRING , TypeDescriptor . valueOf ( java.lang.String .class ) , TypeDescriptor . valueOf ( java.lang.Integer .class ) ) ) ; }  <METHOD_END>
<METHOD_START> @ Test ( expected = ConversionFailedException .class ) public void void ( ) java.text.ParseException { org.springframework.format.support.FormattingConversionService . addFormatterForFieldType ( java.lang.Integer .class , new org.springframework.format.support.FormattingConversionServiceTests.NullReturningFormatter ( ) ) ; assertNull ( org.springframework.format.support.FormattingConversionService . convert ( STRING , TypeDescriptor . valueOf ( java.lang.String .class ) , TypeDescriptor . valueOf ( java.lang.Integer .class ) ) ) ; }  <METHOD_END>
<METHOD_START> @ Test ( expected = ConversionFailedException .class ) public void void ( ) java.text.ParseException { org.springframework.format.support.FormattingConversionService . addFormatterForFieldType ( java.lang.Integer .class , new NumberStyleFormatter ( ) ) ; assertNull ( org.springframework.format.support.FormattingConversionService . convert ( null , TypeDescriptor . valueOf ( java.lang.String .class ) , TypeDescriptor . valueOf ( int .class ) ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.text.ParseException { assertEquals ( null , org.springframework.format.support.FormattingConversionService . convert ( null , TypeDescriptor . valueOf ( java.lang.Integer .class ) , TypeDescriptor . valueOf ( java.lang.String .class ) ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.text.ParseException { assertNull ( org.springframework.format.support.FormattingConversionService . convert ( null , TypeDescriptor . valueOf ( java.lang.String .class ) , TypeDescriptor . valueOf ( java.lang.Integer .class ) ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.text.ParseException { assertNull ( org.springframework.format.support.FormattingConversionService . convert ( STRING , TypeDescriptor . valueOf ( java.lang.String .class ) , TypeDescriptor . valueOf ( java.lang.Integer .class ) ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { org.springframework.format.support.FormattingConversionService . addFormatterForFieldAnnotation ( new JodaDateTimeFormatAnnotationFormatterFactory ( ) { @ java.lang.Override public org.springframework.format.support.Printer<?> < ? > org.springframework.format.support.Printer<?> ( org . springframework . format . org.springframework.format.annotation . org.springframework.format.annotation org.springframework.format.annotation.DateTimeFormat , java.lang.Class<?> < ? > java.lang.Class<?> ) { assertEquals ( org.springframework.format.support.FormattingConversionServiceTests.MyDate .class , java.lang.Class<> ) ; return super. getPrinter ( org.springframework.format.annotation.DateTimeFormat , java.lang.Class<> ) ; } } ) ; org.springframework.format.support.FormattingConversionService . addConverter ( new Converter < org.springframework.format.support.FormattingConversionServiceTests.MyDate , java.lang.Long > ( ) { @ java.lang.Override public java.lang.Long java.lang.Long ( org.springframework.format.support.FormattingConversionServiceTests.MyDate org.springframework.format.support.FormattingConversionServiceTests.MyDate ) { return org.springframework.format.support.FormattingConversionServiceTests.MyDate . long ( ) ; } } ) ; org.springframework.format.support.FormattingConversionService . addConverter ( new Converter < org.springframework.format.support.FormattingConversionServiceTests.MyDate , java.util.Date > ( ) { @ java.lang.Override public java.util.Date java.util.Date ( org.springframework.format.support.FormattingConversionServiceTests.MyDate org.springframework.format.support.FormattingConversionServiceTests.MyDate ) { return org.springframework.format.support.FormattingConversionServiceTests.MyDate ; } } ) ; org.springframework.format.support.FormattingConversionService . convert ( new org.springframework.format.support.FormattingConversionServiceTests.MyDate ( ) , new TypeDescriptor ( org.springframework.format.support.FormattingConversionServiceTests.ModelWithSubclassField .class . java.lang.reflect.Field ( STRING ) ) , TypeDescriptor . valueOf ( java.lang.String .class ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.format.support.Printer<?> < ? > org.springframework.format.support.Printer<?> ( org . springframework . format . org.springframework.format.annotation . org.springframework.format.annotation org.springframework.format.annotation.DateTimeFormat , java.lang.Class<?> < ? > java.lang.Class<?> ) { assertEquals ( org.springframework.format.support.FormattingConversionServiceTests.MyDate .class , java.lang.Class<> ) ; return super. getPrinter ( org.springframework.format.annotation.DateTimeFormat , java.lang.Class<> ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.Long java.lang.Long ( org.springframework.format.support.FormattingConversionServiceTests.MyDate org.springframework.format.support.FormattingConversionServiceTests.MyDate ) { return org.springframework.format.support.FormattingConversionServiceTests.MyDate . long ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.util.Date java.util.Date ( org.springframework.format.support.FormattingConversionServiceTests.MyDate org.springframework.format.support.FormattingConversionServiceTests.MyDate ) { return org.springframework.format.support.FormattingConversionServiceTests.MyDate ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { void ( java.util.Date .class , new java.util.Date ( ) ) ; }  <METHOD_END>
<METHOD_START> private < T > void void ( java.lang.Class<T> < T > java.lang.Class<T> , final T T ) { org.springframework.format.support.FormattingConversionService . addFormatterForFieldType ( java.lang.Class<T> , new Formatter < T > ( ) { @ java.lang.Override public T T ( java.lang.String java.lang.String , java.util.Locale java.util.Locale ) throws java.text.ParseException { return T ; } @ java.lang.Override public java.lang.String java.lang.String ( T T , java.util.Locale java.util.Locale ) { return T . java.lang.String ( ) ; } @ java.lang.Override public java.lang.String java.lang.String ( ) { return T . java.lang.String ( ) ; } } ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public T T ( java.lang.String java.lang.String , java.util.Locale java.util.Locale ) throws java.text.ParseException { return T ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.String java.lang.String ( T T , java.util.Locale java.util.Locale ) { return T . java.lang.String ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.String java.lang.String ( ) { return T . java.lang.String ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.text.ParseException { org.springframework.format.support.FormattingConversionService . addFormatter ( new NumberStyleFormatter ( ) ) ; assertNull ( org.springframework.format.support.FormattingConversionService . convert ( null , TypeDescriptor . valueOf ( java.lang.String .class ) , TypeDescriptor . valueOf ( java.lang.Integer .class ) ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.text.ParseException { Formatter < ? > org.springframework.format.support.Formatter<?> = new NumberStyleFormatter ( ) ; org.springframework.format.support.FormattingConversionService . addFormatter ( ( Formatter < ? > ) new ProxyFactory ( org.springframework.format.support.Formatter<> ) . getProxy ( ) ) ; assertNull ( org.springframework.format.support.FormattingConversionService . convert ( null , TypeDescriptor . valueOf ( java.lang.String .class ) , TypeDescriptor . valueOf ( java.lang.Integer .class ) ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { org.springframework.format.support.FormattingConversionService . addConverter ( new org.springframework.format.support.FormattingConversionServiceTests.IntegerConverter ( ) ) ; assertEquals ( java.lang.Integer . java.lang.Integer ( NUMBER ) , org.springframework.format.support.FormattingConversionService . convert ( STRING , java.lang.Integer .class ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { Converter < ? , ? > org.springframework.format.support.Converter<?,?> = new org.springframework.format.support.FormattingConversionServiceTests.IntegerConverter ( ) ; org.springframework.format.support.FormattingConversionService . addConverter ( ( Converter < ? , ? > ) new ProxyFactory ( org.springframework.format.support.Converter<,> ) . getProxy ( ) ) ; assertEquals ( java.lang.Integer . java.lang.Integer ( NUMBER ) , org.springframework.format.support.FormattingConversionService . convert ( STRING , java.lang.Integer .class ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { org.springframework.format.support.FormattingConversionService . addConverterFactory ( new org.springframework.format.support.FormattingConversionServiceTests.IntegerConverterFactory ( ) ) ; assertEquals ( java.lang.Integer . java.lang.Integer ( NUMBER ) , org.springframework.format.support.FormattingConversionService . convert ( STRING , java.lang.Integer .class ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { ConverterFactory < ? , ? > org.springframework.format.support.ConverterFactory<?,?> = new org.springframework.format.support.FormattingConversionServiceTests.IntegerConverterFactory ( ) ; org.springframework.format.support.FormattingConversionService . addConverterFactory ( ( ConverterFactory < ? , ? > ) new ProxyFactory ( org.springframework.format.support.ConverterFactory<,> ) . getProxy ( ) ) ; assertEquals ( java.lang.Integer . java.lang.Integer ( NUMBER ) , org.springframework.format.support.FormattingConversionService . convert ( STRING , java.lang.Integer .class ) ) ; }  <METHOD_END>
<METHOD_START> public java.util.List<java.util.Date> < java.util.Date > java.util.List<java.util.Date> ( ) { return java.util.List<java.util.Date> ; }  <METHOD_END>
<METHOD_START> public void void ( java.util.List<java.util.Date> < java.util.Date > java.util.List<java.util.Date> ) { this . java.util.List<java.util.Date> = java.util.List<java.util.Date> ; }  <METHOD_END>
<METHOD_START> public java.util.List<java.util.Date> < java.util.Date > java.util.List<java.util.Date> ( ) { return java.util.List<java.util.Date> ; }  <METHOD_END>
<METHOD_START> public void void ( java.util.List<java.util.Date> < java.util.Date > java.util.List<java.util.Date> ) { this . java.util.List<java.util.Date> = java.util.List<java.util.Date> ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.String java.lang.String ( java.lang.Integer java.lang.Integer , java.util.Locale java.util.Locale ) { return null ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.Integer java.lang.Integer ( java.lang.String java.lang.String , java.util.Locale java.util.Locale ) throws java.text.ParseException { return null ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.Integer java.lang.Integer ( java.lang.String java.lang.String ) { return java.lang.Integer . int ( java.lang.String ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override @ java.lang.SuppressWarnings ( STRING ) public < T extends java.lang.Number > org.springframework.format.support.Converter<java.lang.String,T> < java.lang.String , T > org.springframework.format.support.Converter<java.lang.String,T> ( java.lang.Class<T> < T > java.lang.Class<T> ) { if ( java.lang.Integer .class == java.lang.Class<T> ) { return ( Converter < java.lang.String , T > ) new org.springframework.format.support.FormattingConversionServiceTests.IntegerConverter ( ) ; } else { throw new java.lang.IllegalStateException ( ) ; } }  <METHOD_END>
