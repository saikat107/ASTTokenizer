<METHOD_START> @ Test public void void ( ) { GenericMessage < java.lang.String > org.springframework.integration.handler.advice.GenericMessage<java.lang.String> = new GenericMessage < java.lang.String > ( STRING ) ; try { org.springframework.integration.handler.advice.MessageChannel . send ( org.springframework.integration.handler.advice.GenericMessage<java.lang.String> ) ; fail ( STRING ) ; } catch ( MessageHandlingException org.springframework.integration.handler.advice.MessageHandlingException ) { assertThat ( org.springframework.integration.handler.advice.MessageHandlingException . getCause ( ) , Matchers . instanceOf ( java.lang.ArithmeticException .class ) ) ; } try { org.springframework.integration.handler.advice.MessageChannel . send ( org.springframework.integration.handler.advice.GenericMessage<java.lang.String> ) ; fail ( STRING ) ; } catch ( java.lang.RuntimeException java.lang.RuntimeException ) { assertThat ( java.lang.RuntimeException . java.lang.String ( ) , containsString ( STRING ) ) ; } }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { final java.util.concurrent.atomic.AtomicBoolean java.util.concurrent.atomic.AtomicBoolean = new java.util.concurrent.atomic.AtomicBoolean ( ) ; AbstractReplyProducingMessageHandler org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler = new AbstractReplyProducingMessageHandler ( ) { @ java.lang.Override protected java.lang.Object java.lang.Object ( Message < ? > org.springframework.integration.handler.advice.Message<?> ) { if ( java.util.concurrent.atomic.AtomicBoolean . boolean ( ) ) { throw new java.lang.RuntimeException ( STRING ) ; } return STRING ; } } ; java.lang.String java.lang.String = STRING ; org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . setComponentName ( java.lang.String ) ; QueueChannel org.springframework.integration.handler.advice.QueueChannel = new QueueChannel ( ) ; org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . setOutputChannel ( org.springframework.integration.handler.advice.QueueChannel ) ; Message < java.lang.String > org.springframework.integration.handler.advice.Message<java.lang.String> = new GenericMessage < java.lang.String > ( STRING ) ; org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . handleMessage ( org.springframework.integration.handler.advice.Message<java.lang.String> ) ; Message < ? > org.springframework.integration.handler.advice.Message<?> = org.springframework.integration.handler.advice.QueueChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.handler.advice.Message<> ) ; assertEquals ( STRING , org.springframework.integration.handler.advice.Message<> . getPayload ( ) ) ; PollableChannel org.springframework.integration.handler.advice.PollableChannel = new QueueChannel ( ) ; PollableChannel org.springframework.integration.handler.advice.PollableChannel = new QueueChannel ( ) ; ExpressionEvaluatingRequestHandlerAdvice org.springframework.integration.handler.advice.ExpressionEvaluatingRequestHandlerAdvice = new ExpressionEvaluatingRequestHandlerAdvice ( ) ; org.springframework.integration.handler.advice.ExpressionEvaluatingRequestHandlerAdvice . setBeanFactory ( mock ( BeanFactory .class ) ) ; org.springframework.integration.handler.advice.ExpressionEvaluatingRequestHandlerAdvice . setSuccessChannel ( org.springframework.integration.handler.advice.PollableChannel ) ; org.springframework.integration.handler.advice.ExpressionEvaluatingRequestHandlerAdvice . setFailureChannel ( org.springframework.integration.handler.advice.PollableChannel ) ; org.springframework.integration.handler.advice.ExpressionEvaluatingRequestHandlerAdvice . setOnSuccessExpressionString ( STRING ) ; org.springframework.integration.handler.advice.ExpressionEvaluatingRequestHandlerAdvice . setOnFailureExpressionString ( STRING ) ; java.util.List<org.springframework.integration.handler.advice.Advice> < Advice > java.util.List<org.springframework.integration.handler.advice.Advice> = new java.util.ArrayList<org.springframework.integration.handler.advice.Advice> < Advice > ( ) ; java.util.List<org.springframework.integration.handler.advice.Advice> . add ( org.springframework.integration.handler.advice.ExpressionEvaluatingRequestHandlerAdvice ) ; final java.util.concurrent.atomic.AtomicReference<java.lang.String> < java.lang.String > java.util.concurrent.atomic.AtomicReference<java.lang.String> = new java.util.concurrent.atomic.AtomicReference<java.lang.String> < java.lang.String > ( ) ; java.util.List<org.springframework.integration.handler.advice.Advice> . add ( new AbstractRequestHandlerAdvice ( ) { @ java.lang.Override protected java.lang.Object java.lang.Object ( ExecutionCallback org.springframework.integration.handler.advice.ExecutionCallback , java.lang.Object java.lang.Object , Message < ? > org.springframework.integration.handler.advice.Message<?> ) throws java.lang.Exception { java.util.concurrent.atomic.AtomicReference<java.lang.String> . void ( ( ( AbstractReplyProducingMessageHandler . AbstractReplyProducingMessageHandler ) java.lang.Object ) . getAdvisedHandler ( ) . getComponentName ( ) ) ; return org.springframework.integration.handler.advice.ExecutionCallback . execute ( ) ; } } ) ; org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . setAdviceChain ( java.util.List<org.springframework.integration.handler.advice.Advice> ) ; org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . setBeanFactory ( mock ( BeanFactory .class ) ) ; org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . afterPropertiesSet ( ) ; org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . handleMessage ( org.springframework.integration.handler.advice.Message<java.lang.String> ) ; org.springframework.integration.handler.advice.Message<?> = org.springframework.integration.handler.advice.QueueChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.handler.advice.Message<> ) ; assertEquals ( STRING , org.springframework.integration.handler.advice.Message<> . getPayload ( ) ) ; assertEquals ( java.lang.String , java.util.concurrent.atomic.AtomicReference<java.lang.String> . java.lang.String ( ) ) ; Message < ? > org.springframework.integration.handler.advice.Message<?> = org.springframework.integration.handler.advice.PollableChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.handler.advice.Message<> ) ; assertEquals ( STRING , ( ( AdviceMessage < ? > ) org.springframework.integration.handler.advice.Message<> ) . getInputMessage ( ) . getPayload ( ) ) ; assertEquals ( STRING , org.springframework.integration.handler.advice.Message<> . getPayload ( ) ) ; java.util.concurrent.atomic.AtomicBoolean . void ( true ) ; try { org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . handleMessage ( org.springframework.integration.handler.advice.Message<java.lang.String> ) ; fail ( STRING ) ; } catch ( java.lang.Exception java.lang.Exception ) { assertEquals ( STRING , java.lang.Exception . java.lang.Throwable ( ) . java.lang.String ( ) ) ; } Message < ? > org.springframework.integration.handler.advice.Message<?> = org.springframework.integration.handler.advice.PollableChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.handler.advice.Message<> ) ; assertEquals ( STRING , ( ( MessagingException ) org.springframework.integration.handler.advice.Message<> . getPayload ( ) ) . getFailedMessage ( ) . getPayload ( ) ) ; assertEquals ( STRING , ( ( MessageHandlingExpressionEvaluatingAdviceException ) org.springframework.integration.handler.advice.Message<> . getPayload ( ) ) . getEvaluationResult ( ) ) ; org.springframework.integration.handler.advice.ExpressionEvaluatingRequestHandlerAdvice . setTrapException ( true ) ; org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . handleMessage ( org.springframework.integration.handler.advice.Message<java.lang.String> ) ; org.springframework.integration.handler.advice.Message<?> = org.springframework.integration.handler.advice.PollableChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.handler.advice.Message<> ) ; assertEquals ( STRING , ( ( MessagingException ) org.springframework.integration.handler.advice.Message<> . getPayload ( ) ) . getFailedMessage ( ) . getPayload ( ) ) ; assertEquals ( STRING , ( ( MessageHandlingExpressionEvaluatingAdviceException ) org.springframework.integration.handler.advice.Message<> . getPayload ( ) ) . getEvaluationResult ( ) ) ; assertNull ( org.springframework.integration.handler.advice.QueueChannel . receive ( NUMBER ) ) ; org.springframework.integration.handler.advice.ExpressionEvaluatingRequestHandlerAdvice . setReturnFailureExpressionResult ( true ) ; org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . handleMessage ( org.springframework.integration.handler.advice.Message<java.lang.String> ) ; org.springframework.integration.handler.advice.Message<?> = org.springframework.integration.handler.advice.PollableChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.handler.advice.Message<> ) ; assertEquals ( STRING , ( ( MessagingException ) org.springframework.integration.handler.advice.Message<> . getPayload ( ) ) . getFailedMessage ( ) . getPayload ( ) ) ; assertEquals ( STRING , ( ( MessageHandlingExpressionEvaluatingAdviceException ) org.springframework.integration.handler.advice.Message<> . getPayload ( ) ) . getEvaluationResult ( ) ) ; org.springframework.integration.handler.advice.Message<?> = org.springframework.integration.handler.advice.QueueChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.handler.advice.Message<> ) ; assertEquals ( STRING , org.springframework.integration.handler.advice.Message<> . getPayload ( ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected java.lang.Object java.lang.Object ( Message < ? > org.springframework.integration.handler.advice.Message<?> ) { if ( java.util.concurrent.atomic.AtomicBoolean . boolean ( ) ) { throw new java.lang.RuntimeException ( STRING ) ; } return STRING ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected java.lang.Object java.lang.Object ( ExecutionCallback org.springframework.integration.handler.advice.ExecutionCallback , java.lang.Object java.lang.Object , Message < ? > org.springframework.integration.handler.advice.Message<?> ) throws java.lang.Exception { java.util.concurrent.atomic.AtomicReference<java.lang.String> . void ( ( ( AbstractReplyProducingMessageHandler . AbstractReplyProducingMessageHandler ) java.lang.Object ) . getAdvisedHandler ( ) . getComponentName ( ) ) ; return org.springframework.integration.handler.advice.ExecutionCallback . execute ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { final java.util.concurrent.atomic.AtomicBoolean java.util.concurrent.atomic.AtomicBoolean = new java.util.concurrent.atomic.AtomicBoolean ( ) ; AbstractReplyProducingMessageHandler org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler = new AbstractReplyProducingMessageHandler ( ) { @ java.lang.Override protected java.lang.Object java.lang.Object ( Message < ? > org.springframework.integration.handler.advice.Message<?> ) { if ( java.util.concurrent.atomic.AtomicBoolean . boolean ( ) ) { throw new java.lang.RuntimeException ( STRING ) ; } return STRING ; } } ; QueueChannel org.springframework.integration.handler.advice.QueueChannel = new QueueChannel ( ) ; org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . setOutputChannel ( org.springframework.integration.handler.advice.QueueChannel ) ; Message < java.lang.String > org.springframework.integration.handler.advice.Message<java.lang.String> = new GenericMessage < java.lang.String > ( STRING ) ; PollableChannel org.springframework.integration.handler.advice.PollableChannel = new QueueChannel ( ) ; PollableChannel org.springframework.integration.handler.advice.PollableChannel = new QueueChannel ( ) ; ExpressionEvaluatingRequestHandlerAdvice org.springframework.integration.handler.advice.ExpressionEvaluatingRequestHandlerAdvice = new ExpressionEvaluatingRequestHandlerAdvice ( ) ; org.springframework.integration.handler.advice.ExpressionEvaluatingRequestHandlerAdvice . setBeanFactory ( mock ( BeanFactory .class ) ) ; org.springframework.integration.handler.advice.ExpressionEvaluatingRequestHandlerAdvice . setSuccessChannel ( org.springframework.integration.handler.advice.PollableChannel ) ; org.springframework.integration.handler.advice.ExpressionEvaluatingRequestHandlerAdvice . setFailureChannel ( org.springframework.integration.handler.advice.PollableChannel ) ; org.springframework.integration.handler.advice.ExpressionEvaluatingRequestHandlerAdvice . setOnSuccessExpressionString ( STRING ) ; org.springframework.integration.handler.advice.ExpressionEvaluatingRequestHandlerAdvice . setOnFailureExpressionString ( STRING ) ; java.util.List<org.springframework.integration.handler.advice.Advice> < Advice > java.util.List<org.springframework.integration.handler.advice.Advice> = new java.util.ArrayList<org.springframework.integration.handler.advice.Advice> < Advice > ( ) ; java.util.List<org.springframework.integration.handler.advice.Advice> . add ( org.springframework.integration.handler.advice.ExpressionEvaluatingRequestHandlerAdvice ) ; org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . setAdviceChain ( java.util.List<org.springframework.integration.handler.advice.Advice> ) ; org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . setBeanFactory ( mock ( BeanFactory .class ) ) ; org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . afterPropertiesSet ( ) ; org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . handleMessage ( org.springframework.integration.handler.advice.Message<java.lang.String> ) ; Message < ? > org.springframework.integration.handler.advice.Message<?> = org.springframework.integration.handler.advice.QueueChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.handler.advice.Message<> ) ; assertEquals ( STRING , org.springframework.integration.handler.advice.Message<> . getPayload ( ) ) ; Message < ? > org.springframework.integration.handler.advice.Message<?> = org.springframework.integration.handler.advice.PollableChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.handler.advice.Message<> ) ; assertEquals ( STRING , ( ( AdviceMessage < ? > ) org.springframework.integration.handler.advice.Message<> ) . getInputMessage ( ) . getPayload ( ) ) ; assertEquals ( java.lang.ArithmeticException .class , org.springframework.integration.handler.advice.Message<> . getPayload ( ) . getClass ( ) ) ; assertEquals ( STRING , ( ( java.lang.Exception ) org.springframework.integration.handler.advice.Message<> . getPayload ( ) ) . java.lang.String ( ) ) ; org.springframework.integration.handler.advice.ExpressionEvaluatingRequestHandlerAdvice . setPropagateEvaluationFailures ( true ) ; try { org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . handleMessage ( org.springframework.integration.handler.advice.Message<java.lang.String> ) ; fail ( STRING ) ; } catch ( MessageHandlingException org.springframework.integration.handler.advice.MessageHandlingException ) { assertEquals ( STRING , org.springframework.integration.handler.advice.MessageHandlingException . getCause ( ) . getMessage ( ) ) ; } org.springframework.integration.handler.advice.Message<?> = org.springframework.integration.handler.advice.QueueChannel . receive ( NUMBER ) ; assertNull ( org.springframework.integration.handler.advice.Message<> ) ; org.springframework.integration.handler.advice.Message<?> = org.springframework.integration.handler.advice.PollableChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.handler.advice.Message<> ) ; assertEquals ( STRING , ( ( AdviceMessage < ? > ) org.springframework.integration.handler.advice.Message<> ) . getInputMessage ( ) . getPayload ( ) ) ; assertEquals ( java.lang.ArithmeticException .class , org.springframework.integration.handler.advice.Message<> . getPayload ( ) . getClass ( ) ) ; assertEquals ( STRING , ( ( java.lang.Exception ) org.springframework.integration.handler.advice.Message<> . getPayload ( ) ) . java.lang.String ( ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected java.lang.Object java.lang.Object ( Message < ? > org.springframework.integration.handler.advice.Message<?> ) { if ( java.util.concurrent.atomic.AtomicBoolean . boolean ( ) ) { throw new java.lang.RuntimeException ( STRING ) ; } return STRING ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { final java.util.concurrent.atomic.AtomicBoolean java.util.concurrent.atomic.AtomicBoolean = new java.util.concurrent.atomic.AtomicBoolean ( true ) ; AbstractReplyProducingMessageHandler org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler = new AbstractReplyProducingMessageHandler ( ) { @ java.lang.Override protected java.lang.Object java.lang.Object ( Message < ? > org.springframework.integration.handler.advice.Message<?> ) { if ( java.util.concurrent.atomic.AtomicBoolean . boolean ( ) ) { throw new java.lang.RuntimeException ( STRING ) ; } return STRING ; } } ; QueueChannel org.springframework.integration.handler.advice.QueueChannel = new QueueChannel ( ) ; org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . setOutputChannel ( org.springframework.integration.handler.advice.QueueChannel ) ; Message < java.lang.String > org.springframework.integration.handler.advice.Message<java.lang.String> = new GenericMessage < java.lang.String > ( STRING ) ; PollableChannel org.springframework.integration.handler.advice.PollableChannel = new QueueChannel ( ) ; PollableChannel org.springframework.integration.handler.advice.PollableChannel = new QueueChannel ( ) ; ExpressionEvaluatingRequestHandlerAdvice org.springframework.integration.handler.advice.ExpressionEvaluatingRequestHandlerAdvice = new ExpressionEvaluatingRequestHandlerAdvice ( ) ; org.springframework.integration.handler.advice.ExpressionEvaluatingRequestHandlerAdvice . setBeanFactory ( mock ( BeanFactory .class ) ) ; org.springframework.integration.handler.advice.ExpressionEvaluatingRequestHandlerAdvice . setSuccessChannel ( org.springframework.integration.handler.advice.PollableChannel ) ; org.springframework.integration.handler.advice.ExpressionEvaluatingRequestHandlerAdvice . setFailureChannel ( org.springframework.integration.handler.advice.PollableChannel ) ; org.springframework.integration.handler.advice.ExpressionEvaluatingRequestHandlerAdvice . setOnSuccessExpressionString ( STRING ) ; org.springframework.integration.handler.advice.ExpressionEvaluatingRequestHandlerAdvice . setOnFailureExpressionString ( STRING ) ; java.util.List<org.springframework.integration.handler.advice.Advice> < Advice > java.util.List<org.springframework.integration.handler.advice.Advice> = new java.util.ArrayList<org.springframework.integration.handler.advice.Advice> < Advice > ( ) ; java.util.List<org.springframework.integration.handler.advice.Advice> . add ( org.springframework.integration.handler.advice.ExpressionEvaluatingRequestHandlerAdvice ) ; org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . setAdviceChain ( java.util.List<org.springframework.integration.handler.advice.Advice> ) ; org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . setBeanFactory ( mock ( BeanFactory .class ) ) ; org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . afterPropertiesSet ( ) ; try { org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . handleMessage ( org.springframework.integration.handler.advice.Message<java.lang.String> ) ; fail ( STRING ) ; } catch ( java.lang.Exception java.lang.Exception ) { assertEquals ( STRING , java.lang.Exception . java.lang.Throwable ( ) . java.lang.String ( ) ) ; } Message < ? > org.springframework.integration.handler.advice.Message<?> = org.springframework.integration.handler.advice.QueueChannel . receive ( NUMBER ) ; assertNull ( org.springframework.integration.handler.advice.Message<> ) ; Message < ? > org.springframework.integration.handler.advice.Message<?> = org.springframework.integration.handler.advice.PollableChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.handler.advice.Message<> ) ; assertEquals ( STRING , ( ( MessagingException ) org.springframework.integration.handler.advice.Message<> . getPayload ( ) ) . getFailedMessage ( ) . getPayload ( ) ) ; assertEquals ( MessageHandlingExpressionEvaluatingAdviceException .class , org.springframework.integration.handler.advice.Message<> . getPayload ( ) . getClass ( ) ) ; assertEquals ( STRING , ( ( java.lang.Exception ) org.springframework.integration.handler.advice.Message<> . getPayload ( ) ) . java.lang.Throwable ( ) . java.lang.String ( ) ) ; org.springframework.integration.handler.advice.ExpressionEvaluatingRequestHandlerAdvice . setPropagateEvaluationFailures ( true ) ; try { org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . handleMessage ( org.springframework.integration.handler.advice.Message<java.lang.String> ) ; fail ( STRING ) ; } catch ( MessageHandlingException org.springframework.integration.handler.advice.MessageHandlingException ) { assertEquals ( STRING , org.springframework.integration.handler.advice.MessageHandlingException . getCause ( ) . getMessage ( ) ) ; } org.springframework.integration.handler.advice.Message<?> = org.springframework.integration.handler.advice.QueueChannel . receive ( NUMBER ) ; assertNull ( org.springframework.integration.handler.advice.Message<> ) ; org.springframework.integration.handler.advice.Message<?> = org.springframework.integration.handler.advice.PollableChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.handler.advice.Message<> ) ; assertEquals ( STRING , ( ( MessagingException ) org.springframework.integration.handler.advice.Message<> . getPayload ( ) ) . getFailedMessage ( ) . getPayload ( ) ) ; assertEquals ( MessageHandlingExpressionEvaluatingAdviceException .class , org.springframework.integration.handler.advice.Message<> . getPayload ( ) . getClass ( ) ) ; assertEquals ( STRING , ( ( java.lang.Exception ) org.springframework.integration.handler.advice.Message<> . getPayload ( ) ) . java.lang.Throwable ( ) . java.lang.String ( ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected java.lang.Object java.lang.Object ( Message < ? > org.springframework.integration.handler.advice.Message<?> ) { if ( java.util.concurrent.atomic.AtomicBoolean . boolean ( ) ) { throw new java.lang.RuntimeException ( STRING ) ; } return STRING ; }  <METHOD_END>
<METHOD_START> @ Test @ java.lang.SuppressWarnings ( STRING ) public void void ( ) java.lang.Exception { final java.util.concurrent.atomic.AtomicBoolean java.util.concurrent.atomic.AtomicBoolean = new java.util.concurrent.atomic.AtomicBoolean ( ) ; AbstractReplyProducingMessageHandler org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler = new AbstractReplyProducingMessageHandler ( ) { @ java.lang.Override protected java.lang.Object java.lang.Object ( Message < ? > org.springframework.integration.handler.advice.Message<?> ) { if ( java.util.concurrent.atomic.AtomicBoolean . boolean ( ) ) { throw new java.lang.RuntimeException ( STRING ) ; } return STRING ; } } ; org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . setBeanName ( STRING ) ; org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . setOutputChannel ( new QueueChannel ( ) ) ; RequestHandlerCircuitBreakerAdvice org.springframework.integration.handler.advice.RequestHandlerCircuitBreakerAdvice = new RequestHandlerCircuitBreakerAdvice ( ) ; org.springframework.integration.handler.advice.RequestHandlerCircuitBreakerAdvice . setThreshold ( NUMBER ) ; org.springframework.integration.handler.advice.RequestHandlerCircuitBreakerAdvice . setHalfOpenAfter ( NUMBER ) ; java.util.List<org.springframework.integration.handler.advice.Advice> < Advice > java.util.List<org.springframework.integration.handler.advice.Advice> = new java.util.ArrayList<org.springframework.integration.handler.advice.Advice> < Advice > ( ) ; java.util.List<org.springframework.integration.handler.advice.Advice> . add ( org.springframework.integration.handler.advice.RequestHandlerCircuitBreakerAdvice ) ; org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . setAdviceChain ( java.util.List<org.springframework.integration.handler.advice.Advice> ) ; org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . setBeanFactory ( mock ( BeanFactory .class ) ) ; org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . afterPropertiesSet ( ) ; java.util.concurrent.atomic.AtomicBoolean . void ( true ) ; Message < java.lang.String > org.springframework.integration.handler.advice.Message<java.lang.String> = new GenericMessage < java.lang.String > ( STRING ) ; try { org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . handleMessage ( org.springframework.integration.handler.advice.Message<java.lang.String> ) ; fail ( STRING ) ; } catch ( java.lang.Exception java.lang.Exception ) { assertEquals ( STRING , java.lang.Exception . java.lang.Throwable ( ) . java.lang.String ( ) ) ; } try { org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . handleMessage ( org.springframework.integration.handler.advice.Message<java.lang.String> ) ; fail ( STRING ) ; } catch ( java.lang.Exception java.lang.Exception ) { assertEquals ( STRING , java.lang.Exception . java.lang.Throwable ( ) . java.lang.String ( ) ) ; } try { org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . handleMessage ( org.springframework.integration.handler.advice.Message<java.lang.String> ) ; fail ( STRING ) ; } catch ( java.lang.Exception java.lang.Exception ) { assertEquals ( STRING , java.lang.Exception . java.lang.Throwable ( ) . java.lang.String ( ) ) ; } java.util.Map java.util.Map = TestUtils . getPropertyValue ( org.springframework.integration.handler.advice.RequestHandlerCircuitBreakerAdvice , STRING , java.util.Map .class ) ; java.lang.Object java.lang.Object = java.util.Map . java.util.Collection ( ) . java.util.Iterator ( ) . java.lang.Object ( ) ; DirectFieldAccessor org.springframework.integration.handler.advice.DirectFieldAccessor = new DirectFieldAccessor ( java.lang.Object ) ; org.springframework.integration.handler.advice.DirectFieldAccessor . setPropertyValue ( STRING , java.lang.System . long ( ) - NUMBER ) ; try { org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . handleMessage ( org.springframework.integration.handler.advice.Message<java.lang.String> ) ; fail ( STRING ) ; } catch ( java.lang.Exception java.lang.Exception ) { assertEquals ( STRING , java.lang.Exception . java.lang.Throwable ( ) . java.lang.String ( ) ) ; } try { org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . handleMessage ( org.springframework.integration.handler.advice.Message<java.lang.String> ) ; fail ( STRING ) ; } catch ( java.lang.Exception java.lang.Exception ) { assertEquals ( STRING , java.lang.Exception . java.lang.Throwable ( ) . java.lang.String ( ) ) ; } org.springframework.integration.handler.advice.DirectFieldAccessor . setPropertyValue ( STRING , java.lang.System . long ( ) - NUMBER ) ; java.util.concurrent.atomic.AtomicBoolean . void ( false ) ; org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . handleMessage ( org.springframework.integration.handler.advice.Message<java.lang.String> ) ; java.util.concurrent.atomic.AtomicBoolean . void ( true ) ; try { org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . handleMessage ( org.springframework.integration.handler.advice.Message<java.lang.String> ) ; fail ( STRING ) ; } catch ( java.lang.Exception java.lang.Exception ) { assertEquals ( STRING , java.lang.Exception . java.lang.Throwable ( ) . java.lang.String ( ) ) ; } try { org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . handleMessage ( org.springframework.integration.handler.advice.Message<java.lang.String> ) ; fail ( STRING ) ; } catch ( java.lang.Exception java.lang.Exception ) { assertEquals ( STRING , java.lang.Exception . java.lang.Throwable ( ) . java.lang.String ( ) ) ; } try { org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . handleMessage ( org.springframework.integration.handler.advice.Message<java.lang.String> ) ; fail ( STRING ) ; } catch ( java.lang.Exception java.lang.Exception ) { assertEquals ( STRING , java.lang.Exception . java.lang.Throwable ( ) . java.lang.String ( ) ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected java.lang.Object java.lang.Object ( Message < ? > org.springframework.integration.handler.advice.Message<?> ) { if ( java.util.concurrent.atomic.AtomicBoolean . boolean ( ) ) { throw new java.lang.RuntimeException ( STRING ) ; } return STRING ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { final java.util.concurrent.atomic.AtomicInteger java.util.concurrent.atomic.AtomicInteger = new java.util.concurrent.atomic.AtomicInteger ( NUMBER ) ; AbstractReplyProducingMessageHandler org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler = new AbstractReplyProducingMessageHandler ( ) { @ java.lang.Override protected java.lang.Object java.lang.Object ( Message < ? > org.springframework.integration.handler.advice.Message<?> ) { if ( java.util.concurrent.atomic.AtomicInteger . int ( ) > NUMBER ) { throw new java.lang.RuntimeException ( STRING ) ; } return STRING ; } } ; QueueChannel org.springframework.integration.handler.advice.QueueChannel = new QueueChannel ( ) ; org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . setOutputChannel ( org.springframework.integration.handler.advice.QueueChannel ) ; RequestHandlerRetryAdvice org.springframework.integration.handler.advice.RequestHandlerRetryAdvice = new RequestHandlerRetryAdvice ( ) ; java.util.List<org.springframework.integration.handler.advice.Advice> < Advice > java.util.List<org.springframework.integration.handler.advice.Advice> = new java.util.ArrayList<org.springframework.integration.handler.advice.Advice> < Advice > ( ) ; java.util.List<org.springframework.integration.handler.advice.Advice> . add ( org.springframework.integration.handler.advice.RequestHandlerRetryAdvice ) ; org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . setAdviceChain ( java.util.List<org.springframework.integration.handler.advice.Advice> ) ; org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . setBeanFactory ( mock ( BeanFactory .class ) ) ; org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . afterPropertiesSet ( ) ; Message < java.lang.String > org.springframework.integration.handler.advice.Message<java.lang.String> = new GenericMessage < java.lang.String > ( STRING ) ; org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . handleMessage ( org.springframework.integration.handler.advice.Message<java.lang.String> ) ; assertTrue ( java.util.concurrent.atomic.AtomicInteger . int ( ) == - NUMBER ) ; Message < ? > org.springframework.integration.handler.advice.Message<?> = org.springframework.integration.handler.advice.QueueChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.handler.advice.Message<> ) ; assertEquals ( STRING , org.springframework.integration.handler.advice.Message<> . getPayload ( ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected java.lang.Object java.lang.Object ( Message < ? > org.springframework.integration.handler.advice.Message<?> ) { if ( java.util.concurrent.atomic.AtomicInteger . int ( ) > NUMBER ) { throw new java.lang.RuntimeException ( STRING ) ; } return STRING ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { final java.util.concurrent.atomic.AtomicInteger java.util.concurrent.atomic.AtomicInteger = new java.util.concurrent.atomic.AtomicInteger ( NUMBER ) ; AbstractReplyProducingMessageHandler org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler = new AbstractReplyProducingMessageHandler ( ) { @ java.lang.Override protected java.lang.Object java.lang.Object ( Message < ? > org.springframework.integration.handler.advice.Message<?> ) { if ( java.util.concurrent.atomic.AtomicInteger . int ( ) > NUMBER ) { throw new java.lang.RuntimeException ( STRING ) ; } return STRING ; } } ; QueueChannel org.springframework.integration.handler.advice.QueueChannel = new QueueChannel ( ) ; org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . setOutputChannel ( org.springframework.integration.handler.advice.QueueChannel ) ; RequestHandlerRetryAdvice org.springframework.integration.handler.advice.RequestHandlerRetryAdvice = new RequestHandlerRetryAdvice ( ) ; org.springframework.integration.handler.advice.RequestHandlerRetryAdvice . setRetryStateGenerator ( message -> new DefaultRetryState ( message . getHeaders ( ) . getId ( ) ) ) ; java.util.List<org.springframework.integration.handler.advice.Advice> < Advice > java.util.List<org.springframework.integration.handler.advice.Advice> = new java.util.ArrayList<org.springframework.integration.handler.advice.Advice> < Advice > ( ) ; java.util.List<org.springframework.integration.handler.advice.Advice> . add ( org.springframework.integration.handler.advice.RequestHandlerRetryAdvice ) ; org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . setAdviceChain ( java.util.List<org.springframework.integration.handler.advice.Advice> ) ; org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . setBeanFactory ( mock ( BeanFactory .class ) ) ; org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . afterPropertiesSet ( ) ; Message < java.lang.String > org.springframework.integration.handler.advice.Message<java.lang.String> = new GenericMessage < java.lang.String > ( STRING ) ; for ( int int = NUMBER ; int < NUMBER ; int ++ ) { try { org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . handleMessage ( org.springframework.integration.handler.advice.Message<java.lang.String> ) ; } catch ( java.lang.Exception java.lang.Exception ) { assertTrue ( int < NUMBER ) ; } } assertTrue ( java.util.concurrent.atomic.AtomicInteger . int ( ) == - NUMBER ) ; Message < ? > org.springframework.integration.handler.advice.Message<?> = org.springframework.integration.handler.advice.QueueChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.handler.advice.Message<> ) ; assertEquals ( STRING , org.springframework.integration.handler.advice.Message<> . getPayload ( ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected java.lang.Object java.lang.Object ( Message < ? > org.springframework.integration.handler.advice.Message<?> ) { if ( java.util.concurrent.atomic.AtomicInteger . int ( ) > NUMBER ) { throw new java.lang.RuntimeException ( STRING ) ; } return STRING ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { final java.util.concurrent.atomic.AtomicInteger java.util.concurrent.atomic.AtomicInteger = new java.util.concurrent.atomic.AtomicInteger ( NUMBER ) ; AbstractReplyProducingMessageHandler org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler = new AbstractReplyProducingMessageHandler ( ) { @ java.lang.Override protected java.lang.Object java.lang.Object ( Message < ? > org.springframework.integration.handler.advice.Message<?> ) { if ( java.util.concurrent.atomic.AtomicInteger . int ( ) > NUMBER ) { throw new java.lang.RuntimeException ( STRING ) ; } return STRING ; } } ; QueueChannel org.springframework.integration.handler.advice.QueueChannel = new QueueChannel ( ) ; org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . setOutputChannel ( org.springframework.integration.handler.advice.QueueChannel ) ; RequestHandlerRetryAdvice org.springframework.integration.handler.advice.RequestHandlerRetryAdvice = new RequestHandlerRetryAdvice ( ) ; org.springframework.integration.handler.advice.RequestHandlerRetryAdvice . setRetryStateGenerator ( message -> new DefaultRetryState ( message . getHeaders ( ) . getId ( ) ) ) ; void ( java.util.concurrent.atomic.AtomicInteger , org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler , org.springframework.integration.handler.advice.QueueChannel , org.springframework.integration.handler.advice.RequestHandlerRetryAdvice ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected java.lang.Object java.lang.Object ( Message < ? > org.springframework.integration.handler.advice.Message<?> ) { if ( java.util.concurrent.atomic.AtomicInteger . int ( ) > NUMBER ) { throw new java.lang.RuntimeException ( STRING ) ; } return STRING ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { final java.util.concurrent.atomic.AtomicInteger java.util.concurrent.atomic.AtomicInteger = new java.util.concurrent.atomic.AtomicInteger ( NUMBER ) ; AbstractReplyProducingMessageHandler org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler = new AbstractReplyProducingMessageHandler ( ) { @ java.lang.Override protected java.lang.Object java.lang.Object ( Message < ? > org.springframework.integration.handler.advice.Message<?> ) { if ( java.util.concurrent.atomic.AtomicInteger . int ( ) > NUMBER ) { throw new java.lang.RuntimeException ( STRING ) ; } return STRING ; } } ; QueueChannel org.springframework.integration.handler.advice.QueueChannel = new QueueChannel ( ) ; org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . setOutputChannel ( org.springframework.integration.handler.advice.QueueChannel ) ; RequestHandlerRetryAdvice org.springframework.integration.handler.advice.RequestHandlerRetryAdvice = new RequestHandlerRetryAdvice ( ) ; org.springframework.integration.handler.advice.RequestHandlerRetryAdvice . setRetryStateGenerator ( new SpelExpressionRetryStateGenerator ( STRING ) ) ; void ( java.util.concurrent.atomic.AtomicInteger , org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler , org.springframework.integration.handler.advice.QueueChannel , org.springframework.integration.handler.advice.RequestHandlerRetryAdvice ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected java.lang.Object java.lang.Object ( Message < ? > org.springframework.integration.handler.advice.Message<?> ) { if ( java.util.concurrent.atomic.AtomicInteger . int ( ) > NUMBER ) { throw new java.lang.RuntimeException ( STRING ) ; } return STRING ; }  <METHOD_END>
<METHOD_START> private void void ( final java.util.concurrent.atomic.AtomicInteger java.util.concurrent.atomic.AtomicInteger , AbstractReplyProducingMessageHandler org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler , QueueChannel org.springframework.integration.handler.advice.QueueChannel , RequestHandlerRetryAdvice org.springframework.integration.handler.advice.RequestHandlerRetryAdvice ) { org.springframework.integration.handler.advice.RequestHandlerRetryAdvice . setRecoveryCallback ( context -> STRING ) ; java.util.List<org.springframework.integration.handler.advice.Advice> < Advice > java.util.List<org.springframework.integration.handler.advice.Advice> = new java.util.ArrayList<org.springframework.integration.handler.advice.Advice> < Advice > ( ) ; java.util.List<org.springframework.integration.handler.advice.Advice> . add ( org.springframework.integration.handler.advice.RequestHandlerRetryAdvice ) ; org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . setAdviceChain ( java.util.List<org.springframework.integration.handler.advice.Advice> ) ; org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . setBeanFactory ( mock ( BeanFactory .class ) ) ; org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . afterPropertiesSet ( ) ; Message < java.lang.String > org.springframework.integration.handler.advice.Message<java.lang.String> = new GenericMessage < java.lang.String > ( STRING ) ; for ( int int = NUMBER ; int < NUMBER ; int ++ ) { try { org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . handleMessage ( org.springframework.integration.handler.advice.Message<java.lang.String> ) ; } catch ( java.lang.Exception java.lang.Exception ) {			} } assertTrue ( java.util.concurrent.atomic.AtomicInteger . int ( ) == NUMBER ) ; Message < ? > org.springframework.integration.handler.advice.Message<?> = org.springframework.integration.handler.advice.QueueChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.handler.advice.Message<> ) ; assertEquals ( STRING , org.springframework.integration.handler.advice.Message<> . getPayload ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { AbstractReplyProducingMessageHandler org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler = new AbstractReplyProducingMessageHandler ( ) { @ java.lang.Override protected java.lang.Object java.lang.Object ( Message < ? > org.springframework.integration.handler.advice.Message<?> ) { throw new java.lang.RuntimeException ( STRING ) ; } } ; QueueChannel org.springframework.integration.handler.advice.QueueChannel = new QueueChannel ( ) ; RequestHandlerRetryAdvice org.springframework.integration.handler.advice.RequestHandlerRetryAdvice = new RequestHandlerRetryAdvice ( ) ; ErrorMessageSendingRecoverer org.springframework.integration.handler.advice.ErrorMessageSendingRecoverer = new ErrorMessageSendingRecoverer ( org.springframework.integration.handler.advice.QueueChannel ) ; org.springframework.integration.handler.advice.RequestHandlerRetryAdvice . setRecoveryCallback ( org.springframework.integration.handler.advice.ErrorMessageSendingRecoverer ) ; java.util.List<org.springframework.integration.handler.advice.Advice> < Advice > java.util.List<org.springframework.integration.handler.advice.Advice> = new java.util.ArrayList<org.springframework.integration.handler.advice.Advice> < Advice > ( ) ; java.util.List<org.springframework.integration.handler.advice.Advice> . add ( org.springframework.integration.handler.advice.RequestHandlerRetryAdvice ) ; org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . setAdviceChain ( java.util.List<org.springframework.integration.handler.advice.Advice> ) ; org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . setBeanFactory ( mock ( BeanFactory .class ) ) ; org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . afterPropertiesSet ( ) ; Message < java.lang.String > org.springframework.integration.handler.advice.Message<java.lang.String> = new GenericMessage < java.lang.String > ( STRING ) ; org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . handleMessage ( org.springframework.integration.handler.advice.Message<java.lang.String> ) ; Message < ? > org.springframework.integration.handler.advice.Message<?> = org.springframework.integration.handler.advice.QueueChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.handler.advice.Message<> ) ; assertEquals ( STRING , ( ( java.lang.Exception ) org.springframework.integration.handler.advice.Message<> . getPayload ( ) ) . java.lang.Throwable ( ) . java.lang.String ( ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected java.lang.Object java.lang.Object ( Message < ? > org.springframework.integration.handler.advice.Message<?> ) { throw new java.lang.RuntimeException ( STRING ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { AbstractReplyProducingMessageHandler org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler = new AbstractReplyProducingMessageHandler ( ) { @ java.lang.Override protected java.lang.Object java.lang.Object ( Message < ? > org.springframework.integration.handler.advice.Message<?> ) { throw new java.lang.RuntimeException ( STRING ) ; } } ; QueueChannel org.springframework.integration.handler.advice.QueueChannel = new QueueChannel ( ) ; RequestHandlerRetryAdvice org.springframework.integration.handler.advice.RequestHandlerRetryAdvice = new RequestHandlerRetryAdvice ( ) ; ErrorMessageSendingRecoverer org.springframework.integration.handler.advice.ErrorMessageSendingRecoverer = new ErrorMessageSendingRecoverer ( org.springframework.integration.handler.advice.QueueChannel ) ; org.springframework.integration.handler.advice.RequestHandlerRetryAdvice . setRecoveryCallback ( org.springframework.integration.handler.advice.ErrorMessageSendingRecoverer ) ; RetryTemplate org.springframework.integration.handler.advice.RetryTemplate = new RetryTemplate ( ) ; org.springframework.integration.handler.advice.RetryTemplate . setRetryPolicy ( new SimpleRetryPolicy ( ) { static final long long = - NUMBER ; @ java.lang.Override public boolean boolean ( RetryContext org.springframework.integration.handler.advice.RetryContext ) { return false ; } } ) ; org.springframework.integration.handler.advice.RequestHandlerRetryAdvice . setRetryTemplate ( org.springframework.integration.handler.advice.RetryTemplate ) ; org.springframework.integration.handler.advice.RequestHandlerRetryAdvice . setBeanFactory ( mock ( BeanFactory .class ) ) ; org.springframework.integration.handler.advice.RequestHandlerRetryAdvice . afterPropertiesSet ( ) ; java.util.List<org.springframework.integration.handler.advice.Advice> < Advice > java.util.List<org.springframework.integration.handler.advice.Advice> = new java.util.ArrayList<org.springframework.integration.handler.advice.Advice> < Advice > ( ) ; java.util.List<org.springframework.integration.handler.advice.Advice> . add ( org.springframework.integration.handler.advice.RequestHandlerRetryAdvice ) ; org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . setAdviceChain ( java.util.List<org.springframework.integration.handler.advice.Advice> ) ; org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . setBeanFactory ( mock ( BeanFactory .class ) ) ; org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . afterPropertiesSet ( ) ; Message < java.lang.String > org.springframework.integration.handler.advice.Message<java.lang.String> = new GenericMessage < java.lang.String > ( STRING ) ; org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . handleMessage ( org.springframework.integration.handler.advice.Message<java.lang.String> ) ; Message < ? > org.springframework.integration.handler.advice.Message<?> = org.springframework.integration.handler.advice.QueueChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.handler.advice.Message<> ) ; assertTrue ( org.springframework.integration.handler.advice.Message<> . getPayload ( ) instanceof ErrorMessageSendingRecoverer . ErrorMessageSendingRecoverer ) ; assertNotNull ( ( ( MessagingException ) org.springframework.integration.handler.advice.Message<> . getPayload ( ) ) . getFailedMessage ( ) ) ; assertSame ( org.springframework.integration.handler.advice.Message<java.lang.String> , ( ( MessagingException ) org.springframework.integration.handler.advice.Message<> . getPayload ( ) ) . getFailedMessage ( ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected java.lang.Object java.lang.Object ( Message < ? > org.springframework.integration.handler.advice.Message<?> ) { throw new java.lang.RuntimeException ( STRING ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( RetryContext org.springframework.integration.handler.advice.RetryContext ) { return false ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { final java.util.concurrent.atomic.AtomicInteger java.util.concurrent.atomic.AtomicInteger = new java.util.concurrent.atomic.AtomicInteger ( NUMBER ) ; AbstractReplyProducingMessageHandler org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler = new AbstractReplyProducingMessageHandler ( ) { @ java.lang.Override protected java.lang.Object java.lang.Object ( Message < ? > org.springframework.integration.handler.advice.Message<?> ) { return STRING ; } } ; java.util.List<org.springframework.integration.handler.advice.Advice> < Advice > java.util.List<org.springframework.integration.handler.advice.Advice> = new java.util.ArrayList<org.springframework.integration.handler.advice.Advice> < Advice > ( ) ; java.util.List<org.springframework.integration.handler.advice.Advice> . add ( new RequestHandlerRetryAdvice ( ) ) ; java.util.List<org.springframework.integration.handler.advice.Advice> . add ( ( MethodInterceptor ) invocation -> { counter . getAndDecrement ( ) ; throw new RuntimeException ( STRING ) ; } ) ; org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . setBeanFactory ( mock ( BeanFactory .class ) ) ; org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . setAdviceChain ( java.util.List<org.springframework.integration.handler.advice.Advice> ) ; org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . afterPropertiesSet ( ) ; try { org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . handleMessage ( new GenericMessage < java.lang.String > ( STRING ) ) ; } catch ( java.lang.Exception java.lang.Exception ) { java.lang.Throwable java.lang.Throwable = java.lang.Exception . java.lang.Throwable ( ) ; assertEquals ( java.lang.RuntimeException .class , java.lang.Throwable . java.lang.Class<? extends java.lang.Throwable> ( ) ) ; assertEquals ( STRING , java.lang.Throwable . java.lang.String ( ) ) ; } assertTrue ( java.util.concurrent.atomic.AtomicInteger . int ( ) == NUMBER ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected java.lang.Object java.lang.Object ( Message < ? > org.springframework.integration.handler.advice.Message<?> ) { return STRING ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { final java.util.concurrent.atomic.AtomicInteger java.util.concurrent.atomic.AtomicInteger = new java.util.concurrent.atomic.AtomicInteger ( NUMBER ) ; AbstractReplyProducingMessageHandler org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler = new AbstractReplyProducingMessageHandler ( ) { @ java.lang.Override protected java.lang.Object java.lang.Object ( Message < ? > org.springframework.integration.handler.advice.Message<?> ) { return STRING ; } } ; QueueChannel org.springframework.integration.handler.advice.QueueChannel = new QueueChannel ( ) ; org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . setOutputChannel ( org.springframework.integration.handler.advice.QueueChannel ) ; java.util.List<org.springframework.integration.handler.advice.Advice> < Advice > java.util.List<org.springframework.integration.handler.advice.Advice> = new java.util.ArrayList<org.springframework.integration.handler.advice.Advice> < Advice > ( ) ; ExpressionEvaluatingRequestHandlerAdvice org.springframework.integration.handler.advice.ExpressionEvaluatingRequestHandlerAdvice = new ExpressionEvaluatingRequestHandlerAdvice ( ) ; org.springframework.integration.handler.advice.ExpressionEvaluatingRequestHandlerAdvice . setBeanFactory ( mock ( BeanFactory .class ) ) ; org.springframework.integration.handler.advice.ExpressionEvaluatingRequestHandlerAdvice . setOnFailureExpressionString ( STRING ) ; org.springframework.integration.handler.advice.ExpressionEvaluatingRequestHandlerAdvice . setReturnFailureExpressionResult ( true ) ; final java.util.concurrent.atomic.AtomicInteger java.util.concurrent.atomic.AtomicInteger = new java.util.concurrent.atomic.AtomicInteger ( ) ; java.util.List<org.springframework.integration.handler.advice.Advice> . add ( new AbstractRequestHandlerAdvice ( ) { @ java.lang.Override protected java.lang.Object java.lang.Object ( ExecutionCallback org.springframework.integration.handler.advice.ExecutionCallback , java.lang.Object java.lang.Object , Message < ? > org.springframework.integration.handler.advice.Message<?> ) throws java.lang.Exception { java.util.concurrent.atomic.AtomicInteger . int ( ) ; return org.springframework.integration.handler.advice.ExecutionCallback . execute ( ) ; } } ) ; java.util.List<org.springframework.integration.handler.advice.Advice> . add ( org.springframework.integration.handler.advice.ExpressionEvaluatingRequestHandlerAdvice ) ; java.util.List<org.springframework.integration.handler.advice.Advice> . add ( new RequestHandlerRetryAdvice ( ) ) ; java.util.List<org.springframework.integration.handler.advice.Advice> . add ( ( MethodInterceptor ) invocation -> { throw new RuntimeException ( STRING + counter . incrementAndGet ( ) ) ; } ) ; org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . setAdviceChain ( java.util.List<org.springframework.integration.handler.advice.Advice> ) ; org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . setBeanFactory ( mock ( BeanFactory .class ) ) ; org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . afterPropertiesSet ( ) ; org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . handleMessage ( new GenericMessage < java.lang.String > ( STRING ) ) ; Message < ? > org.springframework.integration.handler.advice.Message<?> = org.springframework.integration.handler.advice.QueueChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.handler.advice.Message<> ) ; assertEquals ( STRING , org.springframework.integration.handler.advice.Message<> . getPayload ( ) ) ; assertEquals ( NUMBER , java.util.concurrent.atomic.AtomicInteger . int ( ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected java.lang.Object java.lang.Object ( Message < ? > org.springframework.integration.handler.advice.Message<?> ) { return STRING ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected java.lang.Object java.lang.Object ( ExecutionCallback org.springframework.integration.handler.advice.ExecutionCallback , java.lang.Object java.lang.Object , Message < ? > org.springframework.integration.handler.advice.Message<?> ) throws java.lang.Exception { java.util.concurrent.atomic.AtomicInteger . int ( ) ; return org.springframework.integration.handler.advice.ExecutionCallback . execute ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { final java.util.concurrent.atomic.AtomicInteger java.util.concurrent.atomic.AtomicInteger = new java.util.concurrent.atomic.AtomicInteger ( NUMBER ) ; AbstractReplyProducingMessageHandler org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler = new AbstractReplyProducingMessageHandler ( ) { @ java.lang.Override protected java.lang.Object java.lang.Object ( Message < ? > org.springframework.integration.handler.advice.Message<?> ) { return STRING ; } } ; QueueChannel org.springframework.integration.handler.advice.QueueChannel = new QueueChannel ( ) ; java.util.List<org.springframework.integration.handler.advice.Advice> < Advice > java.util.List<org.springframework.integration.handler.advice.Advice> = new java.util.ArrayList<org.springframework.integration.handler.advice.Advice> < Advice > ( ) ; ExpressionEvaluatingRequestHandlerAdvice org.springframework.integration.handler.advice.ExpressionEvaluatingRequestHandlerAdvice = new ExpressionEvaluatingRequestHandlerAdvice ( ) ; org.springframework.integration.handler.advice.ExpressionEvaluatingRequestHandlerAdvice . setBeanFactory ( mock ( BeanFactory .class ) ) ; org.springframework.integration.handler.advice.ExpressionEvaluatingRequestHandlerAdvice . setOnFailureExpressionString ( STRING ) ; org.springframework.integration.handler.advice.ExpressionEvaluatingRequestHandlerAdvice . setFailureChannel ( org.springframework.integration.handler.advice.QueueChannel ) ; java.util.List<org.springframework.integration.handler.advice.Advice> . add ( new RequestHandlerRetryAdvice ( ) ) ; java.util.List<org.springframework.integration.handler.advice.Advice> . add ( org.springframework.integration.handler.advice.ExpressionEvaluatingRequestHandlerAdvice ) ; java.util.List<org.springframework.integration.handler.advice.Advice> . add ( ( MethodInterceptor ) invocation -> { throw new RuntimeException ( STRING + counter . incrementAndGet ( ) ) ; } ) ; org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . setAdviceChain ( java.util.List<org.springframework.integration.handler.advice.Advice> ) ; org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . setBeanFactory ( mock ( BeanFactory .class ) ) ; org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . afterPropertiesSet ( ) ; try { org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . handleMessage ( new GenericMessage < java.lang.String > ( STRING ) ) ; } catch ( java.lang.Exception java.lang.Exception ) { assertEquals ( STRING , java.lang.Exception . java.lang.Throwable ( ) . java.lang.String ( ) ) ; } for ( int int = NUMBER ; int <= NUMBER ; int ++ ) { Message < ? > org.springframework.integration.handler.advice.Message<?> = org.springframework.integration.handler.advice.QueueChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.handler.advice.Message<> ) ; assertEquals ( STRING + int , ( ( MessageHandlingExpressionEvaluatingAdviceException ) org.springframework.integration.handler.advice.Message<> . getPayload ( ) ) . getEvaluationResult ( ) ) ; } assertNull ( org.springframework.integration.handler.advice.QueueChannel . receive ( NUMBER ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected java.lang.Object java.lang.Object ( Message < ? > org.springframework.integration.handler.advice.Message<?> ) { return STRING ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { AbstractRequestHandlerAdvice org.springframework.integration.handler.advice.AbstractRequestHandlerAdvice = new AbstractRequestHandlerAdvice ( ) { @ java.lang.Override protected java.lang.Object java.lang.Object ( ExecutionCallback org.springframework.integration.handler.advice.ExecutionCallback , java.lang.Object java.lang.Object , Message < ? > org.springframework.integration.handler.advice.Message<?> ) throws java.lang.Exception { java.lang.Object java.lang.Object ; try { java.lang.Object = org.springframework.integration.handler.advice.ExecutionCallback . execute ( ) ; } catch ( java.lang.Exception java.lang.Exception ) { throw this . unwrapExceptionIfNecessary ( java.lang.Exception ) ; } return java.lang.Object ; } } ; final java.lang.Throwable java.lang.Throwable = new java.lang.Throwable ( STRING ) ; MethodInvocation org.springframework.integration.handler.advice.MethodInvocation = mock ( MethodInvocation .class ) ; java.lang.reflect.Method java.lang.reflect.Method = AbstractReplyProducingMessageHandler .class . java.lang.reflect.Method ( STRING , Message .class ) ; when ( org.springframework.integration.handler.advice.MethodInvocation . getMethod ( ) ) . thenReturn ( java.lang.reflect.Method ) ; when ( org.springframework.integration.handler.advice.MethodInvocation . getArguments ( ) ) . thenReturn ( new java.lang.Object [] { new GenericMessage < java.lang.String > ( STRING ) } ) ; try { doAnswer ( invocation -> { throw theThrowable ; } ) . when ( org.springframework.integration.handler.advice.MethodInvocation ) . proceed ( ) ; org.springframework.integration.handler.advice.AbstractRequestHandlerAdvice . invoke ( org.springframework.integration.handler.advice.MethodInvocation ) ; fail ( STRING ) ; } catch ( java.lang.Throwable java.lang.Throwable ) { assertSame ( java.lang.Throwable , java.lang.Throwable ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected java.lang.Object java.lang.Object ( ExecutionCallback org.springframework.integration.handler.advice.ExecutionCallback , java.lang.Object java.lang.Object , Message < ? > org.springframework.integration.handler.advice.Message<?> ) throws java.lang.Exception { java.lang.Object java.lang.Object ; try { java.lang.Object = org.springframework.integration.handler.advice.ExecutionCallback . execute ( ) ; } catch ( java.lang.Exception java.lang.Exception ) { throw this . unwrapExceptionIfNecessary ( java.lang.Exception ) ; } return java.lang.Object ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { QueueChannel org.springframework.integration.handler.advice.QueueChannel = new QueueChannel ( ) ; ExpressionEvaluatingRequestHandlerAdvice org.springframework.integration.handler.advice.ExpressionEvaluatingRequestHandlerAdvice = new ExpressionEvaluatingRequestHandlerAdvice ( ) ; org.springframework.integration.handler.advice.ExpressionEvaluatingRequestHandlerAdvice . setBeanFactory ( mock ( BeanFactory .class ) ) ; org.springframework.integration.handler.advice.ExpressionEvaluatingRequestHandlerAdvice . setOnFailureExpressionString ( STRING ) ; org.springframework.integration.handler.advice.ExpressionEvaluatingRequestHandlerAdvice . setFailureChannel ( org.springframework.integration.handler.advice.QueueChannel ) ; java.lang.Throwable java.lang.Throwable = new java.lang.Throwable ( STRING ) ; ProxyFactory org.springframework.integration.handler.advice.ProxyFactory = new ProxyFactory ( new org.springframework.integration.handler.advice.AdvisedMessageHandlerTests.Foo ( java.lang.Throwable ) ) ; org.springframework.integration.handler.advice.ProxyFactory . addAdvice ( org.springframework.integration.handler.advice.ExpressionEvaluatingRequestHandlerAdvice ) ; org.springframework.integration.handler.advice.AdvisedMessageHandlerTests.Bar org.springframework.integration.handler.advice.AdvisedMessageHandlerTests.Bar = ( org.springframework.integration.handler.advice.AdvisedMessageHandlerTests.Bar ) org.springframework.integration.handler.advice.ProxyFactory . getProxy ( ) ; try { org.springframework.integration.handler.advice.AdvisedMessageHandlerTests.Bar . java.lang.Object ( new GenericMessage < java.lang.String > ( STRING ) ) ; fail ( STRING ) ; } catch ( java.lang.Throwable java.lang.Throwable ) { assertSame ( java.lang.Throwable , java.lang.Throwable ) ; ErrorMessage org.springframework.integration.handler.advice.ErrorMessage = ( ErrorMessage ) org.springframework.integration.handler.advice.QueueChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.handler.advice.ErrorMessage ) ; assertSame ( java.lang.Throwable , org.springframework.integration.handler.advice.ErrorMessage . getPayload ( ) . getCause ( ) ) ; } }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final java.util.concurrent.atomic.AtomicBoolean java.util.concurrent.atomic.AtomicBoolean = new java.util.concurrent.atomic.AtomicBoolean ( false ) ; Advice org.springframework.integration.handler.advice.Advice = new AbstractRequestHandlerAdvice ( ) { @ java.lang.Override protected java.lang.Object java.lang.Object ( ExecutionCallback org.springframework.integration.handler.advice.ExecutionCallback , java.lang.Object java.lang.Object , Message < ? > org.springframework.integration.handler.advice.Message<?> ) throws java.lang.Exception { java.util.concurrent.atomic.AtomicBoolean . void ( true ) ; return org.springframework.integration.handler.advice.ExecutionCallback . execute ( ) ; } } ; PollableChannel org.springframework.integration.handler.advice.PollableChannel = new QueueChannel ( ) ; PollingConsumer org.springframework.integration.handler.advice.PollingConsumer = new PollingConsumer ( org.springframework.integration.handler.advice.PollableChannel , message -> { } ) ; org.springframework.integration.handler.advice.PollingConsumer . setAdviceChain ( java.util.Collections . java.util.List ( org.springframework.integration.handler.advice.Advice ) ) ; org.springframework.integration.handler.advice.PollingConsumer . setTaskExecutor ( new ErrorHandlingTaskExecutor ( java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) , t -> { } ) ) ; org.springframework.integration.handler.advice.PollingConsumer . setBeanFactory ( mock ( BeanFactory .class ) ) ; org.springframework.integration.handler.advice.PollingConsumer . afterPropertiesSet ( ) ; org.springframework.integration.handler.advice.PollingConsumer . setTaskScheduler ( mock ( TaskScheduler .class ) ) ; org.springframework.integration.handler.advice.PollingConsumer . start ( ) ; java.util.concurrent.Callable<?> < ? > java.util.concurrent.Callable<?> = TestUtils . getPropertyValue ( org.springframework.integration.handler.advice.PollingConsumer , STRING , java.util.concurrent.Callable .class ) ; assertTrue ( AopUtils . isAopProxy ( java.util.concurrent.Callable<> ) ) ; Log org.springframework.integration.handler.advice.Log = TestUtils . getPropertyValue ( org.springframework.integration.handler.advice.Advice , STRING , Log .class ) ; org.springframework.integration.handler.advice.Log = spy ( org.springframework.integration.handler.advice.Log ) ; when ( org.springframework.integration.handler.advice.Log . isWarnEnabled ( ) ) . thenReturn ( java.lang.Boolean . java.lang.Boolean ) ; final java.util.concurrent.atomic.AtomicReference<java.lang.String> < java.lang.String > java.util.concurrent.atomic.AtomicReference<java.lang.String> = new java.util.concurrent.atomic.AtomicReference<java.lang.String> < java.lang.String > ( ) ; doAnswer ( invocation -> { logMessage . set ( invocation . getArgument ( NUMBER ) ) ; return null ; } ) . when ( org.springframework.integration.handler.advice.Log ) . warn ( Mockito . anyString ( ) ) ; DirectFieldAccessor org.springframework.integration.handler.advice.DirectFieldAccessor = new DirectFieldAccessor ( org.springframework.integration.handler.advice.Advice ) ; org.springframework.integration.handler.advice.DirectFieldAccessor . setPropertyValue ( STRING , org.springframework.integration.handler.advice.Log ) ; java.util.concurrent.Callable<> . call ( ) ; assertFalse ( java.util.concurrent.atomic.AtomicBoolean . boolean ( ) ) ; assertNotNull ( java.util.concurrent.atomic.AtomicReference<java.lang.String> . java.lang.String ( ) ) ; assertThat ( java.util.concurrent.atomic.AtomicReference<java.lang.String> . java.lang.String ( ) , Matchers . containsString ( STRING + STRING + STRING ) ) ; org.springframework.integration.handler.advice.PollingConsumer . stop ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected java.lang.Object java.lang.Object ( ExecutionCallback org.springframework.integration.handler.advice.ExecutionCallback , java.lang.Object java.lang.Object , Message < ? > org.springframework.integration.handler.advice.Message<?> ) throws java.lang.Exception { java.util.concurrent.atomic.AtomicBoolean . void ( true ) ; return org.springframework.integration.handler.advice.ExecutionCallback . execute ( ) ; }  <METHOD_END>
<METHOD_START> public void void ( ) { MessageFilter org.springframework.integration.handler.advice.MessageFilter = new MessageFilter ( message -> false ) ; QueueChannel org.springframework.integration.handler.advice.QueueChannel = new QueueChannel ( ) ; org.springframework.integration.handler.advice.MessageFilter . setDiscardChannel ( org.springframework.integration.handler.advice.QueueChannel ) ; org.springframework.integration.handler.advice.MessageFilter . handleMessage ( new GenericMessage < java.lang.String > ( STRING ) ) ; assertNotNull ( org.springframework.integration.handler.advice.QueueChannel . receive ( NUMBER ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { MessageFilter org.springframework.integration.handler.advice.MessageFilter = new MessageFilter ( message -> false ) ; final QueueChannel org.springframework.integration.handler.advice.QueueChannel = new QueueChannel ( ) ; org.springframework.integration.handler.advice.MessageFilter . setDiscardChannel ( org.springframework.integration.handler.advice.QueueChannel ) ; java.util.List<org.springframework.integration.handler.advice.Advice> < Advice > java.util.List<org.springframework.integration.handler.advice.Advice> = new java.util.ArrayList<org.springframework.integration.handler.advice.Advice> < Advice > ( ) ; final java.util.concurrent.atomic.AtomicReference<org.springframework.integration.handler.advice.Message<?>> < Message < ? > > java.util.concurrent.atomic.AtomicReference<org.springframework.integration.handler.advice.Message<?>> = new java.util.concurrent.atomic.AtomicReference<org.springframework.integration.handler.advice.Message<?>> < Message < ? > > ( ) ; java.util.List<org.springframework.integration.handler.advice.Advice> . add ( new AbstractRequestHandlerAdvice ( ) { @ java.lang.Override protected java.lang.Object java.lang.Object ( ExecutionCallback org.springframework.integration.handler.advice.ExecutionCallback , java.lang.Object java.lang.Object , Message < ? > org.springframework.integration.handler.advice.Message<?> ) throws java.lang.Exception { java.lang.Object java.lang.Object = org.springframework.integration.handler.advice.ExecutionCallback . execute ( ) ; java.util.concurrent.atomic.AtomicReference<org.springframework.integration.handler.advice.Message<?>> . set ( org.springframework.integration.handler.advice.QueueChannel . receive ( NUMBER ) ) ; return java.lang.Object ; } } ) ; org.springframework.integration.handler.advice.MessageFilter . setAdviceChain ( java.util.List<org.springframework.integration.handler.advice.Advice> ) ; org.springframework.integration.handler.advice.MessageFilter . setBeanFactory ( mock ( BeanFactory .class ) ) ; org.springframework.integration.handler.advice.MessageFilter . afterPropertiesSet ( ) ; org.springframework.integration.handler.advice.MessageFilter . handleMessage ( new GenericMessage < java.lang.String > ( STRING ) ) ; assertNotNull ( java.util.concurrent.atomic.AtomicReference<org.springframework.integration.handler.advice.Message<?>> . get ( ) ) ; assertNull ( org.springframework.integration.handler.advice.QueueChannel . receive ( NUMBER ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected java.lang.Object java.lang.Object ( ExecutionCallback org.springframework.integration.handler.advice.ExecutionCallback , java.lang.Object java.lang.Object , Message < ? > org.springframework.integration.handler.advice.Message<?> ) throws java.lang.Exception { java.lang.Object java.lang.Object = org.springframework.integration.handler.advice.ExecutionCallback . execute ( ) ; java.util.concurrent.atomic.AtomicReference<org.springframework.integration.handler.advice.Message<?>> . set ( org.springframework.integration.handler.advice.QueueChannel . receive ( NUMBER ) ) ; return java.lang.Object ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { MessageFilter org.springframework.integration.handler.advice.MessageFilter = new MessageFilter ( message -> false ) ; final QueueChannel org.springframework.integration.handler.advice.QueueChannel = new QueueChannel ( ) ; org.springframework.integration.handler.advice.MessageFilter . setDiscardChannel ( org.springframework.integration.handler.advice.QueueChannel ) ; java.util.List<org.springframework.integration.handler.advice.Advice> < Advice > java.util.List<org.springframework.integration.handler.advice.Advice> = new java.util.ArrayList<org.springframework.integration.handler.advice.Advice> < Advice > ( ) ; final java.util.concurrent.atomic.AtomicReference<org.springframework.integration.handler.advice.Message<?>> < Message < ? > > java.util.concurrent.atomic.AtomicReference<org.springframework.integration.handler.advice.Message<?>> = new java.util.concurrent.atomic.AtomicReference<org.springframework.integration.handler.advice.Message<?>> < Message < ? > > ( ) ; final java.util.concurrent.atomic.AtomicBoolean java.util.concurrent.atomic.AtomicBoolean = new java.util.concurrent.atomic.AtomicBoolean ( ) ; java.util.List<org.springframework.integration.handler.advice.Advice> . add ( new AbstractRequestHandlerAdvice ( ) { @ java.lang.Override protected java.lang.Object java.lang.Object ( ExecutionCallback org.springframework.integration.handler.advice.ExecutionCallback , java.lang.Object java.lang.Object , Message < ? > org.springframework.integration.handler.advice.Message<?> ) throws java.lang.Exception { java.lang.Object java.lang.Object = org.springframework.integration.handler.advice.ExecutionCallback . execute ( ) ; java.util.concurrent.atomic.AtomicReference<org.springframework.integration.handler.advice.Message<?>> . set ( org.springframework.integration.handler.advice.QueueChannel . receive ( NUMBER ) ) ; java.util.concurrent.atomic.AtomicBoolean . void ( true ) ; return java.lang.Object ; } } ) ; org.springframework.integration.handler.advice.MessageFilter . setAdviceChain ( java.util.List<org.springframework.integration.handler.advice.Advice> ) ; org.springframework.integration.handler.advice.MessageFilter . setDiscardWithinAdvice ( false ) ; org.springframework.integration.handler.advice.MessageFilter . setBeanFactory ( mock ( BeanFactory .class ) ) ; org.springframework.integration.handler.advice.MessageFilter . afterPropertiesSet ( ) ; org.springframework.integration.handler.advice.MessageFilter . handleMessage ( new GenericMessage < java.lang.String > ( STRING ) ) ; assertTrue ( java.util.concurrent.atomic.AtomicBoolean . boolean ( ) ) ; assertNull ( java.util.concurrent.atomic.AtomicReference<org.springframework.integration.handler.advice.Message<?>> . get ( ) ) ; assertNotNull ( org.springframework.integration.handler.advice.QueueChannel . receive ( NUMBER ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected java.lang.Object java.lang.Object ( ExecutionCallback org.springframework.integration.handler.advice.ExecutionCallback , java.lang.Object java.lang.Object , Message < ? > org.springframework.integration.handler.advice.Message<?> ) throws java.lang.Exception { java.lang.Object java.lang.Object = org.springframework.integration.handler.advice.ExecutionCallback . execute ( ) ; java.util.concurrent.atomic.AtomicReference<org.springframework.integration.handler.advice.Message<?>> . set ( org.springframework.integration.handler.advice.QueueChannel . receive ( NUMBER ) ) ; java.util.concurrent.atomic.AtomicBoolean . void ( true ) ; return java.lang.Object ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { void ( false , NUMBER ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { void ( true , NUMBER ) ; }  <METHOD_END>
<METHOD_START> private void void ( boolean boolean , int int ) { final java.util.concurrent.atomic.AtomicInteger java.util.concurrent.atomic.AtomicInteger = new java.util.concurrent.atomic.AtomicInteger ( NUMBER ) ; @ java.lang.SuppressWarnings ( STRING ) class MyException extends java.lang.RuntimeException {		} AbstractReplyProducingMessageHandler org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler = new AbstractReplyProducingMessageHandler ( ) { @ java.lang.Override protected java.lang.Object java.lang.Object ( Message < ? > org.springframework.integration.handler.advice.Message<?> ) { java.util.concurrent.atomic.AtomicInteger . int ( ) ; throw new MyException ( ) ; } } ; QueueChannel org.springframework.integration.handler.advice.QueueChannel = new QueueChannel ( ) ; org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . setOutputChannel ( org.springframework.integration.handler.advice.QueueChannel ) ; RequestHandlerRetryAdvice org.springframework.integration.handler.advice.RequestHandlerRetryAdvice = new RequestHandlerRetryAdvice ( ) ; RetryTemplate org.springframework.integration.handler.advice.RetryTemplate = new RetryTemplate ( ) ; java.util.Map<java.lang.Class<? extends java.lang.Throwable>,java.lang.Boolean> < java.lang.Class<? extends java.lang.Throwable> < ? extends java.lang.Throwable > , java.lang.Boolean > java.util.Map<java.lang.Class<? extends java.lang.Throwable>,java.lang.Boolean> = new java.util.HashMap<java.lang.Class<? extends java.lang.Throwable>,java.lang.Boolean> < java.lang.Class<? extends java.lang.Throwable> < ? extends java.lang.Throwable > , java.lang.Boolean > ( ) ; java.util.Map<java.lang.Class<? extends java.lang.Throwable>,java.lang.Boolean> . java.lang.Boolean ( MyException .class , boolean ) ; java.util.Map<java.lang.Class<? extends java.lang.Throwable>,java.lang.Boolean> . java.lang.Boolean ( MessagingException .class , true ) ; org.springframework.integration.handler.advice.RetryTemplate . setRetryPolicy ( new SimpleRetryPolicy ( NUMBER , java.util.Map<java.lang.Class<? extends java.lang.Throwable>,java.lang.Boolean> ) ) ; org.springframework.integration.handler.advice.RequestHandlerRetryAdvice . setRetryTemplate ( org.springframework.integration.handler.advice.RetryTemplate ) ; java.util.List<org.springframework.integration.handler.advice.Advice> < Advice > java.util.List<org.springframework.integration.handler.advice.Advice> = new java.util.ArrayList<org.springframework.integration.handler.advice.Advice> < Advice > ( ) ; java.util.List<org.springframework.integration.handler.advice.Advice> . add ( org.springframework.integration.handler.advice.RequestHandlerRetryAdvice ) ; org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . setAdviceChain ( java.util.List<org.springframework.integration.handler.advice.Advice> ) ; org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . setBeanFactory ( mock ( BeanFactory .class ) ) ; org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . afterPropertiesSet ( ) ; Message < java.lang.String > org.springframework.integration.handler.advice.Message<java.lang.String> = new GenericMessage < java.lang.String > ( STRING ) ; try { org.springframework.integration.handler.advice.AbstractReplyProducingMessageHandler . handleMessage ( org.springframework.integration.handler.advice.Message<java.lang.String> ) ; fail ( STRING ) ; } catch ( java.lang.Exception java.lang.Exception ) { assertThat ( java.lang.Exception , Matchers . instanceOf ( MessagingException .class ) ) ; assertThat ( java.lang.Exception . java.lang.Throwable ( ) , Matchers . instanceOf ( MyException .class ) ) ; } assertEquals ( int , java.util.concurrent.atomic.AtomicInteger . int ( ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected java.lang.Object java.lang.Object ( Message < ? > org.springframework.integration.handler.advice.Message<?> ) { java.util.concurrent.atomic.AtomicInteger . int ( ) ; throw new MyException ( ) ; }  <METHOD_END>
<METHOD_START> java.lang.Object java.lang.Object ( Message < ? > org.springframework.integration.handler.advice.Message<?> ) throws java.lang.Throwable ;  <METHOD_END>
<METHOD_START> void ( java.lang.Throwable java.lang.Throwable ) { this . java.lang.Throwable = java.lang.Throwable ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.Object java.lang.Object ( Message < ? > org.springframework.integration.handler.advice.Message<?> ) throws java.lang.Throwable { throw this . java.lang.Throwable ; }  <METHOD_END>
