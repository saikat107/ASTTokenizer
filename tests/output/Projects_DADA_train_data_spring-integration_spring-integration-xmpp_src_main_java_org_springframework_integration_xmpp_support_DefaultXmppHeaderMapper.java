<METHOD_START> public void ( ) { super( XmppHeaders . PREFIX , java.util.List<java.lang.String> , java.util.List<java.lang.String> ); }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected java.util.Map<java.lang.String,java.lang.Object> < java.lang.String , java.lang.Object > java.util.Map<java.lang.String,java.lang.Object> ( Message org.springframework.integration.xmpp.support.Message ) { java.util.Map<java.lang.String,java.lang.Object> < java.lang.String , java.lang.Object > java.util.Map<java.lang.String,java.lang.Object> = new java.util.HashMap<java.lang.String,java.lang.Object> < java.lang.String , java.lang.Object > ( ) ; java.lang.String java.lang.String = org.springframework.integration.xmpp.support.Message . getFrom ( ) ; if ( StringUtils . hasText ( java.lang.String ) ) { java.util.Map<java.lang.String,java.lang.Object> . java.lang.Object ( XmppHeaders . FROM , java.lang.String ) ; } java.lang.String java.lang.String = org.springframework.integration.xmpp.support.Message . getSubject ( ) ; if ( StringUtils . hasText ( java.lang.String ) ) { java.util.Map<java.lang.String,java.lang.Object> . java.lang.Object ( XmppHeaders . SUBJECT , java.lang.String ) ; } java.lang.String java.lang.String = org.springframework.integration.xmpp.support.Message . getThread ( ) ; if ( StringUtils . hasText ( java.lang.String ) ) { java.util.Map<java.lang.String,java.lang.Object> . java.lang.Object ( XmppHeaders . THREAD , java.lang.String ) ; } java.lang.String java.lang.String = org.springframework.integration.xmpp.support.Message . getTo ( ) ; if ( StringUtils . hasText ( java.lang.String ) ) { java.util.Map<java.lang.String,java.lang.Object> . java.lang.Object ( XmppHeaders . TO , java.lang.String ) ; } Message . Message Message.Type = org.springframework.integration.xmpp.support.Message . getType ( ) ; if ( Message.Type != null ) { java.util.Map<java.lang.String,java.lang.Object> . java.lang.Object ( XmppHeaders . TYPE , Message.Type ) ; } return java.util.Map<java.lang.String,java.lang.Object> ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected java.util.Map<java.lang.String,java.lang.Object> < java.lang.String , java.lang.Object > java.util.Map<java.lang.String,java.lang.Object> ( Message org.springframework.integration.xmpp.support.Message ) { java.util.Map<java.lang.String,java.lang.Object> < java.lang.String , java.lang.Object > java.util.Map<java.lang.String,java.lang.Object> = new java.util.HashMap<java.lang.String,java.lang.Object> < java.lang.String , java.lang.Object > ( ) ; JivePropertiesExtension org.springframework.integration.xmpp.support.JivePropertiesExtension = ( JivePropertiesExtension ) org.springframework.integration.xmpp.support.Message . getExtension ( JivePropertiesExtension . NAMESPACE ) ; if ( org.springframework.integration.xmpp.support.JivePropertiesExtension == null ) { return java.util.Map<java.lang.String,java.lang.Object> ; } for ( java.lang.String java.lang.String : org.springframework.integration.xmpp.support.JivePropertiesExtension . getPropertyNames ( ) ) { java.util.Map<java.lang.String,java.lang.Object> . java.lang.Object ( java.lang.String , JivePropertiesManager . getProperty ( org.springframework.integration.xmpp.support.Message , java.lang.String ) ) ; } return java.util.Map<java.lang.String,java.lang.Object> ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( java.util.Map<java.lang.String,java.lang.Object> < java.lang.String , java.lang.Object > java.util.Map<java.lang.String,java.lang.Object> , Message org.springframework.integration.xmpp.support.Message ) { java.lang.String java.lang.String = getHeaderIfAvailable ( java.util.Map<java.lang.String,java.lang.Object> , XmppHeaders . THREAD , java.lang.String .class ) ; if ( StringUtils . hasText ( java.lang.String ) ) { org.springframework.integration.xmpp.support.Message . setThread ( java.lang.String ) ; } java.lang.String java.lang.String = getHeaderIfAvailable ( java.util.Map<java.lang.String,java.lang.Object> , XmppHeaders . TO , java.lang.String .class ) ; if ( StringUtils . hasText ( java.lang.String ) ) { org.springframework.integration.xmpp.support.Message . setTo ( java.lang.String ) ; } java.lang.String java.lang.String = getHeaderIfAvailable ( java.util.Map<java.lang.String,java.lang.Object> , XmppHeaders . FROM , java.lang.String .class ) ; if ( StringUtils . hasText ( java.lang.String ) ) { org.springframework.integration.xmpp.support.Message . setFrom ( java.lang.String ) ; } java.lang.String java.lang.String = getHeaderIfAvailable ( java.util.Map<java.lang.String,java.lang.Object> , XmppHeaders . SUBJECT , java.lang.String .class ) ; if ( StringUtils . hasText ( java.lang.String ) ) { org.springframework.integration.xmpp.support.Message . setSubject ( java.lang.String ) ; } java.lang.Object java.lang.Object = getHeaderIfAvailable ( java.util.Map<java.lang.String,java.lang.Object> , XmppHeaders . TYPE , java.lang.Object .class ) ; if ( java.lang.Object instanceof java.lang.String ) { try { java.lang.Object = Message . Type . valueOf ( ( java.lang.String ) java.lang.Object ) ; } catch ( java.lang.Exception java.lang.Exception ) { if ( logger . isWarnEnabled ( ) ) { logger . warn ( STRING + STRING ) ; } } } if ( java.lang.Object instanceof Message . Message ) { org.springframework.integration.xmpp.support.Message . setType ( ( Message . Message ) java.lang.Object ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( java.lang.String java.lang.String , java.lang.Object java.lang.Object , Message org.springframework.integration.xmpp.support.Message ) { JivePropertiesManager . addProperty ( org.springframework.integration.xmpp.support.Message , java.lang.String , java.lang.Object ) ; }  <METHOD_END>
