<METHOD_START> void ( int int , char [] char[] , boolean boolean , char char ) { super( int , char ); int int = - NUMBER ; for ( int int = NUMBER ; int < char[] . int ; int ++ ) { if ( char[] [ int ] == ':' ) { int = int ; break; } } if ( int == - NUMBER ) { java.lang.String = new java.lang.String ( char[] , NUMBER , char[] . int - NUMBER ) ; } else { java.lang.String = new java.lang.String ( char[] , NUMBER , int - NUMBER ) ; if ( boolean ) { java.util.regex.Pattern = java . util . regex . java.util.regex.Pattern . java.util.regex.Pattern ( new java.lang.String ( char[] , int + NUMBER , char[] . int - int - NUMBER ) ) ; } else { java.util.regex.Pattern = java . util . regex . java.util.regex.Pattern . java.util.regex.Pattern ( new java.lang.String ( char[] , int + NUMBER , char[] . int - int - NUMBER ) , java . util . regex . java.util.regex.Pattern . int ) ; } } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( int int , MatchingContext org.springframework.web.util.patterns.MatchingContext ) { int int = org.springframework.web.util.patterns.MatchingContext . scanAhead ( int ) ; java.lang.CharSequence java.lang.CharSequence = null ; if ( java.util.regex.Pattern != null ) { java.lang.CharSequence = new SubSequence ( matchingContext . candidate , int , int ) ; java.util.regex.Matcher java.util.regex.Matcher = java.util.regex.Pattern . java.util.regex.Matcher ( java.lang.CharSequence ) ; if ( java.util.regex.Matcher . int ( ) != NUMBER ) { throw new java.lang.IllegalArgumentException ( STRING + java.util.regex.Pattern . java.lang.String ( ) ) ; } if ( ! java.util.regex.Matcher . boolean ( ) ) { return false ; } } boolean boolean = false ; if ( next == null ) { if ( matchingContext . determineRemaining && int > int ) { matchingContext . remainingPathIndex = int ; boolean = true ; } else { boolean = ( int == matchingContext . candidateLength && int > int ) ; } } else { if ( matchingContext . isMatchStartMatching && int == matchingContext . candidateLength ) { boolean = true ; } else { boolean = next . matches ( int , org.springframework.web.util.patterns.MatchingContext ) ; } } if ( boolean && matchingContext . extractingVariables ) { org.springframework.web.util.patterns.MatchingContext . set ( java.lang.String , new java.lang.String ( matchingContext . candidate , int , int - int ) ) ; } return boolean ; }  <METHOD_END>
<METHOD_START> public java.lang.String java.lang.String ( ) { return this . java.lang.String ; }  <METHOD_END>
<METHOD_START> public java.lang.String java.lang.String ( ) { return STRING + java.lang.String + ( java.util.regex.Pattern == null ? STRING : STRING + java.util.regex.Pattern . java.lang.String ( ) ) + STRING ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public int int ( ) { return NUMBER ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public int int ( ) { return NUMBER ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public int int ( ) { return NUMBER ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public int int ( ) { return CAPTURE_VARIABLE_WEIGHT ; }  <METHOD_END>
