<METHOD_START> @ Test @ java.lang.SuppressWarnings ( STRING ) public void void ( ) { PollableChannel org.springframework.integration.routingslip.PollableChannel = new QueueChannel ( ) ; Message < java.util.List<java.lang.String> < java.lang.String > > org.springframework.integration.routingslip.Message<java.util.List<java.lang.String>> = MessageBuilder . withPayload ( java.util.Arrays . java.util.List<java.lang.String> ( STRING , STRING ) ) . setReplyChannel ( org.springframework.integration.routingslip.PollableChannel ) . setHeader ( STRING , STRING ) . build ( ) ; this . org.springframework.integration.routingslip.MessageChannel . send ( org.springframework.integration.routingslip.Message<java.util.List<java.lang.String>> ) ; Message < ? > org.springframework.integration.routingslip.Message<?> = org.springframework.integration.routingslip.PollableChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.routingslip.Message<> ) ; java.util.List<org.springframework.integration.routingslip.Message<?>> < Message < ? > > java.util.List<org.springframework.integration.routingslip.Message<?>> = ( java.util.List<org.springframework.integration.routingslip.Message<?>> < Message < ? > > ) org.springframework.integration.routingslip.Message<> . getPayload ( ) ; for ( Message < ? > org.springframework.integration.routingslip.Message<?> : java.util.List<org.springframework.integration.routingslip.Message<?>> ) { java.util.Map<java.util.List<java.lang.String>,java.lang.Integer> < java.util.List<java.lang.String> < java.lang.String > , java.lang.Integer > java.util.Map<java.util.List<java.lang.String>,java.lang.Integer> = org.springframework.integration.routingslip.Message<> . getHeaders ( ) . get ( IntegrationMessageHeaderAccessor . ROUTING_SLIP , java.util.Map .class ) ; assertEquals ( java.util.Map<java.util.List<java.lang.String>,java.lang.Integer> . java.util.Set<java.util.List<java.lang.String>> ( ) . java.util.Iterator<java.util.List<java.lang.String>> ( ) . java.util.List<java.lang.String> ( ) . int ( ) , java.util.Map<java.util.List<java.lang.String>,java.lang.Integer> . java.util.Collection<java.lang.Integer> ( ) . java.util.Iterator<java.lang.Integer> ( ) . java.lang.Integer ( ) . int ( ) ) ; MessageHistory org.springframework.integration.routingslip.MessageHistory = MessageHistory . read ( org.springframework.integration.routingslip.Message<> ) ; java.util.List<java.lang.String> < java.lang.String > java.util.List<java.lang.String> = java.util.Arrays . java.util.List<java.lang.String> ( STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING ) ; for ( java.util.Properties java.util.Properties : org.springframework.integration.routingslip.MessageHistory ) { assertTrue ( java.util.List<java.lang.String> . boolean ( java.util.Properties . java.lang.String ( STRING ) ) ) ; } } }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { this . org.springframework.integration.routingslip.MessageChannel . send ( new GenericMessage <> ( STRING ) ) ; Message < ? > org.springframework.integration.routingslip.Message<?> = this . org.springframework.integration.routingslip.PollableChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.routingslip.Message<> ) ; assertEquals ( STRING , org.springframework.integration.routingslip.Message<> . getPayload ( ) ) ; this . org.springframework.integration.routingslip.MessageChannel . send ( new GenericMessage <> ( NUMBER ) ) ; org.springframework.integration.routingslip.Message<?> = this . org.springframework.integration.routingslip.PollableChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.routingslip.Message<> ) ; assertEquals ( NUMBER , org.springframework.integration.routingslip.Message<> . getPayload ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { try { new RoutingSlipHeaderValueMessageProcessor ( new java.util.Date ( ) ) ; fail ( STRING ) ; } catch ( java.lang.Exception java.lang.Exception ) { assertThat ( java.lang.Exception , instanceOf ( java.lang.IllegalArgumentException .class ) ) ; assertThat ( java.lang.Exception . java.lang.String ( ) , containsString ( STRING + STRING + STRING ) ) ; } try { this . org.springframework.integration.routingslip.MessageChannel . send ( new GenericMessage <> ( STRING ) ) ; fail ( STRING ) ; } catch ( java.lang.Exception java.lang.Exception ) { assertThat ( java.lang.Exception , instanceOf ( MessagingException .class ) ) ; assertThat ( java.lang.Exception . java.lang.String ( ) , containsString ( STRING ) ) ; } }  <METHOD_END>
<METHOD_START> public java.lang.String java.lang.String ( Message < ? > org.springframework.integration.routingslip.Message<?> , java.lang.Object java.lang.Object ) { try { return this . java.lang.String[] [ int ++ ] ; } catch ( java.lang.Exception java.lang.Exception ) { return null ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.Object java.lang.Object ( Message < ? > org.springframework.integration.routingslip.Message<?> , java.lang.Object java.lang.Object ) { return ! java.util.concurrent.atomic.AtomicBoolean . boolean ( true ) ? STRING : null ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.integration.routingslip.MessagingTemplate org.springframework.integration.routingslip.MessagingTemplate ( ) { return new MessagingTemplate ( ) ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.integration.routingslip.PollableChannel org.springframework.integration.routingslip.PollableChannel ( ) { return new QueueChannel ( ) ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.integration.routingslip.RoutingSlipRouteStrategy org.springframework.integration.routingslip.RoutingSlipRouteStrategy ( ) { return ( requestMessage , reply ) -> requestMessage . getPayload ( ) instanceof String ? new FixedSubscriberChannel ( m -> Flux . just ( ( String ) m . getPayload ( ) ) . map ( String :: toUpperCase ) . subscribe ( v -> messagingTemplate ( ) . convertAndSend ( resultsChannel ( ) , v ) ) ) : new FixedSubscriberChannel ( m -> Flux . just ( ( Integer ) m . getPayload ( ) ) . map ( v -> v * NUMBER ) . subscribe ( v -> messagingTemplate ( ) . convertAndSend ( resultsChannel ( ) , v ) ) ) ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.integration.routingslip.MessageChannel org.springframework.integration.routingslip.MessageChannel ( ) { return new DirectChannel ( ) ; }  <METHOD_END>
<METHOD_START> @ Bean @ BridgeTo public org.springframework.integration.routingslip.MessageChannel org.springframework.integration.routingslip.MessageChannel ( ) { return new DirectChannel ( ) ; }  <METHOD_END>
<METHOD_START> @ Bean @ Transformer ( inputChannel = STRING , outputChannel = STRING ) public org.springframework.integration.routingslip.HeaderEnricher org.springframework.integration.routingslip.HeaderEnricher ( ) { return new HeaderEnricher ( java.util.Collections . java.util.Map ( IntegrationMessageHeaderAccessor . ROUTING_SLIP , new RoutingSlipHeaderValueMessageProcessor ( org.springframework.integration.routingslip.RoutingSlipRouteStrategy ( ) ) ) ) ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.integration.routingslip.MessageChannel org.springframework.integration.routingslip.MessageChannel ( ) { return new DirectChannel ( ) ; }  <METHOD_END>
<METHOD_START> @ Bean @ Transformer ( inputChannel = STRING , outputChannel = STRING ) public org.springframework.integration.routingslip.HeaderEnricher org.springframework.integration.routingslip.HeaderEnricher ( ) { return new HeaderEnricher ( java.util.Collections . java.util.Map ( IntegrationMessageHeaderAccessor . ROUTING_SLIP , new RoutingSlipHeaderValueMessageProcessor ( ( RoutingSlipRouteStrategy ) ( message , r ) -> new Date ( ) ) ) ) ; }  <METHOD_END>
