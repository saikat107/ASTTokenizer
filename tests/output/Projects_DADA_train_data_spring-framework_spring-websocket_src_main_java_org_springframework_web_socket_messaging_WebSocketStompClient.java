<METHOD_START> public void ( WebSocketClient org.springframework.web.socket.messaging.WebSocketClient ) { Assert . notNull ( org.springframework.web.socket.messaging.WebSocketClient , STRING ) ; this . org.springframework.web.socket.messaging.WebSocketClient = org.springframework.web.socket.messaging.WebSocketClient ; setDefaultHeartbeat ( new long [] { NUMBER , NUMBER } ) ; }  <METHOD_END>
<METHOD_START> public org.springframework.web.socket.messaging.WebSocketClient org.springframework.web.socket.messaging.WebSocketClient ( ) { return this . org.springframework.web.socket.messaging.WebSocketClient ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( TaskScheduler org.springframework.web.socket.messaging.TaskScheduler ) { if ( org.springframework.web.socket.messaging.TaskScheduler != null && ! isDefaultHeartbeatEnabled ( ) ) { setDefaultHeartbeat ( new long [] { NUMBER , NUMBER } ) ; } super. setTaskScheduler ( org.springframework.web.socket.messaging.TaskScheduler ) ; }  <METHOD_END>
<METHOD_START> public void void ( int int ) { this . int = int ; }  <METHOD_END>
<METHOD_START> public int int ( ) { return this . int ; }  <METHOD_END>
<METHOD_START> public void void ( boolean boolean ) { this . boolean = boolean ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( ) { return this . boolean ; }  <METHOD_END>
<METHOD_START> public void void ( int int ) { this . int = int ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public int int ( ) { return this . int ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ) { if ( ! boolean ( ) ) { this . boolean = true ; if ( org.springframework.web.socket.messaging.WebSocketClient ( ) instanceof Lifecycle ) { ( ( Lifecycle ) org.springframework.web.socket.messaging.WebSocketClient ( ) ) . start ( ) ; } } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ) { if ( boolean ( ) ) { this . boolean = false ; if ( org.springframework.web.socket.messaging.WebSocketClient ( ) instanceof Lifecycle ) { ( ( Lifecycle ) org.springframework.web.socket.messaging.WebSocketClient ( ) ) . stop ( ) ; } } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( java.lang.Runnable java.lang.Runnable ) { void ( ) ; java.lang.Runnable . void ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( ) { return this . boolean ; }  <METHOD_END>
<METHOD_START> public org.springframework.web.socket.messaging.ListenableFuture<org.springframework.web.socket.messaging.StompSession> < StompSession > org.springframework.web.socket.messaging.ListenableFuture<org.springframework.web.socket.messaging.StompSession> ( java.lang.String java.lang.String , StompSessionHandler org.springframework.web.socket.messaging.StompSessionHandler , java.lang.Object ... java.lang.Object[] ) { return org.springframework.web.socket.messaging.ListenableFuture<org.springframework.web.socket.messaging.StompSession> ( java.lang.String , null , org.springframework.web.socket.messaging.StompSessionHandler , java.lang.Object[] ) ; }  <METHOD_END>
<METHOD_START> public org.springframework.web.socket.messaging.ListenableFuture<org.springframework.web.socket.messaging.StompSession> < StompSession > org.springframework.web.socket.messaging.ListenableFuture<org.springframework.web.socket.messaging.StompSession> ( java.lang.String java.lang.String , WebSocketHttpHeaders org.springframework.web.socket.messaging.WebSocketHttpHeaders , StompSessionHandler org.springframework.web.socket.messaging.StompSessionHandler , java.lang.Object ... java.lang.Object[] ) { return org.springframework.web.socket.messaging.ListenableFuture<org.springframework.web.socket.messaging.StompSession> ( java.lang.String , org.springframework.web.socket.messaging.WebSocketHttpHeaders , null , org.springframework.web.socket.messaging.StompSessionHandler , java.lang.Object[] ) ; }  <METHOD_END>
<METHOD_START> public org.springframework.web.socket.messaging.ListenableFuture<org.springframework.web.socket.messaging.StompSession> < StompSession > org.springframework.web.socket.messaging.ListenableFuture<org.springframework.web.socket.messaging.StompSession> ( java.lang.String java.lang.String , WebSocketHttpHeaders org.springframework.web.socket.messaging.WebSocketHttpHeaders , StompHeaders org.springframework.web.socket.messaging.StompHeaders , StompSessionHandler org.springframework.web.socket.messaging.StompSessionHandler , java.lang.Object ... java.lang.Object[] ) { Assert . notNull ( java.lang.String , STRING ) ; java.net.URI java.net.URI = UriComponentsBuilder . fromUriString ( java.lang.String ) . buildAndExpand ( java.lang.Object[] ) . encode ( ) . toUri ( ) ; return org.springframework.web.socket.messaging.ListenableFuture<org.springframework.web.socket.messaging.StompSession> ( java.net.URI , org.springframework.web.socket.messaging.WebSocketHttpHeaders , org.springframework.web.socket.messaging.StompHeaders , org.springframework.web.socket.messaging.StompSessionHandler ) ; }  <METHOD_END>
<METHOD_START> public org.springframework.web.socket.messaging.ListenableFuture<org.springframework.web.socket.messaging.StompSession> < StompSession > org.springframework.web.socket.messaging.ListenableFuture<org.springframework.web.socket.messaging.StompSession> ( java.net.URI java.net.URI , WebSocketHttpHeaders org.springframework.web.socket.messaging.WebSocketHttpHeaders , StompHeaders org.springframework.web.socket.messaging.StompHeaders , StompSessionHandler org.springframework.web.socket.messaging.StompSessionHandler ) { Assert . notNull ( java.net.URI , STRING ) ; ConnectionHandlingStompSession org.springframework.web.socket.messaging.ConnectionHandlingStompSession = createSession ( org.springframework.web.socket.messaging.StompHeaders , org.springframework.web.socket.messaging.StompSessionHandler ) ; org.springframework.web.socket.messaging.WebSocketStompClient.WebSocketTcpConnectionHandlerAdapter org.springframework.web.socket.messaging.WebSocketStompClient.WebSocketTcpConnectionHandlerAdapter = new org.springframework.web.socket.messaging.WebSocketStompClient.WebSocketTcpConnectionHandlerAdapter ( org.springframework.web.socket.messaging.ConnectionHandlingStompSession ) ; org.springframework.web.socket.messaging.WebSocketClient ( ) . doHandshake ( org.springframework.web.socket.messaging.WebSocketStompClient.WebSocketTcpConnectionHandlerAdapter , org.springframework.web.socket.messaging.WebSocketHttpHeaders , java.net.URI ) . addCallback ( org.springframework.web.socket.messaging.WebSocketStompClient.WebSocketTcpConnectionHandlerAdapter ) ; return org.springframework.web.socket.messaging.ConnectionHandlingStompSession . getSessionFuture ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected org.springframework.web.socket.messaging.StompHeaders org.springframework.web.socket.messaging.StompHeaders ( StompHeaders org.springframework.web.socket.messaging.StompHeaders ) { org.springframework.web.socket.messaging.StompHeaders = super. processConnectHeaders ( org.springframework.web.socket.messaging.StompHeaders ) ; if ( org.springframework.web.socket.messaging.StompHeaders . isHeartbeatEnabled ( ) ) { Assert . state ( getTaskScheduler ( ) != null , STRING ) ; } return org.springframework.web.socket.messaging.StompHeaders ; }  <METHOD_END>
<METHOD_START> public void ( TcpConnectionHandler < byte [] > org.springframework.web.socket.messaging.TcpConnectionHandler<byte[]> ) { Assert . notNull ( org.springframework.web.socket.messaging.TcpConnectionHandler<byte[]> , STRING ) ; this . org.springframework.web.socket.messaging.TcpConnectionHandler<byte[]> = org.springframework.web.socket.messaging.TcpConnectionHandler<byte[]> ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( WebSocketSession org.springframework.web.socket.messaging.WebSocketSession ) {		}  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( java.lang.Throwable java.lang.Throwable ) { this . org.springframework.web.socket.messaging.TcpConnectionHandler<byte[]> . afterConnectFailure ( java.lang.Throwable ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( WebSocketSession org.springframework.web.socket.messaging.WebSocketSession ) { this . org.springframework.web.socket.messaging.WebSocketSession = org.springframework.web.socket.messaging.WebSocketSession ; this . org.springframework.web.socket.messaging.TcpConnectionHandler<byte[]> . afterConnected ( this ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( WebSocketSession org.springframework.web.socket.messaging.WebSocketSession , WebSocketMessage < ? > org.springframework.web.socket.messaging.WebSocketMessage<?> ) { this . long = ( this . long != - NUMBER ? java.lang.System . long ( ) : - NUMBER ) ; java.util.List<org.springframework.web.socket.messaging.Message<byte[]>> < Message < byte [] > > java.util.List<org.springframework.web.socket.messaging.Message<byte[]>> ; try { java.util.List<org.springframework.web.socket.messaging.Message<byte[]>> = this . org.springframework.web.socket.messaging.WebSocketStompClient.StompWebSocketMessageCodec . java.util.List<org.springframework.web.socket.messaging.Message<byte[]>> ( org.springframework.web.socket.messaging.WebSocketMessage<> ) ; } catch ( java.lang.Throwable java.lang.Throwable ) { this . org.springframework.web.socket.messaging.TcpConnectionHandler<byte[]> . handleFailure ( java.lang.Throwable ) ; return; } for ( Message < byte [] > org.springframework.web.socket.messaging.Message<byte[]> : java.util.List<org.springframework.web.socket.messaging.Message<byte[]>> ) { this . org.springframework.web.socket.messaging.TcpConnectionHandler<byte[]> . handleMessage ( org.springframework.web.socket.messaging.Message<byte[]> ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( WebSocketSession org.springframework.web.socket.messaging.WebSocketSession , java.lang.Throwable java.lang.Throwable ) throws java.lang.Exception { this . org.springframework.web.socket.messaging.TcpConnectionHandler<byte[]> . handleFailure ( java.lang.Throwable ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( WebSocketSession org.springframework.web.socket.messaging.WebSocketSession , CloseStatus org.springframework.web.socket.messaging.CloseStatus ) throws java.lang.Exception { void ( ) ; this . org.springframework.web.socket.messaging.TcpConnectionHandler<byte[]> . afterConnectionClosed ( ) ; }  <METHOD_END>
<METHOD_START> private void void ( ) { for ( java.util.concurrent.ScheduledFuture<?> < ? > java.util.concurrent.ScheduledFuture<?> : this . java.util.List<java.util.concurrent.ScheduledFuture<?>> ) { try { java.util.concurrent.ScheduledFuture<> . boolean ( true ) ; } catch ( java.lang.Throwable java.lang.Throwable ) { } } this . long = - NUMBER ; this . long = - NUMBER ; this . java.util.List<java.util.concurrent.ScheduledFuture<?>> . void ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( ) { return false ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.web.socket.messaging.ListenableFuture<java.lang.Void> < java.lang.Void > org.springframework.web.socket.messaging.ListenableFuture<java.lang.Void> ( Message < byte [] > org.springframework.web.socket.messaging.Message<byte[]> ) { void ( ) ; SettableListenableFuture < java.lang.Void > org.springframework.web.socket.messaging.SettableListenableFuture<java.lang.Void> = new SettableListenableFuture <> ( ) ; try { this . org.springframework.web.socket.messaging.WebSocketSession . sendMessage ( this . org.springframework.web.socket.messaging.WebSocketStompClient.StompWebSocketMessageCodec . org.springframework.web.socket.messaging.WebSocketMessage<?> ( org.springframework.web.socket.messaging.Message<byte[]> , this . org.springframework.web.socket.messaging.WebSocketSession . getClass ( ) ) ) ; org.springframework.web.socket.messaging.SettableListenableFuture<java.lang.Void> . set ( null ) ; } catch ( java.lang.Throwable java.lang.Throwable ) { org.springframework.web.socket.messaging.SettableListenableFuture<java.lang.Void> . setException ( java.lang.Throwable ) ; } finally { void ( ) ; } return org.springframework.web.socket.messaging.SettableListenableFuture<java.lang.Void> ; }  <METHOD_END>
<METHOD_START> private void void ( ) { this . long = ( this . long != - NUMBER ? java.lang.System . long ( ) : - NUMBER ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( final java.lang.Runnable java.lang.Runnable , final long long ) { Assert . state ( getTaskScheduler ( ) != null , STRING ) ; this . long = java.lang.System . long ( ) ; this . java.util.List<java.util.concurrent.ScheduledFuture<?>> . boolean ( getTaskScheduler ( ) . scheduleWithFixedDelay ( new java.lang.Runnable ( ) { @ java.lang.Override public void void ( ) { if ( java.lang.System . long ( ) - long > long ) { try { java.lang.Runnable . void ( ) ; } catch ( java.lang.Throwable java.lang.Throwable ) { if ( org.springframework.web.socket.messaging.Log . isDebugEnabled ( ) ) { org.springframework.web.socket.messaging.Log . debug ( STRING , java.lang.Throwable ) ; } } } } } , long / NUMBER ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ) { if ( java.lang.System . long ( ) - long > long ) { try { java.lang.Runnable . void ( ) ; } catch ( java.lang.Throwable java.lang.Throwable ) { if ( org.springframework.web.socket.messaging.Log . isDebugEnabled ( ) ) { org.springframework.web.socket.messaging.Log . debug ( STRING , java.lang.Throwable ) ; } } } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( final java.lang.Runnable java.lang.Runnable , final long long ) { Assert . state ( getTaskScheduler ( ) != null , STRING ) ; this . long = java.lang.System . long ( ) ; this . java.util.List<java.util.concurrent.ScheduledFuture<?>> . boolean ( getTaskScheduler ( ) . scheduleWithFixedDelay ( new java.lang.Runnable ( ) { @ java.lang.Override public void void ( ) { if ( java.lang.System . long ( ) - long > long ) { try { java.lang.Runnable . void ( ) ; } catch ( java.lang.Throwable java.lang.Throwable ) { if ( org.springframework.web.socket.messaging.Log . isDebugEnabled ( ) ) { org.springframework.web.socket.messaging.Log . debug ( STRING , java.lang.Throwable ) ; } } } } } , long / NUMBER ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ) { if ( java.lang.System . long ( ) - long > long ) { try { java.lang.Runnable . void ( ) ; } catch ( java.lang.Throwable java.lang.Throwable ) { if ( org.springframework.web.socket.messaging.Log . isDebugEnabled ( ) ) { org.springframework.web.socket.messaging.Log . debug ( STRING , java.lang.Throwable ) ; } } } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ) { try { this . org.springframework.web.socket.messaging.WebSocketSession . close ( ) ; } catch ( java.io.IOException java.io.IOException ) { if ( org.springframework.web.socket.messaging.Log . isDebugEnabled ( ) ) { org.springframework.web.socket.messaging.Log . debug ( STRING + this . org.springframework.web.socket.messaging.WebSocketSession . getId ( ) , java.io.IOException ) ; } } }  <METHOD_END>
<METHOD_START> public void ( int int ) { this . org.springframework.web.socket.messaging.BufferingStompDecoder = new BufferingStompDecoder ( org.springframework.web.socket.messaging.StompDecoder , int ) ; }  <METHOD_END>
<METHOD_START> public java.util.List<org.springframework.web.socket.messaging.Message<byte[]>> < Message < byte [] > > java.util.List<org.springframework.web.socket.messaging.Message<byte[]>> ( WebSocketMessage < ? > org.springframework.web.socket.messaging.WebSocketMessage<?> ) { java.util.List<org.springframework.web.socket.messaging.Message<byte[]>> < Message < byte [] > > java.util.List<org.springframework.web.socket.messaging.Message<byte[]>> = java.util.Collections . java.util.List<org.springframework.web.socket.messaging.Message<byte[]>> ( ) ; java.nio.ByteBuffer java.nio.ByteBuffer ; if ( org.springframework.web.socket.messaging.WebSocketMessage<> instanceof TextMessage ) { java.nio.ByteBuffer = java.nio.ByteBuffer . java.nio.ByteBuffer ( ( ( TextMessage ) org.springframework.web.socket.messaging.WebSocketMessage<> ) . asBytes ( ) ) ; } else if ( org.springframework.web.socket.messaging.WebSocketMessage<> instanceof BinaryMessage ) { java.nio.ByteBuffer = ( ( BinaryMessage ) org.springframework.web.socket.messaging.WebSocketMessage<> ) . getPayload ( ) ; } else { return java.util.List<org.springframework.web.socket.messaging.Message<byte[]>> ; } java.util.List<org.springframework.web.socket.messaging.Message<byte[]>> = this . org.springframework.web.socket.messaging.BufferingStompDecoder . decode ( java.nio.ByteBuffer ) ; if ( java.util.List<org.springframework.web.socket.messaging.Message<byte[]>> . isEmpty ( ) ) { if ( org.springframework.web.socket.messaging.Log . isTraceEnabled ( ) ) { org.springframework.web.socket.messaging.Log . trace ( STRING + this . org.springframework.web.socket.messaging.BufferingStompDecoder . getBufferSize ( ) + STRING + this . org.springframework.web.socket.messaging.BufferingStompDecoder . getBufferSizeLimit ( ) + STRING ) ; } } return java.util.List<org.springframework.web.socket.messaging.Message<byte[]>> ; }  <METHOD_END>
<METHOD_START> public org.springframework.web.socket.messaging.WebSocketMessage<?> < ? > org.springframework.web.socket.messaging.WebSocketMessage<?> ( Message < byte [] > org.springframework.web.socket.messaging.Message<byte[]> , java.lang.Class<? extends org.springframework.web.socket.messaging.WebSocketSession> < ? extends WebSocketSession > java.lang.Class<? extends org.springframework.web.socket.messaging.WebSocketSession> ) { StompHeaderAccessor org.springframework.web.socket.messaging.StompHeaderAccessor = MessageHeaderAccessor . getAccessor ( org.springframework.web.socket.messaging.Message<byte[]> , StompHeaderAccessor .class ) ; Assert . notNull ( org.springframework.web.socket.messaging.StompHeaderAccessor , STRING ) ; byte [] byte[] = org.springframework.web.socket.messaging.Message<byte[]> . getPayload ( ) ; byte [] byte[] = org.springframework.web.socket.messaging.StompEncoder . encode ( org.springframework.web.socket.messaging.StompHeaderAccessor . getMessageHeaders ( ) , byte[] ) ; boolean boolean = ( byte[] . int > NUMBER && ! ( SockJsSession .class . boolean ( java.lang.Class<> ) ) && MimeTypeUtils . APPLICATION_OCTET_STREAM . isCompatibleWith ( org.springframework.web.socket.messaging.StompHeaderAccessor . getContentType ( ) ) ) ; return ( boolean ? new BinaryMessage ( byte[] ) : new TextMessage ( byte[] ) ) ; }  <METHOD_END>
