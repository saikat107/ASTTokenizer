<METHOD_START> public void ( SessionFactory < F > org.springframework.integration.file.remote.SessionFactory<F> ) { Assert . notNull ( org.springframework.integration.file.remote.SessionFactory<F> , STRING ) ; this . org.springframework.integration.file.remote.SessionFactory<F> = org.springframework.integration.file.remote.SessionFactory<F> ; }  <METHOD_END>
<METHOD_START> public org.springframework.integration.file.remote.SessionFactory<F> < F > org.springframework.integration.file.remote.SessionFactory<F> ( ) { return this . org.springframework.integration.file.remote.SessionFactory<F> ; }  <METHOD_END>
<METHOD_START> public void void ( boolean boolean ) { this . boolean = boolean ; }  <METHOD_END>
<METHOD_START> public void void ( java.lang.String java.lang.String ) { Assert . notNull ( java.lang.String , STRING ) ; this . java.lang.String = java.lang.String ; }  <METHOD_END>
<METHOD_START> public final java.lang.String java.lang.String ( ) { return this . java.lang.String ; }  <METHOD_END>
<METHOD_START> public void void ( Expression org.springframework.integration.file.remote.Expression ) { Assert . notNull ( org.springframework.integration.file.remote.Expression , STRING ) ; this . org.springframework.integration.file.remote.ExpressionEvaluatingMessageProcessor<java.lang.String> = new ExpressionEvaluatingMessageProcessor <> ( org.springframework.integration.file.remote.Expression , java.lang.String .class ) ; }  <METHOD_END>
<METHOD_START> public void void ( Expression org.springframework.integration.file.remote.Expression ) { Assert . notNull ( org.springframework.integration.file.remote.Expression , STRING ) ; this . org.springframework.integration.file.remote.ExpressionEvaluatingMessageProcessor<java.lang.String> = new ExpressionEvaluatingMessageProcessor <> ( org.springframework.integration.file.remote.Expression , java.lang.String .class ) ; }  <METHOD_END>
<METHOD_START> public void void ( Expression org.springframework.integration.file.remote.Expression ) { Assert . notNull ( org.springframework.integration.file.remote.Expression , STRING ) ; this . org.springframework.integration.file.remote.ExpressionEvaluatingMessageProcessor<java.lang.String> = new ExpressionEvaluatingMessageProcessor <> ( org.springframework.integration.file.remote.Expression , java.lang.String .class ) ; }  <METHOD_END>
<METHOD_START> public java.lang.String java.lang.String ( ) { return this . java.lang.String ; }  <METHOD_END>
<METHOD_START> public boolean boolean ( ) { return this . boolean ; }  <METHOD_END>
<METHOD_START> public void void ( boolean boolean ) { this . boolean = boolean ; }  <METHOD_END>
<METHOD_START> public void void ( FileNameGenerator org.springframework.integration.file.remote.FileNameGenerator ) { this . org.springframework.integration.file.remote.FileNameGenerator = ( org.springframework.integration.file.remote.FileNameGenerator != null ) ? org.springframework.integration.file.remote.FileNameGenerator : new DefaultFileNameGenerator ( ) ; this . boolean = org.springframework.integration.file.remote.FileNameGenerator != null ; }  <METHOD_END>
<METHOD_START> public void void ( java.lang.String java.lang.String ) { this . java.lang.String = java.lang.String ; }  <METHOD_END>
<METHOD_START> public void void ( java.lang.String java.lang.String ) { Assert . notNull ( java.lang.String , STRING ) ; this . boolean = true ; this . java.lang.String = java.lang.String ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( BeanFactory org.springframework.integration.file.remote.BeanFactory ) throws org.springframework.integration.file.remote.BeansException { this . org.springframework.integration.file.remote.BeanFactory = org.springframework.integration.file.remote.BeanFactory ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ) java.lang.Exception { BeanFactory org.springframework.integration.file.remote.BeanFactory = this . org.springframework.integration.file.remote.BeanFactory ; if ( org.springframework.integration.file.remote.BeanFactory != null ) { if ( this . org.springframework.integration.file.remote.ExpressionEvaluatingMessageProcessor<java.lang.String> != null ) { this . org.springframework.integration.file.remote.ExpressionEvaluatingMessageProcessor<java.lang.String> . setBeanFactory ( org.springframework.integration.file.remote.BeanFactory ) ; } if ( this . org.springframework.integration.file.remote.ExpressionEvaluatingMessageProcessor<java.lang.String> != null ) { this . org.springframework.integration.file.remote.ExpressionEvaluatingMessageProcessor<java.lang.String> . setBeanFactory ( org.springframework.integration.file.remote.BeanFactory ) ; } if ( ! this . boolean && this . org.springframework.integration.file.remote.FileNameGenerator instanceof BeanFactoryAware ) { ( ( BeanFactoryAware ) this . org.springframework.integration.file.remote.FileNameGenerator ) . setBeanFactory ( org.springframework.integration.file.remote.BeanFactory ) ; } if ( this . org.springframework.integration.file.remote.ExpressionEvaluatingMessageProcessor<java.lang.String> != null ) { this . org.springframework.integration.file.remote.ExpressionEvaluatingMessageProcessor<java.lang.String> . setBeanFactory ( org.springframework.integration.file.remote.BeanFactory ) ; } } if ( this . boolean ) { Assert . hasText ( this . java.lang.String , STRING ) ; } if ( this . boolean && ! this . boolean ) { this . org.springframework.integration.file.remote.Log . warn ( STRING + STRING ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.String java.lang.String ( final Message < ? > org.springframework.integration.file.remote.Message<?> ) { return java.lang.String ( org.springframework.integration.file.remote.Message<> , null ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.String java.lang.String ( final Message < ? > org.springframework.integration.file.remote.Message<?> , java.lang.String java.lang.String ) { return java.lang.String ( org.springframework.integration.file.remote.Message<> , java.lang.String , FileExistsMode . APPEND ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.String java.lang.String ( Message < ? > org.springframework.integration.file.remote.Message<?> , FileExistsMode ... org.springframework.integration.file.remote.FileExistsMode[] ) { return java.lang.String ( org.springframework.integration.file.remote.Message<> , null , org.springframework.integration.file.remote.FileExistsMode[] ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.String java.lang.String ( final Message < ? > org.springframework.integration.file.remote.Message<?> , java.lang.String java.lang.String , FileExistsMode ... org.springframework.integration.file.remote.FileExistsMode[] ) { FileExistsMode org.springframework.integration.file.remote.FileExistsMode = org.springframework.integration.file.remote.FileExistsMode[] == null || mode . length < NUMBER || org.springframework.integration.file.remote.FileExistsMode[] [ NUMBER ] == null ? FileExistsMode . REPLACE : org.springframework.integration.file.remote.FileExistsMode[] [ NUMBER ] ; return java.lang.String ( org.springframework.integration.file.remote.Message<> , java.lang.String , org.springframework.integration.file.remote.FileExistsMode ) ; }  <METHOD_END>
<METHOD_START> private java.lang.String java.lang.String ( final Message < ? > org.springframework.integration.file.remote.Message<?> , final java.lang.String java.lang.String , final FileExistsMode org.springframework.integration.file.remote.FileExistsMode ) { Assert . notNull ( this . org.springframework.integration.file.remote.ExpressionEvaluatingMessageProcessor<java.lang.String> , STRING ) ; Assert . isTrue ( ! FileExistsMode . APPEND . equals ( org.springframework.integration.file.remote.FileExistsMode ) || ! this . boolean , STRING ) ; Assert . isTrue ( ! FileExistsMode . REPLACE_IF_MODIFIED . equals ( org.springframework.integration.file.remote.FileExistsMode ) , STRING ) ; final org.springframework.integration.file.remote.RemoteFileTemplate.StreamHolder org.springframework.integration.file.remote.RemoteFileTemplate.StreamHolder = this . org.springframework.integration.file.remote.RemoteFileTemplate.StreamHolder ( org.springframework.integration.file.remote.Message<> ) ; if ( org.springframework.integration.file.remote.RemoteFileTemplate.StreamHolder != null ) { try { return this . T ( session -> { String fileName = inputStreamHolder . getName ( ) ; try { String remoteDirectory = RemoteFileTemplate .this . directoryExpressionProcessor . processMessage ( message ) ; remoteDirectory = RemoteFileTemplate .this . normalizeDirectoryPath ( remoteDirectory ) ; if ( StringUtils . hasText ( subDirectory ) ) { if ( subDirectory . startsWith ( RemoteFileTemplate .this . remoteFileSeparator ) ) { remoteDirectory += subDirectory . substring ( NUMBER ) ; } else { remoteDirectory += RemoteFileTemplate .this . normalizeDirectoryPath ( subDirectory ) ; } } String temporaryRemoteDirectory = remoteDirectory ; if ( RemoteFileTemplate .this . temporaryDirectoryExpressionProcessor != null ) { temporaryRemoteDirectory = RemoteFileTemplate .this . temporaryDirectoryExpressionProcessor . processMessage ( message ) ; } fileName = RemoteFileTemplate .this . fileNameGenerator . generateFileName ( message ) ; RemoteFileTemplate .this . sendFileToRemoteDirectory ( inputStreamHolder . getStream ( ) , temporaryRemoteDirectory , remoteDirectory , fileName , session , mode ) ; return remoteDirectory + fileName ; } catch ( FileNotFoundException e ) { throw new MessageDeliveryException ( message , STRING + inputStreamHolder . getName ( ) + STRING , e ) ; } catch ( IOException e ) { throw new MessageDeliveryException ( message , STRING + inputStreamHolder . getName ( ) + STRING + fileName + STRING , e ) ; } catch ( Exception e ) { throw new MessageDeliveryException ( message , STRING + inputStreamHolder . getName ( ) + STRING + fileName + STRING , e ) ; } } ) ; } finally { try { org.springframework.integration.file.remote.RemoteFileTemplate.StreamHolder . java.io.InputStream ( ) . void ( ) ; } catch ( java.io.IOException java.io.IOException ) {				} } } else { if ( this . org.springframework.integration.file.remote.Log . isWarnEnabled ( ) ) { this . org.springframework.integration.file.remote.Log . warn ( STRING + org.springframework.integration.file.remote.Message<> . getPayload ( ) + STRING ) ; } return null ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( final java.lang.String java.lang.String ) { return T ( session -> session . exists ( path ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( final java.lang.String java.lang.String ) { return T ( session -> session . remove ( path ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( final java.lang.String java.lang.String , final java.lang.String java.lang.String ) { Assert . hasText ( java.lang.String , STRING ) ; Assert . hasText ( java.lang.String , STRING ) ; this . T ( ( SessionCallbackWithoutResult < F > ) session -> { int lastSeparator = toPath . lastIndexOf ( RemoteFileTemplate .this . remoteFileSeparator ) ; if ( lastSeparator > NUMBER ) { String remoteFileDirectory = toPath . substring ( NUMBER , lastSeparator + NUMBER ) ; RemoteFileUtils . makeDirectories ( remoteFileDirectory , session , RemoteFileTemplate .this . remoteFileSeparator , RemoteFileTemplate .this . logger ) ; } session . rename ( fromPath , toPath ) ; } ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( Message < ? > org.springframework.integration.file.remote.Message<?> , InputStreamCallback org.springframework.integration.file.remote.InputStreamCallback ) { Assert . notNull ( this . org.springframework.integration.file.remote.ExpressionEvaluatingMessageProcessor<java.lang.String> , STRING ) ; java.lang.String java.lang.String = this . org.springframework.integration.file.remote.ExpressionEvaluatingMessageProcessor<java.lang.String> . processMessage ( org.springframework.integration.file.remote.Message<> ) ; return this . boolean ( java.lang.String , org.springframework.integration.file.remote.InputStreamCallback ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( final java.lang.String java.lang.String , final InputStreamCallback org.springframework.integration.file.remote.InputStreamCallback ) { Assert . notNull ( java.lang.String , STRING ) ; return this . T ( session -> { InputStream inputStream = session . readRaw ( remotePath ) ; callback . doWithInputStream ( inputStream ) ; inputStream . close ( ) ; return session . finalizeRaw ( ) ; } ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public F [] F[] ( java.lang.String java.lang.String ) { return T ( session -> session . list ( path ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.integration.file.remote.Session<F> < F > org.springframework.integration.file.remote.Session<F> ( ) { return this . org.springframework.integration.file.remote.SessionFactory<F> . getSession ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.SuppressWarnings ( STRING ) @ java.lang.Override public < T > T T ( SessionCallback < F , T > org.springframework.integration.file.remote.SessionCallback<F,T> ) { Session < F > org.springframework.integration.file.remote.Session<F> = null ; try { org.springframework.integration.file.remote.Session<F> = this . org.springframework.integration.file.remote.SessionFactory<F> . getSession ( ) ; Assert . notNull ( org.springframework.integration.file.remote.Session<F> , STRING ) ; return org.springframework.integration.file.remote.SessionCallback<F,T> . doInSession ( org.springframework.integration.file.remote.Session<F> ) ; } catch ( java.lang.Exception java.lang.Exception ) { if ( org.springframework.integration.file.remote.Session<F> instanceof CachingSessionFactory < ? > . CachingSessionFactory ) { ( ( CachingSessionFactory . CachingSessionFactory ) org.springframework.integration.file.remote.Session<F> ) . dirty ( ) ; } if ( java.lang.Exception instanceof MessagingException ) { throw ( MessagingException ) java.lang.Exception ; } throw new MessagingException ( STRING , java.lang.Exception ) ; } finally { if ( org.springframework.integration.file.remote.Session<F> != null ) { try { org.springframework.integration.file.remote.Session<F> . close ( ) ; } catch ( java.lang.Exception java.lang.Exception ) { if ( this . org.springframework.integration.file.remote.Log . isDebugEnabled ( ) ) { this . org.springframework.integration.file.remote.Log . debug ( STRING , java.lang.Exception ) ; } } } } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public < T , C > T T ( ClientCallback < C , T > org.springframework.integration.file.remote.ClientCallback<C,T> ) { throw new java.lang.UnsupportedOperationException ( STRING ) ; }  <METHOD_END>
<METHOD_START> private org.springframework.integration.file.remote.RemoteFileTemplate.StreamHolder org.springframework.integration.file.remote.RemoteFileTemplate.StreamHolder ( Message < ? > org.springframework.integration.file.remote.Message<?> ) throws org.springframework.integration.file.remote.MessageDeliveryException { try { java.lang.Object java.lang.Object = org.springframework.integration.file.remote.Message<> . getPayload ( ) ; java.io.InputStream java.io.InputStream = null ; java.lang.String java.lang.String = null ; if ( java.lang.Object instanceof java.io.InputStream ) { java.io.InputStream = ( java.io.InputStream ) java.lang.Object ; } else if ( java.lang.Object instanceof java.io.File ) { java.io.File java.io.File = ( java.io.File ) java.lang.Object ; if ( java.io.File . boolean ( ) ) { java.io.InputStream = new java.io.BufferedInputStream ( new java.io.FileInputStream ( java.io.File ) ) ; java.lang.String = java.io.File . java.lang.String ( ) ; } } else if ( java.lang.Object instanceof byte [] || java.lang.Object instanceof java.lang.String ) { byte [] byte[] = null ; if ( java.lang.Object instanceof java.lang.String ) { byte[] = ( ( java.lang.String ) java.lang.Object ) . byte[] ( this . java.lang.String ) ; java.lang.String = STRING ; } else { byte[] = ( byte [] ) java.lang.Object ; java.lang.String = STRING ; } java.io.InputStream = new java.io.ByteArrayInputStream ( byte[] ) ; } else { throw new java.lang.IllegalArgumentException ( STRING + STRING ) ; } if ( java.io.InputStream == null ) { return null ; } else { return new org.springframework.integration.file.remote.RemoteFileTemplate.StreamHolder ( java.io.InputStream , java.lang.String ) ; } } catch ( java.lang.Exception java.lang.Exception ) { throw new MessageDeliveryException ( org.springframework.integration.file.remote.Message<> , STRING , java.lang.Exception ) ; } }  <METHOD_END>
<METHOD_START> private void void ( java.io.InputStream java.io.InputStream , java.lang.String java.lang.String , java.lang.String java.lang.String , java.lang.String java.lang.String , Session < F > org.springframework.integration.file.remote.Session<F> , FileExistsMode org.springframework.integration.file.remote.FileExistsMode ) throws java.io.IOException { java.lang.String = this . java.lang.String ( java.lang.String ) ; java.lang.String = this . java.lang.String ( java.lang.String ) ; java.lang.String java.lang.String = java.lang.String + java.lang.String ; java.lang.String java.lang.String = java.lang.String + java.lang.String ; java.lang.String java.lang.String = java.lang.String + ( this . boolean ? this . java.lang.String : STRING ) ; if ( this . boolean ) { try { RemoteFileUtils . makeDirectories ( java.lang.String , org.springframework.integration.file.remote.Session<F> , this . java.lang.String , this . org.springframework.integration.file.remote.Log ) ; } catch ( java.lang.IllegalStateException java.lang.IllegalStateException ) { org.springframework.integration.file.remote.Session<F> . mkdir ( java.lang.String ) ; } } try { boolean boolean = this . boolean ; if ( FileExistsMode . REPLACE . equals ( org.springframework.integration.file.remote.FileExistsMode ) ) { org.springframework.integration.file.remote.Session<F> . write ( java.io.InputStream , java.lang.String ) ; } else if ( FileExistsMode . APPEND . equals ( org.springframework.integration.file.remote.FileExistsMode ) ) { org.springframework.integration.file.remote.Session<F> . append ( java.io.InputStream , java.lang.String ) ; } else { if ( boolean ( java.lang.String ) ) { if ( FileExistsMode . FAIL . equals ( org.springframework.integration.file.remote.FileExistsMode ) ) { throw new MessagingException ( STRING + java.lang.String + STRING ) ; } else { if ( this . org.springframework.integration.file.remote.Log . isDebugEnabled ( ) ) { this . org.springframework.integration.file.remote.Log . debug ( STRING + java.lang.String + STRING ) ; } } boolean = false ; } else { org.springframework.integration.file.remote.Session<F> . write ( java.io.InputStream , java.lang.String ) ; } } if ( boolean ) { org.springframework.integration.file.remote.Session<F> . rename ( java.lang.String , java.lang.String ) ; } } catch ( java.lang.Exception java.lang.Exception ) { throw new MessagingException ( STRING + java.lang.String + STRING , java.lang.Exception ) ; } finally { java.io.InputStream . void ( ) ; } }  <METHOD_END>
<METHOD_START> private java.lang.String java.lang.String ( java.lang.String java.lang.String ) { if ( ! StringUtils . hasText ( java.lang.String ) ) { java.lang.String = STRING ; } else if ( ! java.lang.String . boolean ( this . java.lang.String ) ) { java.lang.String += this . java.lang.String ; } return java.lang.String ; }  <METHOD_END>
<METHOD_START> private void ( java.io.InputStream java.io.InputStream , java.lang.String java.lang.String ) { this . java.io.InputStream = java.io.InputStream ; this . java.lang.String = java.lang.String ; }  <METHOD_END>
<METHOD_START> public java.io.InputStream java.io.InputStream ( ) { return this . java.io.InputStream ; }  <METHOD_END>
<METHOD_START> public java.lang.String java.lang.String ( ) { return this . java.lang.String ; }  <METHOD_END>
