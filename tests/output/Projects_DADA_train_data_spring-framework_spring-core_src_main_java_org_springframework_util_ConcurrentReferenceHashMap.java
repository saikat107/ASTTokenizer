<METHOD_START> public void ( ) { this( int , float , int , org.springframework.util.ConcurrentReferenceHashMap.ReferenceType ); }  <METHOD_END>
<METHOD_START> public void ( int int ) { this( int , float , int , org.springframework.util.ConcurrentReferenceHashMap.ReferenceType ); }  <METHOD_END>
<METHOD_START> public void ( int int , float float ) { this( int , float , int , org.springframework.util.ConcurrentReferenceHashMap.ReferenceType ); }  <METHOD_END>
<METHOD_START> public void ( int int , int int ) { this( int , float , int , org.springframework.util.ConcurrentReferenceHashMap.ReferenceType ); }  <METHOD_END>
<METHOD_START> public void ( int int , org.springframework.util.ConcurrentReferenceHashMap.ReferenceType org.springframework.util.ConcurrentReferenceHashMap.ReferenceType ) { this( int , float , int , org.springframework.util.ConcurrentReferenceHashMap.ReferenceType ); }  <METHOD_END>
<METHOD_START> public void ( int int , float float , int int ) { this( int , float , int , org.springframework.util.ConcurrentReferenceHashMap.ReferenceType ); }  <METHOD_END>
<METHOD_START> @ java.lang.SuppressWarnings ( STRING ) public void ( int int , float float , int int , org.springframework.util.ConcurrentReferenceHashMap.ReferenceType org.springframework.util.ConcurrentReferenceHashMap.ReferenceType ) { Assert . isTrue ( int >= NUMBER , STRING ) ; Assert . isTrue ( float > NUMBER , STRING ) ; Assert . isTrue ( int > NUMBER , STRING ) ; Assert . notNull ( org.springframework.util.ConcurrentReferenceHashMap.ReferenceType , STRING ) ; this . float = float ; this . int = int ( int , int ) ; int int = NUMBER << this . int ; this . org.springframework.util.ConcurrentReferenceHashMap.ReferenceType = org.springframework.util.ConcurrentReferenceHashMap.ReferenceType ; int int = ( int ) ( ( int + int - NUMBER ) / int ) ; this . org.springframework.util.ConcurrentReferenceHashMap<K,V>.Segment[] = ( org.springframework.util.ConcurrentReferenceHashMap<K,V>.Segment [] ) java.lang.reflect.Array . java.lang.Object ( org.springframework.util.ConcurrentReferenceHashMap<K,V>.Segment .class , int ) ; for ( int int = NUMBER ; int < this . org.springframework.util.ConcurrentReferenceHashMap<K,V>.Segment[] . int ; int ++ ) { this . org.springframework.util.ConcurrentReferenceHashMap<K,V>.Segment[] [ int ] = new org.springframework.util.ConcurrentReferenceHashMap<K,V>.Segment ( int ) ; } }  <METHOD_END>
<METHOD_START> protected final float float ( ) { return this . float ; }  <METHOD_END>
<METHOD_START> protected final int int ( ) { return this . org.springframework.util.ConcurrentReferenceHashMap<K,V>.Segment[] . int ; }  <METHOD_END>
<METHOD_START> protected final org.springframework.util.ConcurrentReferenceHashMap<K,V>.Segment org.springframework.util.ConcurrentReferenceHashMap<K,V>.Segment ( int int ) { return this . org.springframework.util.ConcurrentReferenceHashMap<K,V>.Segment[] [ int ] ; }  <METHOD_END>
<METHOD_START> protected org.springframework.util.ConcurrentReferenceHashMap<K,V>.ReferenceManager org.springframework.util.ConcurrentReferenceHashMap<K,V>.ReferenceManager ( ) { return new org.springframework.util.ConcurrentReferenceHashMap<K,V>.ReferenceManager ( ) ; }  <METHOD_END>
<METHOD_START> protected int int ( java.lang.Object java.lang.Object ) { int int = java.lang.Object == null ? NUMBER : java.lang.Object . int ( ) ; int += ( int << NUMBER ) ^ NUMBER ; int ^= ( int >>> NUMBER ) ; int += ( int << NUMBER ) ; int ^= ( int >>> NUMBER ) ; int += ( int << NUMBER ) + ( int << NUMBER ) ; int ^= ( int >>> NUMBER ) ; return int ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public V V ( java.lang.Object java.lang.Object ) { org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> < K , V > org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> = org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> ( java.lang.Object , org.springframework.util.ConcurrentReferenceHashMap.Restructure . org.springframework.util.ConcurrentReferenceHashMap.Restructure ) ; org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> < K , V > org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> = ( org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> != null ? org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> . org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> ( ) : null ) ; return ( org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> != null ? org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> . V ( ) : null ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( java.lang.Object java.lang.Object ) { org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> < K , V > org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> = org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> ( java.lang.Object , org.springframework.util.ConcurrentReferenceHashMap.Restructure . org.springframework.util.ConcurrentReferenceHashMap.Restructure ) ; org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> < K , V > org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> = ( org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> != null ? org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> . org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> ( ) : null ) ; return ( org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> != null && ObjectUtils . nullSafeEquals ( org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> . K ( ) , java.lang.Object ) ) ; }  <METHOD_END>
<METHOD_START> protected final org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> < K , V > org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> ( java.lang.Object java.lang.Object , org.springframework.util.ConcurrentReferenceHashMap.Restructure org.springframework.util.ConcurrentReferenceHashMap.Restructure ) { int int = int ( java.lang.Object ) ; return org.springframework.util.ConcurrentReferenceHashMap<K,V>.Segment ( int ) . org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> ( java.lang.Object , int , org.springframework.util.ConcurrentReferenceHashMap.Restructure ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public V V ( K K , V V ) { return V ( K , V , true ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public V V ( K K , V V ) { return V ( K , V , false ) ; }  <METHOD_END>
<METHOD_START> private V V ( final K K , final V V , final boolean boolean ) { return V ( K , new org.springframework.util.ConcurrentReferenceHashMap<K,V>.Task<V> < V > ( org.springframework.util.ConcurrentReferenceHashMap.TaskOption . org.springframework.util.ConcurrentReferenceHashMap.TaskOption , org.springframework.util.ConcurrentReferenceHashMap.TaskOption . org.springframework.util.ConcurrentReferenceHashMap.TaskOption ) { @ java.lang.Override protected V V ( org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> < K , V > org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> , org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> < K , V > org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> , org.springframework.util.ConcurrentReferenceHashMap<K,V>.Entries org.springframework.util.ConcurrentReferenceHashMap<K,V>.Entries ) { if ( org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> != null ) { V V = org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> . V ( ) ; if ( boolean ) { org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> . V ( V ) ; } return V ; } org.springframework.util.ConcurrentReferenceHashMap<K,V>.Entries . void ( V ) ; return null ; } } ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected V V ( org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> < K , V > org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> , org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> < K , V > org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> , org.springframework.util.ConcurrentReferenceHashMap<K,V>.Entries org.springframework.util.ConcurrentReferenceHashMap<K,V>.Entries ) { if ( org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> != null ) { V V = org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> . V ( ) ; if ( boolean ) { org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> . V ( V ) ; } return V ; } org.springframework.util.ConcurrentReferenceHashMap<K,V>.Entries . void ( V ) ; return null ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public V V ( java.lang.Object java.lang.Object ) { return V ( java.lang.Object , new org.springframework.util.ConcurrentReferenceHashMap<K,V>.Task<V> < V > ( org.springframework.util.ConcurrentReferenceHashMap.TaskOption . org.springframework.util.ConcurrentReferenceHashMap.TaskOption , org.springframework.util.ConcurrentReferenceHashMap.TaskOption . org.springframework.util.ConcurrentReferenceHashMap.TaskOption ) { @ java.lang.Override protected V V ( org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> < K , V > org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> , org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> < K , V > org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> ) { if ( org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> != null ) { org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> . void ( ) ; return org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> . V ; } return null ; } } ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected V V ( org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> < K , V > org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> , org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> < K , V > org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> ) { if ( org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> != null ) { org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> . void ( ) ; return org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> . V ; } return null ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( java.lang.Object java.lang.Object , final java.lang.Object java.lang.Object ) { return java.lang.Boolean ( java.lang.Object , new org.springframework.util.ConcurrentReferenceHashMap<K,V>.Task<java.lang.Boolean> < java.lang.Boolean > ( org.springframework.util.ConcurrentReferenceHashMap.TaskOption . org.springframework.util.ConcurrentReferenceHashMap.TaskOption , org.springframework.util.ConcurrentReferenceHashMap.TaskOption . org.springframework.util.ConcurrentReferenceHashMap.TaskOption ) { @ java.lang.Override protected java.lang.Boolean java.lang.Boolean ( org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> < K , V > org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> , org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> < K , V > org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> ) { if ( org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> != null && ObjectUtils . nullSafeEquals ( org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> . V ( ) , java.lang.Object ) ) { org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> . void ( ) ; return true ; } return false ; } } ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected java.lang.Boolean java.lang.Boolean ( org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> < K , V > org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> , org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> < K , V > org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> ) { if ( org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> != null && ObjectUtils . nullSafeEquals ( org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> . V ( ) , java.lang.Object ) ) { org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> . void ( ) ; return true ; } return false ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( K K , final V V , final V V ) { return java.lang.Boolean ( K , new org.springframework.util.ConcurrentReferenceHashMap<K,V>.Task<java.lang.Boolean> < java.lang.Boolean > ( org.springframework.util.ConcurrentReferenceHashMap.TaskOption . org.springframework.util.ConcurrentReferenceHashMap.TaskOption , org.springframework.util.ConcurrentReferenceHashMap.TaskOption . org.springframework.util.ConcurrentReferenceHashMap.TaskOption ) { @ java.lang.Override protected java.lang.Boolean java.lang.Boolean ( org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> < K , V > org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> , org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> < K , V > org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> ) { if ( org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> != null && ObjectUtils . nullSafeEquals ( org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> . V ( ) , V ) ) { org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> . V ( V ) ; return true ; } return false ; } } ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected java.lang.Boolean java.lang.Boolean ( org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> < K , V > org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> , org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> < K , V > org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> ) { if ( org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> != null && ObjectUtils . nullSafeEquals ( org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> . V ( ) , V ) ) { org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> . V ( V ) ; return true ; } return false ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public V V ( K K , final V V ) { return V ( K , new org.springframework.util.ConcurrentReferenceHashMap<K,V>.Task<V> < V > ( org.springframework.util.ConcurrentReferenceHashMap.TaskOption . org.springframework.util.ConcurrentReferenceHashMap.TaskOption , org.springframework.util.ConcurrentReferenceHashMap.TaskOption . org.springframework.util.ConcurrentReferenceHashMap.TaskOption ) { @ java.lang.Override protected V V ( org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> < K , V > org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> , org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> < K , V > org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> ) { if ( org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> != null ) { V V = org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> . V ( ) ; org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> . V ( V ) ; return V ; } return null ; } } ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected V V ( org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> < K , V > org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> , org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> < K , V > org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> ) { if ( org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> != null ) { V V = org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> . V ( ) ; org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> . V ( V ) ; return V ; } return null ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ) { for ( org.springframework.util.ConcurrentReferenceHashMap<K,V>.Segment org.springframework.util.ConcurrentReferenceHashMap<K,V>.Segment : this . org.springframework.util.ConcurrentReferenceHashMap<K,V>.Segment[] ) { org.springframework.util.ConcurrentReferenceHashMap<K,V>.Segment . void ( ) ; } }  <METHOD_END>
<METHOD_START> public void void ( ) { for ( org.springframework.util.ConcurrentReferenceHashMap<K,V>.Segment org.springframework.util.ConcurrentReferenceHashMap<K,V>.Segment : this . org.springframework.util.ConcurrentReferenceHashMap<K,V>.Segment[] ) { org.springframework.util.ConcurrentReferenceHashMap<K,V>.Segment . void ( false ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public int int ( ) { int int = NUMBER ; for ( org.springframework.util.ConcurrentReferenceHashMap<K,V>.Segment org.springframework.util.ConcurrentReferenceHashMap<K,V>.Segment : this . org.springframework.util.ConcurrentReferenceHashMap<K,V>.Segment[] ) { int += org.springframework.util.ConcurrentReferenceHashMap<K,V>.Segment . int ( ) ; } return int ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.util.Set<java.util.Map.Entry<K,V>> < java . util . java.util.Map . java.util.Map.Entry<K,V> < K , V > > java.util.Set<java.util.Map.Entry<K,V>> ( ) { if ( this . java.util.Set<java.util.Map.Entry<K,V>> == null ) { this . java.util.Set<java.util.Map.Entry<K,V>> = new org.springframework.util.ConcurrentReferenceHashMap<K,V>.EntrySet ( ) ; } return this . java.util.Set<java.util.Map.Entry<K,V>> ; }  <METHOD_END>
<METHOD_START> private < T > T T ( java.lang.Object java.lang.Object , org.springframework.util.ConcurrentReferenceHashMap<K,V>.Task<T> < T > org.springframework.util.ConcurrentReferenceHashMap<K,V>.Task<T> ) { int int = int ( java.lang.Object ) ; return org.springframework.util.ConcurrentReferenceHashMap<K,V>.Segment ( int ) . T ( int , java.lang.Object , org.springframework.util.ConcurrentReferenceHashMap<K,V>.Task<T> ) ; }  <METHOD_END>
<METHOD_START> private org.springframework.util.ConcurrentReferenceHashMap<K,V>.Segment org.springframework.util.ConcurrentReferenceHashMap<K,V>.Segment ( int int ) { return this . org.springframework.util.ConcurrentReferenceHashMap<K,V>.Segment[] [ ( int >>> ( NUMBER - this . int ) ) & ( this . org.springframework.util.ConcurrentReferenceHashMap<K,V>.Segment[] . int - NUMBER ) ] ; }  <METHOD_END>
<METHOD_START> protected static int int ( int int , int int ) { int int = NUMBER ; int int = NUMBER ; while ( int < int && int < int ) { int <<= NUMBER ; int ++ ; } return int ; }  <METHOD_END>
<METHOD_START> public void ( int int ) { this . org.springframework.util.ConcurrentReferenceHashMap<K,V>.ReferenceManager = org.springframework.util.ConcurrentReferenceHashMap<K,V>.ReferenceManager ( ) ; this . int = NUMBER << int ( int , int ) ; void ( org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V>[] ( this . int ) ) ; }  <METHOD_END>
<METHOD_START> public org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> < K , V > org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> ( java.lang.Object java.lang.Object , int int , org.springframework.util.ConcurrentReferenceHashMap.Restructure org.springframework.util.ConcurrentReferenceHashMap.Restructure ) { if ( org.springframework.util.ConcurrentReferenceHashMap.Restructure == org.springframework.util.ConcurrentReferenceHashMap.Restructure . org.springframework.util.ConcurrentReferenceHashMap.Restructure ) { void ( false ) ; } if ( this . int == NUMBER ) { return null ; } org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> < K , V > [] org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V>[] = this . org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V>[] ; int int = int ( int , org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V>[] ) ; org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> < K , V > org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> = org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V>[] [ int ] ; return org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> ( org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> , java.lang.Object , int ) ; }  <METHOD_END>
<METHOD_START> public < T > T T ( final int int , final java.lang.Object java.lang.Object , final org.springframework.util.ConcurrentReferenceHashMap<K,V>.Task<T> < T > org.springframework.util.ConcurrentReferenceHashMap<K,V>.Task<T> ) { boolean boolean = org.springframework.util.ConcurrentReferenceHashMap<K,V>.Task<T> . boolean ( org.springframework.util.ConcurrentReferenceHashMap.TaskOption . org.springframework.util.ConcurrentReferenceHashMap.TaskOption ) ; if ( org.springframework.util.ConcurrentReferenceHashMap<K,V>.Task<T> . boolean ( org.springframework.util.ConcurrentReferenceHashMap.TaskOption . org.springframework.util.ConcurrentReferenceHashMap.TaskOption ) ) { void ( boolean ) ; } if ( org.springframework.util.ConcurrentReferenceHashMap<K,V>.Task<T> . boolean ( org.springframework.util.ConcurrentReferenceHashMap.TaskOption . org.springframework.util.ConcurrentReferenceHashMap.TaskOption ) && this . int == NUMBER ) { return org.springframework.util.ConcurrentReferenceHashMap<K,V>.Task<T> . T ( null , null , null ) ; } void ( ) ; try { final int int = int ( int , this . org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V>[] ) ; final org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> < K , V > org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> = this . org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V>[] [ int ] ; org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> < K , V > org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> = org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> ( org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> , java.lang.Object , int ) ; org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> < K , V > org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> = ( org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> != null ? org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> . org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> ( ) : null ) ; org.springframework.util.ConcurrentReferenceHashMap<K,V>.Entries org.springframework.util.ConcurrentReferenceHashMap<K,V>.Entries = new org.springframework.util.ConcurrentReferenceHashMap<K,V>.Entries ( ) { @ java.lang.Override public void void ( V V ) { @ java.lang.SuppressWarnings ( STRING ) org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> < K , V > org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> = new org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> <> ( ( K ) java.lang.Object , V ) ; org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> < K , V > org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> = org.springframework.util.ConcurrentReferenceHashMap<K,V>.Segment .this . org.springframework.util.ConcurrentReferenceHashMap<K,V>.ReferenceManager . org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> ( org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> , int , org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> ) ; org.springframework.util.ConcurrentReferenceHashMap<K,V>.Segment .this . org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V>[] [ int ] = org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> ; org.springframework.util.ConcurrentReferenceHashMap<K,V>.Segment .this . int ++ ; } } ; return org.springframework.util.ConcurrentReferenceHashMap<K,V>.Task<T> . T ( org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> , org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> , org.springframework.util.ConcurrentReferenceHashMap<K,V>.Entries ) ; } finally { void ( ) ; if ( org.springframework.util.ConcurrentReferenceHashMap<K,V>.Task<T> . boolean ( org.springframework.util.ConcurrentReferenceHashMap.TaskOption . org.springframework.util.ConcurrentReferenceHashMap.TaskOption ) ) { void ( boolean ) ; } } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( V V ) { @ java.lang.SuppressWarnings ( STRING ) org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> < K , V > org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> = new org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> <> ( ( K ) java.lang.Object , V ) ; org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> < K , V > org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> = org.springframework.util.ConcurrentReferenceHashMap<K,V>.Segment .this . org.springframework.util.ConcurrentReferenceHashMap<K,V>.ReferenceManager . org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> ( org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> , int , org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> ) ; org.springframework.util.ConcurrentReferenceHashMap<K,V>.Segment .this . org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V>[] [ int ] = org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> ; org.springframework.util.ConcurrentReferenceHashMap<K,V>.Segment .this . int ++ ; }  <METHOD_END>
<METHOD_START> public void void ( ) { if ( this . int == NUMBER ) { return; } void ( ) ; try { void ( org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V>[] ( this . int ) ) ; this . int = NUMBER ; } finally { void ( ) ; } }  <METHOD_END>
<METHOD_START> protected final void void ( boolean boolean ) { boolean boolean = ( ( this . int > NUMBER ) && ( this . int >= this . int ) ) ; org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> < K , V > org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> = this . org.springframework.util.ConcurrentReferenceHashMap<K,V>.ReferenceManager . org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> ( ) ; if ( ( org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> != null ) || ( boolean && boolean ) ) { void ( ) ; try { int int = this . int ; java.util.Set<org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V>> < org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> < K , V > > java.util.Set<org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V>> = java.util.Collections . java.util.Set<org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V>> ( ) ; if ( org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> != null ) { java.util.Set<org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V>> = new java.util.HashSet<org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V>> <> ( ) ; while ( org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> != null ) { java.util.Set<org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V>> . boolean ( org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> ) ; org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> = this . org.springframework.util.ConcurrentReferenceHashMap<K,V>.ReferenceManager . org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> ( ) ; } } int -= java.util.Set<org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V>> . int ( ) ; boolean = ( int > NUMBER && int >= this . int ) ; boolean boolean = false ; int int = this . org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V>[] . int ; if ( boolean && boolean && int < int ) { int <<= NUMBER ; boolean = true ; } org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> < K , V > [] org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V>[] = ( boolean ? org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V>[] ( int ) : this . org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V>[] ) ; for ( int int = NUMBER ; int < this . org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V>[] . int ; int ++ ) { org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> = this . org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V>[] [ int ] ; if ( ! boolean ) { org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V>[] [ int ] = null ; } while ( org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> != null ) { if ( ! java.util.Set<org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V>> . boolean ( org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> ) && ( org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> . org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> ( ) != null ) ) { int int = int ( org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> . int ( ) , org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V>[] ) ; org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V>[] [ int ] = this . org.springframework.util.ConcurrentReferenceHashMap<K,V>.ReferenceManager . org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> ( org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> . org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> ( ) , org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> . int ( ) , org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V>[] [ int ] ) ; } org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> = org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> . org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> ( ) ; } } if ( boolean ) { void ( org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V>[] ) ; } this . int = java.lang.Math . int ( int , NUMBER ) ; } finally { void ( ) ; } } }  <METHOD_END>
<METHOD_START> private org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> < K , V > org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> ( org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> < K , V > org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> , java.lang.Object java.lang.Object , int int ) { while ( org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> != null ) { if ( org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> . int ( ) == int ) { org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> < K , V > org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> = org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> . org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> ( ) ; if ( org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> != null ) { K K = org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> . K ( ) ; if ( K == java.lang.Object || K . boolean ( java.lang.Object ) ) { return org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> ; } } } org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> = org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> . org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> ( ) ; } return null ; }  <METHOD_END>
<METHOD_START> @ java.lang.SuppressWarnings ( STRING ) private org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> < K , V > [] org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V>[] ( int int ) { return ( org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> < K , V > [] ) java.lang.reflect.Array . java.lang.Object ( org.springframework.util.ConcurrentReferenceHashMap.Reference .class , int ) ; }  <METHOD_END>
<METHOD_START> private int int ( int int , org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> < K , V > [] org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V>[] ) { return ( int & ( org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V>[] . int - NUMBER ) ) ; }  <METHOD_END>
<METHOD_START> private void void ( org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> < K , V > [] org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V>[] ) { this . org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V>[] = org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V>[] ; this . int = ( int ) ( org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V>[] . int * float ( ) ) ; }  <METHOD_END>
<METHOD_START> public final int int ( ) { return this . org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V>[] . int ; }  <METHOD_END>
<METHOD_START> public final int int ( ) { return this . int ; }  <METHOD_END>
<METHOD_START> org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> < K , V > org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> ( )  <METHOD_END>
<METHOD_START> int int ( )  <METHOD_END>
<METHOD_START> org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> < K , V > org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> ( )  <METHOD_END>
<METHOD_START> void void ( )  <METHOD_END>
<METHOD_START> public void ( K K , V V ) { this . K = K ; this . V = V ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public K K ( ) { return this . K ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public V V ( ) { return this . V ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public V V ( V V ) { V V = this . V ; this . V = V ; return V ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.String java.lang.String ( ) { return ( this . K + STRING + this . V ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override @ java.lang.SuppressWarnings ( STRING ) public final boolean boolean ( java.lang.Object java.lang.Object ) { if ( this == java.lang.Object ) { return true ; } if ( ! ( java.lang.Object instanceof java.util.Map . java.util.Map.Entry ) ) { return false ; } java.util.Map . java.util.Map.Entry java.util.Map.Entry = ( java.util.Map . java.util.Map.Entry ) java.lang.Object ; return ( ObjectUtils . nullSafeEquals ( K ( ) , java.util.Map.Entry . java.lang.Object ( ) ) && ObjectUtils . nullSafeEquals ( V ( ) , java.util.Map.Entry . java.lang.Object ( ) ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public final int int ( ) { return ( ObjectUtils . nullSafeHashCode ( this . K ) ^ ObjectUtils . nullSafeHashCode ( this . V ) ) ; }  <METHOD_END>
<METHOD_START> public void ( org.springframework.util.ConcurrentReferenceHashMap.TaskOption ... org.springframework.util.ConcurrentReferenceHashMap.TaskOption[] ) { this . java.util.EnumSet<org.springframework.util.ConcurrentReferenceHashMap.TaskOption> = ( org.springframework.util.ConcurrentReferenceHashMap.TaskOption[] . int == NUMBER ? java.util.EnumSet . java.util.EnumSet<org.springframework.util.ConcurrentReferenceHashMap.TaskOption> ( org.springframework.util.ConcurrentReferenceHashMap.TaskOption .class ) : java.util.EnumSet . java.util.EnumSet<org.springframework.util.ConcurrentReferenceHashMap.TaskOption> ( org.springframework.util.ConcurrentReferenceHashMap.TaskOption[] [ NUMBER ] , org.springframework.util.ConcurrentReferenceHashMap.TaskOption[] ) ) ; }  <METHOD_END>
<METHOD_START> public boolean boolean ( org.springframework.util.ConcurrentReferenceHashMap.TaskOption org.springframework.util.ConcurrentReferenceHashMap.TaskOption ) { return this . java.util.EnumSet<org.springframework.util.ConcurrentReferenceHashMap.TaskOption> . boolean ( org.springframework.util.ConcurrentReferenceHashMap.TaskOption ) ; }  <METHOD_END>
<METHOD_START> protected T T ( org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> < K , V > org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> , org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> < K , V > org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> , org.springframework.util.ConcurrentReferenceHashMap<K,V>.Entries org.springframework.util.ConcurrentReferenceHashMap<K,V>.Entries ) { return T ( org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> , org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> ) ; }  <METHOD_END>
<METHOD_START> protected T T ( org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> < K , V > org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> , org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> < K , V > org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> ) { return null ; }  <METHOD_END>
<METHOD_START> public abstract void void ( V V );  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.util.Iterator<java.util.Map.Entry<K,V>> < java.util.Map . java.util.Map.Entry<K,V> < K , V > > java.util.Iterator<java.util.Map.Entry<K,V>> ( ) { return new org.springframework.util.ConcurrentReferenceHashMap<K,V>.EntryIterator ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( java.lang.Object java.lang.Object ) { if ( java.lang.Object != null && java.lang.Object instanceof java.util.Map . java.util.Map.Entry<?,?> < ? , ? > ) { java.util.Map . java.util.Map.Entry<?,?> < ? , ? > java.util.Map.Entry<?,?> = ( java . util . java.util.Map . java.util.Map.Entry<?,?> < ? , ? > ) java.lang.Object ; org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> < K , V > org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> = org.springframework.util.ConcurrentReferenceHashMap .this . org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> ( java.util.Map.Entry<,> . getKey ( ) , org.springframework.util.ConcurrentReferenceHashMap.Restructure . org.springframework.util.ConcurrentReferenceHashMap.Restructure ) ; org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> < K , V > org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> = ( org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> != null ? org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> . org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> ( ) : null ) ; if ( org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> != null ) { return ObjectUtils . nullSafeEquals ( java.util.Map.Entry<,> . getValue ( ) , org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> . V ( ) ) ; } } return false ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( java.lang.Object java.lang.Object ) { if ( java.lang.Object instanceof java.util.Map . java.util.Map.Entry<?,?> < ? , ? > ) { java.util.Map . java.util.Map.Entry<?,?> < ? , ? > java.util.Map.Entry<?,?> = ( java.util.Map . java.util.Map.Entry<?,?> < ? , ? > ) java.lang.Object ; return org.springframework.util.ConcurrentReferenceHashMap .this . boolean ( java.util.Map.Entry<,> . getKey ( ) , java.util.Map.Entry<,> . getValue ( ) ) ; } return false ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public int int ( ) { return org.springframework.util.ConcurrentReferenceHashMap .this . int ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ) { org.springframework.util.ConcurrentReferenceHashMap .this . void ( ) ; }  <METHOD_END>
<METHOD_START> public void ( ) { void ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( ) { void ( ) ; return ( this . org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> != null ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> < K , V > org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> ( ) { void ( ) ; if ( this . org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> == null ) { throw new java.util.NoSuchElementException ( ) ; } this . org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> = this . org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> ; this . org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> = null ; return this . org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> ; }  <METHOD_END>
<METHOD_START> private void void ( ) { while ( this . org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> == null ) { void ( ) ; if ( this . org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> == null ) { return; } this . org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> = this . org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> . org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> ( ) ; } }  <METHOD_END>
<METHOD_START> private void void ( ) { if ( this . org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> != null ) { this . org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> = this . org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> . org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> ( ) ; } while ( this . org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> == null && this . org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V>[] != null ) { if ( this . int >= this . org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V>[] . int ) { void ( ) ; this . int = NUMBER ; } else { this . org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> = this . org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V>[] [ this . int ] ; this . int ++ ; } } }  <METHOD_END>
<METHOD_START> private void void ( ) { this . org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> = null ; this . org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V>[] = null ; if ( this . int < org.springframework.util.ConcurrentReferenceHashMap .this . org.springframework.util.ConcurrentReferenceHashMap<K,V>.Segment[] . int ) { this . org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V>[] = org.springframework.util.ConcurrentReferenceHashMap .this . org.springframework.util.ConcurrentReferenceHashMap<K,V>.Segment[] [ this . int ] . org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V>[] ; this . int ++ ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ) { Assert . state ( this . org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> != null , STRING ) ; org.springframework.util.ConcurrentReferenceHashMap .this . V ( this . org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> . K ( ) ) ; }  <METHOD_END>
<METHOD_START> public org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> < K , V > org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> ( org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> < K , V > org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> , int int , org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> < K , V > org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> ) { if ( org.springframework.util.ConcurrentReferenceHashMap .this . org.springframework.util.ConcurrentReferenceHashMap.ReferenceType == org.springframework.util.ConcurrentReferenceHashMap.ReferenceType . org.springframework.util.ConcurrentReferenceHashMap.ReferenceType ) { return new org.springframework.util.ConcurrentReferenceHashMap.WeakEntryReference<K,V> <> ( org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> , int , org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> , this . java.lang.ref.ReferenceQueue<org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V>> ) ; } return new org.springframework.util.ConcurrentReferenceHashMap.SoftEntryReference<K,V> <> ( org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> , int , org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> , this . java.lang.ref.ReferenceQueue<org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V>> ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.SuppressWarnings ( STRING ) public org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> < K , V > org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> ( ) { return ( org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> < K , V > ) this . java.lang.ref.ReferenceQueue<org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V>> . java.lang.ref.Reference<? extends org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V>> ( ) ; }  <METHOD_END>
<METHOD_START> public void ( org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> < K , V > org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> , int int , org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> < K , V > org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> , java.lang.ref.ReferenceQueue<org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V>> < org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> < K , V > > java.lang.ref.ReferenceQueue<org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V>> ) { super( org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> , java.lang.ref.ReferenceQueue<org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V>> ); this . int = int ; this . org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> = org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public int int ( ) { return this . int ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> < K , V > org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> ( ) { return this . org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ) { boolean ( ) ; void ( ) ; }  <METHOD_END>
<METHOD_START> public void ( org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> < K , V > org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> , int int , org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> < K , V > org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> , java.lang.ref.ReferenceQueue<org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V>> < org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> < K , V > > java.lang.ref.ReferenceQueue<org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V>> ) { super( org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V> , java.lang.ref.ReferenceQueue<org.springframework.util.ConcurrentReferenceHashMap.Entry<K,V>> ); this . int = int ; this . org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> = org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public int int ( ) { return this . int ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> < K , V > org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> ( ) { return this . org.springframework.util.ConcurrentReferenceHashMap.Reference<K,V> ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ) { boolean ( ) ; void ( ) ; }  <METHOD_END>
