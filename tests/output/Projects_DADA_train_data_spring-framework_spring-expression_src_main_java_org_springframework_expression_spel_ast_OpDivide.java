<METHOD_START> public void ( int int , SpelNodeImpl ... org.springframework.expression.spel.ast.SpelNodeImpl[] ) { super( STRING , int , org.springframework.expression.spel.ast.SpelNodeImpl[] ); }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.expression.spel.ast.TypedValue org.springframework.expression.spel.ast.TypedValue ( ExpressionState org.springframework.expression.spel.ast.ExpressionState ) throws org.springframework.expression.spel.ast.EvaluationException { java.lang.Object java.lang.Object = getLeftOperand ( ) . getValueInternal ( org.springframework.expression.spel.ast.ExpressionState ) . getValue ( ) ; java.lang.Object java.lang.Object = getRightOperand ( ) . getValueInternal ( org.springframework.expression.spel.ast.ExpressionState ) . getValue ( ) ; if ( java.lang.Object instanceof java.lang.Number && java.lang.Object instanceof java.lang.Number ) { java.lang.Number java.lang.Number = ( java.lang.Number ) java.lang.Object ; java.lang.Number java.lang.Number = ( java.lang.Number ) java.lang.Object ; if ( java.lang.Number instanceof java.math.BigDecimal || java.lang.Number instanceof java.math.BigDecimal ) { java.math.BigDecimal java.math.BigDecimal = NumberUtils . convertNumberToTargetClass ( java.lang.Number , java.math.BigDecimal .class ) ; java.math.BigDecimal java.math.BigDecimal = NumberUtils . convertNumberToTargetClass ( java.lang.Number , java.math.BigDecimal .class ) ; int int = java.lang.Math . int ( java.math.BigDecimal . int ( ) , java.math.BigDecimal . int ( ) ) ; return new TypedValue ( java.math.BigDecimal . java.math.BigDecimal ( java.math.BigDecimal , int , java.math.RoundingMode . java.math.RoundingMode ) ) ; } else if ( java.lang.Number instanceof java.lang.Double || java.lang.Number instanceof java.lang.Double ) { this . exitTypeDescriptor = STRING ; return new TypedValue ( java.lang.Number . double ( ) / java.lang.Number . double ( ) ) ; } else if ( java.lang.Number instanceof java.lang.Float || java.lang.Number instanceof java.lang.Float ) { this . exitTypeDescriptor = STRING ; return new TypedValue ( java.lang.Number . float ( ) / java.lang.Number . float ( ) ) ; } else if ( java.lang.Number instanceof java.math.BigInteger || java.lang.Number instanceof java.math.BigInteger ) { java.math.BigInteger java.math.BigInteger = NumberUtils . convertNumberToTargetClass ( java.lang.Number , java.math.BigInteger .class ) ; java.math.BigInteger java.math.BigInteger = NumberUtils . convertNumberToTargetClass ( java.lang.Number , java.math.BigInteger .class ) ; return new TypedValue ( java.math.BigInteger . java.math.BigInteger ( java.math.BigInteger ) ) ; } else if ( java.lang.Number instanceof java.lang.Long || java.lang.Number instanceof java.lang.Long ) { this . exitTypeDescriptor = STRING ; return new TypedValue ( java.lang.Number . long ( ) / java.lang.Number . long ( ) ) ; } else if ( CodeFlow . isIntegerForNumericOp ( java.lang.Number ) || CodeFlow . isIntegerForNumericOp ( java.lang.Number ) ) { this . exitTypeDescriptor = STRING ; return new TypedValue ( java.lang.Number . int ( ) / java.lang.Number . int ( ) ) ; } else { return new TypedValue ( java.lang.Number . double ( ) / java.lang.Number . double ( ) ) ; } } return org.springframework.expression.spel.ast.ExpressionState . operate ( Operation . DIVIDE , java.lang.Object , java.lang.Object ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( ) { if ( ! getLeftOperand ( ) . isCompilable ( ) ) { return false ; } if ( this . children . length > NUMBER ) { if ( ! getRightOperand ( ) . isCompilable ( ) ) { return false ; } } return ( this . exitTypeDescriptor != null ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( MethodVisitor org.springframework.expression.spel.ast.MethodVisitor , CodeFlow org.springframework.expression.spel.ast.CodeFlow ) { getLeftOperand ( ) . generateCode ( org.springframework.expression.spel.ast.MethodVisitor , org.springframework.expression.spel.ast.CodeFlow ) ; java.lang.String java.lang.String = getLeftOperand ( ) . exitTypeDescriptor ; CodeFlow . insertNumericUnboxOrPrimitiveTypeCoercion ( org.springframework.expression.spel.ast.MethodVisitor , java.lang.String , this . exitTypeDescriptor . charAt ( NUMBER ) ) ; if ( this . children . length > NUMBER ) { org.springframework.expression.spel.ast.CodeFlow . enterCompilationScope ( ) ; getRightOperand ( ) . generateCode ( org.springframework.expression.spel.ast.MethodVisitor , org.springframework.expression.spel.ast.CodeFlow ) ; java.lang.String java.lang.String = getRightOperand ( ) . exitTypeDescriptor ; org.springframework.expression.spel.ast.CodeFlow . exitCompilationScope ( ) ; CodeFlow . insertNumericUnboxOrPrimitiveTypeCoercion ( org.springframework.expression.spel.ast.MethodVisitor , java.lang.String , this . exitTypeDescriptor . charAt ( NUMBER ) ) ; switch ( this . exitTypeDescriptor . charAt ( NUMBER ) ) { case 'I' : org.springframework.expression.spel.ast.MethodVisitor . visitInsn ( IDIV ) ; break; case 'J' : org.springframework.expression.spel.ast.MethodVisitor . visitInsn ( LDIV ) ; break; case 'F' : org.springframework.expression.spel.ast.MethodVisitor . visitInsn ( FDIV ) ; break; case 'D' : org.springframework.expression.spel.ast.MethodVisitor . visitInsn ( DDIV ) ; break; default: throw new java.lang.IllegalStateException ( STRING + this . exitTypeDescriptor + STRING ) ; } } org.springframework.expression.spel.ast.CodeFlow . pushDescriptor ( this . exitTypeDescriptor ) ; }  <METHOD_END>
