<METHOD_START> public void ( Session org.springframework.cassandra.core.session.Session , Scheduler org.springframework.cassandra.core.session.Scheduler ) { Assert . notNull ( org.springframework.cassandra.core.session.Session , STRING ) ; Assert . notNull ( org.springframework.cassandra.core.session.Scheduler , STRING ) ; this . org.springframework.cassandra.core.session.Session = org.springframework.cassandra.core.session.Session ; this . org.springframework.cassandra.core.session.Scheduler = org.springframework.cassandra.core.session.Scheduler ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.cassandra.core.session.Mono<org.springframework.cassandra.core.session.ReactiveResultSet> < ReactiveResultSet > org.springframework.cassandra.core.session.Mono<org.springframework.cassandra.core.session.ReactiveResultSet> ( java.lang.String java.lang.String ) { Assert . hasText ( java.lang.String , STRING ) ; return org.springframework.cassandra.core.session.Mono<org.springframework.cassandra.core.session.ReactiveResultSet> ( new SimpleStatement ( java.lang.String ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.cassandra.core.session.Mono<org.springframework.cassandra.core.session.ReactiveResultSet> < ReactiveResultSet > org.springframework.cassandra.core.session.Mono<org.springframework.cassandra.core.session.ReactiveResultSet> ( java.lang.String java.lang.String , java.lang.Object ... java.lang.Object[] ) { Assert . hasText ( java.lang.String , STRING ) ; return org.springframework.cassandra.core.session.Mono<org.springframework.cassandra.core.session.ReactiveResultSet> ( new SimpleStatement ( java.lang.String , java.lang.Object[] ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.cassandra.core.session.Mono<org.springframework.cassandra.core.session.ReactiveResultSet> < ReactiveResultSet > org.springframework.cassandra.core.session.Mono<org.springframework.cassandra.core.session.ReactiveResultSet> ( java.lang.String java.lang.String , java.util.Map<java.lang.String,java.lang.Object> < java.lang.String , java.lang.Object > java.util.Map<java.lang.String,java.lang.Object> ) { Assert . hasText ( java.lang.String , STRING ) ; return org.springframework.cassandra.core.session.Mono<org.springframework.cassandra.core.session.ReactiveResultSet> ( new SimpleStatement ( java.lang.String , java.util.Map<java.lang.String,java.lang.Object> ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.cassandra.core.session.Mono<org.springframework.cassandra.core.session.ReactiveResultSet> < ReactiveResultSet > org.springframework.cassandra.core.session.Mono<org.springframework.cassandra.core.session.ReactiveResultSet> ( Statement org.springframework.cassandra.core.session.Statement ) { Assert . notNull ( org.springframework.cassandra.core.session.Statement , STRING ) ; return Mono . defer ( ( ) { try { if ( logger . isDebugEnabled ( ) ) { logger . debug ( STRING , statement ) ; } CompletableFuture < ReactiveResultSet > future = new CompletableFuture <> ( ) ; ResultSetFuture resultSetFuture = session . executeAsync ( statement ) ; resultSetFuture . addListener ( ( ) { if ( resultSetFuture . isDone ( ) ) { try { future . complete ( new DefaultReactiveResultSet ( resultSetFuture . getUninterruptibly ( ) , scheduler ) ) ; } catch ( Exception e ) { future . completeExceptionally ( e ) ; } } } , Runnable :: run ) ; return Mono . fromFuture ( future ) ; } catch ( Exception e ) { return Mono . error ( e ) ; } } ) . subscribeOn ( org.springframework.cassandra.core.session.Scheduler ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.cassandra.core.session.Mono<org.springframework.cassandra.core.session.PreparedStatement> < PreparedStatement > org.springframework.cassandra.core.session.Mono<org.springframework.cassandra.core.session.PreparedStatement> ( java.lang.String java.lang.String ) { Assert . hasText ( java.lang.String , STRING ) ; return org.springframework.cassandra.core.session.Mono<org.springframework.cassandra.core.session.PreparedStatement> ( new SimpleStatement ( java.lang.String ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.cassandra.core.session.Mono<org.springframework.cassandra.core.session.PreparedStatement> < PreparedStatement > org.springframework.cassandra.core.session.Mono<org.springframework.cassandra.core.session.PreparedStatement> ( RegularStatement org.springframework.cassandra.core.session.RegularStatement ) { Assert . notNull ( org.springframework.cassandra.core.session.RegularStatement , STRING ) ; return Mono . defer ( ( ) { try { if ( logger . isDebugEnabled ( ) ) { logger . debug ( STRING , statement ) ; } CompletableFuture < PreparedStatement > future = new CompletableFuture <> ( ) ; ListenableFuture < PreparedStatement > resultSetFuture = session . prepareAsync ( statement ) ; resultSetFuture . addListener ( ( ) { if ( resultSetFuture . isDone ( ) ) { try { future . complete ( resultSetFuture . get ( ) ) ; } catch ( Exception e ) { future . completeExceptionally ( e ) ; } } } , Runnable :: run ) ; return Mono . fromFuture ( future ) ; } catch ( Exception e ) { return Mono . error ( e ) ; } } ) . subscribeOn ( org.springframework.cassandra.core.session.Scheduler ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ) { org.springframework.cassandra.core.session.Session . close ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( ) { return org.springframework.cassandra.core.session.Session . isClosed ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.cassandra.core.session.Cluster org.springframework.cassandra.core.session.Cluster ( ) { return org.springframework.cassandra.core.session.Session . getCluster ( ) ; }  <METHOD_END>
<METHOD_START> void ( ResultSet org.springframework.cassandra.core.session.ResultSet , Scheduler org.springframework.cassandra.core.session.Scheduler ) { this . org.springframework.cassandra.core.session.ResultSet = org.springframework.cassandra.core.session.ResultSet ; this . org.springframework.cassandra.core.session.Scheduler = org.springframework.cassandra.core.session.Scheduler ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.cassandra.core.session.Flux<org.springframework.cassandra.core.session.Row> < Row > org.springframework.cassandra.core.session.Flux<org.springframework.cassandra.core.session.Row> ( ) { int int = java.lang.Math . int ( NUMBER , org.springframework.cassandra.core.session.ResultSet . getAvailableWithoutFetching ( ) ) ; return Flux . fromIterable ( org.springframework.cassandra.core.session.ResultSet ) . subscribeOn ( org.springframework.cassandra.core.session.Scheduler ) . publishOn ( Schedulers . immediate ( ) , int ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.cassandra.core.session.ColumnDefinitions org.springframework.cassandra.core.session.ColumnDefinitions ( ) { return org.springframework.cassandra.core.session.ResultSet . getColumnDefinitions ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( ) { return org.springframework.cassandra.core.session.ResultSet . wasApplied ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.cassandra.core.session.ExecutionInfo org.springframework.cassandra.core.session.ExecutionInfo ( ) { return org.springframework.cassandra.core.session.ResultSet . getExecutionInfo ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.util.List<org.springframework.cassandra.core.session.ExecutionInfo> < ExecutionInfo > java.util.List<org.springframework.cassandra.core.session.ExecutionInfo> ( ) { return org.springframework.cassandra.core.session.ResultSet . getAllExecutionInfo ( ) ; }  <METHOD_END>
