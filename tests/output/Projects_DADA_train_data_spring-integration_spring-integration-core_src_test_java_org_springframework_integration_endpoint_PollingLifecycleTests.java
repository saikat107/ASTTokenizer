<METHOD_START> @ Before public void void ( ) java.lang.Exception { org.springframework.integration.endpoint.ThreadPoolTaskScheduler . afterPropertiesSet ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; QueueChannel org.springframework.integration.endpoint.QueueChannel = new QueueChannel ( ) ; org.springframework.integration.endpoint.QueueChannel . send ( new GenericMessage < java.lang.String > ( STRING ) ) ; MessageHandler org.springframework.integration.endpoint.MessageHandler = Mockito . spy ( new MessageHandler ( ) { @ java.lang.Override public void void ( Message < ? > org.springframework.integration.endpoint.Message<?> ) throws org.springframework.integration.endpoint.MessagingException { java.util.concurrent.CountDownLatch . void ( ) ; } } ) ; PollingConsumer org.springframework.integration.endpoint.PollingConsumer = new PollingConsumer ( org.springframework.integration.endpoint.QueueChannel , org.springframework.integration.endpoint.MessageHandler ) ; org.springframework.integration.endpoint.PollingConsumer . setTrigger ( new PeriodicTrigger ( NUMBER ) ) ; org.springframework.integration.endpoint.PollingConsumer . setErrorHandler ( org.springframework.integration.endpoint.TestErrorHandler ) ; org.springframework.integration.endpoint.PollingConsumer . setTaskScheduler ( org.springframework.integration.endpoint.ThreadPoolTaskScheduler ) ; org.springframework.integration.endpoint.PollingConsumer . setBeanFactory ( mock ( BeanFactory .class ) ) ; org.springframework.integration.endpoint.PollingConsumer . afterPropertiesSet ( ) ; org.springframework.integration.endpoint.PollingConsumer . start ( ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; Mockito . verify ( org.springframework.integration.endpoint.MessageHandler , times ( NUMBER ) ) . handleMessage ( Mockito . any ( Message .class ) ) ; org.springframework.integration.endpoint.PollingConsumer . stop ( ) ; for ( int int = NUMBER ; int < NUMBER ; int ++ ) { org.springframework.integration.endpoint.QueueChannel . send ( new GenericMessage < java.lang.String > ( STRING ) ) ; } java.lang.Thread . void ( NUMBER ) ; Mockito . reset ( org.springframework.integration.endpoint.MessageHandler ) ; Mockito . verify ( org.springframework.integration.endpoint.MessageHandler , atMost ( NUMBER ) ) . handleMessage ( Mockito . any ( Message .class ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( Message < ? > org.springframework.integration.endpoint.Message<?> ) throws org.springframework.integration.endpoint.MessagingException { java.util.concurrent.CountDownLatch . void ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; QueueChannel org.springframework.integration.endpoint.QueueChannel = new QueueChannel ( ) ; SourcePollingChannelAdapterFactoryBean org.springframework.integration.endpoint.SourcePollingChannelAdapterFactoryBean = new SourcePollingChannelAdapterFactoryBean ( ) ; PollerMetadata org.springframework.integration.endpoint.PollerMetadata = new PollerMetadata ( ) ; org.springframework.integration.endpoint.PollerMetadata . setTrigger ( new PeriodicTrigger ( NUMBER ) ) ; org.springframework.integration.endpoint.SourcePollingChannelAdapterFactoryBean . setPollerMetadata ( org.springframework.integration.endpoint.PollerMetadata ) ; MessageSource < java.lang.String > org.springframework.integration.endpoint.MessageSource<java.lang.String> = spy ( new MessageSource < java.lang.String > ( ) { @ java.lang.Override public org.springframework.integration.endpoint.Message<java.lang.String> < java.lang.String > org.springframework.integration.endpoint.Message<java.lang.String> ( ) { java.util.concurrent.CountDownLatch . void ( ) ; return new GenericMessage < java.lang.String > ( STRING ) ; } } ) ; org.springframework.integration.endpoint.SourcePollingChannelAdapterFactoryBean . setSource ( org.springframework.integration.endpoint.MessageSource<java.lang.String> ) ; org.springframework.integration.endpoint.SourcePollingChannelAdapterFactoryBean . setOutputChannel ( org.springframework.integration.endpoint.QueueChannel ) ; org.springframework.integration.endpoint.SourcePollingChannelAdapterFactoryBean . setBeanFactory ( mock ( ConfigurableBeanFactory .class ) ) ; SourcePollingChannelAdapter org.springframework.integration.endpoint.SourcePollingChannelAdapter = org.springframework.integration.endpoint.SourcePollingChannelAdapterFactoryBean . getObject ( ) ; org.springframework.integration.endpoint.SourcePollingChannelAdapter . setTaskScheduler ( org.springframework.integration.endpoint.ThreadPoolTaskScheduler ) ; org.springframework.integration.endpoint.SourcePollingChannelAdapter . afterPropertiesSet ( ) ; org.springframework.integration.endpoint.SourcePollingChannelAdapter . start ( ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; assertNotNull ( org.springframework.integration.endpoint.QueueChannel . receive ( NUMBER ) ) ; org.springframework.integration.endpoint.SourcePollingChannelAdapter . stop ( ) ; assertNull ( org.springframework.integration.endpoint.QueueChannel . receive ( NUMBER ) ) ; Mockito . verify ( org.springframework.integration.endpoint.MessageSource<java.lang.String> , times ( NUMBER ) ) . receive ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.integration.endpoint.Message<java.lang.String> < java.lang.String > org.springframework.integration.endpoint.Message<java.lang.String> ( ) { java.util.concurrent.CountDownLatch . void ( ) ; return new GenericMessage < java.lang.String > ( STRING ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; QueueChannel org.springframework.integration.endpoint.QueueChannel = new QueueChannel ( ) ; SourcePollingChannelAdapterFactoryBean org.springframework.integration.endpoint.SourcePollingChannelAdapterFactoryBean = new SourcePollingChannelAdapterFactoryBean ( ) ; PollerMetadata org.springframework.integration.endpoint.PollerMetadata = new PollerMetadata ( ) ; org.springframework.integration.endpoint.PollerMetadata . setMaxMessagesPerPoll ( - NUMBER ) ; org.springframework.integration.endpoint.PollerMetadata . setTrigger ( new PeriodicTrigger ( NUMBER ) ) ; org.springframework.integration.endpoint.SourcePollingChannelAdapterFactoryBean . setPollerMetadata ( org.springframework.integration.endpoint.PollerMetadata ) ; final java.lang.Runnable java.lang.Runnable = mock ( java.lang.Runnable .class ) ; MessageSource < java.lang.String > org.springframework.integration.endpoint.MessageSource<java.lang.String> = ( ) { try { for ( int i = NUMBER ; i < NUMBER ; i ++ ) { Thread . sleep ( NUMBER ) ; latch . countDown ( ) ; } } catch ( InterruptedException e ) { coughtInterrupted . run ( ) ; } return new GenericMessage < String > ( STRING ) ; } ; org.springframework.integration.endpoint.SourcePollingChannelAdapterFactoryBean . setSource ( org.springframework.integration.endpoint.MessageSource<java.lang.String> ) ; org.springframework.integration.endpoint.SourcePollingChannelAdapterFactoryBean . setOutputChannel ( org.springframework.integration.endpoint.QueueChannel ) ; org.springframework.integration.endpoint.SourcePollingChannelAdapterFactoryBean . setBeanFactory ( mock ( ConfigurableBeanFactory .class ) ) ; SourcePollingChannelAdapter org.springframework.integration.endpoint.SourcePollingChannelAdapter = org.springframework.integration.endpoint.SourcePollingChannelAdapterFactoryBean . getObject ( ) ; org.springframework.integration.endpoint.SourcePollingChannelAdapter . setTaskScheduler ( org.springframework.integration.endpoint.ThreadPoolTaskScheduler ) ; org.springframework.integration.endpoint.SourcePollingChannelAdapter . afterPropertiesSet ( ) ; org.springframework.integration.endpoint.SourcePollingChannelAdapter . start ( ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; org.springframework.integration.endpoint.SourcePollingChannelAdapter . stop ( ) ; java.lang.Thread . void ( NUMBER ) ; Mockito . verify ( java.lang.Runnable , times ( NUMBER ) ) . run ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { SourcePollingChannelAdapterFactoryBean org.springframework.integration.endpoint.SourcePollingChannelAdapterFactoryBean = new SourcePollingChannelAdapterFactoryBean ( ) ; org.springframework.integration.endpoint.SourcePollingChannelAdapterFactoryBean . setOutputChannel ( new NullChannel ( ) ) ; org.springframework.integration.endpoint.SourcePollingChannelAdapterFactoryBean . setBeanFactory ( mock ( ConfigurableBeanFactory .class ) ) ; PollerMetadata org.springframework.integration.endpoint.PollerMetadata = new PollerMetadata ( ) ; org.springframework.integration.endpoint.PollerMetadata . setTrigger ( new PeriodicTrigger ( NUMBER ) ) ; org.springframework.integration.endpoint.SourcePollingChannelAdapterFactoryBean . setPollerMetadata ( org.springframework.integration.endpoint.PollerMetadata ) ; final java.util.concurrent.atomic.AtomicBoolean java.util.concurrent.atomic.AtomicBoolean = new java.util.concurrent.atomic.AtomicBoolean ( ) ; final java.util.concurrent.atomic.AtomicBoolean java.util.concurrent.atomic.AtomicBoolean = new java.util.concurrent.atomic.AtomicBoolean ( ) ; MethodInvokingMessageSource org.springframework.integration.endpoint.MethodInvokingMessageSource = new MethodInvokingMessageSource ( ) ; org.springframework.integration.endpoint.MethodInvokingMessageSource . setObject ( new Lifecycle ( ) { @ java.lang.Override public void void ( ) { java.util.concurrent.atomic.AtomicBoolean . void ( true ) ; } @ java.lang.Override public void void ( ) { java.util.concurrent.atomic.AtomicBoolean . void ( true ) ; } @ java.lang.Override public boolean boolean ( ) { return false ; } } ) ; org.springframework.integration.endpoint.MethodInvokingMessageSource . setMethodName ( STRING ) ; org.springframework.integration.endpoint.SourcePollingChannelAdapterFactoryBean . setSource ( org.springframework.integration.endpoint.MethodInvokingMessageSource ) ; SourcePollingChannelAdapter org.springframework.integration.endpoint.SourcePollingChannelAdapter = org.springframework.integration.endpoint.SourcePollingChannelAdapterFactoryBean . getObject ( ) ; org.springframework.integration.endpoint.SourcePollingChannelAdapter . setTaskScheduler ( this . org.springframework.integration.endpoint.ThreadPoolTaskScheduler ) ; org.springframework.integration.endpoint.SourcePollingChannelAdapter . start ( ) ; org.springframework.integration.endpoint.SourcePollingChannelAdapter . stop ( ) ; assertTrue ( java.util.concurrent.atomic.AtomicBoolean . boolean ( ) ) ; assertTrue ( java.util.concurrent.atomic.AtomicBoolean . boolean ( ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ) { java.util.concurrent.atomic.AtomicBoolean . void ( true ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ) { java.util.concurrent.atomic.AtomicBoolean . void ( true ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( ) { return false ; }  <METHOD_END>
