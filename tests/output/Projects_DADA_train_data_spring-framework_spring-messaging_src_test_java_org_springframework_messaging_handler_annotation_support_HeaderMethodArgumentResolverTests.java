<METHOD_START> @ Before public void void ( ) java.lang.Exception { @ java.lang.SuppressWarnings ( STRING ) GenericApplicationContext org.springframework.messaging.handler.annotation.support.GenericApplicationContext = new GenericApplicationContext ( ) ; org.springframework.messaging.handler.annotation.support.GenericApplicationContext . refresh ( ) ; this . org.springframework.messaging.handler.annotation.support.HeaderMethodArgumentResolver = new HeaderMethodArgumentResolver ( new DefaultConversionService ( ) , org.springframework.messaging.handler.annotation.support.GenericApplicationContext . getBeanFactory ( ) ) ; java.lang.reflect.Method java.lang.reflect.Method = ReflectionUtils . findMethod ( java.lang.Class<? extends org.springframework.messaging.handler.annotation.support.HeaderMethodArgumentResolverTests> ( ) , STRING , ( java.lang.Class<?> < ? > [] ) null ) ; this . org.springframework.messaging.handler.annotation.support.MethodParameter = new SynthesizingMethodParameter ( java.lang.reflect.Method , NUMBER ) ; this . org.springframework.messaging.handler.annotation.support.MethodParameter = new SynthesizingMethodParameter ( java.lang.reflect.Method , NUMBER ) ; this . org.springframework.messaging.handler.annotation.support.MethodParameter = new SynthesizingMethodParameter ( java.lang.reflect.Method , NUMBER ) ; this . org.springframework.messaging.handler.annotation.support.MethodParameter = new SynthesizingMethodParameter ( java.lang.reflect.Method , NUMBER ) ; this . org.springframework.messaging.handler.annotation.support.MethodParameter = new SynthesizingMethodParameter ( java.lang.reflect.Method , NUMBER ) ; this . org.springframework.messaging.handler.annotation.support.MethodParameter = new SynthesizingMethodParameter ( java.lang.reflect.Method , NUMBER ) ; this . org.springframework.messaging.handler.annotation.support.MethodParameter = new SynthesizingMethodParameter ( java.lang.reflect.Method , NUMBER ) ; this . org.springframework.messaging.handler.annotation.support.MethodParameter . initParameterNameDiscovery ( new DefaultParameterNameDiscoverer ( ) ) ; GenericTypeResolver . resolveParameterType ( this . org.springframework.messaging.handler.annotation.support.MethodParameter , HeaderMethodArgumentResolver .class ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { assertTrue ( org.springframework.messaging.handler.annotation.support.HeaderMethodArgumentResolver . supportsParameter ( org.springframework.messaging.handler.annotation.support.MethodParameter ) ) ; assertFalse ( org.springframework.messaging.handler.annotation.support.HeaderMethodArgumentResolver . supportsParameter ( org.springframework.messaging.handler.annotation.support.MethodParameter ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { Message < byte [] > org.springframework.messaging.handler.annotation.support.Message<byte[]> = MessageBuilder . withPayload ( new byte [ NUMBER ] ) . setHeader ( STRING , STRING ) . build ( ) ; java.lang.Object java.lang.Object = this . org.springframework.messaging.handler.annotation.support.HeaderMethodArgumentResolver . resolveArgument ( this . org.springframework.messaging.handler.annotation.support.MethodParameter , org.springframework.messaging.handler.annotation.support.Message<byte[]> ) ; assertEquals ( STRING , java.lang.Object ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { org.springframework.messaging.handler.annotation.support.HeaderMethodArgumentResolverTests.TestMessageHeaderAccessor org.springframework.messaging.handler.annotation.support.HeaderMethodArgumentResolverTests.TestMessageHeaderAccessor = new org.springframework.messaging.handler.annotation.support.HeaderMethodArgumentResolverTests.TestMessageHeaderAccessor ( ) ; org.springframework.messaging.handler.annotation.support.HeaderMethodArgumentResolverTests.TestMessageHeaderAccessor . setNativeHeader ( STRING , STRING ) ; Message < byte [] > org.springframework.messaging.handler.annotation.support.Message<byte[]> = MessageBuilder . withPayload ( new byte [ NUMBER ] ) . setHeaders ( org.springframework.messaging.handler.annotation.support.HeaderMethodArgumentResolverTests.TestMessageHeaderAccessor ) . build ( ) ; assertEquals ( STRING , this . org.springframework.messaging.handler.annotation.support.HeaderMethodArgumentResolver . resolveArgument ( this . org.springframework.messaging.handler.annotation.support.MethodParameter , org.springframework.messaging.handler.annotation.support.Message<byte[]> ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { org.springframework.messaging.handler.annotation.support.HeaderMethodArgumentResolverTests.TestMessageHeaderAccessor org.springframework.messaging.handler.annotation.support.HeaderMethodArgumentResolverTests.TestMessageHeaderAccessor = new org.springframework.messaging.handler.annotation.support.HeaderMethodArgumentResolverTests.TestMessageHeaderAccessor ( ) ; org.springframework.messaging.handler.annotation.support.HeaderMethodArgumentResolverTests.TestMessageHeaderAccessor . setHeader ( STRING , STRING ) ; org.springframework.messaging.handler.annotation.support.HeaderMethodArgumentResolverTests.TestMessageHeaderAccessor . setNativeHeader ( STRING , STRING ) ; Message < byte [] > org.springframework.messaging.handler.annotation.support.Message<byte[]> = MessageBuilder . withPayload ( new byte [ NUMBER ] ) . setHeaders ( org.springframework.messaging.handler.annotation.support.HeaderMethodArgumentResolverTests.TestMessageHeaderAccessor ) . build ( ) ; assertEquals ( STRING , this . org.springframework.messaging.handler.annotation.support.HeaderMethodArgumentResolver . resolveArgument ( this . org.springframework.messaging.handler.annotation.support.MethodParameter , org.springframework.messaging.handler.annotation.support.Message<byte[]> ) ) ; assertEquals ( STRING , this . org.springframework.messaging.handler.annotation.support.HeaderMethodArgumentResolver . resolveArgument ( this . org.springframework.messaging.handler.annotation.support.MethodParameter , org.springframework.messaging.handler.annotation.support.Message<byte[]> ) ) ; }  <METHOD_END>
<METHOD_START> @ Test ( expected = MessageHandlingException .class ) public void void ( ) java.lang.Exception { Message < byte [] > org.springframework.messaging.handler.annotation.support.Message<byte[]> = MessageBuilder . withPayload ( new byte [ NUMBER ] ) . build ( ) ; this . org.springframework.messaging.handler.annotation.support.HeaderMethodArgumentResolver . resolveArgument ( this . org.springframework.messaging.handler.annotation.support.MethodParameter , org.springframework.messaging.handler.annotation.support.Message<byte[]> ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { Message < byte [] > org.springframework.messaging.handler.annotation.support.Message<byte[]> = MessageBuilder . withPayload ( new byte [ NUMBER ] ) . build ( ) ; java.lang.Object java.lang.Object = this . org.springframework.messaging.handler.annotation.support.HeaderMethodArgumentResolver . resolveArgument ( this . org.springframework.messaging.handler.annotation.support.MethodParameter , org.springframework.messaging.handler.annotation.support.Message<byte[]> ) ; assertEquals ( STRING , java.lang.Object ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.lang.System . java.lang.String ( STRING , STRING ) ; try { Message < byte [] > org.springframework.messaging.handler.annotation.support.Message<byte[]> = MessageBuilder . withPayload ( new byte [ NUMBER ] ) . build ( ) ; java.lang.Object java.lang.Object = org.springframework.messaging.handler.annotation.support.HeaderMethodArgumentResolver . resolveArgument ( org.springframework.messaging.handler.annotation.support.MethodParameter , org.springframework.messaging.handler.annotation.support.Message<byte[]> ) ; assertEquals ( STRING , java.lang.Object ) ; } finally { java.lang.System . java.lang.String ( STRING ) ; } }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.lang.System . java.lang.String ( STRING , STRING ) ; try { Message < byte [] > org.springframework.messaging.handler.annotation.support.Message<byte[]> = MessageBuilder . withPayload ( new byte [ NUMBER ] ) . setHeader ( STRING , STRING ) . build ( ) ; java.lang.Object java.lang.Object = org.springframework.messaging.handler.annotation.support.HeaderMethodArgumentResolver . resolveArgument ( org.springframework.messaging.handler.annotation.support.MethodParameter , org.springframework.messaging.handler.annotation.support.Message<byte[]> ) ; assertEquals ( STRING , java.lang.Object ) ; } finally { java.lang.System . java.lang.String ( STRING ) ; } }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { GenericApplicationContext org.springframework.messaging.handler.annotation.support.GenericApplicationContext = new GenericApplicationContext ( ) ; org.springframework.messaging.handler.annotation.support.GenericApplicationContext . refresh ( ) ; HeaderMethodArgumentResolver org.springframework.messaging.handler.annotation.support.HeaderMethodArgumentResolver = new HeaderMethodArgumentResolver ( new DefaultConversionService ( ) , org.springframework.messaging.handler.annotation.support.GenericApplicationContext . getBeanFactory ( ) ) ; Message < java.lang.String > org.springframework.messaging.handler.annotation.support.Message<java.lang.String> = MessageBuilder . withPayload ( STRING ) . setHeader ( STRING , STRING ) . build ( ) ; java.lang.Object java.lang.Object = org.springframework.messaging.handler.annotation.support.HeaderMethodArgumentResolver . resolveArgument ( org.springframework.messaging.handler.annotation.support.MethodParameter , org.springframework.messaging.handler.annotation.support.Message<java.lang.String> ) ; assertEquals ( java.util.Optional . java.util.Optional<java.lang.String> ( STRING ) , java.lang.Object ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { GenericApplicationContext org.springframework.messaging.handler.annotation.support.GenericApplicationContext = new GenericApplicationContext ( ) ; org.springframework.messaging.handler.annotation.support.GenericApplicationContext . refresh ( ) ; HeaderMethodArgumentResolver org.springframework.messaging.handler.annotation.support.HeaderMethodArgumentResolver = new HeaderMethodArgumentResolver ( new DefaultConversionService ( ) , org.springframework.messaging.handler.annotation.support.GenericApplicationContext . getBeanFactory ( ) ) ; Message < java.lang.String > org.springframework.messaging.handler.annotation.support.Message<java.lang.String> = MessageBuilder . withPayload ( STRING ) . build ( ) ; java.lang.Object java.lang.Object = org.springframework.messaging.handler.annotation.support.HeaderMethodArgumentResolver . resolveArgument ( org.springframework.messaging.handler.annotation.support.MethodParameter , org.springframework.messaging.handler.annotation.support.Message<java.lang.String> ) ; assertEquals ( java.util.Optional . java.util.Optional<java.lang.Object> ( ) , java.lang.Object ) ; }  <METHOD_END>
<METHOD_START> public void void ( @ Header java.lang.String java.lang.String , @ Header ( name = STRING , defaultValue = STRING ) java.lang.String java.lang.String , @ Header ( name = STRING , defaultValue = STRING ) java.lang.String java.lang.String , @ Header ( name = STRING ) java.lang.String java.lang.String , java.lang.String java.lang.String , @ Header ( STRING ) java.util.Optional<java.lang.String> < java.lang.String > java.util.Optional<java.lang.String> , @ Header ( STRING ) java.lang.String java.lang.String ) {	}  <METHOD_END>
<METHOD_START> protected void ( ) { super( ( java.util.Map<java.lang.String,java.util.List<java.lang.String>> < java.lang.String , java.util.List<java.lang.String> < java.lang.String > > ) null ); }  <METHOD_END>
