<METHOD_START> public void ( ) { this( java.util.Collections .< java.lang.Class<? extends java.lang.annotation.Annotation> < ? extends java.lang.annotation.Annotation > > java.util.Set<java.lang.Class<? extends java.lang.annotation.Annotation>> ( Publisher .class ) ); }  <METHOD_END>
<METHOD_START> public void ( java.util.Set<java.lang.Class<? extends java.lang.annotation.Annotation>> < java.lang.Class<? extends java.lang.annotation.Annotation> < ? extends java.lang.annotation.Annotation > > java.util.Set<java.lang.Class<? extends java.lang.annotation.Annotation>> ) { Assert . notEmpty ( java.util.Set<java.lang.Class<? extends java.lang.annotation.Annotation>> , STRING ) ; this . java.util.Set<java.lang.Class<? extends java.lang.annotation.Annotation>> = java.util.Set<java.lang.Class<? extends java.lang.annotation.Annotation>> ; }  <METHOD_END>
<METHOD_START> public void void ( java.lang.String java.lang.String ) { Assert . hasText ( java.lang.String , STRING ) ; this . java.lang.String = java.lang.String ; }  <METHOD_END>
<METHOD_START> public java.lang.String java.lang.String ( java.lang.reflect.Method java.lang.reflect.Method ) { java.lang.String java.lang.String = this . java.lang.String ( java.lang.reflect.Method , this . java.lang.String , java.lang.String .class ) ; if ( java.lang.String == null ) { java.lang.String = this . java.lang.String ( java.lang.reflect.Method . java.lang.Class<?> ( ) , this . java.lang.String , java.lang.String .class ) ; } return ( StringUtils . hasText ( java.lang.String ) ? java.lang.String : null ) ; }  <METHOD_END>
<METHOD_START> public java.lang.String java.lang.String ( java.lang.reflect.Method java.lang.reflect.Method ) { java.lang.String java.lang.String = null ; java.lang.annotation.Annotation java.lang.annotation.Annotation = AnnotationUtils . findAnnotation ( java.lang.reflect.Method , Payload .class ) ; if ( java.lang.annotation.Annotation != null ) { java.lang.String = java.lang.String ( java.lang.annotation.Annotation , null , java.lang.String .class ) ; if ( ! StringUtils . hasText ( java.lang.String ) ) { java.lang.String = STRING + PublisherMetadataSource . RETURN_VALUE_VARIABLE_NAME ; } } java.lang.annotation.Annotation [] [] java.lang.annotation.Annotation[][] = java.lang.reflect.Method . java.lang.annotation.Annotation[][] ( ) ; for ( int int = NUMBER ; int < java.lang.annotation.Annotation[][] . int ; int ++ ) { java.lang.annotation.Annotation [] java.lang.annotation.Annotation[] = java.lang.annotation.Annotation[][] [ int ] ; for ( java.lang.annotation.Annotation java.lang.annotation.Annotation : java.lang.annotation.Annotation[] ) { if ( Payload .class . boolean ( java.lang.annotation.Annotation . java.lang.Class<? extends java.lang.annotation.Annotation> ( ) ) ) { Assert . state ( java.lang.String == null , STRING + STRING ) ; Assert . state ( STRING . boolean ( AnnotationUtils . getValue ( java.lang.annotation.Annotation ) ) , STRING ) ; java.lang.String = STRING + PublisherMetadataSource . ARGUMENT_MAP_VARIABLE_NAME + STRING + int + STRING ; } } } if ( java.lang.String == null || java.lang.String . boolean ( STRING + PublisherMetadataSource . RETURN_VALUE_VARIABLE_NAME ) ) { Assert . isTrue ( ! void .class . boolean ( java.lang.reflect.Method . java.lang.Class<?> ( ) ) , STRING + STRING ) ; } return java.lang.String ; }  <METHOD_END>
<METHOD_START> public java.util.Map<java.lang.String,java.lang.String> < java.lang.String , java.lang.String > java.util.Map<java.lang.String,java.lang.String> ( java.lang.reflect.Method java.lang.reflect.Method ) { java.util.Map<java.lang.String,java.lang.String> < java.lang.String , java.lang.String > java.util.Map<java.lang.String,java.lang.String> = new java.util.HashMap<java.lang.String,java.lang.String> < java.lang.String , java.lang.String > ( ) ; java.lang.String [] java.lang.String[] = this . org.springframework.integration.aop.ParameterNameDiscoverer . getParameterNames ( java.lang.reflect.Method ) ; java.lang.annotation.Annotation [] [] java.lang.annotation.Annotation[][] = java.lang.reflect.Method . java.lang.annotation.Annotation[][] ( ) ; for ( int int = NUMBER ; int < java.lang.annotation.Annotation[][] . int ; int ++ ) { java.lang.annotation.Annotation [] java.lang.annotation.Annotation[] = java.lang.annotation.Annotation[][] [ int ] ; for ( java.lang.annotation.Annotation java.lang.annotation.Annotation : java.lang.annotation.Annotation[] ) { if ( Header .class . boolean ( java.lang.annotation.Annotation . java.lang.Class<? extends java.lang.annotation.Annotation> ( ) ) ) { java.lang.String java.lang.String = java.lang.String ( java.lang.annotation.Annotation , null , java.lang.String .class ) ; if ( ! StringUtils . hasText ( java.lang.String ) ) { java.lang.String = java.lang.String[] [ int ] ; } java.util.Map<java.lang.String,java.lang.String> . java.lang.String ( java.lang.String , STRING + PublisherMetadataSource . ARGUMENT_MAP_VARIABLE_NAME + STRING + int + STRING ) ; } } } return java.util.Map<java.lang.String,java.lang.String> ; }  <METHOD_END>
<METHOD_START> private < T > T T ( java.lang.reflect.Method java.lang.reflect.Method , java.lang.String java.lang.String , java.lang.Class<T> < T > java.lang.Class<T> ) { T T = null ; for ( java.lang.Class<? extends java.lang.annotation.Annotation> < ? extends java.lang.annotation.Annotation > java.lang.Class<? extends java.lang.annotation.Annotation> : this . java.util.Set<java.lang.Class<? extends java.lang.annotation.Annotation>> ) { java.lang.annotation.Annotation java.lang.annotation.Annotation = AnnotatedElementUtils . findMergedAnnotation ( java.lang.reflect.Method , java.lang.Class<> ) ; if ( java.lang.annotation.Annotation != null ) { if ( T != null ) { throw new java.lang.IllegalStateException ( STRING + java.lang.reflect.Method + STRING ) ; } T = this . T ( java.lang.annotation.Annotation , java.lang.String , java.lang.Class<T> ) ; } } return T ; }  <METHOD_END>
<METHOD_START> private < T > T T ( java.lang.Class<?> < ? > java.lang.Class<?> , java.lang.String java.lang.String , java.lang.Class<T> < T > java.lang.Class<T> ) { T T = null ; for ( java.lang.Class<? extends java.lang.annotation.Annotation> < ? extends java.lang.annotation.Annotation > java.lang.Class<? extends java.lang.annotation.Annotation> : this . java.util.Set<java.lang.Class<? extends java.lang.annotation.Annotation>> ) { java.lang.annotation.Annotation java.lang.annotation.Annotation = AnnotatedElementUtils . findMergedAnnotation ( java.lang.Class<> , java.lang.Class<> ) ; if ( java.lang.annotation.Annotation != null ) { if ( T != null ) { throw new java.lang.IllegalStateException ( STRING + java.lang.Class<> + STRING ) ; } T = this . T ( java.lang.annotation.Annotation , java.lang.String , java.lang.Class<T> ) ; } } return T ; }  <METHOD_END>
<METHOD_START> @ java.lang.SuppressWarnings ( STRING ) private < T > T T ( java.lang.annotation.Annotation java.lang.annotation.Annotation , java.lang.String java.lang.String , java.lang.Class<T> < T > java.lang.Class<T> ) { T T = null ; java.lang.Object java.lang.Object = ( java.lang.String == null ) ? AnnotationUtils . getValue ( java.lang.annotation.Annotation ) : AnnotationUtils . getValue ( java.lang.annotation.Annotation , java.lang.String ) ; if ( java.lang.Object != null ) { if ( java.lang.Class<T> . boolean ( java.lang.Object . java.lang.Class<? extends java.lang.Object> ( ) ) ) { T = ( T ) java.lang.Object ; } else { throw new java.lang.IllegalArgumentException ( STRING + java.lang.Class<T> . java.lang.String ( ) + STRING + java.lang.String + STRING + java.lang.annotation.Annotation . java.lang.Class<? extends java.lang.annotation.Annotation> ( ) + STRING + java.lang.Object . java.lang.Class<? extends java.lang.Object> ( ) + STRING ) ; } } return T ; }  <METHOD_END>
