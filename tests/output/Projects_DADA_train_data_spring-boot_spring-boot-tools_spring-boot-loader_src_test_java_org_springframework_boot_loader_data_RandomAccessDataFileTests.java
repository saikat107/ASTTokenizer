<METHOD_START> @ Before public void void ( ) java.lang.Exception { this . java.io.File = this . org.springframework.boot.loader.data.TemporaryFolder . newFile ( ) ; java.io.FileOutputStream java.io.FileOutputStream = new java.io.FileOutputStream ( this . java.io.File ) ; java.io.FileOutputStream . void ( byte[] ) ; java.io.FileOutputStream . void ( ) ; this . org.springframework.boot.loader.data.RandomAccessDataFile = new RandomAccessDataFile ( this . java.io.File ) ; this . java.io.InputStream = this . org.springframework.boot.loader.data.RandomAccessDataFile . getInputStream ( ResourceAccess . PER_READ ) ; }  <METHOD_END>
<METHOD_START> @ After public void void ( ) java.lang.Exception { this . java.io.InputStream . void ( ) ; this . org.springframework.boot.loader.data.RandomAccessDataFile . close ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { this . org.springframework.boot.loader.data.ExpectedException . expect ( java.lang.IllegalArgumentException .class ) ; this . org.springframework.boot.loader.data.ExpectedException . expectMessage ( STRING ) ; new RandomAccessDataFile ( null ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { this . org.springframework.boot.loader.data.ExpectedException . expect ( java.lang.IllegalArgumentException .class ) ; this . org.springframework.boot.loader.data.ExpectedException . expectMessage ( STRING ) ; new RandomAccessDataFile ( new java.io.File ( STRING ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { this . org.springframework.boot.loader.data.ExpectedException . expect ( java.lang.IllegalArgumentException .class ) ; this . org.springframework.boot.loader.data.ExpectedException . expectMessage ( STRING ) ; new RandomAccessDataFile ( null , NUMBER ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { this . org.springframework.boot.loader.data.ExpectedException . expect ( java.lang.IllegalArgumentException .class ) ; this . org.springframework.boot.loader.data.ExpectedException . expectMessage ( STRING ) ; new RandomAccessDataFile ( new java.io.File ( STRING ) , NUMBER ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { for ( int int = NUMBER ; int <= NUMBER ; int ++ ) { assertThat ( this . java.io.InputStream . int ( ) ) . isEqualTo ( int ) ; } }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { this . org.springframework.boot.loader.data.ExpectedException . expect ( java.lang.NullPointerException .class ) ; this . org.springframework.boot.loader.data.ExpectedException . expectMessage ( STRING ) ; this . java.io.InputStream . int ( null ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { this . org.springframework.boot.loader.data.ExpectedException . expect ( java.lang.NullPointerException .class ) ; this . org.springframework.boot.loader.data.ExpectedException . expectMessage ( STRING ) ; this . java.io.InputStream . int ( null , NUMBER , NUMBER ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { byte [] byte[] = new byte [ NUMBER ] ; int int = this . java.io.InputStream . int ( byte[] ) ; assertThat ( byte[] ) . isEqualTo ( byte[] ) ; assertThat ( int ) . isEqualTo ( NUMBER ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { byte [] byte[] = new byte [ NUMBER ] ; this . java.io.InputStream . long ( NUMBER ) ; int int = this . java.io.InputStream . int ( byte[] , NUMBER , NUMBER ) ; assertThat ( byte[] ) . isEqualTo ( new byte [] { NUMBER , NUMBER , NUMBER , NUMBER , NUMBER , NUMBER , NUMBER } ) ; assertThat ( int ) . isEqualTo ( NUMBER ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { byte [] byte[] = new byte [ NUMBER ] ; int int = this . java.io.InputStream . int ( byte[] ) ; assertThat ( byte[] ) . startsWith ( byte[] ) ; assertThat ( int ) . isEqualTo ( NUMBER ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { this . java.io.InputStream . long ( NUMBER ) ; assertThat ( this . java.io.InputStream . int ( ) ) . isEqualTo ( NUMBER ) ; assertThat ( this . java.io.InputStream . int ( ) ) . isEqualTo ( - NUMBER ) ; assertThat ( this . java.io.InputStream . int ( ) ) . isEqualTo ( - NUMBER ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { byte [] byte[] = new byte [] { NUMBER } ; int int = this . java.io.InputStream . int ( byte[] , NUMBER , NUMBER ) ; assertThat ( byte[] ) . isEqualTo ( new byte [] { NUMBER } ) ; assertThat ( int ) . isEqualTo ( NUMBER ) ; assertThat ( this . java.io.InputStream . int ( ) ) . isEqualTo ( NUMBER ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { long long = this . java.io.InputStream . long ( NUMBER ) ; assertThat ( this . java.io.InputStream . int ( ) ) . isEqualTo ( NUMBER ) ; assertThat ( long ) . isEqualTo ( NUMBER ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { long long = this . java.io.InputStream . long ( NUMBER ) ; assertThat ( this . java.io.InputStream . int ( ) ) . isEqualTo ( - NUMBER ) ; assertThat ( long ) . isEqualTo ( NUMBER ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { this . java.io.InputStream . long ( NUMBER ) ; long long = this . java.io.InputStream . long ( NUMBER ) ; assertThat ( long ) . isEqualTo ( NUMBER ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { this . org.springframework.boot.loader.data.ExpectedException . expect ( java.lang.IndexOutOfBoundsException .class ) ; this . org.springframework.boot.loader.data.RandomAccessDataFile . getSubsection ( - NUMBER , NUMBER ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { this . org.springframework.boot.loader.data.ExpectedException . expect ( java.lang.IndexOutOfBoundsException .class ) ; this . org.springframework.boot.loader.data.RandomAccessDataFile . getSubsection ( NUMBER , - NUMBER ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { RandomAccessData org.springframework.boot.loader.data.RandomAccessData = this . org.springframework.boot.loader.data.RandomAccessDataFile . getSubsection ( NUMBER , NUMBER ) ; assertThat ( org.springframework.boot.loader.data.RandomAccessData . getInputStream ( ResourceAccess . PER_READ ) . read ( ) ) . isEqualTo ( - NUMBER ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { this . org.springframework.boot.loader.data.RandomAccessDataFile . getSubsection ( NUMBER , NUMBER ) ; this . org.springframework.boot.loader.data.ExpectedException . expect ( java.lang.IndexOutOfBoundsException .class ) ; this . org.springframework.boot.loader.data.RandomAccessDataFile . getSubsection ( NUMBER , NUMBER ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { this . org.springframework.boot.loader.data.RandomAccessDataFile . getSubsection ( NUMBER , NUMBER ) ; this . org.springframework.boot.loader.data.ExpectedException . expect ( java.lang.IndexOutOfBoundsException .class ) ; this . org.springframework.boot.loader.data.RandomAccessDataFile . getSubsection ( NUMBER , NUMBER ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { RandomAccessData org.springframework.boot.loader.data.RandomAccessData = this . org.springframework.boot.loader.data.RandomAccessDataFile . getSubsection ( NUMBER , NUMBER ) ; assertThat ( org.springframework.boot.loader.data.RandomAccessData . getInputStream ( ResourceAccess . PER_READ ) . read ( ) ) . isEqualTo ( NUMBER ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { RandomAccessData org.springframework.boot.loader.data.RandomAccessData = this . org.springframework.boot.loader.data.RandomAccessDataFile . getSubsection ( NUMBER , NUMBER ) ; java.io.InputStream java.io.InputStream = org.springframework.boot.loader.data.RandomAccessData . getInputStream ( ResourceAccess . PER_READ ) ; assertThat ( java.io.InputStream . int ( ) ) . isEqualTo ( NUMBER ) ; assertThat ( java.io.InputStream . int ( ) ) . isEqualTo ( NUMBER ) ; assertThat ( java.io.InputStream . int ( ) ) . isEqualTo ( - NUMBER ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { RandomAccessData org.springframework.boot.loader.data.RandomAccessData = this . org.springframework.boot.loader.data.RandomAccessDataFile . getSubsection ( NUMBER , NUMBER ) ; java.io.InputStream java.io.InputStream = org.springframework.boot.loader.data.RandomAccessData . getInputStream ( ResourceAccess . PER_READ ) ; byte [] byte[] = new byte [ NUMBER ] ; int int = java.io.InputStream . int ( byte[] ) ; assertThat ( byte[] ) . isEqualTo ( new byte [] { NUMBER , NUMBER , NUMBER } ) ; assertThat ( int ) . isEqualTo ( NUMBER ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { RandomAccessData org.springframework.boot.loader.data.RandomAccessData = this . org.springframework.boot.loader.data.RandomAccessDataFile . getSubsection ( NUMBER , NUMBER ) ; java.io.InputStream java.io.InputStream = org.springframework.boot.loader.data.RandomAccessData . getInputStream ( ResourceAccess . PER_READ ) ; assertThat ( java.io.InputStream . long ( NUMBER ) ) . isEqualTo ( NUMBER ) ; assertThat ( java.io.InputStream . int ( ) ) . isEqualTo ( - NUMBER ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { assertThat ( this . java.io.InputStream . long ( - NUMBER ) ) . isEqualTo ( NUMBER ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { assertThat ( this . org.springframework.boot.loader.data.RandomAccessDataFile . getFile ( ) ) . isEqualTo ( this . java.io.File ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.util.concurrent.ExecutorService java.util.concurrent.ExecutorService = java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( NUMBER ) ; java.util.List<java.util.concurrent.Future<java.lang.Boolean>> < java.util.concurrent.Future<java.lang.Boolean> < java.lang.Boolean > > java.util.List<java.util.concurrent.Future<java.lang.Boolean>> = new java.util.ArrayList<java.util.concurrent.Future<java.lang.Boolean>> <> ( ) ; for ( int int = NUMBER ; int < NUMBER ; int ++ ) { java.util.List<java.util.concurrent.Future<java.lang.Boolean>> . boolean ( java.util.concurrent.ExecutorService . java.util.concurrent.Future<java.lang.Boolean> ( new java.util.concurrent.Callable<java.lang.Boolean> < java.lang.Boolean > ( ) { @ java.lang.Override public java.lang.Boolean java.lang.Boolean ( ) java.lang.Exception { java.io.InputStream java.io.InputStream = org.springframework.boot.loader.data.RandomAccessDataFileTests .this . org.springframework.boot.loader.data.RandomAccessDataFile . getSubsection ( NUMBER , NUMBER ) . getInputStream ( ResourceAccess . PER_READ ) ; byte [] byte[] = new byte [ NUMBER ] ; java.io.InputStream . int ( byte[] ) ; return java.util.Arrays . boolean ( byte[] , byte[] ) ; } } ) ) ; } for ( java.util.concurrent.Future<java.lang.Boolean> < java.lang.Boolean > java.util.concurrent.Future<java.lang.Boolean> : java.util.List<java.util.concurrent.Future<java.lang.Boolean>> ) { assertThat ( java.util.concurrent.Future<java.lang.Boolean> . java.lang.Boolean ( ) ) . isTrue ( ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.Boolean java.lang.Boolean ( ) java.lang.Exception { java.io.InputStream java.io.InputStream = org.springframework.boot.loader.data.RandomAccessDataFileTests .this . org.springframework.boot.loader.data.RandomAccessDataFile . getSubsection ( NUMBER , NUMBER ) . getInputStream ( ResourceAccess . PER_READ ) ; byte [] byte[] = new byte [ NUMBER ] ; java.io.InputStream . int ( byte[] ) ; return java.util.Arrays . boolean ( byte[] , byte[] ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { this . org.springframework.boot.loader.data.RandomAccessDataFile . getInputStream ( ResourceAccess . PER_READ ) . read ( ) ; this . org.springframework.boot.loader.data.RandomAccessDataFile . close ( ) ; java.lang.reflect.Field java.lang.reflect.Field = RandomAccessDataFile .class . java.lang.reflect.Field ( STRING ) ; java.lang.reflect.Field . void ( true ) ; java.lang.Object java.lang.Object = java.lang.reflect.Field . java.lang.Object ( this . org.springframework.boot.loader.data.RandomAccessDataFile ) ; java.lang.reflect.Field java.lang.reflect.Field = java.lang.Object . java.lang.Class<? extends java.lang.Object> ( ) . java.lang.reflect.Field ( STRING ) ; java.lang.reflect.Field . void ( true ) ; java.util.Queue<?> < ? > java.util.Queue<?> = ( java.util.Queue<?> < ? > ) java.lang.reflect.Field . java.lang.Object ( java.lang.Object ) ; assertThat ( java.util.Queue<> . int ( ) ) . isEqualTo ( NUMBER ) ; }  <METHOD_END>
