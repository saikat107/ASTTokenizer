<METHOD_START> public void ( java.util.concurrent.Executor java.util.concurrent.Executor ) { Assert . notNull ( java.util.concurrent.Executor , STRING ) ; this . java.util.concurrent.Executor = java.util.concurrent.Executor ; }  <METHOD_END>
<METHOD_START> public final void void ( TaskDecorator org.springframework.core.task.support.TaskDecorator ) { this . org.springframework.core.task.support.TaskDecorator = org.springframework.core.task.support.TaskDecorator ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( java.lang.Runnable java.lang.Runnable ) { try { void ( this . java.util.concurrent.Executor , this . org.springframework.core.task.support.TaskDecorator , java.lang.Runnable ) ; } catch ( java.util.concurrent.RejectedExecutionException java.util.concurrent.RejectedExecutionException ) { throw new TaskRejectedException ( STRING + this . java.util.concurrent.Executor + STRING + java.lang.Runnable , java.util.concurrent.RejectedExecutionException ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( java.lang.Runnable java.lang.Runnable , long long ) { void ( java.lang.Runnable ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.util.concurrent.Future<?> < ? > java.util.concurrent.Future<?> ( java.lang.Runnable java.lang.Runnable ) { try { if ( this . org.springframework.core.task.support.TaskDecorator == null && this . java.util.concurrent.Executor instanceof java.util.concurrent.ExecutorService ) { return ( ( java.util.concurrent.ExecutorService ) this . java.util.concurrent.Executor ) . java.util.concurrent.Future<?> ( java.lang.Runnable ) ; } else { java.util.concurrent.FutureTask<java.lang.Object> < java.lang.Object > java.util.concurrent.FutureTask<java.lang.Object> = new java.util.concurrent.FutureTask<java.lang.Object> <> ( java.lang.Runnable , null ) ; void ( this . java.util.concurrent.Executor , this . org.springframework.core.task.support.TaskDecorator , java.util.concurrent.FutureTask<java.lang.Object> ) ; return java.util.concurrent.FutureTask<java.lang.Object> ; } } catch ( java.util.concurrent.RejectedExecutionException java.util.concurrent.RejectedExecutionException ) { throw new TaskRejectedException ( STRING + this . java.util.concurrent.Executor + STRING + java.lang.Runnable , java.util.concurrent.RejectedExecutionException ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public < T > java.util.concurrent.Future<T> < T > java.util.concurrent.Future<T> ( java.util.concurrent.Callable<T> < T > java.util.concurrent.Callable<T> ) { try { if ( this . org.springframework.core.task.support.TaskDecorator == null && this . java.util.concurrent.Executor instanceof java.util.concurrent.ExecutorService ) { return ( ( java.util.concurrent.ExecutorService ) this . java.util.concurrent.Executor ) . java.util.concurrent.Future<T> ( java.util.concurrent.Callable<T> ) ; } else { java.util.concurrent.FutureTask<T> < T > java.util.concurrent.FutureTask<T> = new java.util.concurrent.FutureTask<T> <> ( java.util.concurrent.Callable<T> ) ; void ( this . java.util.concurrent.Executor , this . org.springframework.core.task.support.TaskDecorator , java.util.concurrent.FutureTask<T> ) ; return java.util.concurrent.FutureTask<T> ; } } catch ( java.util.concurrent.RejectedExecutionException java.util.concurrent.RejectedExecutionException ) { throw new TaskRejectedException ( STRING + this . java.util.concurrent.Executor + STRING + java.util.concurrent.Callable<T> , java.util.concurrent.RejectedExecutionException ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.core.task.support.ListenableFuture<?> < ? > org.springframework.core.task.support.ListenableFuture<?> ( java.lang.Runnable java.lang.Runnable ) { try { ListenableFutureTask < java.lang.Object > org.springframework.core.task.support.ListenableFutureTask<java.lang.Object> = new ListenableFutureTask <> ( java.lang.Runnable , null ) ; void ( this . java.util.concurrent.Executor , this . org.springframework.core.task.support.TaskDecorator , org.springframework.core.task.support.ListenableFutureTask<java.lang.Object> ) ; return org.springframework.core.task.support.ListenableFutureTask<java.lang.Object> ; } catch ( java.util.concurrent.RejectedExecutionException java.util.concurrent.RejectedExecutionException ) { throw new TaskRejectedException ( STRING + this . java.util.concurrent.Executor + STRING + java.lang.Runnable , java.util.concurrent.RejectedExecutionException ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public < T > org.springframework.core.task.support.ListenableFuture<T> < T > org.springframework.core.task.support.ListenableFuture<T> ( java.util.concurrent.Callable<T> < T > java.util.concurrent.Callable<T> ) { try { ListenableFutureTask < T > org.springframework.core.task.support.ListenableFutureTask<T> = new ListenableFutureTask <> ( java.util.concurrent.Callable<T> ) ; void ( this . java.util.concurrent.Executor , this . org.springframework.core.task.support.TaskDecorator , org.springframework.core.task.support.ListenableFutureTask<T> ) ; return org.springframework.core.task.support.ListenableFutureTask<T> ; } catch ( java.util.concurrent.RejectedExecutionException java.util.concurrent.RejectedExecutionException ) { throw new TaskRejectedException ( STRING + this . java.util.concurrent.Executor + STRING + java.util.concurrent.Callable<T> , java.util.concurrent.RejectedExecutionException ) ; } }  <METHOD_END>
<METHOD_START> protected void void ( java.util.concurrent.Executor java.util.concurrent.Executor , TaskDecorator org.springframework.core.task.support.TaskDecorator , java.lang.Runnable java.lang.Runnable )			throws java.util.concurrent.RejectedExecutionException { java.util.concurrent.Executor . void ( org.springframework.core.task.support.TaskDecorator != null ? org.springframework.core.task.support.TaskDecorator . decorate ( java.lang.Runnable ) : java.lang.Runnable ) ; }  <METHOD_END>
