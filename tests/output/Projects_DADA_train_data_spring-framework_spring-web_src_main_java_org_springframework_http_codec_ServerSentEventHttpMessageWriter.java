<METHOD_START> public void ( ) { this( null ); }  <METHOD_END>
<METHOD_START> public void ( Encoder < ? > org.springframework.http.codec.Encoder<?> ) { this . org.springframework.http.codec.Encoder<?> = org.springframework.http.codec.Encoder<> ; }  <METHOD_END>
<METHOD_START> public org.springframework.http.codec.Encoder<?> < ? > org.springframework.http.codec.Encoder<?> ( ) { return this . org.springframework.http.codec.Encoder<> ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.util.List<org.springframework.http.codec.MediaType> < MediaType > java.util.List<org.springframework.http.codec.MediaType> ( ) { return java.util.List<org.springframework.http.codec.MediaType> ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( ResolvableType org.springframework.http.codec.ResolvableType , MediaType org.springframework.http.codec.MediaType ) { return org.springframework.http.codec.MediaType == null || MediaType . TEXT_EVENT_STREAM . includes ( org.springframework.http.codec.MediaType ) || ServerSentEvent .class . boolean ( org.springframework.http.codec.ResolvableType . getRawClass ( ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.http.codec.Mono<java.lang.Void> < java.lang.Void > org.springframework.http.codec.Mono<java.lang.Void> ( Publisher < ? > org.springframework.http.codec.Publisher<?> , ResolvableType org.springframework.http.codec.ResolvableType , MediaType org.springframework.http.codec.MediaType , ReactiveHttpOutputMessage org.springframework.http.codec.ReactiveHttpOutputMessage , java.util.Map<java.lang.String,java.lang.Object> < java.lang.String , java.lang.Object > java.util.Map<java.lang.String,java.lang.Object> ) { org.springframework.http.codec.ReactiveHttpOutputMessage . getHeaders ( ) . setContentType ( MediaType . TEXT_EVENT_STREAM ) ; return org.springframework.http.codec.ReactiveHttpOutputMessage . writeAndFlushWith ( org.springframework.http.codec.Flux<org.springframework.http.codec.Publisher<org.springframework.http.codec.DataBuffer>> ( org.springframework.http.codec.Publisher<> , org.springframework.http.codec.ReactiveHttpOutputMessage . bufferFactory ( ) , org.springframework.http.codec.ResolvableType , java.util.Map<java.lang.String,java.lang.Object> ) ) ; }  <METHOD_END>
<METHOD_START> private org.springframework.http.codec.Flux<org.springframework.http.codec.Publisher<org.springframework.http.codec.DataBuffer>> < Publisher < DataBuffer > > org.springframework.http.codec.Flux<org.springframework.http.codec.Publisher<org.springframework.http.codec.DataBuffer>> ( Publisher < ? > org.springframework.http.codec.Publisher<?> , DataBufferFactory org.springframework.http.codec.DataBufferFactory , ResolvableType org.springframework.http.codec.ResolvableType , java.util.Map<java.lang.String,java.lang.Object> < java.lang.String , java.lang.Object > java.util.Map<java.lang.String,java.lang.Object> ) { ResolvableType org.springframework.http.codec.ResolvableType = ServerSentEvent .class . boolean ( org.springframework.http.codec.ResolvableType . getRawClass ( ) ) ? org.springframework.http.codec.ResolvableType . getGeneric ( NUMBER ) : org.springframework.http.codec.ResolvableType ; return Flux . from ( org.springframework.http.codec.Publisher<> ) . map ( element -> { ServerSentEvent < ? > sse = element instanceof ServerSentEvent ? ( ServerSentEvent < ? > ) element : ServerSentEvent . builder ( ) . data ( element ) . build ( ) ; StringBuilder sb = new StringBuilder ( ) ; sse . id ( ) . ifPresent ( v -> writeField ( STRING , v , sb ) ) ; sse . event ( ) . ifPresent ( v -> writeField ( STRING , v , sb ) ) ; sse . retry ( ) . ifPresent ( v -> writeField ( STRING , v . toMillis ( ) , sb ) ) ; sse . comment ( ) . ifPresent ( v -> sb . append ( ':' ) . append ( v . replaceAll ( STRING , STRING ) ) . append ( STRING ) ) ; sse . data ( ) . ifPresent ( v -> sb . append ( STRING ) ) ; return Flux . concat ( encodeText ( sb , factory ) , encodeData ( sse , valueType , factory , hints ) , encodeText ( STRING , factory ) ) ; } ) ; }  <METHOD_END>
<METHOD_START> private void void ( java.lang.String java.lang.String , java.lang.Object java.lang.Object , java.lang.StringBuilder java.lang.StringBuilder ) { java.lang.StringBuilder . java.lang.StringBuilder ( java.lang.String ) ; java.lang.StringBuilder . java.lang.StringBuilder ( ':' ) ; java.lang.StringBuilder . java.lang.StringBuilder ( java.lang.Object . java.lang.String ( ) ) ; java.lang.StringBuilder . java.lang.StringBuilder ( STRING ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.SuppressWarnings ( STRING ) private < T > org.springframework.http.codec.Flux<org.springframework.http.codec.DataBuffer> < DataBuffer > org.springframework.http.codec.Flux<org.springframework.http.codec.DataBuffer> ( ServerSentEvent < ? > org.springframework.http.codec.ServerSentEvent<?> , ResolvableType org.springframework.http.codec.ResolvableType , DataBufferFactory org.springframework.http.codec.DataBufferFactory , java.util.Map<java.lang.String,java.lang.Object> < java.lang.String , java.lang.Object > java.util.Map<java.lang.String,java.lang.Object> ) { java.lang.Object java.lang.Object = org.springframework.http.codec.ServerSentEvent<> . data ( ) . orElse ( null ) ; if ( java.lang.Object == null ) { return Flux . empty ( ) ; } if ( java.lang.Object instanceof java.lang.String ) { java.lang.String java.lang.String = ( java.lang.String ) java.lang.Object ; return Flux . from ( org.springframework.http.codec.Mono<org.springframework.http.codec.DataBuffer> ( java.lang.String . java.lang.String ( STRING , STRING ) + STRING , org.springframework.http.codec.DataBufferFactory ) ) ; } if ( this . org.springframework.http.codec.Encoder<> == null ) { return Flux . error ( new CodecException ( STRING ) ) ; } return ( ( Encoder < T > ) this . org.springframework.http.codec.Encoder<> ) . encode ( Mono . just ( ( T ) java.lang.Object ) , org.springframework.http.codec.DataBufferFactory , org.springframework.http.codec.ResolvableType , MediaType . TEXT_EVENT_STREAM , java.util.Map<java.lang.String,java.lang.Object> ) . concatWith ( org.springframework.http.codec.Mono<org.springframework.http.codec.DataBuffer> ( STRING , org.springframework.http.codec.DataBufferFactory ) ) ; }  <METHOD_END>
<METHOD_START> private org.springframework.http.codec.Mono<org.springframework.http.codec.DataBuffer> < DataBuffer > org.springframework.http.codec.Mono<org.springframework.http.codec.DataBuffer> ( java.lang.CharSequence java.lang.CharSequence , DataBufferFactory org.springframework.http.codec.DataBufferFactory ) { byte [] byte[] = java.lang.CharSequence . java.lang.String ( ) . byte[] ( java.nio.charset.StandardCharsets . java.nio.charset.Charset ) ; DataBuffer org.springframework.http.codec.DataBuffer = org.springframework.http.codec.DataBufferFactory . allocateBuffer ( byte[] . int ) . write ( byte[] ) ; return Mono . just ( org.springframework.http.codec.DataBuffer ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.http.codec.Mono<java.lang.Void> < java.lang.Void > org.springframework.http.codec.Mono<java.lang.Void> ( Publisher < ? > org.springframework.http.codec.Publisher<?> , ResolvableType org.springframework.http.codec.ResolvableType , ResolvableType org.springframework.http.codec.ResolvableType , MediaType org.springframework.http.codec.MediaType , ServerHttpRequest org.springframework.http.codec.ServerHttpRequest , ServerHttpResponse org.springframework.http.codec.ServerHttpResponse , java.util.Map<java.lang.String,java.lang.Object> < java.lang.String , java.lang.Object > java.util.Map<java.lang.String,java.lang.Object> ) { java.util.Map<java.lang.String,java.lang.Object> < java.lang.String , java.lang.Object > java.util.Map<java.lang.String,java.lang.Object> = new java.util.HashMap<java.lang.String,java.lang.Object> <> ( ) ; java.util.Map<java.lang.String,java.lang.Object> . void ( java.util.Map<java.lang.String,java.lang.Object> ( org.springframework.http.codec.ResolvableType , org.springframework.http.codec.ResolvableType , org.springframework.http.codec.MediaType , org.springframework.http.codec.ServerHttpRequest , org.springframework.http.codec.ServerHttpResponse ) ) ; java.util.Map<java.lang.String,java.lang.Object> . void ( java.util.Map<java.lang.String,java.lang.Object> ) ; return org.springframework.http.codec.Mono<java.lang.Void> ( org.springframework.http.codec.Publisher<> , org.springframework.http.codec.ResolvableType , org.springframework.http.codec.MediaType , org.springframework.http.codec.ServerHttpResponse , java.util.Map<java.lang.String,java.lang.Object> ) ; }  <METHOD_END>
<METHOD_START> private java.util.Map<java.lang.String,java.lang.Object> < java.lang.String , java.lang.Object > java.util.Map<java.lang.String,java.lang.Object> ( ResolvableType org.springframework.http.codec.ResolvableType , ResolvableType org.springframework.http.codec.ResolvableType , MediaType org.springframework.http.codec.MediaType , ServerHttpRequest org.springframework.http.codec.ServerHttpRequest , ServerHttpResponse org.springframework.http.codec.ServerHttpResponse ) { if ( this . org.springframework.http.codec.Encoder<> instanceof HttpMessageEncoder ) { HttpMessageEncoder < ? > org.springframework.http.codec.HttpMessageEncoder<?> = ( HttpMessageEncoder < ? > ) this . org.springframework.http.codec.Encoder<> ; return org.springframework.http.codec.HttpMessageEncoder<> . getEncodeHints ( org.springframework.http.codec.ResolvableType , org.springframework.http.codec.ResolvableType , org.springframework.http.codec.MediaType , org.springframework.http.codec.ServerHttpRequest , org.springframework.http.codec.ServerHttpResponse ) ; } return java.util.Collections . java.util.Map<java.lang.String,java.lang.Object> ( ) ; }  <METHOD_END>
