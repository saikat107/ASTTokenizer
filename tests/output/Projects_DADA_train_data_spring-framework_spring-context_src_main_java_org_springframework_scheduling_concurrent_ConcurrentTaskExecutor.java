<METHOD_START> public void ( ) { void ( null ) ; }  <METHOD_END>
<METHOD_START> public void ( java.util.concurrent.Executor java.util.concurrent.Executor ) { void ( java.util.concurrent.Executor ) ; }  <METHOD_END>
<METHOD_START> public final void void ( java.util.concurrent.Executor java.util.concurrent.Executor ) { if ( java.util.concurrent.Executor != null ) { this . java.util.concurrent.Executor = java.util.concurrent.Executor ; if ( java.lang.Class<> != null && java.lang.Class<> . boolean ( java.util.concurrent.Executor ) ) { this . org.springframework.scheduling.concurrent.TaskExecutorAdapter = new org.springframework.scheduling.concurrent.ConcurrentTaskExecutor.ManagedTaskExecutorAdapter ( java.util.concurrent.Executor ) ; } else { this . org.springframework.scheduling.concurrent.TaskExecutorAdapter = new TaskExecutorAdapter ( java.util.concurrent.Executor ) ; } } else { this . java.util.concurrent.Executor = java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) ; this . org.springframework.scheduling.concurrent.TaskExecutorAdapter = new TaskExecutorAdapter ( this . java.util.concurrent.Executor ) ; } }  <METHOD_END>
<METHOD_START> public final java.util.concurrent.Executor java.util.concurrent.Executor ( ) { return this . java.util.concurrent.Executor ; }  <METHOD_END>
<METHOD_START> public final void void ( TaskDecorator org.springframework.scheduling.concurrent.TaskDecorator ) { this . org.springframework.scheduling.concurrent.TaskExecutorAdapter . setTaskDecorator ( org.springframework.scheduling.concurrent.TaskDecorator ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( java.lang.Runnable java.lang.Runnable ) { this . org.springframework.scheduling.concurrent.TaskExecutorAdapter . execute ( java.lang.Runnable ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( java.lang.Runnable java.lang.Runnable , long long ) { this . org.springframework.scheduling.concurrent.TaskExecutorAdapter . execute ( java.lang.Runnable , long ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.util.concurrent.Future<?> < ? > java.util.concurrent.Future<?> ( java.lang.Runnable java.lang.Runnable ) { return this . org.springframework.scheduling.concurrent.TaskExecutorAdapter . submit ( java.lang.Runnable ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public < T > java.util.concurrent.Future<T> < T > java.util.concurrent.Future<T> ( java.util.concurrent.Callable<T> < T > java.util.concurrent.Callable<T> ) { return this . org.springframework.scheduling.concurrent.TaskExecutorAdapter . submit ( java.util.concurrent.Callable<T> ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.scheduling.concurrent.ListenableFuture<?> < ? > org.springframework.scheduling.concurrent.ListenableFuture<?> ( java.lang.Runnable java.lang.Runnable ) { return this . org.springframework.scheduling.concurrent.TaskExecutorAdapter . submitListenable ( java.lang.Runnable ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public < T > org.springframework.scheduling.concurrent.ListenableFuture<T> < T > org.springframework.scheduling.concurrent.ListenableFuture<T> ( java.util.concurrent.Callable<T> < T > java.util.concurrent.Callable<T> ) { return this . org.springframework.scheduling.concurrent.TaskExecutorAdapter . submitListenable ( java.util.concurrent.Callable<T> ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( ) { return true ; }  <METHOD_END>
<METHOD_START> public void ( java.util.concurrent.Executor java.util.concurrent.Executor ) { super( java.util.concurrent.Executor ); }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( java.lang.Runnable java.lang.Runnable ) { super. execute ( org.springframework.scheduling.concurrent.ConcurrentTaskExecutor.ManagedTaskBuilder . java.lang.Runnable ( java.lang.Runnable , java.lang.Runnable . java.lang.String ( ) ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.util.concurrent.Future<?> < ? > java.util.concurrent.Future<?> ( java.lang.Runnable java.lang.Runnable ) { return super. submit ( org.springframework.scheduling.concurrent.ConcurrentTaskExecutor.ManagedTaskBuilder . java.lang.Runnable ( java.lang.Runnable , java.lang.Runnable . java.lang.String ( ) ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public < T > java.util.concurrent.Future<T> < T > java.util.concurrent.Future<T> ( java.util.concurrent.Callable<T> < T > java.util.concurrent.Callable<T> ) { return super. submit ( org.springframework.scheduling.concurrent.ConcurrentTaskExecutor.ManagedTaskBuilder . java.util.concurrent.Callable<T> ( java.util.concurrent.Callable<T> , java.util.concurrent.Callable<T> . java.lang.String ( ) ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.scheduling.concurrent.ListenableFuture<?> < ? > org.springframework.scheduling.concurrent.ListenableFuture<?> ( java.lang.Runnable java.lang.Runnable ) { return super. submitListenable ( org.springframework.scheduling.concurrent.ConcurrentTaskExecutor.ManagedTaskBuilder . java.lang.Runnable ( java.lang.Runnable , java.lang.Runnable . java.lang.String ( ) ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public < T > org.springframework.scheduling.concurrent.ListenableFuture<T> < T > org.springframework.scheduling.concurrent.ListenableFuture<T> ( java.util.concurrent.Callable<T> < T > java.util.concurrent.Callable<T> ) { return super. submitListenable ( org.springframework.scheduling.concurrent.ConcurrentTaskExecutor.ManagedTaskBuilder . java.util.concurrent.Callable<T> ( java.util.concurrent.Callable<T> , java.util.concurrent.Callable<T> . java.lang.String ( ) ) ) ; }  <METHOD_END>
<METHOD_START> public static java.lang.Runnable java.lang.Runnable ( java.lang.Runnable java.lang.Runnable , java.lang.String java.lang.String ) { java.util.Map<java.lang.String,java.lang.String> < java.lang.String , java.lang.String > java.util.Map<java.lang.String,java.lang.String> = new java.util.HashMap<java.lang.String,java.lang.String> <> ( NUMBER ) ; if ( java.lang.Runnable instanceof SchedulingAwareRunnable ) { java.util.Map<java.lang.String,java.lang.String> . java.lang.String ( ManagedTask . LONGRUNNING_HINT , java.lang.Boolean . java.lang.String ( ( ( SchedulingAwareRunnable ) java.lang.Runnable ) . isLongLived ( ) ) ) ; } java.util.Map<java.lang.String,java.lang.String> . java.lang.String ( ManagedTask . IDENTITY_NAME , java.lang.String ) ; return ManagedExecutors . managedTask ( java.lang.Runnable , java.util.Map<java.lang.String,java.lang.String> , null ) ; }  <METHOD_END>
<METHOD_START> public static < T > java.util.concurrent.Callable<T> < T > java.util.concurrent.Callable<T> ( java.util.concurrent.Callable<T> < T > java.util.concurrent.Callable<T> , java.lang.String java.lang.String ) { java.util.Map<java.lang.String,java.lang.String> < java.lang.String , java.lang.String > java.util.Map<java.lang.String,java.lang.String> = new java.util.HashMap<java.lang.String,java.lang.String> <> ( NUMBER ) ; java.util.Map<java.lang.String,java.lang.String> . java.lang.String ( ManagedTask . IDENTITY_NAME , java.lang.String ) ; return ManagedExecutors . managedTask ( java.util.concurrent.Callable<T> , java.util.Map<java.lang.String,java.lang.String> , null ) ; }  <METHOD_END>
