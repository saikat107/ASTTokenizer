<METHOD_START> @ Test public void void ( ) java.lang.Exception { final java.util.concurrent.atomic.AtomicBoolean java.util.concurrent.atomic.AtomicBoolean = new java.util.concurrent.atomic.AtomicBoolean ( true ) ; final java.util.concurrent.atomic.AtomicInteger java.util.concurrent.atomic.AtomicInteger = new java.util.concurrent.atomic.AtomicInteger ( ) ; SessionFactory < java.lang.String > org.springframework.integration.file.remote.synchronizer.SessionFactory<java.lang.String> = new org.springframework.integration.file.remote.synchronizer.AbstractRemoteFileSynchronizerTests.StringSessionFactory ( ) ; AbstractInboundFileSynchronizer < java.lang.String > org.springframework.integration.file.remote.synchronizer.AbstractInboundFileSynchronizer<java.lang.String> = new AbstractInboundFileSynchronizer < java.lang.String > ( org.springframework.integration.file.remote.synchronizer.SessionFactory<java.lang.String> ) { @ java.lang.Override protected boolean boolean ( java.lang.String java.lang.String ) { return true ; } @ java.lang.Override protected java.lang.String java.lang.String ( java.lang.String java.lang.String ) { return java.lang.String ; } @ java.lang.Override protected long long ( java.lang.String java.lang.String ) { return NUMBER ; } @ java.lang.Override protected void void ( java.lang.String java.lang.String , java.lang.String java.lang.String , java.io.File java.io.File , Session < java.lang.String > org.springframework.integration.file.remote.synchronizer.Session<java.lang.String> ) throws java.io.IOException { if ( STRING . boolean ( java.lang.String ) && java.util.concurrent.atomic.AtomicBoolean . boolean ( false ) ) { throw new java.io.IOException ( STRING ) ; } java.util.concurrent.atomic.AtomicInteger . int ( ) ; } } ; org.springframework.integration.file.remote.synchronizer.AbstractInboundFileSynchronizer<java.lang.String> . setFilter ( new AcceptOnceFileListFilter < java.lang.String > ( ) ) ; org.springframework.integration.file.remote.synchronizer.AbstractInboundFileSynchronizer<java.lang.String> . setRemoteDirectory ( STRING ) ; try { org.springframework.integration.file.remote.synchronizer.AbstractInboundFileSynchronizer<java.lang.String> . synchronizeToLocalDirectory ( mock ( java.io.File .class ) ) ; assertEquals ( NUMBER , java.util.concurrent.atomic.AtomicInteger . int ( ) ) ; fail ( STRING ) ; } catch ( MessagingException org.springframework.integration.file.remote.synchronizer.MessagingException ) { assertThat ( org.springframework.integration.file.remote.synchronizer.MessagingException . getCause ( ) , instanceOf ( MessagingException .class ) ) ; assertThat ( org.springframework.integration.file.remote.synchronizer.MessagingException . getCause ( ) . getCause ( ) , instanceOf ( java.io.IOException .class ) ) ; assertEquals ( STRING , org.springframework.integration.file.remote.synchronizer.MessagingException . getCause ( ) . getCause ( ) . getMessage ( ) ) ; } org.springframework.integration.file.remote.synchronizer.AbstractInboundFileSynchronizer<java.lang.String> . synchronizeToLocalDirectory ( mock ( java.io.File .class ) ) ; assertEquals ( NUMBER , java.util.concurrent.atomic.AtomicInteger . int ( ) ) ; org.springframework.integration.file.remote.synchronizer.AbstractInboundFileSynchronizer<java.lang.String> . close ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected boolean boolean ( java.lang.String java.lang.String ) { return true ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected java.lang.String java.lang.String ( java.lang.String java.lang.String ) { return java.lang.String ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected long long ( java.lang.String java.lang.String ) { return NUMBER ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( java.lang.String java.lang.String , java.lang.String java.lang.String , java.io.File java.io.File , Session < java.lang.String > org.springframework.integration.file.remote.synchronizer.Session<java.lang.String> ) throws java.io.IOException { if ( STRING . boolean ( java.lang.String ) && java.util.concurrent.atomic.AtomicBoolean . boolean ( false ) ) { throw new java.io.IOException ( STRING ) ; } java.util.concurrent.atomic.AtomicInteger . int ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final java.util.concurrent.atomic.AtomicInteger java.util.concurrent.atomic.AtomicInteger = new java.util.concurrent.atomic.AtomicInteger ( ) ; AbstractInboundFileSynchronizer < java.lang.String > org.springframework.integration.file.remote.synchronizer.AbstractInboundFileSynchronizer<java.lang.String> = org.springframework.integration.file.remote.synchronizer.AbstractInboundFileSynchronizer<java.lang.String> ( java.util.concurrent.atomic.AtomicInteger ) ; org.springframework.integration.file.remote.synchronizer.AbstractInboundFileSynchronizer<java.lang.String> . synchronizeToLocalDirectory ( mock ( java.io.File .class ) , NUMBER ) ; assertEquals ( NUMBER , java.util.concurrent.atomic.AtomicInteger . int ( ) ) ; org.springframework.integration.file.remote.synchronizer.AbstractInboundFileSynchronizer<java.lang.String> . synchronizeToLocalDirectory ( mock ( java.io.File .class ) , NUMBER ) ; assertEquals ( NUMBER , java.util.concurrent.atomic.AtomicInteger . int ( ) ) ; org.springframework.integration.file.remote.synchronizer.AbstractInboundFileSynchronizer<java.lang.String> . synchronizeToLocalDirectory ( mock ( java.io.File .class ) , NUMBER ) ; assertEquals ( NUMBER , java.util.concurrent.atomic.AtomicInteger . int ( ) ) ; org.springframework.integration.file.remote.synchronizer.AbstractInboundFileSynchronizer<java.lang.String> . close ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final java.util.concurrent.atomic.AtomicInteger java.util.concurrent.atomic.AtomicInteger = new java.util.concurrent.atomic.AtomicInteger ( ) ; AbstractInboundFileSynchronizer < java.lang.String > org.springframework.integration.file.remote.synchronizer.AbstractInboundFileSynchronizer<java.lang.String> = org.springframework.integration.file.remote.synchronizer.AbstractInboundFileSynchronizer<java.lang.String> ( java.util.concurrent.atomic.AtomicInteger ) ; AbstractInboundFileSynchronizingMessageSource < java.lang.String > org.springframework.integration.file.remote.synchronizer.AbstractInboundFileSynchronizingMessageSource<java.lang.String> = new AbstractInboundFileSynchronizingMessageSource < java.lang.String > ( org.springframework.integration.file.remote.synchronizer.AbstractInboundFileSynchronizer<java.lang.String> ) { @ java.lang.Override public java.lang.String java.lang.String ( ) { return STRING ; } } ; org.springframework.integration.file.remote.synchronizer.AbstractInboundFileSynchronizingMessageSource<java.lang.String> . setLocalDirectory ( new java.io.File ( java.lang.System . java.lang.String ( STRING ) + java.io.File . java.lang.String + java.util.UUID . java.util.UUID ( ) ) ) ; org.springframework.integration.file.remote.synchronizer.AbstractInboundFileSynchronizingMessageSource<java.lang.String> . setAutoCreateLocalDirectory ( true ) ; org.springframework.integration.file.remote.synchronizer.AbstractInboundFileSynchronizingMessageSource<java.lang.String> . setBeanFactory ( mock ( BeanFactory .class ) ) ; org.springframework.integration.file.remote.synchronizer.AbstractInboundFileSynchronizingMessageSource<java.lang.String> . setMaxFetchSize ( NUMBER ) ; org.springframework.integration.file.remote.synchronizer.AbstractInboundFileSynchronizingMessageSource<java.lang.String> . setBeanName ( STRING ) ; org.springframework.integration.file.remote.synchronizer.AbstractInboundFileSynchronizingMessageSource<java.lang.String> . afterPropertiesSet ( ) ; org.springframework.integration.file.remote.synchronizer.AbstractInboundFileSynchronizingMessageSource<java.lang.String> . start ( ) ; org.springframework.integration.file.remote.synchronizer.AbstractInboundFileSynchronizingMessageSource<java.lang.String> . receive ( ) ; assertEquals ( NUMBER , java.util.concurrent.atomic.AtomicInteger . int ( ) ) ; org.springframework.integration.file.remote.synchronizer.AbstractInboundFileSynchronizer<java.lang.String> . synchronizeToLocalDirectory ( mock ( java.io.File .class ) , NUMBER ) ; org.springframework.integration.file.remote.synchronizer.AbstractInboundFileSynchronizingMessageSource<java.lang.String> . receive ( ) ; org.springframework.integration.file.remote.synchronizer.AbstractInboundFileSynchronizer<java.lang.String> . synchronizeToLocalDirectory ( mock ( java.io.File .class ) , NUMBER ) ; org.springframework.integration.file.remote.synchronizer.AbstractInboundFileSynchronizingMessageSource<java.lang.String> . receive ( ) ; org.springframework.integration.file.remote.synchronizer.AbstractInboundFileSynchronizingMessageSource<java.lang.String> . stop ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.String java.lang.String ( ) { return STRING ; }  <METHOD_END>
<METHOD_START> private org.springframework.integration.file.remote.synchronizer.AbstractInboundFileSynchronizer<java.lang.String> < java.lang.String > org.springframework.integration.file.remote.synchronizer.AbstractInboundFileSynchronizer<java.lang.String> ( final java.util.concurrent.atomic.AtomicInteger java.util.concurrent.atomic.AtomicInteger ) { SessionFactory < java.lang.String > org.springframework.integration.file.remote.synchronizer.SessionFactory<java.lang.String> = new org.springframework.integration.file.remote.synchronizer.AbstractRemoteFileSynchronizerTests.StringSessionFactory ( ) ; AbstractInboundFileSynchronizer < java.lang.String > org.springframework.integration.file.remote.synchronizer.AbstractInboundFileSynchronizer<java.lang.String> = new AbstractInboundFileSynchronizer < java.lang.String > ( org.springframework.integration.file.remote.synchronizer.SessionFactory<java.lang.String> ) { @ java.lang.Override protected boolean boolean ( java.lang.String java.lang.String ) { return true ; } @ java.lang.Override protected java.lang.String java.lang.String ( java.lang.String java.lang.String ) { return java.lang.String ; } @ java.lang.Override protected long long ( java.lang.String java.lang.String ) { return NUMBER ; } @ java.lang.Override protected void void ( java.lang.String java.lang.String , java.lang.String java.lang.String , java.io.File java.io.File , Session < java.lang.String > org.springframework.integration.file.remote.synchronizer.Session<java.lang.String> ) throws java.io.IOException { java.util.concurrent.atomic.AtomicInteger . int ( ) ; } } ; org.springframework.integration.file.remote.synchronizer.AbstractInboundFileSynchronizer<java.lang.String> . setFilter ( new AcceptOnceFileListFilter < java.lang.String > ( ) ) ; org.springframework.integration.file.remote.synchronizer.AbstractInboundFileSynchronizer<java.lang.String> . setRemoteDirectory ( STRING ) ; org.springframework.integration.file.remote.synchronizer.AbstractInboundFileSynchronizer<java.lang.String> . setBeanFactory ( mock ( BeanFactory .class ) ) ; return org.springframework.integration.file.remote.synchronizer.AbstractInboundFileSynchronizer<java.lang.String> ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected boolean boolean ( java.lang.String java.lang.String ) { return true ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected java.lang.String java.lang.String ( java.lang.String java.lang.String ) { return java.lang.String ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected long long ( java.lang.String java.lang.String ) { return NUMBER ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( java.lang.String java.lang.String , java.lang.String java.lang.String , java.io.File java.io.File , Session < java.lang.String > org.springframework.integration.file.remote.synchronizer.Session<java.lang.String> ) throws java.io.IOException { java.util.concurrent.atomic.AtomicInteger . int ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.integration.file.remote.synchronizer.Session<java.lang.String> < java.lang.String > org.springframework.integration.file.remote.synchronizer.Session<java.lang.String> ( ) { return new org.springframework.integration.file.remote.synchronizer.AbstractRemoteFileSynchronizerTests.StringSession ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( java.lang.String java.lang.String ) throws java.io.IOException { return true ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.String [] java.lang.String[] ( java.lang.String java.lang.String ) throws java.io.IOException { return new java.lang.String [] { STRING , STRING , STRING } ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( java.lang.String java.lang.String , java.io.OutputStream java.io.OutputStream ) throws java.io.IOException {		}  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( java.io.InputStream java.io.InputStream , java.lang.String java.lang.String ) throws java.io.IOException {		}  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( java.io.InputStream java.io.InputStream , java.lang.String java.lang.String ) throws java.io.IOException {		}  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( java.lang.String java.lang.String ) throws java.io.IOException { return true ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( java.lang.String java.lang.String ) throws java.io.IOException { return true ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( java.lang.String java.lang.String , java.lang.String java.lang.String ) throws java.io.IOException {		}  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ) {		}  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( ) { return true ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( java.lang.String java.lang.String ) throws java.io.IOException { return true ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.String [] java.lang.String[] ( java.lang.String java.lang.String ) throws java.io.IOException { return new java.lang.String [ NUMBER ] ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.io.InputStream java.io.InputStream ( java.lang.String java.lang.String ) throws java.io.IOException { return null ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( ) java.io.IOException { return true ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.Object java.lang.Object ( ) { return null ; }  <METHOD_END>
