<METHOD_START> public void ( SubscribableChannel org.springframework.messaging.simp.stomp.SubscribableChannel , MessageChannel org.springframework.messaging.simp.stomp.MessageChannel , SubscribableChannel org.springframework.messaging.simp.stomp.SubscribableChannel , java.util.Collection<java.lang.String> < java.lang.String > java.util.Collection<java.lang.String> ) { super( org.springframework.messaging.simp.stomp.SubscribableChannel , org.springframework.messaging.simp.stomp.MessageChannel , org.springframework.messaging.simp.stomp.SubscribableChannel , java.util.Collection<java.lang.String> ); }  <METHOD_END>
<METHOD_START> public void void ( java.lang.String java.lang.String ) { Assert . hasText ( java.lang.String , STRING ) ; this . java.lang.String = java.lang.String ; }  <METHOD_END>
<METHOD_START> public java.lang.String java.lang.String ( ) { return this . java.lang.String ; }  <METHOD_END>
<METHOD_START> public void void ( int int ) { this . int = int ; }  <METHOD_END>
<METHOD_START> public int int ( ) { return this . int ; }  <METHOD_END>
<METHOD_START> public void void ( java.lang.String java.lang.String ) { Assert . hasText ( java.lang.String , STRING ) ; this . java.lang.String = java.lang.String ; }  <METHOD_END>
<METHOD_START> public java.lang.String java.lang.String ( ) { return this . java.lang.String ; }  <METHOD_END>
<METHOD_START> public void void ( java.lang.String java.lang.String ) { Assert . hasText ( java.lang.String , STRING ) ; this . java.lang.String = java.lang.String ; }  <METHOD_END>
<METHOD_START> public java.lang.String java.lang.String ( ) { return this . java.lang.String ; }  <METHOD_END>
<METHOD_START> public void void ( java.lang.String java.lang.String ) { Assert . hasText ( java.lang.String , STRING ) ; this . java.lang.String = java.lang.String ; }  <METHOD_END>
<METHOD_START> public java.lang.String java.lang.String ( ) { return this . java.lang.String ; }  <METHOD_END>
<METHOD_START> public void void ( java.lang.String java.lang.String ) { this . java.lang.String = java.lang.String ; }  <METHOD_END>
<METHOD_START> public java.lang.String java.lang.String ( ) { return this . java.lang.String ; }  <METHOD_END>
<METHOD_START> public void void ( long long ) { this . long = long ; }  <METHOD_END>
<METHOD_START> public long long ( ) { return this . long ; }  <METHOD_END>
<METHOD_START> public void void ( long long ) { this . long = long ; }  <METHOD_END>
<METHOD_START> public long long ( ) { return this . long ; }  <METHOD_END>
<METHOD_START> public void void ( java.util.Map<java.lang.String,org.springframework.messaging.simp.stomp.MessageHandler> < java.lang.String , MessageHandler > java.util.Map<java.lang.String,org.springframework.messaging.simp.stomp.MessageHandler> ) { this . java.util.Map<java.lang.String,org.springframework.messaging.simp.stomp.MessageHandler> . clear ( ) ; if ( java.util.Map<java.lang.String,org.springframework.messaging.simp.stomp.MessageHandler> != null ) { this . java.util.Map<java.lang.String,org.springframework.messaging.simp.stomp.MessageHandler> . putAll ( java.util.Map<java.lang.String,org.springframework.messaging.simp.stomp.MessageHandler> ) ; } }  <METHOD_END>
<METHOD_START> public java.util.Map<java.lang.String,org.springframework.messaging.simp.stomp.MessageHandler> < java.lang.String , MessageHandler > java.util.Map<java.lang.String,org.springframework.messaging.simp.stomp.MessageHandler> ( ) { return this . java.util.Map<java.lang.String,org.springframework.messaging.simp.stomp.MessageHandler> ; }  <METHOD_END>
<METHOD_START> public void void ( java.lang.String java.lang.String ) { this . java.lang.String = java.lang.String ; }  <METHOD_END>
<METHOD_START> public java.lang.String java.lang.String ( ) { return this . java.lang.String ; }  <METHOD_END>
<METHOD_START> public void void ( TcpOperations < byte [] > org.springframework.messaging.simp.stomp.TcpOperations<byte[]> ) { this . org.springframework.messaging.simp.stomp.TcpOperations<byte[]> = org.springframework.messaging.simp.stomp.TcpOperations<byte[]> ; }  <METHOD_END>
<METHOD_START> public org.springframework.messaging.simp.stomp.TcpOperations<byte[]> < byte [] > org.springframework.messaging.simp.stomp.TcpOperations<byte[]> ( ) { return this . org.springframework.messaging.simp.stomp.TcpOperations<byte[]> ; }  <METHOD_END>
<METHOD_START> public void void ( MessageHeaderInitializer org.springframework.messaging.simp.stomp.MessageHeaderInitializer ) { this . org.springframework.messaging.simp.stomp.MessageHeaderInitializer = org.springframework.messaging.simp.stomp.MessageHeaderInitializer ; }  <METHOD_END>
<METHOD_START> public org.springframework.messaging.simp.stomp.MessageHeaderInitializer org.springframework.messaging.simp.stomp.MessageHeaderInitializer ( ) { return this . org.springframework.messaging.simp.stomp.MessageHeaderInitializer ; }  <METHOD_END>
<METHOD_START> public java.lang.String java.lang.String ( ) { return this . org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler.Stats . java.lang.String ( ) ; }  <METHOD_END>
<METHOD_START> public int int ( ) { return this . java.util.Map<java.lang.String,org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler.StompConnectionHandler> . int ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( ) { if ( this . org.springframework.messaging.simp.stomp.TcpOperations<byte[]> == null ) { StompDecoder org.springframework.messaging.simp.stomp.StompDecoder = new StompDecoder ( ) ; org.springframework.messaging.simp.stomp.StompDecoder . setHeaderInitializer ( org.springframework.messaging.simp.stomp.MessageHeaderInitializer ( ) ) ; ReactorNettyCodec < byte [] > org.springframework.messaging.simp.stomp.ReactorNettyCodec<byte[]> = new StompReactorNettyCodec ( org.springframework.messaging.simp.stomp.StompDecoder ) ; this . org.springframework.messaging.simp.stomp.TcpOperations<byte[]> = new ReactorNettyTcpClient <> ( this . java.lang.String , this . int , org.springframework.messaging.simp.stomp.ReactorNettyCodec<byte[]> ) ; } if ( logger . isInfoEnabled ( ) ) { logger . info ( STRING + this . java.lang.String + STRING + this . int ) ; } StompHeaderAccessor org.springframework.messaging.simp.stomp.StompHeaderAccessor = StompHeaderAccessor . create ( StompCommand . CONNECT ) ; org.springframework.messaging.simp.stomp.StompHeaderAccessor . setAcceptVersion ( STRING ) ; org.springframework.messaging.simp.stomp.StompHeaderAccessor . setLogin ( this . java.lang.String ) ; org.springframework.messaging.simp.stomp.StompHeaderAccessor . setPasscode ( this . java.lang.String ) ; org.springframework.messaging.simp.stomp.StompHeaderAccessor . setHeartbeat ( this . long , this . long ) ; org.springframework.messaging.simp.stomp.StompHeaderAccessor . setHost ( java.lang.String ( ) ) ; org.springframework.messaging.simp.stomp.StompHeaderAccessor . setSessionId ( java.lang.String ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( STRING + org.springframework.messaging.simp.stomp.StompHeaderAccessor . getShortLogMessage ( byte[] ) ) ; } org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler.SystemStompConnectionHandler org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler.SystemStompConnectionHandler = new org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler.SystemStompConnectionHandler ( org.springframework.messaging.simp.stomp.StompHeaderAccessor ) ; this . java.util.Map<java.lang.String,org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler.StompConnectionHandler> . org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler.StompConnectionHandler ( org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler.SystemStompConnectionHandler . java.lang.String ( ) , org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler.SystemStompConnectionHandler ) ; this . org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler.Stats . void ( ) ; this . org.springframework.messaging.simp.stomp.TcpOperations<byte[]> . connect ( org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler.SystemStompConnectionHandler , new FixedIntervalReconnectStrategy ( NUMBER ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( ) { publishBrokerUnavailableEvent ( ) ; try { this . org.springframework.messaging.simp.stomp.TcpOperations<byte[]> . shutdown ( ) . get ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ; } catch ( java.lang.Throwable java.lang.Throwable ) { logger . error ( STRING , java.lang.Throwable ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( Message < ? > org.springframework.messaging.simp.stomp.Message<?> ) { java.lang.String java.lang.String = SimpMessageHeaderAccessor . getSessionId ( org.springframework.messaging.simp.stomp.Message<> . getHeaders ( ) ) ; if ( ! isBrokerAvailable ( ) ) { if ( java.lang.String == null || java.lang.String . boolean ( java.lang.String ) ) { throw new MessageDeliveryException ( STRING + STRING ) ; } org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler.StompConnectionHandler org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler.StompConnectionHandler = this . java.util.Map<java.lang.String,org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler.StompConnectionHandler> . org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler.StompConnectionHandler ( java.lang.String ) ; if ( org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler.StompConnectionHandler != null ) { org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler.StompConnectionHandler . void ( STRING ) ; org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler.StompConnectionHandler . void ( ) ; } else { StompHeaderAccessor org.springframework.messaging.simp.stomp.StompHeaderAccessor = StompHeaderAccessor . create ( StompCommand . ERROR ) ; if ( org.springframework.messaging.simp.stomp.MessageHeaderInitializer ( ) != null ) { org.springframework.messaging.simp.stomp.MessageHeaderInitializer ( ) . initHeaders ( org.springframework.messaging.simp.stomp.StompHeaderAccessor ) ; } org.springframework.messaging.simp.stomp.StompHeaderAccessor . setSessionId ( java.lang.String ) ; org.springframework.messaging.simp.stomp.StompHeaderAccessor . setUser ( SimpMessageHeaderAccessor . getUser ( org.springframework.messaging.simp.stomp.Message<> . getHeaders ( ) ) ) ; org.springframework.messaging.simp.stomp.StompHeaderAccessor . setMessage ( STRING ) ; MessageHeaders org.springframework.messaging.simp.stomp.MessageHeaders = org.springframework.messaging.simp.stomp.StompHeaderAccessor . getMessageHeaders ( ) ; getClientOutboundChannel ( ) . send ( MessageBuilder . createMessage ( byte[] , org.springframework.messaging.simp.stomp.MessageHeaders ) ) ; } return; } StompHeaderAccessor org.springframework.messaging.simp.stomp.StompHeaderAccessor ; StompCommand org.springframework.messaging.simp.stomp.StompCommand ; MessageHeaderAccessor org.springframework.messaging.simp.stomp.MessageHeaderAccessor = MessageHeaderAccessor . getAccessor ( org.springframework.messaging.simp.stomp.Message<> , MessageHeaderAccessor .class ) ; if ( org.springframework.messaging.simp.stomp.MessageHeaderAccessor == null ) { throw new java.lang.IllegalStateException ( STRING + org.springframework.messaging.simp.stomp.Message<> ) ; } else if ( org.springframework.messaging.simp.stomp.MessageHeaderAccessor instanceof StompHeaderAccessor ) { org.springframework.messaging.simp.stomp.StompHeaderAccessor = ( StompHeaderAccessor ) org.springframework.messaging.simp.stomp.MessageHeaderAccessor ; org.springframework.messaging.simp.stomp.StompCommand = org.springframework.messaging.simp.stomp.StompHeaderAccessor . getCommand ( ) ; } else if ( org.springframework.messaging.simp.stomp.MessageHeaderAccessor instanceof SimpMessageHeaderAccessor ) { org.springframework.messaging.simp.stomp.StompHeaderAccessor = StompHeaderAccessor . wrap ( org.springframework.messaging.simp.stomp.Message<> ) ; org.springframework.messaging.simp.stomp.StompCommand = org.springframework.messaging.simp.stomp.StompHeaderAccessor . getCommand ( ) ; if ( org.springframework.messaging.simp.stomp.StompCommand == null ) { org.springframework.messaging.simp.stomp.StompCommand = org.springframework.messaging.simp.stomp.StompHeaderAccessor . updateStompCommandAsClientMessage ( ) ; } } else { throw new java.lang.IllegalStateException ( STRING + org.springframework.messaging.simp.stomp.MessageHeaderAccessor . getClass ( ) + STRING + org.springframework.messaging.simp.stomp.Message<> ) ; } if ( java.lang.String == null ) { if ( ! SimpMessageType . MESSAGE . equals ( org.springframework.messaging.simp.stomp.StompHeaderAccessor . getMessageType ( ) ) ) { if ( logger . isErrorEnabled ( ) ) { logger . error ( STRING + org.springframework.messaging.simp.stomp.Message<> ) ; } return; } java.lang.String = java.lang.String ; org.springframework.messaging.simp.stomp.StompHeaderAccessor . setSessionId ( java.lang.String ) ; } java.lang.String java.lang.String = org.springframework.messaging.simp.stomp.StompHeaderAccessor . getDestination ( ) ; if ( org.springframework.messaging.simp.stomp.StompCommand != null && org.springframework.messaging.simp.stomp.StompCommand . requiresDestination ( ) && ! checkDestinationPrefix ( java.lang.String ) ) { return; } if ( StompCommand . CONNECT . equals ( org.springframework.messaging.simp.stomp.StompCommand ) ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( org.springframework.messaging.simp.stomp.StompHeaderAccessor . getShortLogMessage ( byte[] ) ) ; } org.springframework.messaging.simp.stomp.StompHeaderAccessor = ( org.springframework.messaging.simp.stomp.StompHeaderAccessor . isMutable ( ) ? org.springframework.messaging.simp.stomp.StompHeaderAccessor : StompHeaderAccessor . wrap ( org.springframework.messaging.simp.stomp.Message<> ) ) ; org.springframework.messaging.simp.stomp.StompHeaderAccessor . setLogin ( this . java.lang.String ) ; org.springframework.messaging.simp.stomp.StompHeaderAccessor . setPasscode ( this . java.lang.String ) ; if ( java.lang.String ( ) != null ) { org.springframework.messaging.simp.stomp.StompHeaderAccessor . setHost ( java.lang.String ( ) ) ; } org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler.StompConnectionHandler org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler.StompConnectionHandler = new org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler.StompConnectionHandler ( java.lang.String , org.springframework.messaging.simp.stomp.StompHeaderAccessor ) ; this . java.util.Map<java.lang.String,org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler.StompConnectionHandler> . org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler.StompConnectionHandler ( java.lang.String , org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler.StompConnectionHandler ) ; this . org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler.Stats . void ( ) ; this . org.springframework.messaging.simp.stomp.TcpOperations<byte[]> . connect ( org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler.StompConnectionHandler ) ; } else if ( StompCommand . DISCONNECT . equals ( org.springframework.messaging.simp.stomp.StompCommand ) ) { org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler.StompConnectionHandler org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler.StompConnectionHandler = this . java.util.Map<java.lang.String,org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler.StompConnectionHandler> . org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler.StompConnectionHandler ( java.lang.String ) ; if ( org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler.StompConnectionHandler == null ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( STRING + java.lang.String + STRING ) ; } return; } org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler.Stats . void ( ) ; org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler.StompConnectionHandler . org.springframework.messaging.simp.stomp.ListenableFuture<java.lang.Void> ( org.springframework.messaging.simp.stomp.Message<> , org.springframework.messaging.simp.stomp.StompHeaderAccessor ) ; } else { org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler.StompConnectionHandler org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler.StompConnectionHandler = this . java.util.Map<java.lang.String,org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler.StompConnectionHandler> . org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler.StompConnectionHandler ( java.lang.String ) ; if ( org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler.StompConnectionHandler == null ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( STRING + java.lang.String + STRING + org.springframework.messaging.simp.stomp.Message<> ) ; } return; } org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler.StompConnectionHandler . org.springframework.messaging.simp.stomp.ListenableFuture<java.lang.Void> ( org.springframework.messaging.simp.stomp.Message<> , org.springframework.messaging.simp.stomp.StompHeaderAccessor ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.String java.lang.String ( ) { return STRING + this . java.lang.String + STRING + this . int + STRING ; }  <METHOD_END>
<METHOD_START> private void ( java.lang.String java.lang.String , StompHeaderAccessor org.springframework.messaging.simp.stomp.StompHeaderAccessor ) { this( java.lang.String , org.springframework.messaging.simp.stomp.StompHeaderAccessor , true ); }  <METHOD_END>
<METHOD_START> private void ( java.lang.String java.lang.String , StompHeaderAccessor org.springframework.messaging.simp.stomp.StompHeaderAccessor , boolean boolean ) { Assert . notNull ( java.lang.String , STRING ) ; Assert . notNull ( org.springframework.messaging.simp.stomp.StompHeaderAccessor , STRING ) ; this . java.lang.String = java.lang.String ; this . org.springframework.messaging.simp.stomp.StompHeaderAccessor = org.springframework.messaging.simp.stomp.StompHeaderAccessor ; this . boolean = boolean ; }  <METHOD_END>
<METHOD_START> public java.lang.String java.lang.String ( ) { return this . java.lang.String ; }  <METHOD_END>
<METHOD_START> protected org.springframework.messaging.simp.stomp.TcpConnection<byte[]> < byte [] > org.springframework.messaging.simp.stomp.TcpConnection<byte[]> ( ) { return this . org.springframework.messaging.simp.stomp.TcpConnection<byte[]> ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( TcpConnection < byte [] > org.springframework.messaging.simp.stomp.TcpConnection<byte[]> ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( STRING + java.lang.String ( ) ) ; } this . org.springframework.messaging.simp.stomp.TcpConnection<byte[]> = org.springframework.messaging.simp.stomp.TcpConnection<byte[]> ; this . org.springframework.messaging.simp.stomp.TcpConnection<byte[]> . onReadInactivity ( new java.lang.Runnable ( ) { @ java.lang.Override public void void ( ) { if ( org.springframework.messaging.simp.stomp.TcpConnection<byte[]> != null && ! boolean ) { void ( STRING + int + STRING , null ) ; } } } , int ) ; org.springframework.messaging.simp.stomp.TcpConnection<byte[]> . send ( MessageBuilder . createMessage ( byte[] , this . org.springframework.messaging.simp.stomp.StompHeaderAccessor . getMessageHeaders ( ) ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ) { if ( org.springframework.messaging.simp.stomp.TcpConnection<byte[]> != null && ! boolean ) { void ( STRING + int + STRING , null ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( java.lang.Throwable java.lang.Throwable ) { void ( STRING + java.lang.Throwable . java.lang.String ( ) , java.lang.Throwable ) ; }  <METHOD_END>
<METHOD_START> protected void void ( java.lang.String java.lang.String , java.lang.Throwable java.lang.Throwable ) { if ( logger . isErrorEnabled ( ) ) { logger . error ( STRING + this . java.lang.String + STRING + java.lang.String , java.lang.Throwable ) ; } try { void ( java.lang.String ) ; } finally { try { void ( ) ; } catch ( java.lang.Throwable java.lang.Throwable ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( STRING + this . java.lang.String , java.lang.Throwable ) ; } } } }  <METHOD_END>
<METHOD_START> private void void ( java.lang.String java.lang.String ) { if ( this . boolean ) { StompHeaderAccessor org.springframework.messaging.simp.stomp.StompHeaderAccessor = StompHeaderAccessor . create ( StompCommand . ERROR ) ; if ( org.springframework.messaging.simp.stomp.MessageHeaderInitializer ( ) != null ) { org.springframework.messaging.simp.stomp.MessageHeaderInitializer ( ) . initHeaders ( org.springframework.messaging.simp.stomp.StompHeaderAccessor ) ; } org.springframework.messaging.simp.stomp.StompHeaderAccessor . setSessionId ( this . java.lang.String ) ; org.springframework.messaging.simp.stomp.StompHeaderAccessor . setUser ( this . org.springframework.messaging.simp.stomp.StompHeaderAccessor . getUser ( ) ) ; org.springframework.messaging.simp.stomp.StompHeaderAccessor . setMessage ( java.lang.String ) ; Message < ? > org.springframework.messaging.simp.stomp.Message<?> = MessageBuilder . createMessage ( byte[] , org.springframework.messaging.simp.stomp.StompHeaderAccessor . getMessageHeaders ( ) ) ; void ( org.springframework.messaging.simp.stomp.Message<> ) ; } }  <METHOD_END>
<METHOD_START> protected void void ( Message < ? > org.springframework.messaging.simp.stomp.Message<?> ) { if ( this . boolean ) { StompHeaderAccessor org.springframework.messaging.simp.stomp.StompHeaderAccessor = MessageHeaderAccessor . getAccessor ( org.springframework.messaging.simp.stomp.Message<> , StompHeaderAccessor .class ) ; org.springframework.messaging.simp.stomp.StompHeaderAccessor . setImmutable ( ) ; org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler .this . getClientOutboundChannel ( ) . send ( org.springframework.messaging.simp.stomp.Message<> ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( Message < byte [] > org.springframework.messaging.simp.stomp.Message<byte[]> ) { StompHeaderAccessor org.springframework.messaging.simp.stomp.StompHeaderAccessor = MessageHeaderAccessor . getAccessor ( org.springframework.messaging.simp.stomp.Message<byte[]> , StompHeaderAccessor .class ) ; org.springframework.messaging.simp.stomp.StompHeaderAccessor . setSessionId ( this . java.lang.String ) ; org.springframework.messaging.simp.stomp.StompHeaderAccessor . setUser ( this . org.springframework.messaging.simp.stomp.StompHeaderAccessor . getUser ( ) ) ; StompCommand org.springframework.messaging.simp.stomp.StompCommand = org.springframework.messaging.simp.stomp.StompHeaderAccessor . getCommand ( ) ; if ( StompCommand . CONNECTED . equals ( org.springframework.messaging.simp.stomp.StompCommand ) ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( STRING + org.springframework.messaging.simp.stomp.StompHeaderAccessor . getShortLogMessage ( byte[] ) ) ; } void ( org.springframework.messaging.simp.stomp.StompHeaderAccessor ) ; } else if ( logger . isErrorEnabled ( ) && StompCommand . ERROR . equals ( org.springframework.messaging.simp.stomp.StompCommand ) ) { logger . error ( STRING + org.springframework.messaging.simp.stomp.StompHeaderAccessor . getShortLogMessage ( org.springframework.messaging.simp.stomp.Message<byte[]> . getPayload ( ) ) ) ; } else if ( logger . isTraceEnabled ( ) ) { logger . trace ( STRING + org.springframework.messaging.simp.stomp.StompHeaderAccessor . getDetailedLogMessage ( org.springframework.messaging.simp.stomp.Message<byte[]> . getPayload ( ) ) ) ; } void ( org.springframework.messaging.simp.stomp.Message<byte[]> ) ; }  <METHOD_END>
<METHOD_START> protected void void ( StompHeaderAccessor org.springframework.messaging.simp.stomp.StompHeaderAccessor ) { this . boolean = true ; org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler.Stats . void ( ) ; void ( org.springframework.messaging.simp.stomp.StompHeaderAccessor ) ; }  <METHOD_END>
<METHOD_START> private void void ( StompHeaderAccessor org.springframework.messaging.simp.stomp.StompHeaderAccessor ) { if ( this . boolean ) { return; } long long = this . org.springframework.messaging.simp.stomp.StompHeaderAccessor . getHeartbeat ( ) [ NUMBER ] ; long long = this . org.springframework.messaging.simp.stomp.StompHeaderAccessor . getHeartbeat ( ) [ NUMBER ] ; long long = org.springframework.messaging.simp.stomp.StompHeaderAccessor . getHeartbeat ( ) [ NUMBER ] ; long long = org.springframework.messaging.simp.stomp.StompHeaderAccessor . getHeartbeat ( ) [ NUMBER ] ; if ( long > NUMBER && long > NUMBER ) { long long = java.lang.Math . long ( long , long ) ; this . org.springframework.messaging.simp.stomp.TcpConnection<byte[]> . onWriteInactivity ( new java.lang.Runnable ( ) { @ java.lang.Override public void void ( ) { TcpConnection < byte [] > org.springframework.messaging.simp.stomp.TcpConnection<byte[]> = org.springframework.messaging.simp.stomp.TcpConnection<byte[]> ; if ( org.springframework.messaging.simp.stomp.TcpConnection<byte[]> != null ) { org.springframework.messaging.simp.stomp.TcpConnection<byte[]> . send ( org.springframework.messaging.simp.stomp.Message<byte[]> ) . addCallback ( new ListenableFutureCallback < java.lang.Void > ( ) { public void void ( java.lang.Void java.lang.Void ) {										} public void void ( java.lang.Throwable java.lang.Throwable ) { void ( STRING + java.lang.Throwable . java.lang.String ( ) , java.lang.Throwable ) ; } } ) ; } } } , long ) ; } if ( long > NUMBER && long > NUMBER ) { final long long = java.lang.Math . long ( long , long ) * long ; this . org.springframework.messaging.simp.stomp.TcpConnection<byte[]> . onReadInactivity ( new java.lang.Runnable ( ) { @ java.lang.Override public void void ( ) { void ( STRING + long + STRING , null ) ; } } , long ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ) { TcpConnection < byte [] > org.springframework.messaging.simp.stomp.TcpConnection<byte[]> = org.springframework.messaging.simp.stomp.TcpConnection<byte[]> ; if ( org.springframework.messaging.simp.stomp.TcpConnection<byte[]> != null ) { org.springframework.messaging.simp.stomp.TcpConnection<byte[]> . send ( org.springframework.messaging.simp.stomp.Message<byte[]> ) . addCallback ( new ListenableFutureCallback < java.lang.Void > ( ) { public void void ( java.lang.Void java.lang.Void ) {										} public void void ( java.lang.Throwable java.lang.Throwable ) { void ( STRING + java.lang.Throwable . java.lang.String ( ) , java.lang.Throwable ) ; } } ) ; } }  <METHOD_END>
<METHOD_START> public void void ( java.lang.Void java.lang.Void ) {										}  <METHOD_END>
<METHOD_START> public void void ( java.lang.Throwable java.lang.Throwable ) { void ( STRING + java.lang.Throwable . java.lang.String ( ) , java.lang.Throwable ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ) { void ( STRING + long + STRING , null ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( java.lang.Throwable java.lang.Throwable ) { if ( this . org.springframework.messaging.simp.stomp.TcpConnection<byte[]> != null ) { void ( STRING + java.lang.Throwable . java.lang.String ( ) , java.lang.Throwable ) ; } else if ( logger . isErrorEnabled ( ) ) { logger . error ( STRING + java.lang.Throwable ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ) { if ( this . org.springframework.messaging.simp.stomp.TcpConnection<byte[]> == null ) { return; } try { if ( logger . isDebugEnabled ( ) ) { logger . debug ( STRING + this . java.lang.String ) ; } void ( STRING ) ; } finally { try { this . org.springframework.messaging.simp.stomp.TcpConnection<byte[]> = null ; void ( ) ; } catch ( java.lang.Throwable java.lang.Throwable ) { } } }  <METHOD_END>
<METHOD_START> @ java.lang.SuppressWarnings ( STRING ) public org.springframework.messaging.simp.stomp.ListenableFuture<java.lang.Void> < java.lang.Void > org.springframework.messaging.simp.stomp.ListenableFuture<java.lang.Void> ( final Message < ? > org.springframework.messaging.simp.stomp.Message<?> , final StompHeaderAccessor org.springframework.messaging.simp.stomp.StompHeaderAccessor ) { TcpConnection < byte [] > org.springframework.messaging.simp.stomp.TcpConnection<byte[]> = this . org.springframework.messaging.simp.stomp.TcpConnection<byte[]> ; if ( ! this . boolean || org.springframework.messaging.simp.stomp.TcpConnection<byte[]> == null ) { if ( this . boolean ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( STRING + org.springframework.messaging.simp.stomp.StompHeaderAccessor . getShortLogMessage ( org.springframework.messaging.simp.stomp.Message<> . getPayload ( ) ) ) ; } return org.springframework.messaging.simp.stomp.ListenableFutureTask<java.lang.Void> ; } else { throw new java.lang.IllegalStateException ( STRING + ( org.springframework.messaging.simp.stomp.TcpConnection<byte[]> != null ? STRING : STRING ) + STRING + STRING + org.springframework.messaging.simp.stomp.StompHeaderAccessor . getShortLogMessage ( org.springframework.messaging.simp.stomp.Message<> . getPayload ( ) ) ) ; } } final Message < ? > org.springframework.messaging.simp.stomp.Message<?> = ( org.springframework.messaging.simp.stomp.StompHeaderAccessor . isMutable ( ) && org.springframework.messaging.simp.stomp.StompHeaderAccessor . isModified ( ) ) ? MessageBuilder . createMessage ( org.springframework.messaging.simp.stomp.Message<> . getPayload ( ) , org.springframework.messaging.simp.stomp.StompHeaderAccessor . getMessageHeaders ( ) ) : org.springframework.messaging.simp.stomp.Message<> ; StompCommand org.springframework.messaging.simp.stomp.StompCommand = org.springframework.messaging.simp.stomp.StompHeaderAccessor . getCommand ( ) ; if ( logger . isDebugEnabled ( ) && ( StompCommand . SEND . equals ( org.springframework.messaging.simp.stomp.StompCommand ) || StompCommand . SUBSCRIBE . equals ( org.springframework.messaging.simp.stomp.StompCommand ) || StompCommand . UNSUBSCRIBE . equals ( org.springframework.messaging.simp.stomp.StompCommand ) || StompCommand . DISCONNECT . equals ( org.springframework.messaging.simp.stomp.StompCommand ) ) ) { logger . debug ( STRING + org.springframework.messaging.simp.stomp.StompHeaderAccessor . getShortLogMessage ( org.springframework.messaging.simp.stomp.Message<> . getPayload ( ) ) ) ; } else if ( logger . isTraceEnabled ( ) ) { logger . trace ( STRING + org.springframework.messaging.simp.stomp.StompHeaderAccessor . getDetailedLogMessage ( org.springframework.messaging.simp.stomp.Message<> . getPayload ( ) ) ) ; } ListenableFuture < java.lang.Void > org.springframework.messaging.simp.stomp.ListenableFuture<java.lang.Void> = org.springframework.messaging.simp.stomp.TcpConnection<byte[]> . send ( ( Message < byte [] > ) org.springframework.messaging.simp.stomp.Message<> ) ; org.springframework.messaging.simp.stomp.ListenableFuture<java.lang.Void> . addCallback ( new ListenableFutureCallback < java.lang.Void > ( ) { @ java.lang.Override public void void ( java.lang.Void java.lang.Void ) { if ( org.springframework.messaging.simp.stomp.StompHeaderAccessor . getCommand ( ) == StompCommand . DISCONNECT ) { void ( org.springframework.messaging.simp.stomp.StompHeaderAccessor ) ; } } @ java.lang.Override public void void ( java.lang.Throwable java.lang.Throwable ) { if ( org.springframework.messaging.simp.stomp.TcpConnection<byte[]> != null ) { void ( STRING + org.springframework.messaging.simp.stomp.StompHeaderAccessor . getShortLogMessage ( org.springframework.messaging.simp.stomp.Message<> . getPayload ( ) ) , java.lang.Throwable ) ; } else if ( logger . isErrorEnabled ( ) ) { logger . error ( STRING + org.springframework.messaging.simp.stomp.StompHeaderAccessor . getShortLogMessage ( org.springframework.messaging.simp.stomp.Message<> . getPayload ( ) ) ) ; } } } ) ; return org.springframework.messaging.simp.stomp.ListenableFuture<java.lang.Void> ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( java.lang.Void java.lang.Void ) { if ( org.springframework.messaging.simp.stomp.StompHeaderAccessor . getCommand ( ) == StompCommand . DISCONNECT ) { void ( org.springframework.messaging.simp.stomp.StompHeaderAccessor ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( java.lang.Throwable java.lang.Throwable ) { if ( org.springframework.messaging.simp.stomp.TcpConnection<byte[]> != null ) { void ( STRING + org.springframework.messaging.simp.stomp.StompHeaderAccessor . getShortLogMessage ( org.springframework.messaging.simp.stomp.Message<> . getPayload ( ) ) , java.lang.Throwable ) ; } else if ( logger . isErrorEnabled ( ) ) { logger . error ( STRING + org.springframework.messaging.simp.stomp.StompHeaderAccessor . getShortLogMessage ( org.springframework.messaging.simp.stomp.Message<> . getPayload ( ) ) ) ; } }  <METHOD_END>
<METHOD_START> private void void ( StompHeaderAccessor org.springframework.messaging.simp.stomp.StompHeaderAccessor ) { if ( org.springframework.messaging.simp.stomp.StompHeaderAccessor . getReceipt ( ) == null ) { try { void ( ) ; } catch ( java.lang.Throwable java.lang.Throwable ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( STRING + this . java.lang.String , java.lang.Throwable ) ; } } } }  <METHOD_END>
<METHOD_START> public void void ( ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( STRING + this . java.lang.String ) ; } if ( this . boolean ) { org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler .this . java.util.Map<java.lang.String,org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler.StompConnectionHandler> . org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler.StompConnectionHandler ( this . java.lang.String ) ; } this . boolean = false ; TcpConnection < byte [] > org.springframework.messaging.simp.stomp.TcpConnection<byte[]> = this . org.springframework.messaging.simp.stomp.TcpConnection<byte[]> ; this . org.springframework.messaging.simp.stomp.TcpConnection<byte[]> = null ; if ( org.springframework.messaging.simp.stomp.TcpConnection<byte[]> != null ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( STRING + this . java.lang.String ) ; } org.springframework.messaging.simp.stomp.TcpConnection<byte[]> . close ( ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.String java.lang.String ( ) { return STRING + this . java.lang.String + STRING ; }  <METHOD_END>
<METHOD_START> public void ( StompHeaderAccessor org.springframework.messaging.simp.stomp.StompHeaderAccessor ) { super( java.lang.String , org.springframework.messaging.simp.stomp.StompHeaderAccessor , false ); }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( StompHeaderAccessor org.springframework.messaging.simp.stomp.StompHeaderAccessor ) { if ( logger . isInfoEnabled ( ) ) { logger . info ( STRING ) ; } super. void ( org.springframework.messaging.simp.stomp.StompHeaderAccessor ) ; publishBrokerAvailableEvent ( ) ; void ( ) ; }  <METHOD_END>
<METHOD_START> private void void ( ) { int int = NUMBER ; for ( java.lang.String java.lang.String : java.util.Map<java.lang.String,org.springframework.messaging.simp.stomp.MessageHandler> ( ) . keySet ( ) ) { StompHeaderAccessor org.springframework.messaging.simp.stomp.StompHeaderAccessor = StompHeaderAccessor . create ( StompCommand . SUBSCRIBE ) ; org.springframework.messaging.simp.stomp.StompHeaderAccessor . setSubscriptionId ( java.lang.String . java.lang.String ( int ++ ) ) ; org.springframework.messaging.simp.stomp.StompHeaderAccessor . setDestination ( java.lang.String ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( STRING + java.lang.String + STRING ) ; } TcpConnection < byte [] > org.springframework.messaging.simp.stomp.TcpConnection<byte[]> = org.springframework.messaging.simp.stomp.TcpConnection<byte[]> ( ) ; if ( org.springframework.messaging.simp.stomp.TcpConnection<byte[]> != null ) { MessageHeaders org.springframework.messaging.simp.stomp.MessageHeaders = org.springframework.messaging.simp.stomp.StompHeaderAccessor . getMessageHeaders ( ) ; org.springframework.messaging.simp.stomp.TcpConnection<byte[]> . send ( MessageBuilder . createMessage ( byte[] , org.springframework.messaging.simp.stomp.MessageHeaders ) ) . addCallback ( new ListenableFutureCallback < java.lang.Void > ( ) { public void void ( java.lang.Void java.lang.Void ) {								} public void void ( java.lang.Throwable java.lang.Throwable ) { java.lang.String java.lang.String = STRING ; void ( java.lang.String , java.lang.Throwable ) ; } } ) ; } } }  <METHOD_END>
<METHOD_START> public void void ( java.lang.Void java.lang.Void ) {								}  <METHOD_END>
<METHOD_START> public void void ( java.lang.Throwable java.lang.Throwable ) { java.lang.String java.lang.String = STRING ; void ( java.lang.String , java.lang.Throwable ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( Message < ? > org.springframework.messaging.simp.stomp.Message<?> ) { StompHeaderAccessor org.springframework.messaging.simp.stomp.StompHeaderAccessor = MessageHeaderAccessor . getAccessor ( org.springframework.messaging.simp.stomp.Message<> , StompHeaderAccessor .class ) ; if ( StompCommand . MESSAGE . equals ( org.springframework.messaging.simp.stomp.StompHeaderAccessor . getCommand ( ) ) ) { java.lang.String java.lang.String = org.springframework.messaging.simp.stomp.StompHeaderAccessor . getDestination ( ) ; if ( java.lang.String == null ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( STRING + org.springframework.messaging.simp.stomp.StompHeaderAccessor . getDetailedLogMessage ( org.springframework.messaging.simp.stomp.Message<> . getPayload ( ) ) ) ; } return; } if ( ! java.util.Map<java.lang.String,org.springframework.messaging.simp.stomp.MessageHandler> ( ) . containsKey ( java.lang.String ) ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( STRING + org.springframework.messaging.simp.stomp.StompHeaderAccessor . getDetailedLogMessage ( org.springframework.messaging.simp.stomp.Message<> . getPayload ( ) ) ) ; } return; } try { MessageHandler org.springframework.messaging.simp.stomp.MessageHandler = java.util.Map<java.lang.String,org.springframework.messaging.simp.stomp.MessageHandler> ( ) . get ( java.lang.String ) ; org.springframework.messaging.simp.stomp.MessageHandler . handleMessage ( org.springframework.messaging.simp.stomp.Message<> ) ; } catch ( java.lang.Throwable java.lang.Throwable ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( STRING , java.lang.Throwable ) ; } } } }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( java.lang.String java.lang.String , java.lang.Throwable java.lang.Throwable ) { super. void ( java.lang.String , java.lang.Throwable ) ; publishBrokerUnavailableEvent ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ) { super. void ( ) ; publishBrokerUnavailableEvent ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.messaging.simp.stomp.ListenableFuture<java.lang.Void> < java.lang.Void > org.springframework.messaging.simp.stomp.ListenableFuture<java.lang.Void> ( Message < ? > org.springframework.messaging.simp.stomp.Message<?> , StompHeaderAccessor org.springframework.messaging.simp.stomp.StompHeaderAccessor ) { try { ListenableFuture < java.lang.Void > org.springframework.messaging.simp.stomp.ListenableFuture<java.lang.Void> = super. org.springframework.messaging.simp.stomp.ListenableFuture<java.lang.Void> ( org.springframework.messaging.simp.stomp.Message<> , org.springframework.messaging.simp.stomp.StompHeaderAccessor ) ; if ( org.springframework.messaging.simp.stomp.Message<> . getHeaders ( ) . get ( SimpMessageHeaderAccessor . IGNORE_ERROR ) == null ) { org.springframework.messaging.simp.stomp.ListenableFuture<java.lang.Void> . get ( ) ; } return org.springframework.messaging.simp.stomp.ListenableFuture<java.lang.Void> ; } catch ( java.lang.Throwable java.lang.Throwable ) { throw new MessageDeliveryException ( org.springframework.messaging.simp.stomp.Message<> , java.lang.Throwable ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.Void java.lang.Void ( ) java.lang.Exception { return null ; }  <METHOD_END>
<METHOD_START> public void void ( ) { this . java.util.concurrent.atomic.AtomicInteger . int ( ) ; }  <METHOD_END>
<METHOD_START> public void void ( ) { this . java.util.concurrent.atomic.AtomicInteger . int ( ) ; }  <METHOD_END>
<METHOD_START> public void void ( ) { this . java.util.concurrent.atomic.AtomicInteger . int ( ) ; }  <METHOD_END>
<METHOD_START> public java.lang.String java.lang.String ( ) { return ( java.util.Map<java.lang.String,org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler.StompConnectionHandler> . int ( ) + STRING + java.lang.String + STRING + int + ( isBrokerAvailable ( ) ? STRING : STRING ) + STRING + this . java.util.concurrent.atomic.AtomicInteger . int ( ) + STRING + this . java.util.concurrent.atomic.AtomicInteger . int ( ) + STRING + this . java.util.concurrent.atomic.AtomicInteger . int ( ) + STRING ) ; }  <METHOD_END>
