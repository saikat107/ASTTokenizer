<METHOD_START> @ Test ( expected = java.lang.IllegalArgumentException .class ) public void void ( ) { new CustomizableTraceInterceptor ( ) . setEnterMessage ( STRING ) ; }  <METHOD_END>
<METHOD_START> @ Test ( expected = java.lang.IllegalArgumentException .class ) public void void ( ) { new CustomizableTraceInterceptor ( ) . setEnterMessage ( CustomizableTraceInterceptor . PLACEHOLDER_RETURN_VALUE ) ; }  <METHOD_END>
<METHOD_START> @ Test ( expected = java.lang.IllegalArgumentException .class ) public void void ( ) { new CustomizableTraceInterceptor ( ) . setEnterMessage ( CustomizableTraceInterceptor . PLACEHOLDER_EXCEPTION ) ; }  <METHOD_END>
<METHOD_START> @ Test ( expected = java.lang.IllegalArgumentException .class ) public void void ( ) { new CustomizableTraceInterceptor ( ) . setEnterMessage ( CustomizableTraceInterceptor . PLACEHOLDER_INVOCATION_TIME ) ; }  <METHOD_END>
<METHOD_START> @ Test ( expected = java.lang.IllegalArgumentException .class ) public void void ( ) { new CustomizableTraceInterceptor ( ) . setExitMessage ( STRING ) ; }  <METHOD_END>
<METHOD_START> @ Test ( expected = java.lang.IllegalArgumentException .class ) public void void ( ) { new CustomizableTraceInterceptor ( ) . setExitMessage ( CustomizableTraceInterceptor . PLACEHOLDER_EXCEPTION ) ; }  <METHOD_END>
<METHOD_START> @ Test ( expected = java.lang.IllegalArgumentException .class ) public void void ( ) { new CustomizableTraceInterceptor ( ) . setExceptionMessage ( STRING ) ; }  <METHOD_END>
<METHOD_START> @ Test ( expected = java.lang.IllegalArgumentException .class ) public void void ( ) { new CustomizableTraceInterceptor ( ) . setExceptionMessage ( CustomizableTraceInterceptor . PLACEHOLDER_RETURN_VALUE ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Throwable { MethodInvocation org.springframework.aop.interceptor.MethodInvocation = mock ( MethodInvocation .class ) ; given ( org.springframework.aop.interceptor.MethodInvocation . getMethod ( ) ) . willReturn ( java.lang.String .class . java.lang.reflect.Method ( STRING , new java.lang.Class [] {} ) ) ; given ( org.springframework.aop.interceptor.MethodInvocation . getThis ( ) ) . willReturn ( this ) ; Log org.springframework.aop.interceptor.Log = mock ( Log .class ) ; given ( org.springframework.aop.interceptor.Log . isTraceEnabled ( ) ) . willReturn ( true ) ; CustomizableTraceInterceptor org.springframework.aop.interceptor.CustomizableTraceInterceptor = new org.springframework.aop.interceptor.CustomizableTraceInterceptorTests.StubCustomizableTraceInterceptor ( org.springframework.aop.interceptor.Log ) ; org.springframework.aop.interceptor.CustomizableTraceInterceptor . invoke ( org.springframework.aop.interceptor.MethodInvocation ) ; verify ( org.springframework.aop.interceptor.Log , times ( NUMBER ) ) . trace ( anyString ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Throwable { MethodInvocation org.springframework.aop.interceptor.MethodInvocation = mock ( MethodInvocation .class ) ; java.lang.IllegalArgumentException java.lang.IllegalArgumentException = new java.lang.IllegalArgumentException ( ) ; given ( org.springframework.aop.interceptor.MethodInvocation . getMethod ( ) ) . willReturn ( java.lang.String .class . java.lang.reflect.Method ( STRING , new java.lang.Class [] {} ) ) ; given ( org.springframework.aop.interceptor.MethodInvocation . getThis ( ) ) . willReturn ( this ) ; given ( org.springframework.aop.interceptor.MethodInvocation . proceed ( ) ) . willThrow ( java.lang.IllegalArgumentException ) ; Log org.springframework.aop.interceptor.Log = mock ( Log .class ) ; given ( org.springframework.aop.interceptor.Log . isTraceEnabled ( ) ) . willReturn ( true ) ; CustomizableTraceInterceptor org.springframework.aop.interceptor.CustomizableTraceInterceptor = new org.springframework.aop.interceptor.CustomizableTraceInterceptorTests.StubCustomizableTraceInterceptor ( org.springframework.aop.interceptor.Log ) ; try { org.springframework.aop.interceptor.CustomizableTraceInterceptor . invoke ( org.springframework.aop.interceptor.MethodInvocation ) ; fail ( STRING ) ; } catch ( java.lang.IllegalArgumentException java.lang.IllegalArgumentException ) {		} verify ( org.springframework.aop.interceptor.Log ) . trace ( anyString ( ) ) ; verify ( org.springframework.aop.interceptor.Log ) . trace ( anyString ( ) , eq ( java.lang.IllegalArgumentException ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Throwable { MethodInvocation org.springframework.aop.interceptor.MethodInvocation = mock ( MethodInvocation .class ) ; given ( org.springframework.aop.interceptor.MethodInvocation . getMethod ( ) ) . willReturn ( java.lang.String .class . java.lang.reflect.Method ( STRING , new java.lang.Class [ NUMBER ] ) ) ; given ( org.springframework.aop.interceptor.MethodInvocation . getThis ( ) ) . willReturn ( this ) ; given ( org.springframework.aop.interceptor.MethodInvocation . getArguments ( ) ) . willReturn ( new java.lang.Object [] { STRING , new java.lang.Long ( NUMBER ) } ) ; given ( org.springframework.aop.interceptor.MethodInvocation . proceed ( ) ) . willReturn ( STRING ) ; Log org.springframework.aop.interceptor.Log = mock ( Log .class ) ; given ( org.springframework.aop.interceptor.Log . isTraceEnabled ( ) ) . willReturn ( true ) ; CustomizableTraceInterceptor org.springframework.aop.interceptor.CustomizableTraceInterceptor = new org.springframework.aop.interceptor.CustomizableTraceInterceptorTests.StubCustomizableTraceInterceptor ( org.springframework.aop.interceptor.Log ) ; org.springframework.aop.interceptor.CustomizableTraceInterceptor . setEnterMessage ( new java.lang.StringBuffer ( ) . java.lang.StringBuffer ( STRING ) . java.lang.StringBuffer ( CustomizableTraceInterceptor . PLACEHOLDER_METHOD_NAME ) . append ( STRING ) . append ( CustomizableTraceInterceptor . PLACEHOLDER_TARGET_CLASS_NAME ) . append ( STRING ) . append ( CustomizableTraceInterceptor . PLACEHOLDER_ARGUMENTS ) . append ( STRING ) . append ( CustomizableTraceInterceptor . PLACEHOLDER_ARGUMENT_TYPES ) . append ( STRING ) . toString ( ) ) ; org.springframework.aop.interceptor.CustomizableTraceInterceptor . setExitMessage ( new java.lang.StringBuffer ( ) . java.lang.StringBuffer ( STRING ) . java.lang.StringBuffer ( CustomizableTraceInterceptor . PLACEHOLDER_METHOD_NAME ) . append ( STRING ) . append ( CustomizableTraceInterceptor . PLACEHOLDER_TARGET_CLASS_SHORT_NAME ) . append ( STRING ) . append ( CustomizableTraceInterceptor . PLACEHOLDER_ARGUMENTS ) . append ( STRING ) . append ( CustomizableTraceInterceptor . PLACEHOLDER_ARGUMENT_TYPES ) . append ( STRING ) . append ( CustomizableTraceInterceptor . PLACEHOLDER_RETURN_VALUE ) . append ( STRING ) . append ( CustomizableTraceInterceptor . PLACEHOLDER_INVOCATION_TIME ) . append ( STRING ) . toString ( ) ) ; org.springframework.aop.interceptor.CustomizableTraceInterceptor . invoke ( org.springframework.aop.interceptor.MethodInvocation ) ; verify ( org.springframework.aop.interceptor.Log , times ( NUMBER ) ) . trace ( anyString ( ) ) ; }  <METHOD_END>
<METHOD_START> public void ( Log org.springframework.aop.interceptor.Log ) { super. setUseDynamicLogger ( false ) ; this . org.springframework.aop.interceptor.Log = org.springframework.aop.interceptor.Log ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected org.springframework.aop.interceptor.Log org.springframework.aop.interceptor.Log ( MethodInvocation org.springframework.aop.interceptor.MethodInvocation ) { return this . org.springframework.aop.interceptor.Log ; }  <METHOD_END>
