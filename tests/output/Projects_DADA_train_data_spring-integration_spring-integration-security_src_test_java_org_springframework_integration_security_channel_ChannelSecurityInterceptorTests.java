<METHOD_START> @ After public void void ( ) { SecurityContextHolder . clearContext ( ) ; }  <METHOD_END>
<METHOD_START> @ Test ( expected = AuthenticationException .class ) public void void ( ) java.lang.Exception { MessageChannel org.springframework.integration.security.channel.MessageChannel = org.springframework.integration.security.channel.MessageChannel ( STRING ) ; org.springframework.integration.security.channel.MessageChannel . send ( new GenericMessage < java.lang.String > ( STRING ) ) ; }  <METHOD_END>
<METHOD_START> @ Test ( expected = AccessDeniedException .class ) public void void ( ) java.lang.Exception { MessageChannel org.springframework.integration.security.channel.MessageChannel = org.springframework.integration.security.channel.MessageChannel ( STRING ) ; SecurityContext org.springframework.integration.security.channel.SecurityContext = SecurityTestUtils . createContext ( STRING , STRING , STRING ) ; SecurityContextHolder . setContext ( org.springframework.integration.security.channel.SecurityContext ) ; org.springframework.integration.security.channel.MessageChannel . send ( new GenericMessage < java.lang.String > ( STRING ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { MessageChannel org.springframework.integration.security.channel.MessageChannel = org.springframework.integration.security.channel.MessageChannel ( STRING ) ; SecurityContext org.springframework.integration.security.channel.SecurityContext = SecurityTestUtils . createContext ( STRING , STRING , STRING ) ; SecurityContextHolder . setContext ( org.springframework.integration.security.channel.SecurityContext ) ; org.springframework.integration.security.channel.MessageChannel . send ( new GenericMessage < java.lang.String > ( STRING ) ) ; }  <METHOD_END>
<METHOD_START> private static org.springframework.integration.security.channel.MessageChannel org.springframework.integration.security.channel.MessageChannel ( java.lang.String java.lang.String ) throws java.lang.Exception { QueueChannel org.springframework.integration.security.channel.QueueChannel = new QueueChannel ( ) ; org.springframework.integration.security.channel.QueueChannel . setBeanName ( STRING ) ; ProxyFactory org.springframework.integration.security.channel.ProxyFactory = new ProxyFactory ( org.springframework.integration.security.channel.QueueChannel ) ; org.springframework.integration.security.channel.ProxyFactory . addAdvice ( org.springframework.integration.security.channel.ChannelSecurityInterceptor ( java.lang.String ) ) ; return ( MessageChannel ) org.springframework.integration.security.channel.ProxyFactory . getProxy ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.SuppressWarnings ( STRING ) private static org.springframework.integration.security.channel.ChannelSecurityInterceptor org.springframework.integration.security.channel.ChannelSecurityInterceptor ( java.lang.String java.lang.String ) throws java.lang.Exception { ChannelSecurityMetadataSource org.springframework.integration.security.channel.ChannelSecurityMetadataSource = new ChannelSecurityMetadataSource ( ) ; org.springframework.integration.security.channel.ChannelSecurityMetadataSource . addPatternMapping ( java.util.regex.Pattern . java.util.regex.Pattern ( STRING ) , new DefaultChannelAccessPolicy ( java.lang.String , null ) ) ; ChannelSecurityInterceptor org.springframework.integration.security.channel.ChannelSecurityInterceptor = new ChannelSecurityInterceptor ( org.springframework.integration.security.channel.ChannelSecurityMetadataSource ) ; AffirmativeBased org.springframework.integration.security.channel.AffirmativeBased = AffirmativeBased .class . java.lang.reflect.Constructor<org.springframework.integration.security.channel.AffirmativeBased> ( java.util.List .class ) . newInstance ( java.util.Collections . java.util.List ( new RoleVoter ( ) ) ) ; org.springframework.integration.security.channel.AffirmativeBased . afterPropertiesSet ( ) ; org.springframework.integration.security.channel.ChannelSecurityInterceptor . setAccessDecisionManager ( org.springframework.integration.security.channel.AffirmativeBased ) ; org.springframework.integration.security.channel.ChannelSecurityInterceptor . setAuthenticationManager ( new MockAuthenticationManager ( true ) ) ; org.springframework.integration.security.channel.ChannelSecurityInterceptor . afterPropertiesSet ( ) ; return org.springframework.integration.security.channel.ChannelSecurityInterceptor ; }  <METHOD_END>
