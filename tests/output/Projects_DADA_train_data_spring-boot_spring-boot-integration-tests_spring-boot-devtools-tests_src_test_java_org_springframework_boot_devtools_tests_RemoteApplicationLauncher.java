<METHOD_START> @ java.lang.Override public org.springframework.boot.devtools.tests.LaunchedApplication org.springframework.boot.devtools.tests.LaunchedApplication ( JvmLauncher org.springframework.boot.devtools.tests.JvmLauncher )			throws java.lang.Exception { int int = SocketUtils . findAvailableTcpPort ( ) ; LaunchedJvm org.springframework.boot.devtools.tests.LaunchedJvm = org.springframework.boot.devtools.tests.JvmLauncher . launch ( STRING , java.lang.String ( ) , STRING , STRING + int , STRING ) ; LaunchedJvm org.springframework.boot.devtools.tests.LaunchedJvm = org.springframework.boot.devtools.tests.JvmLauncher . launch ( STRING , java.lang.String ( ) , RemoteSpringApplication .class . java.lang.String ( ) , STRING , STRING + int ) ; return new LaunchedApplication ( new java.io.File ( STRING ) , org.springframework.boot.devtools.tests.LaunchedJvm . getStandardOut ( ) , org.springframework.boot.devtools.tests.LaunchedJvm . getProcess ( ) , org.springframework.boot.devtools.tests.LaunchedJvm . getProcess ( ) ) ; }  <METHOD_END>
<METHOD_START> protected abstract java.lang.String java.lang.String ( ) java.lang.Exception ;  <METHOD_END>
<METHOD_START> private java.lang.String java.lang.String ( ) java.lang.Exception { java.io.File java.io.File = new java.io.File ( STRING ) ; FileSystemUtils . deleteRecursively ( java.io.File ) ; java.io.File . boolean ( ) ; FileSystemUtils . copyRecursively ( new java.io.File ( STRING ) , new java.io.File ( STRING ) ) ; java.util.List<java.lang.String> < java.lang.String > java.util.List<java.lang.String> = new java.util.ArrayList<java.lang.String> <> ( ) ; java.util.List<java.lang.String> . boolean ( STRING ) ; for ( java.io.File java.io.File : new java.io.File ( STRING ) . java.io.File[] ( ) ) { java.util.List<java.lang.String> . boolean ( java.io.File . java.lang.String ( ) ) ; } return StringUtils . collectionToDelimitedString ( java.util.List<java.lang.String> , java.io.File . java.lang.String ) ; }  <METHOD_END>
