<METHOD_START> @ Before public void void ( ) { this . org.springframework.core.codec.ResourceRegionEncoder = new ResourceRegionEncoder ( ) ; this . bufferFactory = new DefaultDataBufferFactory ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { ResolvableType org.springframework.core.codec.ResolvableType = ResolvableType . forClass ( ResourceRegion .class ) ; MimeType org.springframework.core.codec.MimeType = MimeType . valueOf ( STRING ) ; assertFalse ( this . org.springframework.core.codec.ResourceRegionEncoder . canEncode ( ResolvableType . forClass ( Resource .class ) , MimeTypeUtils . APPLICATION_OCTET_STREAM ) ) ; assertFalse ( this . org.springframework.core.codec.ResourceRegionEncoder . canEncode ( ResolvableType . forClass ( Resource .class ) , org.springframework.core.codec.MimeType ) ) ; assertTrue ( this . org.springframework.core.codec.ResourceRegionEncoder . canEncode ( org.springframework.core.codec.ResolvableType , MimeTypeUtils . APPLICATION_OCTET_STREAM ) ) ; assertTrue ( this . org.springframework.core.codec.ResourceRegionEncoder . canEncode ( org.springframework.core.codec.ResolvableType , org.springframework.core.codec.MimeType ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { void ( new ClassPathResource ( STRING , java.lang.Class<? extends org.springframework.core.codec.ResourceRegionEncoderTests> ( ) ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.lang.String java.lang.String = STRING ; void ( new ByteArrayResource ( java.lang.String . byte[] ( java.nio.charset.StandardCharsets . java.nio.charset.Charset ) ) ) ; }  <METHOD_END>
<METHOD_START> private void void ( Resource org.springframework.core.codec.Resource ) { ResourceRegion org.springframework.core.codec.ResourceRegion = new ResourceRegion ( org.springframework.core.codec.Resource , NUMBER , NUMBER ) ; Flux < DataBuffer > org.springframework.core.codec.Flux<org.springframework.core.codec.DataBuffer> = this . org.springframework.core.codec.ResourceRegionEncoder . encode ( Mono . just ( org.springframework.core.codec.ResourceRegion ) , this . bufferFactory , ResolvableType . forClass ( ResourceRegion .class ) , MimeTypeUtils . APPLICATION_OCTET_STREAM , java.util.Collections . java.util.Map<java.lang.Object,java.lang.Object> ( ) ) ; StepVerifier . create ( org.springframework.core.codec.Flux<org.springframework.core.codec.DataBuffer> ) . consumeNextWith ( stringConsumer ( STRING ) ) . expectComplete ( ) . verify ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { void ( new ClassPathResource ( STRING , java.lang.Class<? extends org.springframework.core.codec.ResourceRegionEncoderTests> ( ) ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.lang.String java.lang.String = STRING ; void ( new ByteArrayResource ( java.lang.String . byte[] ( java.nio.charset.StandardCharsets . java.nio.charset.Charset ) ) ) ; }  <METHOD_END>
<METHOD_START> private void void ( Resource org.springframework.core.codec.Resource ) { Flux < ResourceRegion > org.springframework.core.codec.Flux<org.springframework.core.codec.ResourceRegion> = Flux . just ( new ResourceRegion ( org.springframework.core.codec.Resource , NUMBER , NUMBER ) , new ResourceRegion ( org.springframework.core.codec.Resource , NUMBER , NUMBER ) , new ResourceRegion ( org.springframework.core.codec.Resource , NUMBER , NUMBER ) , new ResourceRegion ( org.springframework.core.codec.Resource , NUMBER , NUMBER ) ) ; java.lang.String java.lang.String = MimeTypeUtils . generateMultipartBoundaryString ( ) ; Flux < DataBuffer > org.springframework.core.codec.Flux<org.springframework.core.codec.DataBuffer> = this . org.springframework.core.codec.ResourceRegionEncoder . encode ( org.springframework.core.codec.Flux<org.springframework.core.codec.ResourceRegion> , this . bufferFactory , ResolvableType . forClass ( ResourceRegion .class ) , MimeType . valueOf ( STRING ) , java.util.Collections . java.util.Map ( ResourceRegionEncoder . BOUNDARY_STRING_HINT , java.lang.String ) ) ; Mono < DataBuffer > org.springframework.core.codec.Mono<org.springframework.core.codec.DataBuffer> = org.springframework.core.codec.Flux<org.springframework.core.codec.DataBuffer> . reduce ( bufferFactory . allocateBuffer ( ) , ( previous , current ) -> { previous . write ( current ) ; DataBufferUtils . release ( current ) ; return previous ; } ) ; StepVerifier . create ( org.springframework.core.codec.Mono<org.springframework.core.codec.DataBuffer> ) . consumeNextWith ( buf -> { String content = DataBufferTestUtils . dumpString ( buf , StandardCharsets . UTF_8 ) ; String [] ranges = StringUtils . tokenizeToStringArray ( content , STRING , false , true ) ; String [] expected = new String [] { STRING + boundary , STRING , STRING , STRING , STRING + boundary , STRING , STRING , STRING , STRING + boundary , STRING , STRING , STRING , STRING + boundary , STRING , STRING , STRING , STRING + boundary + STRING } ; assertArrayEquals ( expected , ranges ) ; } ) . expectComplete ( ) . verify ( ) ; }  <METHOD_END>
