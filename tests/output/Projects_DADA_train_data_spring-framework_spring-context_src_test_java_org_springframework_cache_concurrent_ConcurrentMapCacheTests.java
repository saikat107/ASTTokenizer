<METHOD_START> @ Before public void void ( ) java.lang.Exception { this . java.util.concurrent.ConcurrentMap<java.lang.Object,java.lang.Object> = new java.util.concurrent.ConcurrentHashMap<java.lang.Object,java.lang.Object> <> ( ) ; this . org.springframework.cache.concurrent.ConcurrentMapCache = new ConcurrentMapCache ( CACHE_NAME , this . java.util.concurrent.ConcurrentMap<java.lang.Object,java.lang.Object> , true ) ; this . java.util.concurrent.ConcurrentMap<java.lang.Object,java.lang.Object> = new java.util.concurrent.ConcurrentHashMap<java.lang.Object,java.lang.Object> <> ( ) ; this . org.springframework.cache.concurrent.ConcurrentMapCache = new ConcurrentMapCache ( CACHE_NAME_NO_NULL , this . java.util.concurrent.ConcurrentMap<java.lang.Object,java.lang.Object> , false ) ; this . org.springframework.cache.concurrent.ConcurrentMapCache . clear ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected org.springframework.cache.concurrent.ConcurrentMapCache org.springframework.cache.concurrent.ConcurrentMapCache ( ) { return org.springframework.cache.concurrent.ConcurrentMapCache ( true ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected org.springframework.cache.concurrent.ConcurrentMapCache org.springframework.cache.concurrent.ConcurrentMapCache ( boolean boolean ) { return boolean ? this . org.springframework.cache.concurrent.ConcurrentMapCache : this . org.springframework.cache.concurrent.ConcurrentMapCache ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected java.util.concurrent.ConcurrentMap<java.lang.Object,java.lang.Object> < java.lang.Object , java.lang.Object > java.util.concurrent.ConcurrentMap<java.lang.Object,java.lang.Object> ( ) { return this . java.util.concurrent.ConcurrentMap<java.lang.Object,java.lang.Object> ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { assertFalse ( this . org.springframework.cache.concurrent.ConcurrentMapCache . isStoreByValue ( ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.SuppressWarnings ( STRING ) @ Test public void void ( ) { ConcurrentMapCache org.springframework.cache.concurrent.ConcurrentMapCache = org.springframework.cache.concurrent.ConcurrentMapCache ( ) ; assertTrue ( org.springframework.cache.concurrent.ConcurrentMapCache . isStoreByValue ( ) ) ; java.lang.Object java.lang.Object = createRandomKey ( ) ; java.util.List<java.lang.String> < java.lang.String > java.util.List<java.lang.String> = new java.util.ArrayList<java.lang.String> <> ( ) ; java.util.List<java.lang.String> . boolean ( java.util.Arrays . java.util.List<java.lang.String> ( STRING , STRING , STRING ) ) ; org.springframework.cache.concurrent.ConcurrentMapCache . put ( java.lang.Object , java.util.List<java.lang.String> ) ; java.util.List<java.lang.String> . java.lang.String ( NUMBER ) ; java.util.List<java.lang.String> < java.lang.String > java.util.List<java.lang.String> = ( java.util.List<java.lang.String> < java.lang.String > ) org.springframework.cache.concurrent.ConcurrentMapCache . get ( java.lang.Object ) . get ( ) ; assertEquals ( NUMBER , java.util.List<java.lang.String> . int ( ) ) ; assertEquals ( STRING , java.util.List<java.lang.String> . java.lang.String ( NUMBER ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { ConcurrentMapCache org.springframework.cache.concurrent.ConcurrentMapCache = org.springframework.cache.concurrent.ConcurrentMapCache ( ) ; this . thrown . expect ( java.lang.IllegalArgumentException .class ) ; this . thrown . expectMessage ( STRING ) ; this . thrown . expectMessage ( this . org.springframework.cache.concurrent.ConcurrentMapCache . getClass ( ) . getName ( ) ) ; org.springframework.cache.concurrent.ConcurrentMapCache . put ( createRandomKey ( ) , this . org.springframework.cache.concurrent.ConcurrentMapCache ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { ConcurrentMapCache org.springframework.cache.concurrent.ConcurrentMapCache = org.springframework.cache.concurrent.ConcurrentMapCache ( ) ; java.lang.String java.lang.String = createRandomKey ( ) ; this . java.util.concurrent.ConcurrentMap<java.lang.Object,java.lang.Object> . java.lang.Object ( java.lang.String , STRING ) ; this . thrown . expect ( java.lang.IllegalArgumentException .class ) ; this . thrown . expectMessage ( STRING ) ; this . thrown . expectMessage ( STRING ) ; org.springframework.cache.concurrent.ConcurrentMapCache . get ( java.lang.String ) ; }  <METHOD_END>
<METHOD_START> private org.springframework.cache.concurrent.ConcurrentMapCache org.springframework.cache.concurrent.ConcurrentMapCache ( ) { return new ConcurrentMapCache ( CACHE_NAME , this . java.util.concurrent.ConcurrentMap<java.lang.Object,java.lang.Object> , true , new SerializationDelegate ( org.springframework.cache.concurrent.ConcurrentMapCacheTests .class . java.lang.ClassLoader ( ) ) ) ; }  <METHOD_END>
