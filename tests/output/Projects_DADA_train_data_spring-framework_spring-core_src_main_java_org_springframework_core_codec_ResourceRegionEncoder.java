<METHOD_START> public void ( ) { this( int ); }  <METHOD_END>
<METHOD_START> public void ( int int ) { super( MimeTypeUtils . APPLICATION_OCTET_STREAM , MimeTypeUtils . ALL ); Assert . isTrue ( int > NUMBER , STRING ) ; this . int = int ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( ResolvableType org.springframework.core.codec.ResolvableType , MimeType org.springframework.core.codec.MimeType ) { return super. canEncode ( org.springframework.core.codec.ResolvableType , org.springframework.core.codec.MimeType ) && ResourceRegion .class . boolean ( org.springframework.core.codec.ResolvableType . getRawClass ( ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override @ java.lang.SuppressWarnings ( STRING ) public org.springframework.core.codec.Flux<org.springframework.core.codec.DataBuffer> < DataBuffer > org.springframework.core.codec.Flux<org.springframework.core.codec.DataBuffer> ( Publisher < ? extends ResourceRegion > org.springframework.core.codec.Publisher<? extends org.springframework.core.codec.ResourceRegion> , DataBufferFactory org.springframework.core.codec.DataBufferFactory , ResolvableType org.springframework.core.codec.ResolvableType , MimeType org.springframework.core.codec.MimeType , java.util.Map<java.lang.String,java.lang.Object> < java.lang.String , java.lang.Object > java.util.Map<java.lang.String,java.lang.Object> ) { Assert . notNull ( org.springframework.core.codec.Publisher<> , STRING ) ; Assert . notNull ( org.springframework.core.codec.DataBufferFactory , STRING ) ; Assert . notNull ( org.springframework.core.codec.ResolvableType , STRING ) ; if ( org.springframework.core.codec.Publisher<> instanceof Mono ) { return ( ( Mono < ? extends ResourceRegion > ) org.springframework.core.codec.Publisher<> ) . flatMap ( region -> writeResourceRegion ( region , bufferFactory ) ) ; } else { Assert . notNull ( java.util.Map<java.lang.String,java.lang.Object> , STRING ) ; Assert . isTrue ( java.util.Map<java.lang.String,java.lang.Object> . boolean ( java.lang.String ) , STRING ) ; final java.lang.String java.lang.String = ( java.lang.String ) java.util.Map<java.lang.String,java.lang.Object> . java.lang.Object ( java.lang.String ) ; byte [] byte[] = byte[] ( STRING + java.lang.String + STRING ) ; byte [] byte[] = byte[] ( STRING + org.springframework.core.codec.MimeType . toString ( ) + STRING ) ; Flux < DataBuffer > org.springframework.core.codec.Flux<org.springframework.core.codec.DataBuffer> = Flux . from ( org.springframework.core.codec.Publisher<> ) . concatMap ( region -> Flux . concat ( getRegionPrefix ( bufferFactory , startBoundary , contentType , region ) , writeResourceRegion ( region , bufferFactory ) ) ) ; return Flux . concat ( org.springframework.core.codec.Flux<org.springframework.core.codec.DataBuffer> , org.springframework.core.codec.Flux<org.springframework.core.codec.DataBuffer> ( org.springframework.core.codec.DataBufferFactory , java.lang.String ) ) ; } }  <METHOD_END>
<METHOD_START> private org.springframework.core.codec.Flux<org.springframework.core.codec.DataBuffer> < DataBuffer > org.springframework.core.codec.Flux<org.springframework.core.codec.DataBuffer> ( DataBufferFactory org.springframework.core.codec.DataBufferFactory , byte [] byte[] , byte [] byte[] , ResourceRegion org.springframework.core.codec.ResourceRegion ) { return Flux . just ( org.springframework.core.codec.DataBufferFactory . allocateBuffer ( byte[] . int ) . write ( byte[] ) , org.springframework.core.codec.DataBufferFactory . allocateBuffer ( byte[] . int ) . write ( byte[] ) , org.springframework.core.codec.DataBufferFactory . wrap ( java.nio.ByteBuffer . java.nio.ByteBuffer ( byte[] ( org.springframework.core.codec.ResourceRegion ) ) ) ) ; }  <METHOD_END>
<METHOD_START> private org.springframework.core.codec.Flux<org.springframework.core.codec.DataBuffer> < DataBuffer > org.springframework.core.codec.Flux<org.springframework.core.codec.DataBuffer> ( ResourceRegion org.springframework.core.codec.ResourceRegion , DataBufferFactory org.springframework.core.codec.DataBufferFactory ) { Flux < DataBuffer > org.springframework.core.codec.Flux<org.springframework.core.codec.DataBuffer> = org.springframework.core.codec.Flux<org.springframework.core.codec.DataBuffer> ( org.springframework.core.codec.ResourceRegion , org.springframework.core.codec.DataBufferFactory ) ; return DataBufferUtils . takeUntilByteCount ( org.springframework.core.codec.Flux<org.springframework.core.codec.DataBuffer> , org.springframework.core.codec.ResourceRegion . getCount ( ) ) ; }  <METHOD_END>
<METHOD_START> private org.springframework.core.codec.Flux<org.springframework.core.codec.DataBuffer> < DataBuffer > org.springframework.core.codec.Flux<org.springframework.core.codec.DataBuffer> ( ResourceRegion org.springframework.core.codec.ResourceRegion , DataBufferFactory org.springframework.core.codec.DataBufferFactory ) { Resource org.springframework.core.codec.Resource = org.springframework.core.codec.ResourceRegion . getResource ( ) ; try { if ( org.springframework.core.codec.Resource . isFile ( ) ) { java.io.File java.io.File = org.springframework.core.codec.ResourceRegion . getResource ( ) . getFile ( ) ; java.nio.channels.AsynchronousFileChannel java.nio.channels.AsynchronousFileChannel = java.nio.channels.AsynchronousFileChannel . java.nio.channels.AsynchronousFileChannel ( java.io.File . java.nio.file.Path ( ) , java.nio.file.StandardOpenOption . java.nio.file.StandardOpenOption ) ; return DataBufferUtils . read ( java.nio.channels.AsynchronousFileChannel , org.springframework.core.codec.ResourceRegion . getPosition ( ) , org.springframework.core.codec.DataBufferFactory , this . int ) ; } } catch ( java.io.IOException java.io.IOException ) { } try { java.nio.channels.ReadableByteChannel java.nio.channels.ReadableByteChannel = org.springframework.core.codec.Resource . readableChannel ( ) ; Flux < DataBuffer > org.springframework.core.codec.Flux<org.springframework.core.codec.DataBuffer> = DataBufferUtils . read ( java.nio.channels.ReadableByteChannel , org.springframework.core.codec.DataBufferFactory , this . int ) ; return DataBufferUtils . skipUntilByteCount ( org.springframework.core.codec.Flux<org.springframework.core.codec.DataBuffer> , org.springframework.core.codec.ResourceRegion . getPosition ( ) ) ; } catch ( java.io.IOException java.io.IOException ) { return Flux . error ( java.io.IOException ) ; } }  <METHOD_END>
<METHOD_START> private org.springframework.core.codec.Flux<org.springframework.core.codec.DataBuffer> < DataBuffer > org.springframework.core.codec.Flux<org.springframework.core.codec.DataBuffer> ( DataBufferFactory org.springframework.core.codec.DataBufferFactory , java.lang.String java.lang.String ) { byte [] byte[] = byte[] ( STRING + java.lang.String + STRING ) ; return Flux . just ( org.springframework.core.codec.DataBufferFactory . allocateBuffer ( byte[] . int ) . write ( byte[] ) ) ; }  <METHOD_END>
<METHOD_START> private byte [] byte[] ( java.lang.String java.lang.String ) { return java.lang.String . byte[] ( java.nio.charset.StandardCharsets . java.nio.charset.Charset ) ; }  <METHOD_END>
<METHOD_START> private byte [] byte[] ( ResourceRegion org.springframework.core.codec.ResourceRegion ) { long long = org.springframework.core.codec.ResourceRegion . getPosition ( ) ; long long = long + org.springframework.core.codec.ResourceRegion . getCount ( ) - NUMBER ; java.util.OptionalLong java.util.OptionalLong = java.util.OptionalLong ( org.springframework.core.codec.ResourceRegion . getResource ( ) ) ; if ( java.util.OptionalLong . boolean ( ) ) { return byte[] ( STRING + long + '-' + long + '/' + java.util.OptionalLong . long ( ) + STRING ) ; } else { return byte[] ( STRING + long + '-' + long + STRING ) ; } }  <METHOD_END>
<METHOD_START> private java.util.OptionalLong java.util.OptionalLong ( Resource org.springframework.core.codec.Resource ) { if ( InputStreamResource .class != org.springframework.core.codec.Resource . getClass ( ) ) { try { return java.util.OptionalLong . java.util.OptionalLong ( org.springframework.core.codec.Resource . contentLength ( ) ) ; } catch ( java.io.IOException java.io.IOException ) {			} } return java.util.OptionalLong . java.util.OptionalLong ( ) ; }  <METHOD_END>
