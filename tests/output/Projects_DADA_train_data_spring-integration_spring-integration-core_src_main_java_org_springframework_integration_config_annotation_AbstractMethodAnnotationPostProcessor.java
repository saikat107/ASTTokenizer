<METHOD_START> @ java.lang.SuppressWarnings ( STRING ) public void ( ConfigurableListableBeanFactory org.springframework.integration.config.annotation.ConfigurableListableBeanFactory ) { Assert . notNull ( org.springframework.integration.config.annotation.ConfigurableListableBeanFactory , STRING ) ; this . java.util.List<java.lang.String> . boolean ( java.lang.String ) ; this . org.springframework.integration.config.annotation.ConfigurableListableBeanFactory = org.springframework.integration.config.annotation.ConfigurableListableBeanFactory ; ConversionService org.springframework.integration.config.annotation.ConversionService = this . org.springframework.integration.config.annotation.ConfigurableListableBeanFactory . getConversionService ( ) ; if ( org.springframework.integration.config.annotation.ConversionService != null ) { this . org.springframework.integration.config.annotation.ConversionService = org.springframework.integration.config.annotation.ConversionService ; } else { this . org.springframework.integration.config.annotation.ConversionService = DefaultConversionService . getSharedInstance ( ) ; } this . org.springframework.integration.config.annotation.DestinationResolver<org.springframework.integration.config.annotation.MessageChannel> = new BeanFactoryChannelResolver ( org.springframework.integration.config.annotation.ConfigurableListableBeanFactory ) ; this . java.lang.Class<T> = ( java.lang.Class<T> < T > ) GenericTypeResolver . resolveTypeArgument ( this . java.lang.Class<? extends org.springframework.integration.config.annotation.AbstractMethodAnnotationPostProcessor> ( ) , MethodAnnotationPostProcessor .class ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.Object java.lang.Object ( java.lang.Object java.lang.Object , java.lang.String java.lang.String , java.lang.reflect.Method java.lang.reflect.Method , java.util.List<java.lang.annotation.Annotation> < java.lang.annotation.Annotation > java.util.List<java.lang.annotation.Annotation> ) { if ( this . boolean ( ) && AnnotatedElementUtils . isAnnotated ( java.lang.reflect.Method , Bean .class . java.lang.String ( ) ) ) { try { java.lang.Object ( java.lang.reflect.Method ) ; } catch ( NoSuchBeanDefinitionException org.springframework.integration.config.annotation.NoSuchBeanDefinitionException ) { if ( this . org.springframework.integration.config.annotation.Log . isDebugEnabled ( ) ) { this . org.springframework.integration.config.annotation.Log . debug ( STRING + org.springframework.integration.config.annotation.NoSuchBeanDefinitionException . getMessage ( ) + STRING ) ; } return null ; } } java.util.List<org.springframework.integration.config.annotation.Advice> < Advice > java.util.List<org.springframework.integration.config.annotation.Advice> = java.util.List<org.springframework.integration.config.annotation.Advice> ( java.lang.String , java.util.List<java.lang.annotation.Annotation> ) ; MessageHandler org.springframework.integration.config.annotation.MessageHandler = org.springframework.integration.config.annotation.MessageHandler ( java.lang.Object , java.lang.reflect.Method , java.util.List<java.lang.annotation.Annotation> ) ; if ( ! CollectionUtils . isEmpty ( java.util.List<org.springframework.integration.config.annotation.Advice> ) && org.springframework.integration.config.annotation.MessageHandler instanceof AbstractReplyProducingMessageHandler ) { ( ( AbstractReplyProducingMessageHandler ) org.springframework.integration.config.annotation.MessageHandler ) . setAdviceChain ( java.util.List<org.springframework.integration.config.annotation.Advice> ) ; } if ( org.springframework.integration.config.annotation.MessageHandler instanceof Orderable ) { Order org.springframework.integration.config.annotation.Order = AnnotationUtils . findAnnotation ( java.lang.reflect.Method , Order .class ) ; if ( org.springframework.integration.config.annotation.Order != null ) { ( ( Orderable ) org.springframework.integration.config.annotation.MessageHandler ) . setOrder ( org.springframework.integration.config.annotation.Order . value ( ) ) ; } } if ( org.springframework.integration.config.annotation.MessageHandler instanceof AbstractMessageProducingHandler || org.springframework.integration.config.annotation.MessageHandler instanceof AbstractMessageRouter ) { java.lang.String java.lang.String = MessagingAnnotationUtils . resolveAttribute ( java.util.List<java.lang.annotation.Annotation> , STRING , java.lang.String .class ) ; if ( java.lang.String != null ) { java.lang.Long java.lang.Long = java.lang.Long . java.lang.Long ( this . org.springframework.integration.config.annotation.ConfigurableListableBeanFactory . resolveEmbeddedValue ( java.lang.String ) ) ; if ( org.springframework.integration.config.annotation.MessageHandler instanceof AbstractMessageProducingHandler ) { ( ( AbstractMessageProducingHandler ) org.springframework.integration.config.annotation.MessageHandler ) . setSendTimeout ( java.lang.Long ) ; } else { ( ( AbstractMessageRouter ) org.springframework.integration.config.annotation.MessageHandler ) . setSendTimeout ( java.lang.Long ) ; } } } boolean boolean = false ; if ( this . boolean ( ) && AnnotatedElementUtils . isAnnotated ( java.lang.reflect.Method , Bean .class . java.lang.String ( ) ) ) { java.lang.Object java.lang.Object = this . java.lang.Object ( java.lang.reflect.Method ) ; boolean = java.lang.Object != null && org.springframework.integration.config.annotation.MessageHandler == java.lang.Object ; } if ( ! boolean ) { java.lang.String java.lang.String = java.lang.String ( java.lang.String , java.lang.reflect.Method ) ; this . org.springframework.integration.config.annotation.ConfigurableListableBeanFactory . registerSingleton ( java.lang.String , org.springframework.integration.config.annotation.MessageHandler ) ; org.springframework.integration.config.annotation.MessageHandler = ( MessageHandler ) this . org.springframework.integration.config.annotation.ConfigurableListableBeanFactory . initializeBean ( org.springframework.integration.config.annotation.MessageHandler , java.lang.String ) ; } if ( AnnotatedElementUtils . isAnnotated ( java.lang.reflect.Method , IdempotentReceiver .class . java.lang.String ( ) ) && ! AnnotatedElementUtils . isAnnotated ( java.lang.reflect.Method , Bean .class . java.lang.String ( ) ) ) { java.lang.String [] java.lang.String[] = AnnotationUtils . getAnnotation ( java.lang.reflect.Method , IdempotentReceiver .class ) . value ( ) ; for ( java.lang.String java.lang.String : java.lang.String[] ) { DefaultBeanFactoryPointcutAdvisor org.springframework.integration.config.annotation.DefaultBeanFactoryPointcutAdvisor = new DefaultBeanFactoryPointcutAdvisor ( ) ; org.springframework.integration.config.annotation.DefaultBeanFactoryPointcutAdvisor . setAdviceBeanName ( java.lang.String ) ; NameMatchMethodPointcut org.springframework.integration.config.annotation.NameMatchMethodPointcut = new NameMatchMethodPointcut ( ) ; org.springframework.integration.config.annotation.NameMatchMethodPointcut . setMappedName ( STRING ) ; org.springframework.integration.config.annotation.DefaultBeanFactoryPointcutAdvisor . setPointcut ( org.springframework.integration.config.annotation.NameMatchMethodPointcut ) ; org.springframework.integration.config.annotation.DefaultBeanFactoryPointcutAdvisor . setBeanFactory ( this . org.springframework.integration.config.annotation.ConfigurableListableBeanFactory ) ; if ( org.springframework.integration.config.annotation.MessageHandler instanceof Advised ) { ( ( Advised ) org.springframework.integration.config.annotation.MessageHandler ) . addAdvisor ( org.springframework.integration.config.annotation.DefaultBeanFactoryPointcutAdvisor ) ; } else { ProxyFactory org.springframework.integration.config.annotation.ProxyFactory = new ProxyFactory ( org.springframework.integration.config.annotation.MessageHandler ) ; org.springframework.integration.config.annotation.ProxyFactory . addAdvisor ( org.springframework.integration.config.annotation.DefaultBeanFactoryPointcutAdvisor ) ; org.springframework.integration.config.annotation.MessageHandler = ( MessageHandler ) org.springframework.integration.config.annotation.ProxyFactory . getProxy ( this . org.springframework.integration.config.annotation.ConfigurableListableBeanFactory . getBeanClassLoader ( ) ) ; } } } if ( ! CollectionUtils . isEmpty ( java.util.List<org.springframework.integration.config.annotation.Advice> ) ) { for ( Advice org.springframework.integration.config.annotation.Advice : java.util.List<org.springframework.integration.config.annotation.Advice> ) { if ( org.springframework.integration.config.annotation.Advice instanceof HandleMessageAdvice ) { NameMatchMethodPointcutAdvisor org.springframework.integration.config.annotation.NameMatchMethodPointcutAdvisor = new NameMatchMethodPointcutAdvisor ( org.springframework.integration.config.annotation.Advice ) ; org.springframework.integration.config.annotation.NameMatchMethodPointcutAdvisor . addMethodName ( STRING ) ; if ( org.springframework.integration.config.annotation.MessageHandler instanceof Advised ) { ( ( Advised ) org.springframework.integration.config.annotation.MessageHandler ) . addAdvisor ( org.springframework.integration.config.annotation.NameMatchMethodPointcutAdvisor ) ; } else { ProxyFactory org.springframework.integration.config.annotation.ProxyFactory = new ProxyFactory ( org.springframework.integration.config.annotation.MessageHandler ) ; org.springframework.integration.config.annotation.ProxyFactory . addAdvisor ( org.springframework.integration.config.annotation.NameMatchMethodPointcutAdvisor ) ; org.springframework.integration.config.annotation.MessageHandler = ( MessageHandler ) org.springframework.integration.config.annotation.ProxyFactory . getProxy ( this . org.springframework.integration.config.annotation.ConfigurableListableBeanFactory . getBeanClassLoader ( ) ) ; } } } } AbstractEndpoint org.springframework.integration.config.annotation.AbstractEndpoint = org.springframework.integration.config.annotation.AbstractEndpoint ( org.springframework.integration.config.annotation.MessageHandler , java.lang.reflect.Method , java.util.List<java.lang.annotation.Annotation> ) ; if ( org.springframework.integration.config.annotation.AbstractEndpoint != null ) { return org.springframework.integration.config.annotation.AbstractEndpoint ; } return org.springframework.integration.config.annotation.MessageHandler ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( java.lang.reflect.Method java.lang.reflect.Method , java.util.List<java.lang.annotation.Annotation> < java.lang.annotation.Annotation > java.util.List<java.lang.annotation.Annotation> ) { java.lang.String java.lang.String = MessagingAnnotationUtils . resolveAttribute ( java.util.List<java.lang.annotation.Annotation> , java.lang.String ( ) , java.lang.String .class ) ; boolean boolean = StringUtils . hasText ( java.lang.String ) ; if ( ! boolean && boolean ( ) ) { boolean boolean = AnnotatedElementUtils . isAnnotated ( java.lang.reflect.Method , Bean .class . java.lang.String ( ) ) ; Assert . isTrue ( ! boolean , STRING + java.lang.String ( ) + STRING + this . java.lang.Class<T> + STRING ) ; } return boolean ; }  <METHOD_END>
<METHOD_START> protected java.lang.String java.lang.String ( ) { return java.lang.String ; }  <METHOD_END>
<METHOD_START> protected boolean boolean ( ) { return true ; }  <METHOD_END>
<METHOD_START> protected java.util.List<org.springframework.integration.config.annotation.Advice> < Advice > java.util.List<org.springframework.integration.config.annotation.Advice> ( java.lang.String java.lang.String , java.util.List<java.lang.annotation.Annotation> < java.lang.annotation.Annotation > java.util.List<java.lang.annotation.Annotation> ) { java.util.List<org.springframework.integration.config.annotation.Advice> < Advice > java.util.List<org.springframework.integration.config.annotation.Advice> = null ; java.lang.String [] java.lang.String[] = MessagingAnnotationUtils . resolveAttribute ( java.util.List<java.lang.annotation.Annotation> , java.lang.String , java.lang.String [] .class ) ; if ( java.lang.String[] != null && java.lang.String[] . int > NUMBER ) { java.util.List<org.springframework.integration.config.annotation.Advice> = new java.util.ArrayList<org.springframework.integration.config.annotation.Advice> < Advice > ( ) ; for ( java.lang.String java.lang.String : java.lang.String[] ) { java.lang.Object java.lang.Object = this . org.springframework.integration.config.annotation.ConfigurableListableBeanFactory . getBean ( java.lang.String ) ; if ( java.lang.Object instanceof Advice ) { java.util.List<org.springframework.integration.config.annotation.Advice> . add ( ( Advice ) java.lang.Object ) ; } else if ( java.lang.Object instanceof Advice [] ) { java.util.Collections . boolean ( java.util.List<org.springframework.integration.config.annotation.Advice> , ( Advice [] ) java.lang.Object ) ; } else if ( java.lang.Object instanceof java.util.Collection ) { @ java.lang.SuppressWarnings ( STRING ) java.util.Collection<org.springframework.integration.config.annotation.Advice> < Advice > java.util.Collection<org.springframework.integration.config.annotation.Advice> = ( java.util.Collection<org.springframework.integration.config.annotation.Advice> < Advice > ) java.lang.Object ; for ( Advice org.springframework.integration.config.annotation.Advice : java.util.Collection<org.springframework.integration.config.annotation.Advice> ) { java.util.List<org.springframework.integration.config.annotation.Advice> . add ( org.springframework.integration.config.annotation.Advice ) ; } } else { throw new java.lang.IllegalArgumentException ( STRING + java.lang.String . java.lang.Class<? extends java.lang.String> ( ) . java.lang.String ( ) + STRING + java.lang.String + STRING ) ; } } } return java.util.List<org.springframework.integration.config.annotation.Advice> ; }  <METHOD_END>
<METHOD_START> protected org.springframework.integration.config.annotation.AbstractEndpoint org.springframework.integration.config.annotation.AbstractEndpoint ( MessageHandler org.springframework.integration.config.annotation.MessageHandler , java.lang.reflect.Method java.lang.reflect.Method , java.util.List<java.lang.annotation.Annotation> < java.lang.annotation.Annotation > java.util.List<java.lang.annotation.Annotation> ) { AbstractEndpoint org.springframework.integration.config.annotation.AbstractEndpoint = null ; java.lang.String java.lang.String = MessagingAnnotationUtils . resolveAttribute ( java.util.List<java.lang.annotation.Annotation> , java.lang.String ( ) , java.lang.String .class ) ; if ( StringUtils . hasText ( java.lang.String ) ) { MessageChannel org.springframework.integration.config.annotation.MessageChannel ; try { org.springframework.integration.config.annotation.MessageChannel = this . org.springframework.integration.config.annotation.DestinationResolver<org.springframework.integration.config.annotation.MessageChannel> . resolveDestination ( java.lang.String ) ; } catch ( DestinationResolutionException org.springframework.integration.config.annotation.DestinationResolutionException ) { if ( org.springframework.integration.config.annotation.DestinationResolutionException . getCause ( ) instanceof NoSuchBeanDefinitionException ) { org.springframework.integration.config.annotation.MessageChannel = new DirectChannel ( ) ; this . org.springframework.integration.config.annotation.ConfigurableListableBeanFactory . registerSingleton ( java.lang.String , org.springframework.integration.config.annotation.MessageChannel ) ; org.springframework.integration.config.annotation.MessageChannel = ( MessageChannel ) this . org.springframework.integration.config.annotation.ConfigurableListableBeanFactory . initializeBean ( org.springframework.integration.config.annotation.MessageChannel , java.lang.String ) ; } else { throw org.springframework.integration.config.annotation.DestinationResolutionException ; } } Assert . notNull ( org.springframework.integration.config.annotation.MessageChannel , STRING + java.lang.String + STRING ) ; org.springframework.integration.config.annotation.AbstractEndpoint = org.springframework.integration.config.annotation.AbstractEndpoint ( org.springframework.integration.config.annotation.MessageHandler , org.springframework.integration.config.annotation.MessageChannel , java.util.List<java.lang.annotation.Annotation> ) ; } return org.springframework.integration.config.annotation.AbstractEndpoint ; }  <METHOD_END>
<METHOD_START> protected org.springframework.integration.config.annotation.AbstractEndpoint org.springframework.integration.config.annotation.AbstractEndpoint ( MessageHandler org.springframework.integration.config.annotation.MessageHandler , MessageChannel org.springframework.integration.config.annotation.MessageChannel , java.util.List<java.lang.annotation.Annotation> < java.lang.annotation.Annotation > java.util.List<java.lang.annotation.Annotation> ) { AbstractEndpoint org.springframework.integration.config.annotation.AbstractEndpoint ; if ( org.springframework.integration.config.annotation.MessageChannel instanceof PollableChannel ) { PollingConsumer org.springframework.integration.config.annotation.PollingConsumer = new PollingConsumer ( ( PollableChannel ) org.springframework.integration.config.annotation.MessageChannel , org.springframework.integration.config.annotation.MessageHandler ) ; void ( org.springframework.integration.config.annotation.PollingConsumer , java.util.List<java.lang.annotation.Annotation> ) ; org.springframework.integration.config.annotation.AbstractEndpoint = org.springframework.integration.config.annotation.PollingConsumer ; } else { Poller [] org.springframework.integration.config.annotation.Poller[] = MessagingAnnotationUtils . resolveAttribute ( java.util.List<java.lang.annotation.Annotation> , STRING , Poller [] .class ) ; Assert . state ( ObjectUtils . isEmpty ( org.springframework.integration.config.annotation.Poller[] ) , STRING + STRING + org.springframework.integration.config.annotation.MessageChannel + STRING ) ; if ( org.springframework.integration.config.annotation.MessageChannel instanceof Publisher ) { org.springframework.integration.config.annotation.AbstractEndpoint = new ReactiveConsumer ( org.springframework.integration.config.annotation.MessageChannel , org.springframework.integration.config.annotation.MessageHandler ) ; } else { org.springframework.integration.config.annotation.AbstractEndpoint = new EventDrivenConsumer ( ( SubscribableChannel ) org.springframework.integration.config.annotation.MessageChannel , org.springframework.integration.config.annotation.MessageHandler ) ; } } return org.springframework.integration.config.annotation.AbstractEndpoint ; }  <METHOD_END>
<METHOD_START> protected void void ( AbstractPollingEndpoint org.springframework.integration.config.annotation.AbstractPollingEndpoint , java.util.List<java.lang.annotation.Annotation> < java.lang.annotation.Annotation > java.util.List<java.lang.annotation.Annotation> ) { PollerMetadata org.springframework.integration.config.annotation.PollerMetadata = null ; Poller [] org.springframework.integration.config.annotation.Poller[] = MessagingAnnotationUtils . resolveAttribute ( java.util.List<java.lang.annotation.Annotation> , STRING , Poller [] .class ) ; if ( ! ObjectUtils . isEmpty ( org.springframework.integration.config.annotation.Poller[] ) ) { Assert . state ( pollers . length == NUMBER , STRING ) ; Poller org.springframework.integration.config.annotation.Poller = org.springframework.integration.config.annotation.Poller[] [ NUMBER ] ; java.lang.String java.lang.String = org.springframework.integration.config.annotation.Poller . value ( ) ; java.lang.String java.lang.String = org.springframework.integration.config.annotation.Poller . trigger ( ) ; java.lang.String java.lang.String = org.springframework.integration.config.annotation.Poller . taskExecutor ( ) ; java.lang.String java.lang.String = this . org.springframework.integration.config.annotation.ConfigurableListableBeanFactory . resolveEmbeddedValue ( org.springframework.integration.config.annotation.Poller . fixedDelay ( ) ) ; java.lang.String java.lang.String = this . org.springframework.integration.config.annotation.ConfigurableListableBeanFactory . resolveEmbeddedValue ( org.springframework.integration.config.annotation.Poller . fixedRate ( ) ) ; java.lang.String java.lang.String = this . org.springframework.integration.config.annotation.ConfigurableListableBeanFactory . resolveEmbeddedValue ( org.springframework.integration.config.annotation.Poller . maxMessagesPerPoll ( ) ) ; java.lang.String java.lang.String = this . org.springframework.integration.config.annotation.ConfigurableListableBeanFactory . resolveEmbeddedValue ( org.springframework.integration.config.annotation.Poller . cron ( ) ) ; java.lang.String java.lang.String = this . org.springframework.integration.config.annotation.ConfigurableListableBeanFactory . resolveEmbeddedValue ( org.springframework.integration.config.annotation.Poller . errorChannel ( ) ) ; if ( StringUtils . hasText ( java.lang.String ) ) { Assert . state ( ! StringUtils . hasText ( java.lang.String ) && ! StringUtils . hasText ( java.lang.String ) && ! StringUtils . hasText ( java.lang.String ) && ! StringUtils . hasText ( java.lang.String ) && ! StringUtils . hasText ( java.lang.String ) && ! StringUtils . hasText ( java.lang.String ) , STRING ) ; org.springframework.integration.config.annotation.PollerMetadata = this . org.springframework.integration.config.annotation.ConfigurableListableBeanFactory . getBean ( java.lang.String , PollerMetadata .class ) ; } else { org.springframework.integration.config.annotation.PollerMetadata = new PollerMetadata ( ) ; if ( StringUtils . hasText ( java.lang.String ) ) { org.springframework.integration.config.annotation.PollerMetadata . setMaxMessagesPerPoll ( java.lang.Long . long ( java.lang.String ) ) ; } else if ( org.springframework.integration.config.annotation.AbstractPollingEndpoint instanceof SourcePollingChannelAdapter ) { org.springframework.integration.config.annotation.PollerMetadata . setMaxMessagesPerPoll ( NUMBER ) ; } if ( StringUtils . hasText ( java.lang.String ) ) { org.springframework.integration.config.annotation.PollerMetadata . setTaskExecutor ( this . org.springframework.integration.config.annotation.ConfigurableListableBeanFactory . getBean ( java.lang.String , TaskExecutor .class ) ) ; } Trigger org.springframework.integration.config.annotation.Trigger = null ; if ( StringUtils . hasText ( java.lang.String ) ) { Assert . state ( ! StringUtils . hasText ( java.lang.String ) && ! StringUtils . hasText ( java.lang.String ) && ! StringUtils . hasText ( java.lang.String ) , STRING ) ; org.springframework.integration.config.annotation.Trigger = this . org.springframework.integration.config.annotation.ConfigurableListableBeanFactory . getBean ( java.lang.String , Trigger .class ) ; } else if ( StringUtils . hasText ( java.lang.String ) ) { Assert . state ( ! StringUtils . hasText ( java.lang.String ) && ! StringUtils . hasText ( java.lang.String ) , STRING ) ; org.springframework.integration.config.annotation.Trigger = new CronTrigger ( java.lang.String ) ; } else if ( StringUtils . hasText ( java.lang.String ) ) { Assert . state ( ! StringUtils . hasText ( java.lang.String ) , STRING ) ; org.springframework.integration.config.annotation.Trigger = new PeriodicTrigger ( java.lang.Long . long ( java.lang.String ) ) ; } else if ( StringUtils . hasText ( java.lang.String ) ) { org.springframework.integration.config.annotation.Trigger = new PeriodicTrigger ( java.lang.Long . long ( java.lang.String ) ) ; ( ( PeriodicTrigger ) org.springframework.integration.config.annotation.Trigger ) . setFixedRate ( true ) ; } org.springframework.integration.config.annotation.PollerMetadata . setTrigger ( org.springframework.integration.config.annotation.Trigger ) ; if ( StringUtils . hasText ( java.lang.String ) ) { MessagePublishingErrorHandler org.springframework.integration.config.annotation.MessagePublishingErrorHandler = new MessagePublishingErrorHandler ( ) ; org.springframework.integration.config.annotation.MessagePublishingErrorHandler . setDefaultErrorChannelName ( java.lang.String ) ; org.springframework.integration.config.annotation.MessagePublishingErrorHandler . setBeanFactory ( this . org.springframework.integration.config.annotation.ConfigurableListableBeanFactory ) ; org.springframework.integration.config.annotation.PollerMetadata . setErrorHandler ( org.springframework.integration.config.annotation.MessagePublishingErrorHandler ) ; } } } else { org.springframework.integration.config.annotation.PollerMetadata = PollerMetadata . getDefaultPollerMetadata ( this . org.springframework.integration.config.annotation.ConfigurableListableBeanFactory ) ; Assert . notNull ( org.springframework.integration.config.annotation.PollerMetadata , STRING + STRING ) ; } org.springframework.integration.config.annotation.AbstractPollingEndpoint . setTaskExecutor ( org.springframework.integration.config.annotation.PollerMetadata . getTaskExecutor ( ) ) ; org.springframework.integration.config.annotation.AbstractPollingEndpoint . setTrigger ( org.springframework.integration.config.annotation.PollerMetadata . getTrigger ( ) ) ; org.springframework.integration.config.annotation.AbstractPollingEndpoint . setAdviceChain ( org.springframework.integration.config.annotation.PollerMetadata . getAdviceChain ( ) ) ; org.springframework.integration.config.annotation.AbstractPollingEndpoint . setMaxMessagesPerPoll ( org.springframework.integration.config.annotation.PollerMetadata . getMaxMessagesPerPoll ( ) ) ; org.springframework.integration.config.annotation.AbstractPollingEndpoint . setErrorHandler ( org.springframework.integration.config.annotation.PollerMetadata . getErrorHandler ( ) ) ; if ( org.springframework.integration.config.annotation.AbstractPollingEndpoint instanceof PollingConsumer ) { ( ( PollingConsumer ) org.springframework.integration.config.annotation.AbstractPollingEndpoint ) . setReceiveTimeout ( org.springframework.integration.config.annotation.PollerMetadata . getReceiveTimeout ( ) ) ; } org.springframework.integration.config.annotation.AbstractPollingEndpoint . setTransactionSynchronizationFactory ( org.springframework.integration.config.annotation.PollerMetadata . getTransactionSynchronizationFactory ( ) ) ; }  <METHOD_END>
<METHOD_START> protected java.lang.String java.lang.String ( java.lang.String java.lang.String , java.lang.reflect.Method java.lang.reflect.Method ) { java.lang.String java.lang.String = java.lang.String + STRING + java.lang.reflect.Method . java.lang.String ( ) + STRING + ClassUtils . getShortNameAsProperty ( this . java.lang.Class<T> ) ; java.lang.String java.lang.String = java.lang.String ; int int = NUMBER ; while ( this . org.springframework.integration.config.annotation.ConfigurableListableBeanFactory . containsBean ( java.lang.String ) ) { java.lang.String = java.lang.String + STRING + ( ++ int ) ; } return java.lang.String + IntegrationConfigUtils . HANDLER_ALIAS_SUFFIX ; }  <METHOD_END>
<METHOD_START> protected void void ( java.util.List<java.lang.annotation.Annotation> < java.lang.annotation.Annotation > java.util.List<java.lang.annotation.Annotation> , AbstractReplyProducingMessageHandler org.springframework.integration.config.annotation.AbstractReplyProducingMessageHandler ) { java.lang.String java.lang.String = MessagingAnnotationUtils . resolveAttribute ( java.util.List<java.lang.annotation.Annotation> , STRING , java.lang.String .class ) ; if ( StringUtils . hasText ( java.lang.String ) ) { org.springframework.integration.config.annotation.AbstractReplyProducingMessageHandler . setOutputChannelName ( java.lang.String ) ; } }  <METHOD_END>
<METHOD_START> protected java.lang.Object java.lang.Object ( java.lang.reflect.Method java.lang.reflect.Method ) { java.lang.String java.lang.String = java.lang.String ( java.lang.reflect.Method ) ; return this . org.springframework.integration.config.annotation.ConfigurableListableBeanFactory . getBean ( java.lang.String ) ; }  <METHOD_END>
<METHOD_START> protected java.lang.String java.lang.String ( java.lang.reflect.Method java.lang.reflect.Method ) { java.lang.String java.lang.String = null ; java.lang.String [] java.lang.String[] = AnnotationUtils . getAnnotation ( java.lang.reflect.Method , Bean .class ) . name ( ) ; if ( ! ObjectUtils . isEmpty ( java.lang.String[] ) ) { java.lang.String = java.lang.String[] [ NUMBER ] ; } if ( ! StringUtils . hasText ( java.lang.String ) ) { java.lang.String = java.lang.reflect.Method . java.lang.String ( ) ; } return java.lang.String ; }  <METHOD_END>
<METHOD_START> @ java.lang.SuppressWarnings ( STRING ) protected < H > H H ( java.lang.Object java.lang.Object , java.lang.Class<H> < H > java.lang.Class<H> ) { if ( java.lang.Object == null ) { return null ; } if ( java.lang.Class<H> . boolean ( java.lang.Object . java.lang.Class<? extends java.lang.Object> ( ) ) ) { return ( H ) java.lang.Object ; } if ( java.lang.Object instanceof Advised ) { TargetSource org.springframework.integration.config.annotation.TargetSource = ( ( Advised ) java.lang.Object ) . getTargetSource ( ) ; if ( org.springframework.integration.config.annotation.TargetSource == null ) { return null ; } try { return java.lang.Object ( org.springframework.integration.config.annotation.TargetSource . getTarget ( ) , java.lang.Class<H> ) ; } catch ( java.lang.Exception java.lang.Exception ) { throw new java.lang.IllegalStateException ( java.lang.Exception ) ; } } return null ; }  <METHOD_END>
<METHOD_START> protected void void ( java.lang.String java.lang.String , java.util.List<java.lang.annotation.Annotation> < java.lang.annotation.Annotation > java.util.List<java.lang.annotation.Annotation> ) { for ( java.lang.String java.lang.String : this . java.util.List<java.lang.String> ) { for ( java.lang.annotation.Annotation java.lang.annotation.Annotation : java.util.List<java.lang.annotation.Annotation> ) { java.lang.Object java.lang.Object = AnnotationUtils . getValue ( java.lang.annotation.Annotation , java.lang.String ) ; if ( MessagingAnnotationUtils . hasValue ( java.lang.Object ) ) { throw new BeanDefinitionValidationException ( STRING + java.lang.String + STRING + STRING + this . java.util.List<java.lang.String> + STRING + STRING + STRING + java.lang.String + STRING + STRING + STRING ) ; } } } }  <METHOD_END>
<METHOD_START> protected abstract org.springframework.integration.config.annotation.MessageHandler org.springframework.integration.config.annotation.MessageHandler ( java.lang.Object java.lang.Object , java.lang.reflect.Method java.lang.reflect.Method , java.util.List<java.lang.annotation.Annotation> < java.lang.annotation.Annotation > java.util.List<java.lang.annotation.Annotation> );  <METHOD_END>
