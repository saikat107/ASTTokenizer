<METHOD_START> @ Before public void void ( ) { Assume . group ( TestGroup . PERFORMANCE ) ; org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspectTests.CountingExecutor = new org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspectTests.CountingExecutor ( ) ; AnnotationAsyncExecutionAspect . aspectOf ( ) . setExecutor ( org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspectTests.CountingExecutor ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspectTests.ClassWithoutAsyncAnnotation org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspectTests.ClassWithoutAsyncAnnotation = new org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspectTests.ClassWithoutAsyncAnnotation ( ) ; org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspectTests.ClassWithoutAsyncAnnotation . void ( ) ; org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspectTests.CountingExecutor . void ( ) ; assertEquals ( NUMBER , org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspectTests.ClassWithoutAsyncAnnotation . int ) ; assertEquals ( NUMBER , org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspectTests.CountingExecutor . int ) ; assertEquals ( NUMBER , org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspectTests.CountingExecutor . int ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.InterruptedException , java.util.concurrent.ExecutionException { org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspectTests.ClassWithoutAsyncAnnotation org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspectTests.ClassWithoutAsyncAnnotation = new org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspectTests.ClassWithoutAsyncAnnotation ( ) ; java.util.concurrent.Future<java.lang.Integer> < java.lang.Integer > java.util.concurrent.Future<java.lang.Integer> = org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspectTests.ClassWithoutAsyncAnnotation . java.util.concurrent.Future<java.lang.Integer> ( ) ; assertEquals ( NUMBER , java.util.concurrent.Future<java.lang.Integer> . java.lang.Integer ( ) . int ( ) ) ; assertEquals ( NUMBER , org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspectTests.ClassWithoutAsyncAnnotation . int ) ; assertEquals ( NUMBER , org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspectTests.CountingExecutor . int ) ; assertEquals ( NUMBER , org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspectTests.CountingExecutor . int ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspectTests.ClassWithoutAsyncAnnotation org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspectTests.ClassWithoutAsyncAnnotation = new org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspectTests.ClassWithoutAsyncAnnotation ( ) ; org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspectTests.ClassWithoutAsyncAnnotation . void ( ) ; assertEquals ( NUMBER , org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspectTests.ClassWithoutAsyncAnnotation . int ) ; assertEquals ( NUMBER , org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspectTests.CountingExecutor . int ) ; assertEquals ( NUMBER , org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspectTests.CountingExecutor . int ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { Assume . group ( TestGroup . PERFORMANCE ) ; org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspectTests.ClassWithAsyncAnnotation org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspectTests.ClassWithAsyncAnnotation = new org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspectTests.ClassWithAsyncAnnotation ( ) ; org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspectTests.ClassWithAsyncAnnotation . void ( ) ; org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspectTests.CountingExecutor . void ( ) ; assertEquals ( NUMBER , org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspectTests.ClassWithAsyncAnnotation . int ) ; assertEquals ( NUMBER , org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspectTests.CountingExecutor . int ) ; assertEquals ( NUMBER , org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspectTests.CountingExecutor . int ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.InterruptedException , java.util.concurrent.ExecutionException { org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspectTests.ClassWithAsyncAnnotation org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspectTests.ClassWithAsyncAnnotation = new org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspectTests.ClassWithAsyncAnnotation ( ) ; java.util.concurrent.Future<java.lang.Integer> < java.lang.Integer > java.util.concurrent.Future<java.lang.Integer> = org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspectTests.ClassWithAsyncAnnotation . java.util.concurrent.Future<java.lang.Integer> ( ) ; assertEquals ( NUMBER , java.util.concurrent.Future<java.lang.Integer> . java.lang.Integer ( ) . int ( ) ) ; assertEquals ( NUMBER , org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspectTests.ClassWithAsyncAnnotation . int ) ; assertEquals ( NUMBER , org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspectTests.CountingExecutor . int ) ; assertEquals ( NUMBER , org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspectTests.CountingExecutor . int ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.InterruptedException , java.util.concurrent.ExecutionException { DefaultListableBeanFactory org.springframework.scheduling.aspectj.DefaultListableBeanFactory = new DefaultListableBeanFactory ( ) ; org.springframework.scheduling.aspectj.DefaultListableBeanFactory . registerBeanDefinition ( STRING , new RootBeanDefinition ( ThreadPoolTaskExecutor .class ) ) ; AnnotationAsyncExecutionAspect . aspectOf ( ) . setBeanFactory ( org.springframework.scheduling.aspectj.DefaultListableBeanFactory ) ; org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspectTests.ClassWithQualifiedAsyncMethods org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspectTests.ClassWithQualifiedAsyncMethods = new org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspectTests.ClassWithQualifiedAsyncMethods ( ) ; java.util.concurrent.Future<java.lang.Thread> < java.lang.Thread > java.util.concurrent.Future<java.lang.Thread> = org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspectTests.ClassWithQualifiedAsyncMethods . java.util.concurrent.Future<java.lang.Thread> ( ) ; assertThat ( java.util.concurrent.Future<java.lang.Thread> . java.lang.Thread ( ) , not ( java.lang.Thread . java.lang.Thread ( ) ) ) ; assertThat ( java.util.concurrent.Future<java.lang.Thread> . java.lang.Thread ( ) . java.lang.String ( ) , not ( startsWith ( STRING ) ) ) ; ListenableFuture < java.lang.Thread > org.springframework.scheduling.aspectj.ListenableFuture<java.lang.Thread> = org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspectTests.ClassWithQualifiedAsyncMethods . org.springframework.scheduling.aspectj.ListenableFuture<java.lang.Thread> ( ) ; assertThat ( org.springframework.scheduling.aspectj.ListenableFuture<java.lang.Thread> . get ( ) . getName ( ) , startsWith ( STRING ) ) ; java.util.concurrent.CompletableFuture<java.lang.Thread> < java.lang.Thread > java.util.concurrent.CompletableFuture<java.lang.Thread> = org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspectTests.ClassWithQualifiedAsyncMethods . java.util.concurrent.CompletableFuture<java.lang.Thread> ( ) ; assertThat ( java.util.concurrent.CompletableFuture<java.lang.Thread> . java.lang.Thread ( ) . java.lang.String ( ) , startsWith ( STRING ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { java.lang.reflect.Method java.lang.reflect.Method = ReflectionUtils . findMethod ( org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspectTests.ClassWithException .class , STRING ) ; TestableAsyncUncaughtExceptionHandler org.springframework.scheduling.aspectj.TestableAsyncUncaughtExceptionHandler = new TestableAsyncUncaughtExceptionHandler ( ) ; AnnotationAsyncExecutionAspect . aspectOf ( ) . setExceptionHandler ( org.springframework.scheduling.aspectj.TestableAsyncUncaughtExceptionHandler ) ; try { assertFalse ( STRING , org.springframework.scheduling.aspectj.TestableAsyncUncaughtExceptionHandler . isCalled ( ) ) ; org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspectTests.ClassWithException org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspectTests.ClassWithException = new org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspectTests.ClassWithException ( ) ; org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspectTests.ClassWithException . void ( ) ; org.springframework.scheduling.aspectj.TestableAsyncUncaughtExceptionHandler . await ( NUMBER ) ; org.springframework.scheduling.aspectj.TestableAsyncUncaughtExceptionHandler . assertCalledWith ( java.lang.reflect.Method , java.lang.UnsupportedOperationException .class ) ; } finally { AnnotationAsyncExecutionAspect . aspectOf ( ) . setExceptionHandler ( org.springframework.scheduling.aspectj.AsyncUncaughtExceptionHandler ) ; } }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { java.lang.reflect.Method java.lang.reflect.Method = ReflectionUtils . findMethod ( org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspectTests.ClassWithException .class , STRING ) ; TestableAsyncUncaughtExceptionHandler org.springframework.scheduling.aspectj.TestableAsyncUncaughtExceptionHandler = new TestableAsyncUncaughtExceptionHandler ( true ) ; AnnotationAsyncExecutionAspect . aspectOf ( ) . setExceptionHandler ( org.springframework.scheduling.aspectj.TestableAsyncUncaughtExceptionHandler ) ; try { assertFalse ( STRING , org.springframework.scheduling.aspectj.TestableAsyncUncaughtExceptionHandler . isCalled ( ) ) ; org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspectTests.ClassWithException org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspectTests.ClassWithException = new org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspectTests.ClassWithException ( ) ; try { org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspectTests.ClassWithException . void ( ) ; org.springframework.scheduling.aspectj.TestableAsyncUncaughtExceptionHandler . await ( NUMBER ) ; org.springframework.scheduling.aspectj.TestableAsyncUncaughtExceptionHandler . assertCalledWith ( java.lang.reflect.Method , java.lang.UnsupportedOperationException .class ) ; } catch ( java.lang.Exception java.lang.Exception ) { fail ( STRING + java.lang.Exception . java.lang.String ( ) ) ; } } finally { AnnotationAsyncExecutionAspect . aspectOf ( ) . setExceptionHandler ( org.springframework.scheduling.aspectj.AsyncUncaughtExceptionHandler ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public < T > java.util.concurrent.Future<T> < T > java.util.concurrent.Future<T> ( java.util.concurrent.Callable<T> < T > java.util.concurrent.Callable<T> ) { int ++ ; java.util.concurrent.Future<T> < T > java.util.concurrent.Future<T> = super. submit ( java.util.concurrent.Callable<T> ) ; int ++ ; synchronized ( this ) { void ( ) ; } return java.util.concurrent.Future<T> ; }  <METHOD_END>
<METHOD_START> public synchronized void void ( ) { try { void ( long ) ; } catch ( java.lang.InterruptedException java.lang.InterruptedException ) { fail ( STRING + long + STRING ) ; } }  <METHOD_END>
<METHOD_START> @ Async public void void ( ) { int ++ ; }  <METHOD_END>
<METHOD_START> public void void ( ) { int ++ ; }  <METHOD_END>
<METHOD_START> @ Async public java.util.concurrent.Future<java.lang.Integer> < java.lang.Integer > java.util.concurrent.Future<java.lang.Integer> ( ) { int ++ ; return new AsyncResult < java.lang.Integer > ( NUMBER ) ; }  <METHOD_END>
<METHOD_START> public void void ( ) { int ++ ; }  <METHOD_END>
<METHOD_START> public java.util.concurrent.Future<java.lang.Integer> < java.lang.Integer > java.util.concurrent.Future<java.lang.Integer> ( ) { int ++ ; return new AsyncResult < java.lang.Integer > ( NUMBER ) ; }  <METHOD_END>
<METHOD_START> @ Async public java.util.concurrent.Future<java.lang.Thread> < java.lang.Thread > java.util.concurrent.Future<java.lang.Thread> ( ) { return new AsyncResult < java.lang.Thread > ( java.lang.Thread . java.lang.Thread ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Async ( STRING ) public org.springframework.scheduling.aspectj.ListenableFuture<java.lang.Thread> < java.lang.Thread > org.springframework.scheduling.aspectj.ListenableFuture<java.lang.Thread> ( ) { return new AsyncResult < java.lang.Thread > ( java.lang.Thread . java.lang.Thread ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Async ( STRING ) public java.util.concurrent.CompletableFuture<java.lang.Thread> < java.lang.Thread > java.util.concurrent.CompletableFuture<java.lang.Thread> ( ) { return java.util.concurrent.CompletableFuture . java.util.concurrent.CompletableFuture<java.lang.Thread> ( java.lang.Thread . java.lang.Thread ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Async public void void ( ) { throw new java.lang.UnsupportedOperationException ( STRING ) ; }  <METHOD_END>
