<METHOD_START> public void ( final byte [] byte[] ) { this( byte[] , NUMBER , byte[] . int ); }  <METHOD_END>
<METHOD_START> public void ( final byte [] byte[] , final int int , final int int ) { this . byte[] = byte[] ; int[] = new int [ int ( int + NUMBER ) ] ; int int = int[] . int ; java.lang.String[] = new java.lang.String [ int ] ; int int = NUMBER ; int int = int + NUMBER ; for ( int int = NUMBER ; int < int ; ++ int ) { int[] [ int ] = int + NUMBER ; int int ; switch ( byte[] [ int ] ) { case ClassWriter . FIELD : case ClassWriter . METH : case ClassWriter . IMETH : case ClassWriter . INT : case ClassWriter . FLOAT : case ClassWriter . NAME_TYPE : case ClassWriter . INDY : int = NUMBER ; break; case ClassWriter . LONG : case ClassWriter . DOUBLE : int = NUMBER ; ++ int ; break; case ClassWriter . UTF8 : int = NUMBER + int ( int + NUMBER ) ; if ( int > int ) { int = int ; } break; case ClassWriter . HANDLE : int = NUMBER ; break; default: int = NUMBER ; break; } int += int ; } int = int ; int = int ; }  <METHOD_END>
<METHOD_START> public int int ( ) { return int ( int ) ; }  <METHOD_END>
<METHOD_START> public java.lang.String java.lang.String ( ) { return java.lang.String ( int + NUMBER , new char [ int ] ) ; }  <METHOD_END>
<METHOD_START> public java.lang.String java.lang.String ( ) { return java.lang.String ( int + NUMBER , new char [ int ] ) ; }  <METHOD_END>
<METHOD_START> public java.lang.String [] java.lang.String[] ( ) { int int = int + NUMBER ; int int = int ( int ) ; java.lang.String [] java.lang.String[] = new java.lang.String [ int ] ; if ( int > NUMBER ) { char [] char[] = new char [ int ] ; for ( int int = NUMBER ; int < int ; ++ int ) { int += NUMBER ; java.lang.String[] [ int ] = java.lang.String ( int , char[] ) ; } } return java.lang.String[] ; }  <METHOD_END>
<METHOD_START> void void ( final ClassWriter org.springframework.asm.ClassWriter ) { char [] char[] = new char [ int ] ; int int = int[] . int ; Item [] org.springframework.asm.Item[] = new Item [ int ] ; for ( int int = NUMBER ; int < int ; int ++ ) { int int = int[] [ int ] ; int int = byte[] [ int - NUMBER ] ; Item org.springframework.asm.Item = new Item ( int ) ; int int ; switch ( int ) { case ClassWriter . FIELD : case ClassWriter . METH : case ClassWriter . IMETH : int = int[] [ int ( int + NUMBER ) ] ; org.springframework.asm.Item . set ( int , java.lang.String ( int , char[] ) , java.lang.String ( int , char[] ) , java.lang.String ( int + NUMBER , char[] ) ) ; break; case ClassWriter . INT : org.springframework.asm.Item . set ( int ( int ) ) ; break; case ClassWriter . FLOAT : org.springframework.asm.Item . set ( java.lang.Float . float ( int ( int ) ) ) ; break; case ClassWriter . NAME_TYPE : org.springframework.asm.Item . set ( int , java.lang.String ( int , char[] ) , java.lang.String ( int + NUMBER , char[] ) , null ) ; break; case ClassWriter . LONG : org.springframework.asm.Item . set ( long ( int ) ) ; ++ int ; break; case ClassWriter . DOUBLE : org.springframework.asm.Item . set ( java.lang.Double . double ( long ( int ) ) ) ; ++ int ; break; case ClassWriter . UTF8 : { java.lang.String java.lang.String = java.lang.String[] [ int ] ; if ( java.lang.String == null ) { int = int[] [ int ] ; java.lang.String = java.lang.String[] [ int ] = java.lang.String ( int + NUMBER , int ( int ) , char[] ) ; } org.springframework.asm.Item . set ( int , java.lang.String , null , null ) ; break; } case ClassWriter . HANDLE : { int int = int[] [ int ( int + NUMBER ) ] ; int = int[] [ int ( int + NUMBER ) ] ; org.springframework.asm.Item . set ( ClassWriter . HANDLE_BASE + int ( int ) , java.lang.String ( int , char[] ) , java.lang.String ( int , char[] ) , java.lang.String ( int + NUMBER , char[] ) ) ; break; } case ClassWriter . INDY : if ( classWriter . bootstrapMethods == null ) { void ( org.springframework.asm.ClassWriter , org.springframework.asm.Item[] , char[] ) ; } int = int[] [ int ( int + NUMBER ) ] ; org.springframework.asm.Item . set ( java.lang.String ( int , char[] ) , java.lang.String ( int + NUMBER , char[] ) , int ( int ) ) ; break; default: org.springframework.asm.Item . set ( int , java.lang.String ( int , char[] ) , null , null ) ; break; } int int = item . hashCode % items2 . length ; item . next = org.springframework.asm.Item[] [ int ] ; org.springframework.asm.Item[] [ int ] = org.springframework.asm.Item ; } int int = int[] [ NUMBER ] - NUMBER ; classWriter . pool . putByteArray ( byte[] , int , int - int ) ; classWriter . items = org.springframework.asm.Item[] ; classWriter . threshold = ( int ) ( NUMBER * int ) ; classWriter . index = int ; }  <METHOD_END>
<METHOD_START> private void void ( final ClassWriter org.springframework.asm.ClassWriter , final Item [] org.springframework.asm.Item[] , final char [] char[] ) { int int = int ( ) ; boolean boolean = false ; for ( int int = int ( int ) ; int > NUMBER ; -- int ) { java.lang.String java.lang.String = java.lang.String ( int + NUMBER , char[] ) ; if ( STRING . boolean ( java.lang.String ) ) { boolean = true ; break; } int += NUMBER + int ( int + NUMBER ) ; } if ( ! boolean ) { return; } int int = int ( int + NUMBER ) ; for ( int int = NUMBER , int = int + NUMBER ; int < int ; int ++ ) { int int = int - int - NUMBER ; int int = java.lang.Object ( int ( int ) , char[] ) . int ( ) ; for ( int int = int ( int + NUMBER ) ; int > NUMBER ; -- int ) { int ^= java.lang.Object ( int ( int + NUMBER ) , char[] ) . int ( ) ; int += NUMBER ; } int += NUMBER ; Item org.springframework.asm.Item = new Item ( int ) ; org.springframework.asm.Item . set ( int , int & NUMBER ) ; int int = item . hashCode % items . length ; item . next = org.springframework.asm.Item[] [ int ] ; org.springframework.asm.Item[] [ int ] = org.springframework.asm.Item ; } int int = int ( int + NUMBER ) ; ByteVector org.springframework.asm.ByteVector = new ByteVector ( int + NUMBER ) ; org.springframework.asm.ByteVector . putByteArray ( byte[] , int + NUMBER , int - NUMBER ) ; classWriter . bootstrapMethodsCount = int ; classWriter . bootstrapMethods = org.springframework.asm.ByteVector ; }  <METHOD_END>
<METHOD_START> public void ( final java.io.InputStream java.io.InputStream ) throws java.io.IOException { this( byte[] ( java.io.InputStream , false ) ); }  <METHOD_END>
<METHOD_START> public void ( final java.lang.String java.lang.String ) throws java.io.IOException { this( byte[] ( java.lang.ClassLoader . java.io.InputStream ( java.lang.String . java.lang.String ( '.' , '/' ) + STRING ) , true ) ); }  <METHOD_END>
<METHOD_START> private static byte [] byte[] ( final java.io.InputStream java.io.InputStream , boolean boolean )            throws java.io.IOException { if ( java.io.InputStream == null ) { throw new java.io.IOException ( STRING ) ; } try { byte [] byte[] = new byte [ java.io.InputStream . int ( ) ] ; int int = NUMBER ; while ( true ) { int int = java.io.InputStream . int ( byte[] , int , byte[] . int - int ) ; if ( int == - NUMBER ) { if ( int < byte[] . int ) { byte [] byte[] = new byte [ int ] ; java.lang.System . void ( byte[] , NUMBER , byte[] , NUMBER , int ) ; byte[] = byte[] ; } return byte[] ; } int += int ; if ( int == byte[] . int ) { int int = java.io.InputStream . int ( ) ; if ( int < NUMBER ) { return byte[] ; } byte [] byte[] = new byte [ byte[] . int + NUMBER ] ; java.lang.System . void ( byte[] , NUMBER , byte[] , NUMBER , int ) ; byte[] [ int ++ ] = ( byte ) int ; byte[] = byte[] ; } } } finally { if ( boolean ) { java.io.InputStream . void ( ) ; } } }  <METHOD_END>
<METHOD_START> public void void ( final ClassVisitor org.springframework.asm.ClassVisitor , final int int ) { void ( org.springframework.asm.ClassVisitor , new Attribute [ NUMBER ] , int ) ; }  <METHOD_END>
<METHOD_START> public void void ( final ClassVisitor org.springframework.asm.ClassVisitor , final Attribute [] org.springframework.asm.Attribute[] , final int int ) { int int = int ; char [] char[] = new char [ int ] ; Context org.springframework.asm.Context = new Context ( ) ; context . attrs = org.springframework.asm.Attribute[] ; context . flags = int ; context . buffer = char[] ; int int = int ( int ) ; java.lang.String java.lang.String = java.lang.String ( int + NUMBER , char[] ) ; java.lang.String java.lang.String = java.lang.String ( int + NUMBER , char[] ) ; java.lang.String [] java.lang.String[] = new java.lang.String [ int ( int + NUMBER ) ] ; int += NUMBER ; for ( int int = NUMBER ; int < java.lang.String[] . int ; ++ int ) { java.lang.String[] [ int ] = java.lang.String ( int , char[] ) ; int += NUMBER ; } java.lang.String java.lang.String = null ; java.lang.String java.lang.String = null ; java.lang.String java.lang.String = null ; java.lang.String java.lang.String = null ; java.lang.String java.lang.String = null ; java.lang.String java.lang.String = null ; int int = NUMBER ; int int = NUMBER ; int int = NUMBER ; int int = NUMBER ; int int = NUMBER ; Attribute org.springframework.asm.Attribute = null ; int = int ( ) ; for ( int int = int ( int ) ; int > NUMBER ; -- int ) { java.lang.String java.lang.String = java.lang.String ( int + NUMBER , char[] ) ; if ( STRING . boolean ( java.lang.String ) ) { java.lang.String = java.lang.String ( int + NUMBER , char[] ) ; } else if ( STRING . boolean ( java.lang.String ) ) { int = int + NUMBER ; } else if ( STRING . boolean ( java.lang.String ) ) { java.lang.String = java.lang.String ( int + NUMBER , char[] ) ; int int = int ( int + NUMBER ) ; if ( int != NUMBER ) { java.lang.String = java.lang.String ( int[] [ int ] , char[] ) ; java.lang.String = java.lang.String ( int[] [ int ] + NUMBER , char[] ) ; } } else if ( boolean && STRING . boolean ( java.lang.String ) ) { java.lang.String = java.lang.String ( int + NUMBER , char[] ) ; } else if ( boolean && STRING . boolean ( java.lang.String ) ) { int = int + NUMBER ; } else if ( boolean && STRING . boolean ( java.lang.String ) ) { int = int + NUMBER ; } else if ( STRING . boolean ( java.lang.String ) ) { int |= Opcodes . ACC_DEPRECATED ; } else if ( STRING . boolean ( java.lang.String ) ) { int |= Opcodes . ACC_SYNTHETIC | ClassWriter . ACC_SYNTHETIC_ATTRIBUTE ; } else if ( STRING . boolean ( java.lang.String ) ) { int int = int ( int + NUMBER ) ; java.lang.String = java.lang.String ( int + NUMBER , int , new char [ int ] ) ; } else if ( boolean && STRING . boolean ( java.lang.String ) ) { int = int + NUMBER ; } else if ( boolean && STRING . boolean ( java.lang.String ) ) { int = int + NUMBER ; } else if ( STRING . boolean ( java.lang.String ) ) { int [] int[] = new int [ int ( int + NUMBER ) ] ; for ( int int = NUMBER , int = int + NUMBER ; int < int[] . int ; int ++ ) { int[] [ int ] = int ; int += NUMBER + int ( int + NUMBER ) << NUMBER ; } context . bootstrapMethods = int[] ; } else { Attribute org.springframework.asm.Attribute = org.springframework.asm.Attribute ( org.springframework.asm.Attribute[] , java.lang.String , int + NUMBER , int ( int + NUMBER ) , char[] , - NUMBER , null ) ; if ( org.springframework.asm.Attribute != null ) { attr . next = org.springframework.asm.Attribute ; org.springframework.asm.Attribute = org.springframework.asm.Attribute ; } } int += NUMBER + int ( int + NUMBER ) ; } org.springframework.asm.ClassVisitor . visit ( int ( int[] [ NUMBER ] - NUMBER ) , int , java.lang.String , java.lang.String , java.lang.String , java.lang.String[] ) ; if ( ( int & int ) == NUMBER && ( java.lang.String != null || java.lang.String != null ) ) { org.springframework.asm.ClassVisitor . visitSource ( java.lang.String , java.lang.String ) ; } if ( java.lang.String != null ) { org.springframework.asm.ClassVisitor . visitOuterClass ( java.lang.String , java.lang.String , java.lang.String ) ; } if ( boolean && int != NUMBER ) { for ( int int = int ( int ) , int = int + NUMBER ; int > NUMBER ; -- int ) { int = int ( int + NUMBER , char[] , true , org.springframework.asm.ClassVisitor . visitAnnotation ( java.lang.String ( int , char[] ) , true ) ) ; } } if ( boolean && int != NUMBER ) { for ( int int = int ( int ) , int = int + NUMBER ; int > NUMBER ; -- int ) { int = int ( int + NUMBER , char[] , true , org.springframework.asm.ClassVisitor . visitAnnotation ( java.lang.String ( int , char[] ) , false ) ) ; } } if ( boolean && int != NUMBER ) { for ( int int = int ( int ) , int = int + NUMBER ; int > NUMBER ; -- int ) { int = int ( org.springframework.asm.Context , int ) ; int = int ( int + NUMBER , char[] , true , org.springframework.asm.ClassVisitor . visitTypeAnnotation ( context . typeRef , context . typePath , java.lang.String ( int , char[] ) , true ) ) ; } } if ( boolean && int != NUMBER ) { for ( int int = int ( int ) , int = int + NUMBER ; int > NUMBER ; -- int ) { int = int ( org.springframework.asm.Context , int ) ; int = int ( int + NUMBER , char[] , true , org.springframework.asm.ClassVisitor . visitTypeAnnotation ( context . typeRef , context . typePath , java.lang.String ( int , char[] ) , false ) ) ; } } while ( org.springframework.asm.Attribute != null ) { Attribute org.springframework.asm.Attribute = attributes . next ; attributes . next = null ; org.springframework.asm.ClassVisitor . visitAttribute ( org.springframework.asm.Attribute ) ; org.springframework.asm.Attribute = org.springframework.asm.Attribute ; } if ( int != NUMBER ) { int int = int + NUMBER ; for ( int int = int ( int ) ; int > NUMBER ; -- int ) { org.springframework.asm.ClassVisitor . visitInnerClass ( java.lang.String ( int , char[] ) , java.lang.String ( int + NUMBER , char[] ) , java.lang.String ( int + NUMBER , char[] ) , int ( int + NUMBER ) ) ; int += NUMBER ; } } int = int + NUMBER + NUMBER * java.lang.String[] . int ; for ( int int = int ( int - NUMBER ) ; int > NUMBER ; -- int ) { int = int ( org.springframework.asm.ClassVisitor , org.springframework.asm.Context , int ) ; } int += NUMBER ; for ( int int = int ( int - NUMBER ) ; int > NUMBER ; -- int ) { int = int ( org.springframework.asm.ClassVisitor , org.springframework.asm.Context , int ) ; } org.springframework.asm.ClassVisitor . visitEnd ( ) ; }  <METHOD_END>
<METHOD_START> private int int ( final ClassVisitor org.springframework.asm.ClassVisitor , final Context org.springframework.asm.Context , int int ) { char [] char[] = context . buffer ; int int = int ( int ) ; java.lang.String java.lang.String = java.lang.String ( int + NUMBER , char[] ) ; java.lang.String java.lang.String = java.lang.String ( int + NUMBER , char[] ) ; int += NUMBER ; java.lang.String java.lang.String = null ; int int = NUMBER ; int int = NUMBER ; int int = NUMBER ; int int = NUMBER ; java.lang.Object java.lang.Object = null ; Attribute org.springframework.asm.Attribute = null ; for ( int int = int ( int ) ; int > NUMBER ; -- int ) { java.lang.String java.lang.String = java.lang.String ( int + NUMBER , char[] ) ; if ( STRING . boolean ( java.lang.String ) ) { int int = int ( int + NUMBER ) ; java.lang.Object = int == NUMBER ? null : java.lang.Object ( int , char[] ) ; } else if ( boolean && STRING . boolean ( java.lang.String ) ) { java.lang.String = java.lang.String ( int + NUMBER , char[] ) ; } else if ( STRING . boolean ( java.lang.String ) ) { int |= Opcodes . ACC_DEPRECATED ; } else if ( STRING . boolean ( java.lang.String ) ) { int |= Opcodes . ACC_SYNTHETIC | ClassWriter . ACC_SYNTHETIC_ATTRIBUTE ; } else if ( boolean && STRING . boolean ( java.lang.String ) ) { int = int + NUMBER ; } else if ( boolean && STRING . boolean ( java.lang.String ) ) { int = int + NUMBER ; } else if ( boolean && STRING . boolean ( java.lang.String ) ) { int = int + NUMBER ; } else if ( boolean && STRING . boolean ( java.lang.String ) ) { int = int + NUMBER ; } else { Attribute org.springframework.asm.Attribute = org.springframework.asm.Attribute ( context . attrs , java.lang.String , int + NUMBER , int ( int + NUMBER ) , char[] , - NUMBER , null ) ; if ( org.springframework.asm.Attribute != null ) { attr . next = org.springframework.asm.Attribute ; org.springframework.asm.Attribute = org.springframework.asm.Attribute ; } } int += NUMBER + int ( int + NUMBER ) ; } int += NUMBER ; FieldVisitor org.springframework.asm.FieldVisitor = org.springframework.asm.ClassVisitor . visitField ( int , java.lang.String , java.lang.String , java.lang.String , java.lang.Object ) ; if ( org.springframework.asm.FieldVisitor == null ) { return int ; } if ( boolean && int != NUMBER ) { for ( int int = int ( int ) , int = int + NUMBER ; int > NUMBER ; -- int ) { int = int ( int + NUMBER , char[] , true , org.springframework.asm.FieldVisitor . visitAnnotation ( java.lang.String ( int , char[] ) , true ) ) ; } } if ( boolean && int != NUMBER ) { for ( int int = int ( int ) , int = int + NUMBER ; int > NUMBER ; -- int ) { int = int ( int + NUMBER , char[] , true , org.springframework.asm.FieldVisitor . visitAnnotation ( java.lang.String ( int , char[] ) , false ) ) ; } } if ( boolean && int != NUMBER ) { for ( int int = int ( int ) , int = int + NUMBER ; int > NUMBER ; -- int ) { int = int ( org.springframework.asm.Context , int ) ; int = int ( int + NUMBER , char[] , true , org.springframework.asm.FieldVisitor . visitTypeAnnotation ( context . typeRef , context . typePath , java.lang.String ( int , char[] ) , true ) ) ; } } if ( boolean && int != NUMBER ) { for ( int int = int ( int ) , int = int + NUMBER ; int > NUMBER ; -- int ) { int = int ( org.springframework.asm.Context , int ) ; int = int ( int + NUMBER , char[] , true , org.springframework.asm.FieldVisitor . visitTypeAnnotation ( context . typeRef , context . typePath , java.lang.String ( int , char[] ) , false ) ) ; } } while ( org.springframework.asm.Attribute != null ) { Attribute org.springframework.asm.Attribute = attributes . next ; attributes . next = null ; org.springframework.asm.FieldVisitor . visitAttribute ( org.springframework.asm.Attribute ) ; org.springframework.asm.Attribute = org.springframework.asm.Attribute ; } org.springframework.asm.FieldVisitor . visitEnd ( ) ; return int ; }  <METHOD_END>
<METHOD_START> private int int ( final ClassVisitor org.springframework.asm.ClassVisitor , final Context org.springframework.asm.Context , int int ) { char [] char[] = context . buffer ; context . access = int ( int ) ; context . name = java.lang.String ( int + NUMBER , char[] ) ; context . desc = java.lang.String ( int + NUMBER , char[] ) ; int += NUMBER ; int int = NUMBER ; int int = NUMBER ; java.lang.String [] java.lang.String[] = null ; java.lang.String java.lang.String = null ; int int = NUMBER ; int int = NUMBER ; int int = NUMBER ; int int = NUMBER ; int int = NUMBER ; int int = NUMBER ; int int = NUMBER ; int int = NUMBER ; int int = int ; Attribute org.springframework.asm.Attribute = null ; for ( int int = int ( int ) ; int > NUMBER ; -- int ) { java.lang.String java.lang.String = java.lang.String ( int + NUMBER , char[] ) ; if ( STRING . boolean ( java.lang.String ) ) { if ( ( context . flags & int ) == NUMBER ) { int = int + NUMBER ; } } else if ( STRING . boolean ( java.lang.String ) ) { java.lang.String[] = new java.lang.String [ int ( int + NUMBER ) ] ; int = int + NUMBER ; for ( int int = NUMBER ; int < java.lang.String[] . int ; ++ int ) { java.lang.String[] [ int ] = java.lang.String ( int , char[] ) ; int += NUMBER ; } } else if ( boolean && STRING . boolean ( java.lang.String ) ) { java.lang.String = java.lang.String ( int + NUMBER , char[] ) ; } else if ( STRING . boolean ( java.lang.String ) ) { context . access |= Opcodes . ACC_DEPRECATED ; } else if ( boolean && STRING . boolean ( java.lang.String ) ) { int = int + NUMBER ; } else if ( boolean && STRING . boolean ( java.lang.String ) ) { int = int + NUMBER ; } else if ( boolean && STRING . boolean ( java.lang.String ) ) { int = int + NUMBER ; } else if ( STRING . boolean ( java.lang.String ) ) { context . access |= Opcodes . ACC_SYNTHETIC | ClassWriter . ACC_SYNTHETIC_ATTRIBUTE ; } else if ( boolean && STRING . boolean ( java.lang.String ) ) { int = int + NUMBER ; } else if ( boolean && STRING . boolean ( java.lang.String ) ) { int = int + NUMBER ; } else if ( boolean && STRING . boolean ( java.lang.String ) ) { int = int + NUMBER ; } else if ( boolean && STRING . boolean ( java.lang.String ) ) { int = int + NUMBER ; } else if ( STRING . boolean ( java.lang.String ) ) { int = int + NUMBER ; } else { Attribute org.springframework.asm.Attribute = org.springframework.asm.Attribute ( context . attrs , java.lang.String , int + NUMBER , int ( int + NUMBER ) , char[] , - NUMBER , null ) ; if ( org.springframework.asm.Attribute != null ) { attr . next = org.springframework.asm.Attribute ; org.springframework.asm.Attribute = org.springframework.asm.Attribute ; } } int += NUMBER + int ( int + NUMBER ) ; } int += NUMBER ; MethodVisitor org.springframework.asm.MethodVisitor = org.springframework.asm.ClassVisitor . visitMethod ( context . access , context . name , context . desc , java.lang.String , java.lang.String[] ) ; if ( org.springframework.asm.MethodVisitor == null ) { return int ; } if ( boolean && org.springframework.asm.MethodVisitor instanceof MethodWriter ) { MethodWriter org.springframework.asm.MethodWriter = ( MethodWriter ) org.springframework.asm.MethodVisitor ; if ( mw . cw . cr == this && ( java.lang.String != null ? java.lang.String . boolean ( mw . signature ) : mw . signature == null ) ) { boolean boolean = false ; if ( java.lang.String[] == null ) { boolean = mw . exceptionCount == NUMBER ; } else if ( java.lang.String[] . int == mw . exceptionCount ) { boolean = true ; for ( int int = java.lang.String[] . int - NUMBER ; int >= NUMBER ; -- int ) { int -= NUMBER ; if ( mw . exceptions [ int ] != int ( int ) ) { boolean = false ; break; } } } if ( boolean ) { mw . classReaderOffset = int ; mw . classReaderLength = int - int ; return int ; } } } if ( int != NUMBER ) { for ( int int = byte[] [ int ] & NUMBER , int = int + NUMBER ; int > NUMBER ; -- int , int = int + NUMBER ) { org.springframework.asm.MethodVisitor . visitParameter ( java.lang.String ( int , char[] ) , int ( int + NUMBER ) ) ; } } if ( boolean && int != NUMBER ) { AnnotationVisitor org.springframework.asm.AnnotationVisitor = org.springframework.asm.MethodVisitor . visitAnnotationDefault ( ) ; int ( int , char[] , null , org.springframework.asm.AnnotationVisitor ) ; if ( org.springframework.asm.AnnotationVisitor != null ) { org.springframework.asm.AnnotationVisitor . visitEnd ( ) ; } } if ( boolean && int != NUMBER ) { for ( int int = int ( int ) , int = int + NUMBER ; int > NUMBER ; -- int ) { int = int ( int + NUMBER , char[] , true , org.springframework.asm.MethodVisitor . visitAnnotation ( java.lang.String ( int , char[] ) , true ) ) ; } } if ( boolean && int != NUMBER ) { for ( int int = int ( int ) , int = int + NUMBER ; int > NUMBER ; -- int ) { int = int ( int + NUMBER , char[] , true , org.springframework.asm.MethodVisitor . visitAnnotation ( java.lang.String ( int , char[] ) , false ) ) ; } } if ( boolean && int != NUMBER ) { for ( int int = int ( int ) , int = int + NUMBER ; int > NUMBER ; -- int ) { int = int ( org.springframework.asm.Context , int ) ; int = int ( int + NUMBER , char[] , true , org.springframework.asm.MethodVisitor . visitTypeAnnotation ( context . typeRef , context . typePath , java.lang.String ( int , char[] ) , true ) ) ; } } if ( boolean && int != NUMBER ) { for ( int int = int ( int ) , int = int + NUMBER ; int > NUMBER ; -- int ) { int = int ( org.springframework.asm.Context , int ) ; int = int ( int + NUMBER , char[] , true , org.springframework.asm.MethodVisitor . visitTypeAnnotation ( context . typeRef , context . typePath , java.lang.String ( int , char[] ) , false ) ) ; } } if ( boolean && int != NUMBER ) { void ( org.springframework.asm.MethodVisitor , org.springframework.asm.Context , int , true ) ; } if ( boolean && int != NUMBER ) { void ( org.springframework.asm.MethodVisitor , org.springframework.asm.Context , int , false ) ; } while ( org.springframework.asm.Attribute != null ) { Attribute org.springframework.asm.Attribute = attributes . next ; attributes . next = null ; org.springframework.asm.MethodVisitor . visitAttribute ( org.springframework.asm.Attribute ) ; org.springframework.asm.Attribute = org.springframework.asm.Attribute ; } if ( int != NUMBER ) { org.springframework.asm.MethodVisitor . visitCode ( ) ; void ( org.springframework.asm.MethodVisitor , org.springframework.asm.Context , int ) ; } org.springframework.asm.MethodVisitor . visitEnd ( ) ; return int ; }  <METHOD_END>
<METHOD_START> private void void ( final MethodVisitor org.springframework.asm.MethodVisitor , final Context org.springframework.asm.Context , int int ) { byte [] byte[] = this . byte[] ; char [] char[] = context . buffer ; int int = int ( int ) ; int int = int ( int + NUMBER ) ; int int = int ( int + NUMBER ) ; int += NUMBER ; int int = int ; int int = int + int ; Label [] org.springframework.asm.Label[] = context . labels = new Label [ int + NUMBER ] ; org.springframework.asm.Label ( int + NUMBER , org.springframework.asm.Label[] ) ; while ( int < int ) { int int = int - int ; int int = byte[] [ int ] & NUMBER ; switch ( ClassWriter . TYPE [ int ] ) { case ClassWriter . NOARG_INSN : case ClassWriter . IMPLVAR_INSN : int += NUMBER ; break; case ClassWriter . LABEL_INSN : org.springframework.asm.Label ( int + short ( int + NUMBER ) , org.springframework.asm.Label[] ) ; int += NUMBER ; break; case ClassWriter . ASM_LABEL_INSN : org.springframework.asm.Label ( int + int ( int + NUMBER ) , org.springframework.asm.Label[] ) ; int += NUMBER ; break; case ClassWriter . LABELW_INSN : org.springframework.asm.Label ( int + int ( int + NUMBER ) , org.springframework.asm.Label[] ) ; int += NUMBER ; break; case ClassWriter . WIDE_INSN : int = byte[] [ int + NUMBER ] & NUMBER ; if ( int == Opcodes . IINC ) { int += NUMBER ; } else { int += NUMBER ; } break; case ClassWriter . TABL_INSN : int = int + NUMBER - ( int & NUMBER ) ; org.springframework.asm.Label ( int + int ( int ) , org.springframework.asm.Label[] ) ; for ( int int = int ( int + NUMBER ) - int ( int + NUMBER ) + NUMBER ; int > NUMBER ; -- int ) { org.springframework.asm.Label ( int + int ( int + NUMBER ) , org.springframework.asm.Label[] ) ; int += NUMBER ; } int += NUMBER ; break; case ClassWriter . LOOK_INSN : int = int + NUMBER - ( int & NUMBER ) ; org.springframework.asm.Label ( int + int ( int ) , org.springframework.asm.Label[] ) ; for ( int int = int ( int + NUMBER ) ; int > NUMBER ; -- int ) { org.springframework.asm.Label ( int + int ( int + NUMBER ) , org.springframework.asm.Label[] ) ; int += NUMBER ; } int += NUMBER ; break; case ClassWriter . VAR_INSN : case ClassWriter . SBYTE_INSN : case ClassWriter . LDC_INSN : int += NUMBER ; break; case ClassWriter . SHORT_INSN : case ClassWriter . LDCW_INSN : case ClassWriter . FIELDORMETH_INSN : case ClassWriter . TYPE_INSN : case ClassWriter . IINC_INSN : int += NUMBER ; break; case ClassWriter . ITFMETH_INSN : case ClassWriter . INDYMETH_INSN : int += NUMBER ; break; default: int += NUMBER ; break; } } for ( int int = int ( int ) ; int > NUMBER ; -- int ) { Label org.springframework.asm.Label = org.springframework.asm.Label ( int ( int + NUMBER ) , org.springframework.asm.Label[] ) ; Label org.springframework.asm.Label = org.springframework.asm.Label ( int ( int + NUMBER ) , org.springframework.asm.Label[] ) ; Label org.springframework.asm.Label = org.springframework.asm.Label ( int ( int + NUMBER ) , org.springframework.asm.Label[] ) ; java.lang.String java.lang.String = java.lang.String ( int[] [ int ( int + NUMBER ) ] , char[] ) ; org.springframework.asm.MethodVisitor . visitTryCatchBlock ( org.springframework.asm.Label , org.springframework.asm.Label , org.springframework.asm.Label , java.lang.String ) ; int += NUMBER ; } int += NUMBER ; int [] int[] = null ; int [] int[] = null ; int int = NUMBER ; int int = NUMBER ; int int = - NUMBER ; int int = - NUMBER ; int int = NUMBER ; int int = NUMBER ; boolean boolean = true ; boolean boolean = ( context . flags & int ) != NUMBER ; int int = NUMBER ; int int = NUMBER ; int int = NUMBER ; Context org.springframework.asm.Context = null ; Attribute org.springframework.asm.Attribute = null ; for ( int int = int ( int ) ; int > NUMBER ; -- int ) { java.lang.String java.lang.String = java.lang.String ( int + NUMBER , char[] ) ; if ( STRING . boolean ( java.lang.String ) ) { if ( ( context . flags & int ) == NUMBER ) { int = int + NUMBER ; for ( int int = int ( int + NUMBER ) , int = int ; int > NUMBER ; -- int ) { int int = int ( int + NUMBER ) ; if ( org.springframework.asm.Label[] [ int ] == null ) { org.springframework.asm.Label ( int , org.springframework.asm.Label[] ) . status |= Label . DEBUG ; } int += int ( int + NUMBER ) ; if ( org.springframework.asm.Label[] [ int ] == null ) { org.springframework.asm.Label ( int , org.springframework.asm.Label[] ) . status |= Label . DEBUG ; } int += NUMBER ; } } } else if ( STRING . boolean ( java.lang.String ) ) { int = int + NUMBER ; } else if ( STRING . boolean ( java.lang.String ) ) { if ( ( context . flags & int ) == NUMBER ) { for ( int int = int ( int + NUMBER ) , int = int ; int > NUMBER ; -- int ) { int int = int ( int + NUMBER ) ; if ( org.springframework.asm.Label[] [ int ] == null ) { org.springframework.asm.Label ( int , org.springframework.asm.Label[] ) . status |= Label . DEBUG ; } Label org.springframework.asm.Label = org.springframework.asm.Label[] [ int ] ; while ( l . line > NUMBER ) { if ( l . next == null ) { l . next = new Label ( ) ; } org.springframework.asm.Label = l . next ; } l . line = int ( int + NUMBER ) ; int += NUMBER ; } } } else if ( boolean && STRING . boolean ( java.lang.String ) ) { int[] = int[] ( org.springframework.asm.MethodVisitor , org.springframework.asm.Context , int + NUMBER , true ) ; int = int[] . int == NUMBER || int ( int[] [ NUMBER ] ) < NUMBER ? - NUMBER : int ( int[] [ NUMBER ] + NUMBER ) ; } else if ( boolean && STRING . boolean ( java.lang.String ) ) { int[] = int[] ( org.springframework.asm.MethodVisitor , org.springframework.asm.Context , int + NUMBER , false ) ; int = int[] . int == NUMBER || int ( int[] [ NUMBER ] ) < NUMBER ? - NUMBER : int ( int[] [ NUMBER ] + NUMBER ) ; } else if ( boolean && STRING . boolean ( java.lang.String ) ) { if ( ( context . flags & int ) == NUMBER ) { int = int + NUMBER ; int = int ( int + NUMBER ) ; int = int ( int + NUMBER ) ; } } else if ( boolean && STRING . boolean ( java.lang.String ) ) { if ( ( context . flags & int ) == NUMBER ) { boolean = false ; int = int + NUMBER ; int = int ( int + NUMBER ) ; int = int ( int + NUMBER ) ; } } else { for ( int int = NUMBER ; int < context . attrs . length ; ++ int ) { if ( context . attrs [ int ] . type . equals ( java.lang.String ) ) { Attribute org.springframework.asm.Attribute = context . attrs [ int ] . read ( this , int + NUMBER , int ( int + NUMBER ) , char[] , int - NUMBER , org.springframework.asm.Label[] ) ; if ( org.springframework.asm.Attribute != null ) { attr . next = org.springframework.asm.Attribute ; org.springframework.asm.Attribute = org.springframework.asm.Attribute ; } } } } int += NUMBER + int ( int + NUMBER ) ; } int += NUMBER ; if ( boolean && int != NUMBER ) { org.springframework.asm.Context = org.springframework.asm.Context ; frame . offset = - NUMBER ; frame . mode = NUMBER ; frame . localCount = NUMBER ; frame . localDiff = NUMBER ; frame . stackCount = NUMBER ; frame . local = new java.lang.Object [ int ] ; frame . stack = new java.lang.Object [ int ] ; if ( boolean ) { void ( org.springframework.asm.Context ) ; } for ( int int = int ; int < int + int - NUMBER ; ++ int ) { if ( byte[] [ int ] == NUMBER ) { int int = int ( int + NUMBER ) ; if ( int >= NUMBER && int < int ) { if ( ( byte[] [ int + int ] & NUMBER ) == Opcodes . NEW ) { org.springframework.asm.Label ( int , org.springframework.asm.Label[] ) ; } } } } } if ( ( context . flags & int ) != NUMBER ) { org.springframework.asm.MethodVisitor . visitFrame ( Opcodes . F_NEW , int , null , NUMBER , null ) ; } int int = ( context . flags & int ) == NUMBER ? - NUMBER : NUMBER ; int = int ; while ( int < int ) { int int = int - int ; Label org.springframework.asm.Label = org.springframework.asm.Label[] [ int ] ; if ( org.springframework.asm.Label != null ) { Label org.springframework.asm.Label = l . next ; l . next = null ; org.springframework.asm.MethodVisitor . visitLabel ( org.springframework.asm.Label ) ; if ( ( context . flags & int ) == NUMBER && l . line > NUMBER ) { org.springframework.asm.MethodVisitor . visitLineNumber ( l . line , org.springframework.asm.Label ) ; while ( org.springframework.asm.Label != null ) { org.springframework.asm.MethodVisitor . visitLineNumber ( next . line , org.springframework.asm.Label ) ; org.springframework.asm.Label = next . next ; } } } while ( boolean && org.springframework.asm.Context != null && ( frame . offset == int || frame . offset == - NUMBER ) ) { if ( frame . offset != - NUMBER ) { if ( ! boolean || boolean ) { org.springframework.asm.MethodVisitor . visitFrame ( Opcodes . F_NEW , frame . localCount , frame . local , frame . stackCount , frame . stack ) ; } else { org.springframework.asm.MethodVisitor . visitFrame ( frame . mode , frame . localDiff , frame . local , frame . stackCount , frame . stack ) ; } } if ( int > NUMBER ) { int = int ( int , boolean , boolean , org.springframework.asm.Context ) ; -- int ; } else { org.springframework.asm.Context = null ; } } int int = byte[] [ int ] & NUMBER ; switch ( ClassWriter . TYPE [ int ] ) { case ClassWriter . NOARG_INSN : org.springframework.asm.MethodVisitor . visitInsn ( int ) ; int += NUMBER ; break; case ClassWriter . IMPLVAR_INSN : if ( int > Opcodes . ISTORE ) { int -= NUMBER ; org.springframework.asm.MethodVisitor . visitVarInsn ( Opcodes . ISTORE + ( int >> NUMBER ) , int & NUMBER ) ; } else { int -= NUMBER ; org.springframework.asm.MethodVisitor . visitVarInsn ( Opcodes . ILOAD + ( int >> NUMBER ) , int & NUMBER ) ; } int += NUMBER ; break; case ClassWriter . LABEL_INSN : org.springframework.asm.MethodVisitor . visitJumpInsn ( int , org.springframework.asm.Label[] [ int + short ( int + NUMBER ) ] ) ; int += NUMBER ; break; case ClassWriter . LABELW_INSN : org.springframework.asm.MethodVisitor . visitJumpInsn ( int + int , org.springframework.asm.Label[] [ int + int ( int + NUMBER ) ] ) ; int += NUMBER ; break; case ClassWriter . ASM_LABEL_INSN : { int = int < NUMBER ? int - NUMBER : int - NUMBER ; Label org.springframework.asm.Label = org.springframework.asm.Label[] [ int + int ( int + NUMBER ) ] ; if ( int == Opcodes . GOTO || int == Opcodes . JSR ) { org.springframework.asm.MethodVisitor . visitJumpInsn ( int + NUMBER , org.springframework.asm.Label ) ; } else { int = int <= NUMBER ? ( ( int + NUMBER ) ^ NUMBER ) - NUMBER : int ^ NUMBER ; Label org.springframework.asm.Label = new Label ( ) ; org.springframework.asm.MethodVisitor . visitJumpInsn ( int , org.springframework.asm.Label ) ; org.springframework.asm.MethodVisitor . visitJumpInsn ( NUMBER , org.springframework.asm.Label ) ; org.springframework.asm.MethodVisitor . visitLabel ( org.springframework.asm.Label ) ; if ( boolean && int != NUMBER && ( org.springframework.asm.Context == null || frame . offset != int + NUMBER ) ) { org.springframework.asm.MethodVisitor . visitFrame ( ClassWriter . F_INSERT , NUMBER , null , NUMBER , null ) ; } } int += NUMBER ; break; } case ClassWriter . WIDE_INSN : int = byte[] [ int + NUMBER ] & NUMBER ; if ( int == Opcodes . IINC ) { org.springframework.asm.MethodVisitor . visitIincInsn ( int ( int + NUMBER ) , short ( int + NUMBER ) ) ; int += NUMBER ; } else { org.springframework.asm.MethodVisitor . visitVarInsn ( int , int ( int + NUMBER ) ) ; int += NUMBER ; } break; case ClassWriter . TABL_INSN : { int = int + NUMBER - ( int & NUMBER ) ; int int = int + int ( int ) ; int int = int ( int + NUMBER ) ; int int = int ( int + NUMBER ) ; Label [] org.springframework.asm.Label[] = new Label [ int - int + NUMBER ] ; int += NUMBER ; for ( int int = NUMBER ; int < table . length ; ++ int ) { org.springframework.asm.Label[] [ int ] = org.springframework.asm.Label[] [ int + int ( int ) ] ; int += NUMBER ; } org.springframework.asm.MethodVisitor . visitTableSwitchInsn ( int , int , org.springframework.asm.Label[] [ int ] , org.springframework.asm.Label[] ) ; break; } case ClassWriter . LOOK_INSN : { int = int + NUMBER - ( int & NUMBER ) ; int int = int + int ( int ) ; int int = int ( int + NUMBER ) ; int [] int[] = new int [ int ] ; Label [] org.springframework.asm.Label[] = new Label [ int ] ; int += NUMBER ; for ( int int = NUMBER ; int < int ; ++ int ) { int[] [ int ] = int ( int ) ; org.springframework.asm.Label[] [ int ] = org.springframework.asm.Label[] [ int + int ( int + NUMBER ) ] ; int += NUMBER ; } org.springframework.asm.MethodVisitor . visitLookupSwitchInsn ( org.springframework.asm.Label[] [ int ] , int[] , org.springframework.asm.Label[] ) ; break; } case ClassWriter . VAR_INSN : org.springframework.asm.MethodVisitor . visitVarInsn ( int , byte[] [ int + NUMBER ] & NUMBER ) ; int += NUMBER ; break; case ClassWriter . SBYTE_INSN : org.springframework.asm.MethodVisitor . visitIntInsn ( int , byte[] [ int + NUMBER ] ) ; int += NUMBER ; break; case ClassWriter . SHORT_INSN : org.springframework.asm.MethodVisitor . visitIntInsn ( int , short ( int + NUMBER ) ) ; int += NUMBER ; break; case ClassWriter . LDC_INSN : org.springframework.asm.MethodVisitor . visitLdcInsn ( java.lang.Object ( byte[] [ int + NUMBER ] & NUMBER , char[] ) ) ; int += NUMBER ; break; case ClassWriter . LDCW_INSN : org.springframework.asm.MethodVisitor . visitLdcInsn ( java.lang.Object ( int ( int + NUMBER ) , char[] ) ) ; int += NUMBER ; break; case ClassWriter . FIELDORMETH_INSN : case ClassWriter . ITFMETH_INSN : { int int = int[] [ int ( int + NUMBER ) ] ; boolean boolean = byte[] [ int - NUMBER ] == ClassWriter . IMETH ; java.lang.String java.lang.String = java.lang.String ( int , char[] ) ; int = int[] [ int ( int + NUMBER ) ] ; java.lang.String java.lang.String = java.lang.String ( int , char[] ) ; java.lang.String java.lang.String = java.lang.String ( int + NUMBER , char[] ) ; if ( int < Opcodes . INVOKEVIRTUAL ) { org.springframework.asm.MethodVisitor . visitFieldInsn ( int , java.lang.String , java.lang.String , java.lang.String ) ; } else { org.springframework.asm.MethodVisitor . visitMethodInsn ( int , java.lang.String , java.lang.String , java.lang.String , boolean ) ; } if ( int == Opcodes . INVOKEINTERFACE ) { int += NUMBER ; } else { int += NUMBER ; } break; } case ClassWriter . INDYMETH_INSN : { int int = int[] [ int ( int + NUMBER ) ] ; int int = context . bootstrapMethods [ int ( int ) ] ; Handle org.springframework.asm.Handle = ( Handle ) java.lang.Object ( int ( int ) , char[] ) ; int int = int ( int + NUMBER ) ; java.lang.Object [] java.lang.Object[] = new java.lang.Object [ int ] ; int += NUMBER ; for ( int int = NUMBER ; int < int ; int ++ ) { java.lang.Object[] [ int ] = java.lang.Object ( int ( int ) , char[] ) ; int += NUMBER ; } int = int[] [ int ( int + NUMBER ) ] ; java.lang.String java.lang.String = java.lang.String ( int , char[] ) ; java.lang.String java.lang.String = java.lang.String ( int + NUMBER , char[] ) ; org.springframework.asm.MethodVisitor . visitInvokeDynamicInsn ( java.lang.String , java.lang.String , org.springframework.asm.Handle , java.lang.Object[] ) ; int += NUMBER ; break; } case ClassWriter . TYPE_INSN : org.springframework.asm.MethodVisitor . visitTypeInsn ( int , java.lang.String ( int + NUMBER , char[] ) ) ; int += NUMBER ; break; case ClassWriter . IINC_INSN : org.springframework.asm.MethodVisitor . visitIincInsn ( byte[] [ int + NUMBER ] & NUMBER , byte[] [ int + NUMBER ] ) ; int += NUMBER ; break; default: org.springframework.asm.MethodVisitor . visitMultiANewArrayInsn ( java.lang.String ( int + NUMBER , char[] ) , byte[] [ int + NUMBER ] & NUMBER ) ; int += NUMBER ; break; } while ( int[] != null && int < int[] . int && int <= int ) { if ( int == int ) { int int = int ( org.springframework.asm.Context , int[] [ int ] ) ; int ( int + NUMBER , char[] , true , org.springframework.asm.MethodVisitor . visitInsnAnnotation ( context . typeRef , context . typePath , java.lang.String ( int , char[] ) , true ) ) ; } int = ++ int >= int[] . int || int ( int[] [ int ] ) < NUMBER ? - NUMBER : int ( int[] [ int ] + NUMBER ) ; } while ( int[] != null && int < int[] . int && int <= int ) { if ( int == int ) { int int = int ( org.springframework.asm.Context , int[] [ int ] ) ; int ( int + NUMBER , char[] , true , org.springframework.asm.MethodVisitor . visitInsnAnnotation ( context . typeRef , context . typePath , java.lang.String ( int , char[] ) , false ) ) ; } int = ++ int >= int[] . int || int ( int[] [ int ] ) < NUMBER ? - NUMBER : int ( int[] [ int ] + NUMBER ) ; } } if ( org.springframework.asm.Label[] [ int ] != null ) { org.springframework.asm.MethodVisitor . visitLabel ( org.springframework.asm.Label[] [ int ] ) ; } if ( ( context . flags & int ) == NUMBER && int != NUMBER ) { int [] int[] = null ; if ( int != NUMBER ) { int = int + NUMBER ; int[] = new int [ int ( int ) * NUMBER ] ; for ( int int = int[] . int ; int > NUMBER ;) { int[] [ -- int ] = int + NUMBER ; int[] [ -- int ] = int ( int + NUMBER ) ; int[] [ -- int ] = int ( int ) ; int += NUMBER ; } } int = int + NUMBER ; for ( int int = int ( int ) ; int > NUMBER ; -- int ) { int int = int ( int ) ; int int = int ( int + NUMBER ) ; int int = int ( int + NUMBER ) ; java.lang.String java.lang.String = null ; if ( int[] != null ) { for ( int int = NUMBER ; int < int[] . int ; int += NUMBER ) { if ( int[] [ int ] == int && int[] [ int + NUMBER ] == int ) { java.lang.String = java.lang.String ( int[] [ int + NUMBER ] , char[] ) ; break; } } } org.springframework.asm.MethodVisitor . visitLocalVariable ( java.lang.String ( int + NUMBER , char[] ) , java.lang.String ( int + NUMBER , char[] ) , java.lang.String , org.springframework.asm.Label[] [ int ] , org.springframework.asm.Label[] [ int + int ] , int ) ; int += NUMBER ; } } if ( int[] != null ) { for ( int int = NUMBER ; int < int[] . int ; ++ int ) { if ( ( int ( int[] [ int ] ) >> NUMBER ) == ( NUMBER >> NUMBER ) ) { int int = int ( org.springframework.asm.Context , int[] [ int ] ) ; int = int ( int + NUMBER , char[] , true , org.springframework.asm.MethodVisitor . visitLocalVariableAnnotation ( context . typeRef , context . typePath , context . start , context . end , context . index , java.lang.String ( int , char[] ) , true ) ) ; } } } if ( int[] != null ) { for ( int int = NUMBER ; int < int[] . int ; ++ int ) { if ( ( int ( int[] [ int ] ) >> NUMBER ) == ( NUMBER >> NUMBER ) ) { int int = int ( org.springframework.asm.Context , int[] [ int ] ) ; int = int ( int + NUMBER , char[] , true , org.springframework.asm.MethodVisitor . visitLocalVariableAnnotation ( context . typeRef , context . typePath , context . start , context . end , context . index , java.lang.String ( int , char[] ) , false ) ) ; } } } while ( org.springframework.asm.Attribute != null ) { Attribute org.springframework.asm.Attribute = attributes . next ; attributes . next = null ; org.springframework.asm.MethodVisitor . visitAttribute ( org.springframework.asm.Attribute ) ; org.springframework.asm.Attribute = org.springframework.asm.Attribute ; } org.springframework.asm.MethodVisitor . visitMaxs ( int , int ) ; }  <METHOD_END>
<METHOD_START> private int [] int[] ( final MethodVisitor org.springframework.asm.MethodVisitor , final Context org.springframework.asm.Context , int int , boolean boolean ) { char [] char[] = context . buffer ; int [] int[] = new int [ int ( int ) ] ; int += NUMBER ; for ( int int = NUMBER ; int < int[] . int ; ++ int ) { int[] [ int ] = int ; int int = int ( int ) ; switch ( int >>> NUMBER ) { case NUMBER : case NUMBER : case NUMBER : int += NUMBER ; break; case NUMBER : case NUMBER : case NUMBER : int += NUMBER ; break; case NUMBER : case NUMBER : for ( int int = int ( int + NUMBER ) ; int > NUMBER ; -- int ) { int int = int ( int + NUMBER ) ; int int = int ( int + NUMBER ) ; org.springframework.asm.Label ( int , context . labels ) ; org.springframework.asm.Label ( int + int , context . labels ) ; int += NUMBER ; } int += NUMBER ; break; case NUMBER : case NUMBER : case NUMBER : case NUMBER : case NUMBER : int += NUMBER ; break; default: int += NUMBER ; break; } int int = int ( int ) ; if ( ( int >>> NUMBER ) == NUMBER ) { TypePath org.springframework.asm.TypePath = int == NUMBER ? null : new TypePath ( byte[] , int ) ; int += NUMBER + NUMBER * int ; int = int ( int + NUMBER , char[] , true , org.springframework.asm.MethodVisitor . visitTryCatchAnnotation ( int , org.springframework.asm.TypePath , java.lang.String ( int , char[] ) , boolean ) ) ; } else { int = int ( int + NUMBER + NUMBER * int , char[] , true , null ) ; } } return int[] ; }  <METHOD_END>
<METHOD_START> private int int ( final Context org.springframework.asm.Context , int int ) { int int = int ( int ) ; switch ( int >>> NUMBER ) { case NUMBER : case NUMBER : case NUMBER : int &= NUMBER ; int += NUMBER ; break; case NUMBER : case NUMBER : case NUMBER : int &= NUMBER ; int += NUMBER ; break; case NUMBER : case NUMBER : { int &= NUMBER ; int int = int ( int + NUMBER ) ; context . start = new Label [ int ] ; context . end = new Label [ int ] ; context . index = new int [ int ] ; int += NUMBER ; for ( int int = NUMBER ; int < int ; ++ int ) { int int = int ( int ) ; int int = int ( int + NUMBER ) ; context . start [ int ] = org.springframework.asm.Label ( int , context . labels ) ; context . end [ int ] = org.springframework.asm.Label ( int + int , context . labels ) ; context . index [ int ] = int ( int + NUMBER ) ; int += NUMBER ; } break; } case NUMBER : case NUMBER : case NUMBER : case NUMBER : case NUMBER : int &= NUMBER ; int += NUMBER ; break; default: int &= ( int >>> NUMBER ) < NUMBER ? NUMBER : NUMBER ; int += NUMBER ; break; } int int = int ( int ) ; context . typeRef = int ; context . typePath = int == NUMBER ? null : new TypePath ( byte[] , int ) ; return int + NUMBER + NUMBER * int ; }  <METHOD_END>
<METHOD_START> private void void ( final MethodVisitor org.springframework.asm.MethodVisitor , final Context org.springframework.asm.Context , int int , final boolean boolean ) { int int ; int int = byte[] [ int ++ ] & NUMBER ; int int = Type . getArgumentTypes ( context . desc ) . length - int ; AnnotationVisitor org.springframework.asm.AnnotationVisitor ; for ( int = NUMBER ; int < int ; ++ int ) { org.springframework.asm.AnnotationVisitor = org.springframework.asm.MethodVisitor . visitParameterAnnotation ( int , STRING , false ) ; if ( org.springframework.asm.AnnotationVisitor != null ) { org.springframework.asm.AnnotationVisitor . visitEnd ( ) ; } } char [] char[] = context . buffer ; for (; int < int + int ; ++ int ) { int int = int ( int ) ; int += NUMBER ; for (; int > NUMBER ; -- int ) { org.springframework.asm.AnnotationVisitor = org.springframework.asm.MethodVisitor . visitParameterAnnotation ( int , java.lang.String ( int , char[] ) , boolean ) ; int = int ( int + NUMBER , char[] , true , org.springframework.asm.AnnotationVisitor ) ; } } }  <METHOD_END>
<METHOD_START> private int int ( int int , final char [] char[] , final boolean boolean , final AnnotationVisitor org.springframework.asm.AnnotationVisitor ) { int int = int ( int ) ; int += NUMBER ; if ( boolean ) { for (; int > NUMBER ; -- int ) { int = int ( int + NUMBER , char[] , java.lang.String ( int , char[] ) , org.springframework.asm.AnnotationVisitor ) ; } } else { for (; int > NUMBER ; -- int ) { int = int ( int , char[] , null , org.springframework.asm.AnnotationVisitor ) ; } } if ( org.springframework.asm.AnnotationVisitor != null ) { org.springframework.asm.AnnotationVisitor . visitEnd ( ) ; } return int ; }  <METHOD_END>
<METHOD_START> private int int ( int int , final char [] char[] , final java.lang.String java.lang.String , final AnnotationVisitor org.springframework.asm.AnnotationVisitor ) { int int ; if ( org.springframework.asm.AnnotationVisitor == null ) { switch ( byte[] [ int ] & NUMBER ) { case 'e' : return int + NUMBER ; case '@' : return int ( int + NUMBER , char[] , true , null ) ; case '[' : return int ( int + NUMBER , char[] , false , null ) ; default: return int + NUMBER ; } } switch ( byte[] [ int ++ ] & NUMBER ) { case 'I' : case 'J' : case 'F' : case 'D' : org.springframework.asm.AnnotationVisitor . visit ( java.lang.String , java.lang.Object ( int ( int ) , char[] ) ) ; int += NUMBER ; break; case 'B' : org.springframework.asm.AnnotationVisitor . visit ( java.lang.String , ( byte ) int ( int[] [ int ( int ) ] ) ) ; int += NUMBER ; break; case 'Z' : org.springframework.asm.AnnotationVisitor . visit ( java.lang.String , int ( int[] [ int ( int ) ] ) == NUMBER ? java.lang.Boolean . java.lang.Boolean : java.lang.Boolean . java.lang.Boolean ) ; int += NUMBER ; break; case 'S' : org.springframework.asm.AnnotationVisitor . visit ( java.lang.String , ( short ) int ( int[] [ int ( int ) ] ) ) ; int += NUMBER ; break; case 'C' : org.springframework.asm.AnnotationVisitor . visit ( java.lang.String , ( char ) int ( int[] [ int ( int ) ] ) ) ; int += NUMBER ; break; case 's' : org.springframework.asm.AnnotationVisitor . visit ( java.lang.String , java.lang.String ( int , char[] ) ) ; int += NUMBER ; break; case 'e' : org.springframework.asm.AnnotationVisitor . visitEnum ( java.lang.String , java.lang.String ( int , char[] ) , java.lang.String ( int + NUMBER , char[] ) ) ; int += NUMBER ; break; case 'c' : org.springframework.asm.AnnotationVisitor . visit ( java.lang.String , Type . getType ( java.lang.String ( int , char[] ) ) ) ; int += NUMBER ; break; case '@' : int = int ( int + NUMBER , char[] , true , org.springframework.asm.AnnotationVisitor . visitAnnotation ( java.lang.String , java.lang.String ( int , char[] ) ) ) ; break; case '[' : int int = int ( int ) ; int += NUMBER ; if ( int == NUMBER ) { return int ( int - NUMBER , char[] , false , org.springframework.asm.AnnotationVisitor . visitArray ( java.lang.String ) ) ; } switch ( this . byte[] [ int ++ ] & NUMBER ) { case 'B' : byte [] byte[] = new byte [ int ] ; for ( int = NUMBER ; int < int ; int ++ ) { byte[] [ int ] = ( byte ) int ( int[] [ int ( int ) ] ) ; int += NUMBER ; } org.springframework.asm.AnnotationVisitor . visit ( java.lang.String , byte[] ) ; -- int ; break; case 'Z' : boolean [] boolean[] = new boolean [ int ] ; for ( int = NUMBER ; int < int ; int ++ ) { boolean[] [ int ] = int ( int[] [ int ( int ) ] ) != NUMBER ; int += NUMBER ; } org.springframework.asm.AnnotationVisitor . visit ( java.lang.String , boolean[] ) ; -- int ; break; case 'S' : short [] short[] = new short [ int ] ; for ( int = NUMBER ; int < int ; int ++ ) { short[] [ int ] = ( short ) int ( int[] [ int ( int ) ] ) ; int += NUMBER ; } org.springframework.asm.AnnotationVisitor . visit ( java.lang.String , short[] ) ; -- int ; break; case 'C' : char [] char[] = new char [ int ] ; for ( int = NUMBER ; int < int ; int ++ ) { char[] [ int ] = ( char ) int ( int[] [ int ( int ) ] ) ; int += NUMBER ; } org.springframework.asm.AnnotationVisitor . visit ( java.lang.String , char[] ) ; -- int ; break; case 'I' : int [] int[] = new int [ int ] ; for ( int = NUMBER ; int < int ; int ++ ) { int[] [ int ] = int ( int[] [ int ( int ) ] ) ; int += NUMBER ; } org.springframework.asm.AnnotationVisitor . visit ( java.lang.String , int[] ) ; -- int ; break; case 'J' : long [] long[] = new long [ int ] ; for ( int = NUMBER ; int < int ; int ++ ) { long[] [ int ] = long ( int[] [ int ( int ) ] ) ; int += NUMBER ; } org.springframework.asm.AnnotationVisitor . visit ( java.lang.String , long[] ) ; -- int ; break; case 'F' : float [] float[] = new float [ int ] ; for ( int = NUMBER ; int < int ; int ++ ) { float[] [ int ] = java.lang.Float . float ( int ( int[] [ int ( int ) ] ) ) ; int += NUMBER ; } org.springframework.asm.AnnotationVisitor . visit ( java.lang.String , float[] ) ; -- int ; break; case 'D' : double [] double[] = new double [ int ] ; for ( int = NUMBER ; int < int ; int ++ ) { double[] [ int ] = java.lang.Double . double ( long ( int[] [ int ( int ) ] ) ) ; int += NUMBER ; } org.springframework.asm.AnnotationVisitor . visit ( java.lang.String , double[] ) ; -- int ; break; default: int = int ( int - NUMBER , char[] , false , org.springframework.asm.AnnotationVisitor . visitArray ( java.lang.String ) ) ; } } return int ; }  <METHOD_END>
<METHOD_START> private void void ( final Context org.springframework.asm.Context ) { java.lang.String java.lang.String = frame . desc ; java.lang.Object [] java.lang.Object[] = frame . local ; int int = NUMBER ; if ( ( frame . access & Opcodes . ACC_STATIC ) == NUMBER ) { if ( STRING . boolean ( frame . name ) ) { java.lang.Object[] [ int ++ ] = Opcodes . UNINITIALIZED_THIS ; } else { java.lang.Object[] [ int ++ ] = java.lang.String ( int + NUMBER , frame . buffer ) ; } } int int = NUMBER ; loop : while ( true ) { int int = int ; switch ( java.lang.String . char ( int ++ ) ) { case 'Z' : case 'C' : case 'B' : case 'S' : case 'I' : java.lang.Object[] [ int ++ ] = Opcodes . INTEGER ; break; case 'F' : java.lang.Object[] [ int ++ ] = Opcodes . FLOAT ; break; case 'J' : java.lang.Object[] [ int ++ ] = Opcodes . LONG ; break; case 'D' : java.lang.Object[] [ int ++ ] = Opcodes . DOUBLE ; break; case '[' : while ( java.lang.String . char ( int ) == '[' ) { ++ int ; } if ( java.lang.String . char ( int ) == 'L' ) { ++ int ; while ( java.lang.String . char ( int ) != ';' ) { ++ int ; } } java.lang.Object[] [ int ++ ] = java.lang.String . java.lang.String ( int , ++ int ) ; break; case 'L' : while ( java.lang.String . char ( int ) != ';' ) { ++ int ; } java.lang.Object[] [ int ++ ] = java.lang.String . java.lang.String ( int + NUMBER , int ++ ) ; break; default: break loop ; } } frame . localCount = int ; }  <METHOD_END>
<METHOD_START> private int int ( int int , boolean boolean , boolean boolean , Context org.springframework.asm.Context ) { char [] char[] = frame . buffer ; Label [] org.springframework.asm.Label[] = frame . labels ; int int ; int int ; if ( boolean ) { int = byte[] [ int ++ ] & NUMBER ; } else { int = MethodWriter . FULL_FRAME ; frame . offset = - NUMBER ; } frame . localDiff = NUMBER ; if ( int < MethodWriter . SAME_LOCALS_1_STACK_ITEM_FRAME ) { int = int ; frame . mode = Opcodes . F_SAME ; frame . stackCount = NUMBER ; } else if ( int < MethodWriter . RESERVED ) { int = int - MethodWriter . SAME_LOCALS_1_STACK_ITEM_FRAME ; int = int ( frame . stack , NUMBER , int , char[] , org.springframework.asm.Label[] ) ; frame . mode = Opcodes . F_SAME1 ; frame . stackCount = NUMBER ; } else { int = int ( int ) ; int += NUMBER ; if ( int == MethodWriter . SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED ) { int = int ( frame . stack , NUMBER , int , char[] , org.springframework.asm.Label[] ) ; frame . mode = Opcodes . F_SAME1 ; frame . stackCount = NUMBER ; } else if ( int >= MethodWriter . CHOP_FRAME && int < MethodWriter . SAME_FRAME_EXTENDED ) { frame . mode = Opcodes . F_CHOP ; frame . localDiff = MethodWriter . SAME_FRAME_EXTENDED - int ; frame . localCount -= frame . localDiff ; frame . stackCount = NUMBER ; } else if ( int == MethodWriter . SAME_FRAME_EXTENDED ) { frame . mode = Opcodes . F_SAME ; frame . stackCount = NUMBER ; } else if ( int < MethodWriter . FULL_FRAME ) { int int = boolean ? frame . localCount : NUMBER ; for ( int int = int - MethodWriter . SAME_FRAME_EXTENDED ; int > NUMBER ; int -- ) { int = int ( frame . local , int ++ , int , char[] , org.springframework.asm.Label[] ) ; } frame . mode = Opcodes . F_APPEND ; frame . localDiff = int - MethodWriter . SAME_FRAME_EXTENDED ; frame . localCount += frame . localDiff ; frame . stackCount = NUMBER ; } else { frame . mode = Opcodes . F_FULL ; int int = int ( int ) ; int += NUMBER ; frame . localDiff = int ; frame . localCount = int ; for ( int int = NUMBER ; int > NUMBER ; int -- ) { int = int ( frame . local , int ++ , int , char[] , org.springframework.asm.Label[] ) ; } int = int ( int ) ; int += NUMBER ; frame . stackCount = int ; for ( int int = NUMBER ; int > NUMBER ; int -- ) { int = int ( frame . stack , int ++ , int , char[] , org.springframework.asm.Label[] ) ; } } } frame . offset += int + NUMBER ; org.springframework.asm.Label ( frame . offset , org.springframework.asm.Label[] ) ; return int ; }  <METHOD_END>
<METHOD_START> private int int ( final java.lang.Object [] java.lang.Object[] , final int int , int int , final char [] char[] , final Label [] org.springframework.asm.Label[] ) { int int = byte[] [ int ++ ] & NUMBER ; switch ( int ) { case NUMBER : java.lang.Object[] [ int ] = Opcodes . TOP ; break; case NUMBER : java.lang.Object[] [ int ] = Opcodes . INTEGER ; break; case NUMBER : java.lang.Object[] [ int ] = Opcodes . FLOAT ; break; case NUMBER : java.lang.Object[] [ int ] = Opcodes . DOUBLE ; break; case NUMBER : java.lang.Object[] [ int ] = Opcodes . LONG ; break; case NUMBER : java.lang.Object[] [ int ] = Opcodes . NULL ; break; case NUMBER : java.lang.Object[] [ int ] = Opcodes . UNINITIALIZED_THIS ; break; case NUMBER : java.lang.Object[] [ int ] = java.lang.String ( int , char[] ) ; int += NUMBER ; break; default: java.lang.Object[] [ int ] = org.springframework.asm.Label ( int ( int ) , org.springframework.asm.Label[] ) ; int += NUMBER ; } return int ; }  <METHOD_END>
<METHOD_START> protected org.springframework.asm.Label org.springframework.asm.Label ( int int , Label [] org.springframework.asm.Label[] ) { if ( int >= labels . length ) { return new Label ( ) ; } if ( org.springframework.asm.Label[] [ int ] == null ) { org.springframework.asm.Label[] [ int ] = new Label ( ) ; } return org.springframework.asm.Label[] [ int ] ; }  <METHOD_END>
<METHOD_START> private int int ( ) { int int = int + NUMBER + int ( int + NUMBER ) * NUMBER ; for ( int int = int ( int ) ; int > NUMBER ; -- int ) { for ( int int = int ( int + NUMBER ) ; int > NUMBER ; -- int ) { int += NUMBER + int ( int + NUMBER ) ; } int += NUMBER ; } int += NUMBER ; for ( int int = int ( int ) ; int > NUMBER ; -- int ) { for ( int int = int ( int + NUMBER ) ; int > NUMBER ; -- int ) { int += NUMBER + int ( int + NUMBER ) ; } int += NUMBER ; } return int + NUMBER ; }  <METHOD_END>
<METHOD_START> private org.springframework.asm.Attribute org.springframework.asm.Attribute ( final Attribute [] org.springframework.asm.Attribute[] , final java.lang.String java.lang.String , final int int , final int int , final char [] char[] , final int int , final Label [] org.springframework.asm.Label[] ) { for ( int int = NUMBER ; int < attrs . length ; ++ int ) { if ( org.springframework.asm.Attribute[] [ int ] . type . equals ( java.lang.String ) ) { return org.springframework.asm.Attribute[] [ int ] . read ( this , int , int , char[] , int , org.springframework.asm.Label[] ) ; } } return new Attribute ( java.lang.String ) . read ( this , int , int , null , - NUMBER , null ) ; }  <METHOD_END>
<METHOD_START> public int int ( ) { return int[] . int ; }  <METHOD_END>
<METHOD_START> public int int ( final int int ) { return int[] [ int ] ; }  <METHOD_END>
<METHOD_START> public int int ( ) { return int ; }  <METHOD_END>
<METHOD_START> public int int ( final int int ) { return byte[] [ int ] & NUMBER ; }  <METHOD_END>
<METHOD_START> public int int ( final int int ) { byte [] byte[] = this . byte[] ; return ( ( byte[] [ int ] & NUMBER ) << NUMBER ) | ( byte[] [ int + NUMBER ] & NUMBER ) ; }  <METHOD_END>
<METHOD_START> public short short ( final int int ) { byte [] byte[] = this . byte[] ; return ( short ) ( ( ( byte[] [ int ] & NUMBER ) << NUMBER ) | ( byte[] [ int + NUMBER ] & NUMBER ) ) ; }  <METHOD_END>
<METHOD_START> public int int ( final int int ) { byte [] byte[] = this . byte[] ; return ( ( byte[] [ int ] & NUMBER ) << NUMBER ) | ( ( byte[] [ int + NUMBER ] & NUMBER ) << NUMBER ) | ( ( byte[] [ int + NUMBER ] & NUMBER ) << NUMBER ) | ( byte[] [ int + NUMBER ] & NUMBER ) ; }  <METHOD_END>
<METHOD_START> public long long ( final int int ) { long long = int ( int ) ; long long = int ( int + NUMBER ) & NUMBER ; return ( long << NUMBER ) | long ; }  <METHOD_END>
<METHOD_START> public java.lang.String java.lang.String ( int int , final char [] char[] ) { int int = int ( int ) ; if ( int == NUMBER || int == NUMBER ) { return null ; } java.lang.String java.lang.String = java.lang.String[] [ int ] ; if ( java.lang.String != null ) { return java.lang.String ; } int = int[] [ int ] ; return java.lang.String[] [ int ] = java.lang.String ( int + NUMBER , int ( int ) , char[] ) ; }  <METHOD_END>
<METHOD_START> private java.lang.String java.lang.String ( int int , final int int , final char [] char[] ) { int int = int + int ; byte [] byte[] = this . byte[] ; int int = NUMBER ; int int ; int int = NUMBER ; char char = NUMBER ; while ( int < int ) { int = byte[] [ int ++ ] ; switch ( int ) { case NUMBER : int = int & NUMBER ; if ( int < NUMBER ) { char[] [ int ++ ] = ( char ) int ; } else if ( int < NUMBER && int > NUMBER ) { char = ( char ) ( int & NUMBER ) ; int = NUMBER ; } else { char = ( char ) ( int & NUMBER ) ; int = NUMBER ; } break; case NUMBER : char[] [ int ++ ] = ( char ) ( ( char << NUMBER ) | ( int & NUMBER ) ) ; int = NUMBER ; break; case NUMBER : char = ( char ) ( ( char << NUMBER ) | ( int & NUMBER ) ) ; int = NUMBER ; break; } } return new java.lang.String ( char[] , NUMBER , int ) ; }  <METHOD_END>
<METHOD_START> public java.lang.String java.lang.String ( final int int , final char [] char[] ) { java.lang.String java.lang.String = java.lang.String ( int[] [ int ( int ) ] , char[] ) ; return ( java.lang.String != null ? java.lang.String . java.lang.String ( ) : null ) ; }  <METHOD_END>
<METHOD_START> public java.lang.Object java.lang.Object ( final int int , final char [] char[] ) { int int = int[] [ int ] ; switch ( byte[] [ int - NUMBER ] ) { case ClassWriter . INT : return int ( int ) ; case ClassWriter . FLOAT : return java.lang.Float . float ( int ( int ) ) ; case ClassWriter . LONG : return long ( int ) ; case ClassWriter . DOUBLE : return java.lang.Double . double ( long ( int ) ) ; case ClassWriter . CLASS : return Type . getObjectType ( java.lang.String ( int , char[] ) ) ; case ClassWriter . STR : return java.lang.String ( int , char[] ) ; case ClassWriter . MTYPE : return Type . getMethodType ( java.lang.String ( int , char[] ) ) ; default: int int = int ( int ) ; int [] int[] = this . int[] ; int int = int[] [ int ( int + NUMBER ) ] ; boolean boolean = byte[] [ int - NUMBER ] == ClassWriter . IMETH ; java.lang.String java.lang.String = java.lang.String ( int , char[] ) ; int = int[] [ int ( int + NUMBER ) ] ; java.lang.String java.lang.String = java.lang.String ( int , char[] ) ; java.lang.String java.lang.String = java.lang.String ( int + NUMBER , char[] ) ; return new Handle ( int , java.lang.String , java.lang.String , java.lang.String , boolean ) ; } }  <METHOD_END>
