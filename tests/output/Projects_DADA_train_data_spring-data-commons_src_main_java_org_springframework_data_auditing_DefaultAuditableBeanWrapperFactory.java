<METHOD_START> @ java.lang.SuppressWarnings ( STRING ) public java.util.Optional<org.springframework.data.auditing.AuditableBeanWrapper> < AuditableBeanWrapper > java.util.Optional<org.springframework.data.auditing.AuditableBeanWrapper> ( java.lang.Object java.lang.Object ) { Assert . notNull ( java.lang.Object , STRING ) ; return java.util.Optional . java.util.Optional<java.lang.Object> ( java.lang.Object ) . java.util.Optional<org.springframework.data.auditing.AuditableBeanWrapper> ( java.lang.Object -> { if ( java.lang.Object instanceof Auditable ) { return new org.springframework.data.auditing.DefaultAuditableBeanWrapperFactory.AuditableInterfaceBeanWrapper ( ( Auditable < java.lang.Object , ? , java.time.temporal.TemporalAccessor > ) java.lang.Object ) ; } AnnotationAuditingMetadata org.springframework.data.auditing.AnnotationAuditingMetadata = AnnotationAuditingMetadata . getMetadata ( java.lang.Object . java.lang.Class<? extends java.lang.Object> ( ) ) ; if ( org.springframework.data.auditing.AnnotationAuditingMetadata . isAuditable ( ) ) { return new org.springframework.data.auditing.DefaultAuditableBeanWrapperFactory.ReflectionAuditingBeanWrapper ( java.lang.Object ) ; } return null ; } ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.SuppressWarnings ( STRING ) public void ( Auditable < java.lang.Object , ? , java.time.temporal.TemporalAccessor > org.springframework.data.auditing.Auditable<java.lang.Object,?,java.time.temporal.TemporalAccessor> ) { this . org.springframework.data.auditing.Auditable<java.lang.Object,?,java.time.temporal.TemporalAccessor> = org.springframework.data.auditing.Auditable<java.lang.Object,,java.time.temporal.TemporalAccessor> ; this . java.lang.Class<? extends java.time.temporal.TemporalAccessor> = ( java.lang.Class<? extends java.time.temporal.TemporalAccessor> < ? extends java.time.temporal.TemporalAccessor > ) ResolvableType . forClass ( Auditable .class , org.springframework.data.auditing.Auditable<java.lang.Object,,java.time.temporal.TemporalAccessor> . getClass ( ) ) . getGeneric ( NUMBER ) . getRawClass ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.Object java.lang.Object ( java.lang.Object java.lang.Object ) { org.springframework.data.auditing.Auditable<java.lang.Object,,java.time.temporal.TemporalAccessor> . setCreatedBy ( java.lang.Object ) ; return java.lang.Object ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.time.temporal.TemporalAccessor java.time.temporal.TemporalAccessor ( java.time.temporal.TemporalAccessor java.time.temporal.TemporalAccessor ) { org.springframework.data.auditing.Auditable<java.lang.Object,,java.time.temporal.TemporalAccessor> . setCreatedDate ( java.util.Optional<> ( java.util.Optional . java.util.Optional<java.time.temporal.TemporalAccessor> ( java.time.temporal.TemporalAccessor ) , java.lang.Class<> ) . orElseThrow ( ( ) new java.lang.IllegalStateException ( ) ) ) ; return java.time.temporal.TemporalAccessor ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.Object java.lang.Object ( java.lang.Object java.lang.Object ) { org.springframework.data.auditing.Auditable<java.lang.Object,,java.time.temporal.TemporalAccessor> . setLastModifiedBy ( java.lang.Object ) ; return java.lang.Object ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.util.Optional<java.time.temporal.TemporalAccessor> < java.time.temporal.TemporalAccessor > java.util.Optional<java.time.temporal.TemporalAccessor> ( ) { return java.util.Optional ( org.springframework.data.auditing.Auditable<java.lang.Object,,java.time.temporal.TemporalAccessor> . getLastModifiedDate ( ) , java.time.temporal.TemporalAccessor .class ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.time.temporal.TemporalAccessor java.time.temporal.TemporalAccessor ( java.time.temporal.TemporalAccessor java.time.temporal.TemporalAccessor ) { org.springframework.data.auditing.Auditable<java.lang.Object,,java.time.temporal.TemporalAccessor> . setLastModifiedDate ( java.util.Optional<> ( java.util.Optional . java.util.Optional<java.time.temporal.TemporalAccessor> ( java.time.temporal.TemporalAccessor ) , java.lang.Class<> ) . orElseThrow ( ( ) new java.lang.IllegalStateException ( ) ) ) ; return java.time.temporal.TemporalAccessor ; }  <METHOD_END>
<METHOD_START> public void ( ) { DefaultFormattingConversionService org.springframework.data.auditing.DefaultFormattingConversionService = new DefaultFormattingConversionService ( ) ; JodaTimeConverters . getConvertersToRegister ( ) . forEach ( org.springframework.data.auditing.DefaultFormattingConversionService :: addConverter ) ; Jsr310Converters . getConvertersToRegister ( ) . forEach ( org.springframework.data.auditing.DefaultFormattingConversionService :: addConverter ) ; ThreeTenBackPortConverters . getConvertersToRegister ( ) . forEach ( org.springframework.data.auditing.DefaultFormattingConversionService :: addConverter ) ; this . org.springframework.data.auditing.ConversionService = org.springframework.data.auditing.DefaultFormattingConversionService ; }  <METHOD_END>
<METHOD_START> protected java.lang.Object java.lang.Object ( java.time.temporal.TemporalAccessor java.time.temporal.TemporalAccessor , java.lang.Class<?> < ? > java.lang.Class<?> , java.lang.Object java.lang.Object ) { if ( java.time.temporal.TemporalAccessor .class . boolean ( java.lang.Class<> ) ) { return java.time.temporal.TemporalAccessor ; } if ( org.springframework.data.auditing.ConversionService . canConvert ( java.time.temporal.TemporalAccessor . java.lang.Class<? extends java.time.temporal.TemporalAccessor> ( ) , java.lang.Class<> ) ) { return org.springframework.data.auditing.ConversionService . convert ( java.time.temporal.TemporalAccessor , java.lang.Class<> ) ; } if ( org.springframework.data.auditing.ConversionService . canConvert ( java.util.Date .class , java.lang.Class<> ) ) { if ( ! org.springframework.data.auditing.ConversionService . canConvert ( java.time.temporal.TemporalAccessor . java.lang.Class<? extends java.time.temporal.TemporalAccessor> ( ) , java.util.Date .class ) ) { throw new java.lang.IllegalArgumentException ( java.lang.String . java.lang.String ( STRING , java.lang.Object , java.time.temporal.TemporalAccessor . java.lang.Class<? extends java.time.temporal.TemporalAccessor> ( ) , java.lang.Class<> ) ) ; } java.util.Date java.util.Date = org.springframework.data.auditing.ConversionService . convert ( java.time.temporal.TemporalAccessor , java.util.Date .class ) ; return org.springframework.data.auditing.ConversionService . convert ( java.util.Date , java.lang.Class<> ) ; } throw new java.lang.IllegalArgumentException ( java.lang.String . java.lang.String ( STRING , java.lang.Object , AnnotationAuditingMetadata . SUPPORTED_DATE_TYPES ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.SuppressWarnings ( STRING ) protected < T extends java.time.temporal.TemporalAccessor > java.util.Optional<T> < T > java.util.Optional<T> ( java.util.Optional<? extends java.lang.Object> < ? extends java.lang.Object > java.util.Optional<? extends java.lang.Object> , java.lang.Class<? extends T> < ? extends T > java.lang.Class<? extends T> ) { return java.util.Optional<> . java.util.Optional<T> ( it -> java.lang.Class<> . boolean ( it ) ? ( T ) it : org.springframework.data.auditing.ConversionService . convert ( it , java.lang.Class<> ) ) ; }  <METHOD_END>
<METHOD_START> public void ( java.lang.Object java.lang.Object ) { Assert . notNull ( java.lang.Object , STRING ) ; this . org.springframework.data.auditing.AnnotationAuditingMetadata = AnnotationAuditingMetadata . getMetadata ( java.lang.Object . java.lang.Class<? extends java.lang.Object> ( ) ) ; this . java.lang.Object = java.lang.Object ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.Object java.lang.Object ( java.lang.Object java.lang.Object ) { return java.lang.Object ( org.springframework.data.auditing.AnnotationAuditingMetadata . getCreatedByField ( ) , java.lang.Object ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.time.temporal.TemporalAccessor java.time.temporal.TemporalAccessor ( java.time.temporal.TemporalAccessor java.time.temporal.TemporalAccessor ) { return java.time.temporal.TemporalAccessor ( org.springframework.data.auditing.AnnotationAuditingMetadata . getCreatedDateField ( ) , java.time.temporal.TemporalAccessor ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.Object java.lang.Object ( java.lang.Object java.lang.Object ) { return java.lang.Object ( org.springframework.data.auditing.AnnotationAuditingMetadata . getLastModifiedByField ( ) , java.lang.Object ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.util.Optional<java.time.temporal.TemporalAccessor> < java.time.temporal.TemporalAccessor > java.util.Optional<java.time.temporal.TemporalAccessor> ( ) { return java.util.Optional ( org.springframework.data.auditing.AnnotationAuditingMetadata . getLastModifiedDateField ( ) . map ( field -> { Object value = org . springframework . util . ReflectionUtils . getField ( field , target ) ; return Optional .class . isInstance ( value ) ? ( ( Optional < ? > ) value ) . orElse ( null ) : value ; } ) , java.time.temporal.TemporalAccessor .class ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.time.temporal.TemporalAccessor java.time.temporal.TemporalAccessor ( java.time.temporal.TemporalAccessor java.time.temporal.TemporalAccessor ) { return java.time.temporal.TemporalAccessor ( org.springframework.data.auditing.AnnotationAuditingMetadata . getLastModifiedDateField ( ) , java.time.temporal.TemporalAccessor ) ; }  <METHOD_END>
<METHOD_START> private < T > T T ( java.util.Optional<java.lang.reflect.Field> < java.lang.reflect.Field > java.util.Optional<java.lang.reflect.Field> , T T ) { java.util.Optional<java.lang.reflect.Field> . void ( java.lang.reflect.Field -> ReflectionUtils . setField ( java.lang.reflect.Field , java.lang.Object , T ) ) ; return T ; }  <METHOD_END>
<METHOD_START> private java.time.temporal.TemporalAccessor java.time.temporal.TemporalAccessor ( java.util.Optional<java.lang.reflect.Field> < java.lang.reflect.Field > java.util.Optional<java.lang.reflect.Field> , java.time.temporal.TemporalAccessor java.time.temporal.TemporalAccessor ) { java.util.Optional<java.lang.reflect.Field> . void ( java.lang.reflect.Field -> ReflectionUtils . setField ( java.lang.reflect.Field , java.lang.Object , java.lang.Object ( java.time.temporal.TemporalAccessor , java.lang.reflect.Field . java.lang.Class<?> ( ) , java.lang.reflect.Field ) ) ) ; return java.time.temporal.TemporalAccessor ; }  <METHOD_END>
