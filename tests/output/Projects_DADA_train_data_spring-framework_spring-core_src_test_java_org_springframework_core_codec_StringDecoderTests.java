<METHOD_START> @ Test public void void ( ) { assertTrue ( this . org.springframework.core.codec.StringDecoder . canDecode ( ResolvableType . forClass ( java.lang.String .class ) , MimeTypeUtils . TEXT_PLAIN ) ) ; assertTrue ( this . org.springframework.core.codec.StringDecoder . canDecode ( ResolvableType . forClass ( java.lang.String .class ) , MimeTypeUtils . TEXT_HTML ) ) ; assertTrue ( this . org.springframework.core.codec.StringDecoder . canDecode ( ResolvableType . forClass ( java.lang.String .class ) , MimeTypeUtils . APPLICATION_JSON ) ) ; assertFalse ( this . org.springframework.core.codec.StringDecoder . canDecode ( ResolvableType . forClass ( java.lang.Integer .class ) , MimeTypeUtils . TEXT_PLAIN ) ) ; assertFalse ( this . org.springframework.core.codec.StringDecoder . canDecode ( ResolvableType . forClass ( java.lang.Object .class ) , MimeTypeUtils . APPLICATION_JSON ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.InterruptedException { this . org.springframework.core.codec.StringDecoder = StringDecoder . allMimeTypes ( false ) ; Flux < DataBuffer > org.springframework.core.codec.Flux<org.springframework.core.codec.DataBuffer> = Flux . just ( stringBuffer ( STRING ) , stringBuffer ( STRING ) , stringBuffer ( STRING ) ) ; Flux < java.lang.String > org.springframework.core.codec.Flux<java.lang.String> = this . org.springframework.core.codec.StringDecoder . decode ( org.springframework.core.codec.Flux<org.springframework.core.codec.DataBuffer> , ResolvableType . forClass ( java.lang.String .class ) , null , java.util.Collections . java.util.Map<java.lang.Object,java.lang.Object> ( ) ) ; StepVerifier . create ( org.springframework.core.codec.Flux<java.lang.String> ) . expectNext ( STRING , STRING , STRING ) . expectComplete ( ) . verify ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.InterruptedException { DataBuffer org.springframework.core.codec.DataBuffer = stringBuffer ( STRING ) ; DataBuffer org.springframework.core.codec.DataBuffer = stringBuffer ( STRING ) ; Flux < DataBuffer > org.springframework.core.codec.Flux<org.springframework.core.codec.DataBuffer> = Flux . just ( org.springframework.core.codec.DataBuffer , org.springframework.core.codec.DataBuffer ) ; Flux < java.lang.String > org.springframework.core.codec.Flux<java.lang.String> = org.springframework.core.codec.StringDecoder . decode ( org.springframework.core.codec.Flux<org.springframework.core.codec.DataBuffer> , ResolvableType . forClass ( java.lang.String .class ) , null , java.util.Collections . java.util.Map<java.lang.Object,java.lang.Object> ( ) ) ; StepVerifier . create ( org.springframework.core.codec.Flux<java.lang.String> ) . expectNext ( STRING , STRING , STRING , STRING , STRING , STRING ) . expectComplete ( ) . verify ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.InterruptedException { Flux < DataBuffer > org.springframework.core.codec.Flux<org.springframework.core.codec.DataBuffer> = Flux . empty ( ) ; Flux < java.lang.String > org.springframework.core.codec.Flux<java.lang.String> = this . org.springframework.core.codec.StringDecoder . decode ( org.springframework.core.codec.Flux<org.springframework.core.codec.DataBuffer> , ResolvableType . forClass ( java.lang.String .class ) , null , java.util.Collections . java.util.Map<java.lang.Object,java.lang.Object> ( ) ) ; StepVerifier . create ( org.springframework.core.codec.Flux<java.lang.String> ) . expectNextCount ( NUMBER ) . expectComplete ( ) . verify ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.InterruptedException { Flux < DataBuffer > org.springframework.core.codec.Flux<org.springframework.core.codec.DataBuffer> = Flux . just ( stringBuffer ( STRING ) ) ; Flux < java.lang.String > org.springframework.core.codec.Flux<java.lang.String> = this . org.springframework.core.codec.StringDecoder . decode ( org.springframework.core.codec.Flux<org.springframework.core.codec.DataBuffer> , ResolvableType . forClass ( java.lang.String .class ) , null , java.util.Collections . java.util.Map<java.lang.Object,java.lang.Object> ( ) ) ; StepVerifier . create ( org.springframework.core.codec.Flux<java.lang.String> ) . expectNext ( STRING ) . expectComplete ( ) . verify ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.InterruptedException { this . org.springframework.core.codec.StringDecoder = StringDecoder . allMimeTypes ( false ) ; Flux < DataBuffer > org.springframework.core.codec.Flux<org.springframework.core.codec.DataBuffer> = Flux . just ( stringBuffer ( STRING ) , stringBuffer ( STRING ) , stringBuffer ( STRING ) ) ; Mono < java.lang.String > org.springframework.core.codec.Mono<java.lang.String> = this . org.springframework.core.codec.StringDecoder . decodeToMono ( org.springframework.core.codec.Flux<org.springframework.core.codec.DataBuffer> , ResolvableType . forClass ( java.lang.String .class ) , null , java.util.Collections . java.util.Map<java.lang.Object,java.lang.Object> ( ) ) ; StepVerifier . create ( org.springframework.core.codec.Mono<java.lang.String> ) . expectNext ( STRING ) . expectComplete ( ) . verify ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.InterruptedException { Flux < DataBuffer > org.springframework.core.codec.Flux<org.springframework.core.codec.DataBuffer> = Flux . empty ( ) ; Mono < java.lang.String > org.springframework.core.codec.Mono<java.lang.String> = this . org.springframework.core.codec.StringDecoder . decodeToMono ( org.springframework.core.codec.Flux<org.springframework.core.codec.DataBuffer> , ResolvableType . forClass ( java.lang.String .class ) , null , java.util.Collections . java.util.Map<java.lang.Object,java.lang.Object> ( ) ) ; StepVerifier . create ( org.springframework.core.codec.Mono<java.lang.String> ) . expectNextCount ( NUMBER ) . expectComplete ( ) . verify ( ) ; }  <METHOD_END>
