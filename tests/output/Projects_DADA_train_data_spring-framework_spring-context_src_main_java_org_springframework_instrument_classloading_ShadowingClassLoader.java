<METHOD_START> public void ( java.lang.ClassLoader java.lang.ClassLoader ) { Assert . notNull ( java.lang.ClassLoader , STRING ) ; this . java.lang.ClassLoader = java.lang.ClassLoader ; for ( java.lang.String java.lang.String : java.lang.String[] ) { excludePackage ( java.lang.String ) ; } }  <METHOD_END>
<METHOD_START> public void void ( java.lang.instrument.ClassFileTransformer java.lang.instrument.ClassFileTransformer ) { Assert . notNull ( java.lang.instrument.ClassFileTransformer , STRING ) ; this . java.util.List<java.lang.instrument.ClassFileTransformer> . boolean ( java.lang.instrument.ClassFileTransformer ) ; }  <METHOD_END>
<METHOD_START> public void void ( org.springframework.instrument.classloading.ShadowingClassLoader org.springframework.instrument.classloading.ShadowingClassLoader ) { Assert . notNull ( org.springframework.instrument.classloading.ShadowingClassLoader , STRING ) ; this . java.util.List<java.lang.instrument.ClassFileTransformer> . boolean ( org.springframework.instrument.classloading.ShadowingClassLoader . java.util.List<java.lang.instrument.ClassFileTransformer> ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.Class<?> < ? > java.lang.Class<?> ( java.lang.String java.lang.String ) throws java.lang.ClassNotFoundException { if ( boolean ( java.lang.String ) ) { java.lang.Class<?> < ? > java.lang.Class<?> = this . java.util.Map<java.lang.String,java.lang.Class<?>> . java.lang.Class<?> ( java.lang.String ) ; if ( java.lang.Class<> != null ) { return java.lang.Class<> ; } return java.lang.Class<?> ( java.lang.String ) ; } else { return this . java.lang.ClassLoader . java.lang.Class<?> ( java.lang.String ) ; } }  <METHOD_END>
<METHOD_START> private boolean boolean ( java.lang.String java.lang.String ) { return ( ! java.lang.String . boolean ( java.lang.Class<? extends org.springframework.instrument.classloading.ShadowingClassLoader> ( ) . java.lang.String ( ) ) && ! java.lang.String . boolean ( STRING ) && boolean ( java.lang.String ) ) ; }  <METHOD_END>
<METHOD_START> protected boolean boolean ( java.lang.String java.lang.String ) { return ! isExcluded ( java.lang.String ) ; }  <METHOD_END>
<METHOD_START> private java.lang.Class<?> < ? > java.lang.Class<?> ( java.lang.String java.lang.String ) throws java.lang.ClassNotFoundException { java.lang.String java.lang.String = StringUtils . replace ( java.lang.String , STRING , STRING ) + STRING ; java.io.InputStream java.io.InputStream = this . java.lang.ClassLoader . java.io.InputStream ( java.lang.String ) ; if ( java.io.InputStream == null ) { throw new java.lang.ClassNotFoundException ( java.lang.String ) ; } try { byte [] byte[] = FileCopyUtils . copyToByteArray ( java.io.InputStream ) ; byte[] = byte[] ( java.lang.String , byte[] ) ; java.lang.Class<?> < ? > java.lang.Class<?> = defineClass ( java.lang.String , byte[] , NUMBER , byte[] . int ) ; if ( java.lang.Class<> . java.lang.Package ( ) == null ) { int int = java.lang.String . int ( '.' ) ; if ( int != - NUMBER ) { java.lang.String java.lang.String = java.lang.String . java.lang.String ( NUMBER , int ) ; definePackage ( java.lang.String , null , null , null , null , null , null , null ) ; } } this . java.util.Map<java.lang.String,java.lang.Class<?>> . java.lang.Class<?> ( java.lang.String , java.lang.Class<> ) ; return java.lang.Class<> ; } catch ( java.io.IOException java.io.IOException ) { throw new java.lang.ClassNotFoundException ( STRING + java.lang.String + STRING , java.io.IOException ) ; } }  <METHOD_END>
<METHOD_START> private byte [] byte[] ( java.lang.String java.lang.String , byte [] byte[] ) { java.lang.String java.lang.String = StringUtils . replace ( java.lang.String , STRING , STRING ) ; try { for ( java.lang.instrument.ClassFileTransformer java.lang.instrument.ClassFileTransformer : this . java.util.List<java.lang.instrument.ClassFileTransformer> ) { byte [] byte[] = java.lang.instrument.ClassFileTransformer . byte[] ( this , java.lang.String , null , null , byte[] ) ; byte[] = ( byte[] != null ? byte[] : byte[] ) ; } return byte[] ; } catch ( java.lang.instrument.IllegalClassFormatException java.lang.instrument.IllegalClassFormatException ) { throw new java.lang.IllegalStateException ( java.lang.instrument.IllegalClassFormatException ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.net.URL java.net.URL ( java.lang.String java.lang.String ) { return this . java.lang.ClassLoader . java.net.URL ( java.lang.String ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.io.InputStream java.io.InputStream ( java.lang.String java.lang.String ) { return this . java.lang.ClassLoader . java.io.InputStream ( java.lang.String ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.util.Enumeration<java.net.URL> < java.net.URL > java.util.Enumeration<java.net.URL> ( java.lang.String java.lang.String ) throws java.io.IOException { return this . java.lang.ClassLoader . java.util.Enumeration<java.net.URL> ( java.lang.String ) ; }  <METHOD_END>
