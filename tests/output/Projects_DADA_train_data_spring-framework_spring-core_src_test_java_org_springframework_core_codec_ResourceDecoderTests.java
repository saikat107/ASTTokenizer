<METHOD_START> @ Test public void void ( ) java.lang.Exception { assertTrue ( this . org.springframework.core.codec.ResourceDecoder . canDecode ( ResolvableType . forClass ( InputStreamResource .class ) , MimeTypeUtils . TEXT_PLAIN ) ) ; assertTrue ( this . org.springframework.core.codec.ResourceDecoder . canDecode ( ResolvableType . forClass ( ByteArrayResource .class ) , MimeTypeUtils . TEXT_PLAIN ) ) ; assertTrue ( this . org.springframework.core.codec.ResourceDecoder . canDecode ( ResolvableType . forClass ( Resource .class ) , MimeTypeUtils . TEXT_PLAIN ) ) ; assertTrue ( this . org.springframework.core.codec.ResourceDecoder . canDecode ( ResolvableType . forClass ( InputStreamResource .class ) , MimeTypeUtils . APPLICATION_JSON ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { DataBuffer org.springframework.core.codec.DataBuffer = stringBuffer ( STRING ) ; DataBuffer org.springframework.core.codec.DataBuffer = stringBuffer ( STRING ) ; Flux < DataBuffer > org.springframework.core.codec.Flux<org.springframework.core.codec.DataBuffer> = Flux . just ( org.springframework.core.codec.DataBuffer , org.springframework.core.codec.DataBuffer ) ; Flux < Resource > org.springframework.core.codec.Flux<org.springframework.core.codec.Resource> = this . org.springframework.core.codec.ResourceDecoder . decode ( org.springframework.core.codec.Flux<org.springframework.core.codec.DataBuffer> , ResolvableType . forClass ( Resource .class ) , null , java.util.Collections . java.util.Map<java.lang.Object,java.lang.Object> ( ) ) ; StepVerifier . create ( org.springframework.core.codec.Flux<org.springframework.core.codec.Resource> ) . consumeNextWith ( resource -> { try { byte [] bytes = StreamUtils . copyToByteArray ( resource . getInputStream ( ) ) ; assertEquals ( STRING , new String ( bytes ) ) ; } catch ( IOException e ) { fail ( e . getMessage ( ) ) ; } } ) . expectComplete ( ) . verify ( ) ; }  <METHOD_END>
