<METHOD_START> public void ( ) { this . org.springframework.integration.support.json.ObjectMapper = new ObjectMapper ( ) ; this . org.springframework.integration.support.json.ObjectMapper . configure ( MapperFeature . DEFAULT_VIEW_INCLUSION , false ) ; this . org.springframework.integration.support.json.ObjectMapper . configure ( DeserializationFeature . FAIL_ON_UNKNOWN_PROPERTIES , false ) ; }  <METHOD_END>
<METHOD_START> public void ( ObjectMapper org.springframework.integration.support.json.ObjectMapper ) { Assert . notNull ( org.springframework.integration.support.json.ObjectMapper , STRING ) ; this . org.springframework.integration.support.json.ObjectMapper = org.springframework.integration.support.json.ObjectMapper ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.String java.lang.String ( java.lang.Object java.lang.Object ) throws java.lang.Exception { return this . org.springframework.integration.support.json.ObjectMapper . writeValueAsString ( java.lang.Object ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( java.lang.Object java.lang.Object , java.io.Writer java.io.Writer ) throws java.lang.Exception { this . org.springframework.integration.support.json.ObjectMapper . writeValue ( java.io.Writer , java.lang.Object ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.integration.support.json.JsonNode org.springframework.integration.support.json.JsonNode ( java.lang.Object java.lang.Object ) throws java.lang.Exception { return this . org.springframework.integration.support.json.ObjectMapper . valueToTree ( java.lang.Object ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected < T > T T ( java.lang.Object java.lang.Object , JavaType org.springframework.integration.support.json.JavaType ) throws java.lang.Exception { if ( java.lang.Object instanceof java.lang.String ) { return this . org.springframework.integration.support.json.ObjectMapper . readValue ( ( java.lang.String ) java.lang.Object , org.springframework.integration.support.json.JavaType ) ; } else if ( java.lang.Object instanceof byte [] ) { return this . org.springframework.integration.support.json.ObjectMapper . readValue ( ( byte [] ) java.lang.Object , org.springframework.integration.support.json.JavaType ) ; } else if ( java.lang.Object instanceof java.io.File ) { return this . org.springframework.integration.support.json.ObjectMapper . readValue ( ( java.io.File ) java.lang.Object , org.springframework.integration.support.json.JavaType ) ; } else if ( java.lang.Object instanceof java.net.URL ) { return this . org.springframework.integration.support.json.ObjectMapper . readValue ( ( java.net.URL ) java.lang.Object , org.springframework.integration.support.json.JavaType ) ; } else if ( java.lang.Object instanceof java.io.InputStream ) { return this . org.springframework.integration.support.json.ObjectMapper . readValue ( ( java.io.InputStream ) java.lang.Object , org.springframework.integration.support.json.JavaType ) ; } else if ( java.lang.Object instanceof java.io.Reader ) { return this . org.springframework.integration.support.json.ObjectMapper . readValue ( ( java.io.Reader ) java.lang.Object , org.springframework.integration.support.json.JavaType ) ; } else { throw new java.lang.IllegalArgumentException ( STRING + supportedJsonTypes + STRING + java.lang.Object . java.lang.Class<? extends java.lang.Object> ( ) ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public < T > T T ( JsonParser org.springframework.integration.support.json.JsonParser , java.lang.reflect.Type java.lang.reflect.Type ) throws java.lang.Exception { return this . org.springframework.integration.support.json.ObjectMapper . readValue ( org.springframework.integration.support.json.JsonParser , org.springframework.integration.support.json.JavaType ( java.lang.reflect.Type ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override @ java.lang.SuppressWarnings ( { STRING } ) protected org.springframework.integration.support.json.JavaType org.springframework.integration.support.json.JavaType ( java.util.Map<java.lang.String,java.lang.Object> < java.lang.String , java.lang.Object > java.util.Map<java.lang.String,java.lang.Object> ) throws java.lang.Exception { JavaType org.springframework.integration.support.json.JavaType = this . createJavaType ( java.util.Map<java.lang.String,java.lang.Object> , JsonHeaders . TYPE_ID ) ; if ( ! org.springframework.integration.support.json.JavaType . isContainerType ( ) || org.springframework.integration.support.json.JavaType . isArrayType ( ) ) { return org.springframework.integration.support.json.JavaType ; } JavaType org.springframework.integration.support.json.JavaType = this . createJavaType ( java.util.Map<java.lang.String,java.lang.Object> , JsonHeaders . CONTENT_TYPE_ID ) ; if ( org.springframework.integration.support.json.JavaType . getKeyType ( ) == null ) { return this . org.springframework.integration.support.json.ObjectMapper . getTypeFactory ( ) . constructCollectionType ( ( java.lang.Class<? extends java.util.Collection<?>> < ? extends java.util.Collection<?> < ? > > ) org.springframework.integration.support.json.JavaType . getRawClass ( ) , org.springframework.integration.support.json.JavaType ) ; } JavaType org.springframework.integration.support.json.JavaType = this . createJavaType ( java.util.Map<java.lang.String,java.lang.Object> , JsonHeaders . KEY_TYPE_ID ) ; return this . org.springframework.integration.support.json.ObjectMapper . getTypeFactory ( ) . constructMapType ( ( java.lang.Class<? extends java.util.Map<?,?>> < ? extends java.util.Map<?,?> < ? , ? > > ) org.springframework.integration.support.json.JavaType . getRawClass ( ) , org.springframework.integration.support.json.JavaType , org.springframework.integration.support.json.JavaType ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected org.springframework.integration.support.json.JavaType org.springframework.integration.support.json.JavaType ( java.lang.reflect.Type java.lang.reflect.Type ) { return this . org.springframework.integration.support.json.ObjectMapper . constructType ( java.lang.reflect.Type ) ; }  <METHOD_END>
