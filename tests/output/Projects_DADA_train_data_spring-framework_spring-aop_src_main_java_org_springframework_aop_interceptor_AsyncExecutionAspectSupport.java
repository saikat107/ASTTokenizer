<METHOD_START> public void ( java.util.concurrent.Executor java.util.concurrent.Executor ) { this( java.util.concurrent.Executor , new SimpleAsyncUncaughtExceptionHandler ( ) ); }  <METHOD_END>
<METHOD_START> public void ( java.util.concurrent.Executor java.util.concurrent.Executor , AsyncUncaughtExceptionHandler org.springframework.aop.interceptor.AsyncUncaughtExceptionHandler ) { this . java.util.concurrent.Executor = java.util.concurrent.Executor ; this . org.springframework.aop.interceptor.AsyncUncaughtExceptionHandler = org.springframework.aop.interceptor.AsyncUncaughtExceptionHandler ; }  <METHOD_END>
<METHOD_START> public void void ( java.util.concurrent.Executor java.util.concurrent.Executor ) { this . java.util.concurrent.Executor = java.util.concurrent.Executor ; }  <METHOD_END>
<METHOD_START> public void void ( AsyncUncaughtExceptionHandler org.springframework.aop.interceptor.AsyncUncaughtExceptionHandler ) { this . org.springframework.aop.interceptor.AsyncUncaughtExceptionHandler = org.springframework.aop.interceptor.AsyncUncaughtExceptionHandler ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( BeanFactory org.springframework.aop.interceptor.BeanFactory ) { this . org.springframework.aop.interceptor.BeanFactory = org.springframework.aop.interceptor.BeanFactory ; }  <METHOD_END>
<METHOD_START> protected org.springframework.aop.interceptor.AsyncTaskExecutor org.springframework.aop.interceptor.AsyncTaskExecutor ( java.lang.reflect.Method java.lang.reflect.Method ) { AsyncTaskExecutor org.springframework.aop.interceptor.AsyncTaskExecutor = this . java.util.Map<java.lang.reflect.Method,org.springframework.aop.interceptor.AsyncTaskExecutor> . get ( java.lang.reflect.Method ) ; if ( org.springframework.aop.interceptor.AsyncTaskExecutor == null ) { java.util.concurrent.Executor java.util.concurrent.Executor ; java.lang.String java.lang.String = java.lang.String ( java.lang.reflect.Method ) ; if ( StringUtils . hasLength ( java.lang.String ) ) { java.util.concurrent.Executor = java.util.concurrent.Executor ( this . org.springframework.aop.interceptor.BeanFactory , java.lang.String ) ; } else { java.util.concurrent.Executor = this . java.util.concurrent.Executor ; if ( java.util.concurrent.Executor == null ) { synchronized ( this . java.util.Map<java.lang.reflect.Method,org.springframework.aop.interceptor.AsyncTaskExecutor> ) { if ( this . java.util.concurrent.Executor == null ) { this . java.util.concurrent.Executor = java.util.concurrent.Executor ( this . org.springframework.aop.interceptor.BeanFactory ) ; } java.util.concurrent.Executor = this . java.util.concurrent.Executor ; } } } if ( java.util.concurrent.Executor == null ) { return null ; } org.springframework.aop.interceptor.AsyncTaskExecutor = ( java.util.concurrent.Executor instanceof AsyncListenableTaskExecutor ? ( AsyncListenableTaskExecutor ) java.util.concurrent.Executor : new TaskExecutorAdapter ( java.util.concurrent.Executor ) ) ; this . java.util.Map<java.lang.reflect.Method,org.springframework.aop.interceptor.AsyncTaskExecutor> . put ( java.lang.reflect.Method , org.springframework.aop.interceptor.AsyncTaskExecutor ) ; } return org.springframework.aop.interceptor.AsyncTaskExecutor ; }  <METHOD_END>
<METHOD_START> protected abstract java.lang.String java.lang.String ( java.lang.reflect.Method java.lang.reflect.Method );  <METHOD_END>
<METHOD_START> protected java.util.concurrent.Executor java.util.concurrent.Executor ( BeanFactory org.springframework.aop.interceptor.BeanFactory , java.lang.String java.lang.String ) { if ( org.springframework.aop.interceptor.BeanFactory == null ) { throw new java.lang.IllegalStateException ( STRING + java.lang.Class<? extends org.springframework.aop.interceptor.AsyncExecutionAspectSupport> ( ) . java.lang.String ( ) + STRING + java.lang.String + STRING ) ; } return BeanFactoryAnnotationUtils . qualifiedBeanOfType ( org.springframework.aop.interceptor.BeanFactory , java.util.concurrent.Executor .class , java.lang.String ) ; }  <METHOD_END>
<METHOD_START> protected java.util.concurrent.Executor java.util.concurrent.Executor ( BeanFactory org.springframework.aop.interceptor.BeanFactory ) { if ( org.springframework.aop.interceptor.BeanFactory != null ) { try { return org.springframework.aop.interceptor.BeanFactory . getBean ( TaskExecutor .class ) ; } catch ( NoUniqueBeanDefinitionException org.springframework.aop.interceptor.NoUniqueBeanDefinitionException ) { try { return org.springframework.aop.interceptor.BeanFactory . getBean ( java.lang.String , java.util.concurrent.Executor .class ) ; } catch ( NoSuchBeanDefinitionException org.springframework.aop.interceptor.NoSuchBeanDefinitionException ) { if ( org.springframework.aop.interceptor.Log . isInfoEnabled ( ) ) { org.springframework.aop.interceptor.Log . info ( STRING + STRING + STRING + org.springframework.aop.interceptor.NoUniqueBeanDefinitionException . getBeanNamesFound ( ) ) ; } } } catch ( NoSuchBeanDefinitionException org.springframework.aop.interceptor.NoSuchBeanDefinitionException ) { org.springframework.aop.interceptor.Log . debug ( STRING , org.springframework.aop.interceptor.NoSuchBeanDefinitionException ) ; org.springframework.aop.interceptor.Log . info ( STRING ) ; } } return null ; }  <METHOD_END>
<METHOD_START> protected java.lang.Object java.lang.Object ( java.util.concurrent.Callable<java.lang.Object> < java.lang.Object > java.util.concurrent.Callable<java.lang.Object> , AsyncTaskExecutor org.springframework.aop.interceptor.AsyncTaskExecutor , java.lang.Class<?> < ? > java.lang.Class<?> ) { if ( java.util.concurrent.CompletableFuture .class . boolean ( java.lang.Class<> ) ) { return java.util.concurrent.CompletableFuture . java.util.concurrent.CompletableFuture ( new java.util.function.Supplier<java.lang.Object> < java.lang.Object > ( ) { @ java.lang.Override public java.lang.Object java.lang.Object ( ) { try { return java.util.concurrent.Callable<java.lang.Object> . java.lang.Object ( ) ; } catch ( java.lang.Throwable java.lang.Throwable ) { throw new java.util.concurrent.CompletionException ( java.lang.Throwable ) ; } } } , org.springframework.aop.interceptor.AsyncTaskExecutor ) ; } else if ( ListenableFuture .class . boolean ( java.lang.Class<> ) ) { return ( ( AsyncListenableTaskExecutor ) org.springframework.aop.interceptor.AsyncTaskExecutor ) . submitListenable ( java.util.concurrent.Callable<java.lang.Object> ) ; } else if ( java.util.concurrent.Future .class . boolean ( java.lang.Class<> ) ) { return org.springframework.aop.interceptor.AsyncTaskExecutor . submit ( java.util.concurrent.Callable<java.lang.Object> ) ; } else { org.springframework.aop.interceptor.AsyncTaskExecutor . submit ( java.util.concurrent.Callable<java.lang.Object> ) ; return null ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.Object java.lang.Object ( ) { try { return java.util.concurrent.Callable<java.lang.Object> . java.lang.Object ( ) ; } catch ( java.lang.Throwable java.lang.Throwable ) { throw new java.util.concurrent.CompletionException ( java.lang.Throwable ) ; } }  <METHOD_END>
<METHOD_START> protected void void ( java.lang.Throwable java.lang.Throwable , java.lang.reflect.Method java.lang.reflect.Method , java.lang.Object ... java.lang.Object[] ) throws java.lang.Exception { if ( java.util.concurrent.Future .class . boolean ( java.lang.reflect.Method . java.lang.Class<?> ( ) ) ) { ReflectionUtils . rethrowException ( java.lang.Throwable ) ; } else { try { this . org.springframework.aop.interceptor.AsyncUncaughtExceptionHandler . handleUncaughtException ( java.lang.Throwable , java.lang.reflect.Method , java.lang.Object[] ) ; } catch ( java.lang.Throwable java.lang.Throwable ) { org.springframework.aop.interceptor.Log . error ( STRING + java.lang.reflect.Method . java.lang.String ( ) + STRING , java.lang.Throwable ) ; } } }  <METHOD_END>
