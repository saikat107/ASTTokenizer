<METHOD_START> @ Before public void void ( ) { this . org.springframework.integration.jdbc.lock.JdbcLockRegistry . expireUnusedOlderThan ( NUMBER ) ; this . org.springframework.integration.jdbc.lock.LockRepository . close ( ) ; this . org.springframework.integration.jdbc.lock.AnnotationConfigApplicationContext = new AnnotationConfigApplicationContext ( ) ; this . org.springframework.integration.jdbc.lock.AnnotationConfigApplicationContext . register ( DefaultLockRepository .class ) ; this . org.springframework.integration.jdbc.lock.AnnotationConfigApplicationContext . setParent ( this . org.springframework.integration.jdbc.lock.ConfigurableApplicationContext ) ; this . org.springframework.integration.jdbc.lock.AnnotationConfigApplicationContext . refresh ( ) ; }  <METHOD_END>
<METHOD_START> @ After public void void ( ) { if ( this . org.springframework.integration.jdbc.lock.AnnotationConfigApplicationContext != null ) { this . org.springframework.integration.jdbc.lock.AnnotationConfigApplicationContext . close ( ) ; } }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { for ( int int = NUMBER ; int < NUMBER ; int ++ ) { final JdbcLockRegistry org.springframework.integration.jdbc.lock.JdbcLockRegistry = this . org.springframework.integration.jdbc.lock.JdbcLockRegistry ; final JdbcLockRegistry org.springframework.integration.jdbc.lock.JdbcLockRegistry = this . org.springframework.integration.jdbc.lock.AnnotationConfigApplicationContext . getBean ( JdbcLockRegistry .class ) ; final java.util.concurrent.locks.Lock java.util.concurrent.locks.Lock = org.springframework.integration.jdbc.lock.JdbcLockRegistry . obtain ( STRING ) ; final java.util.concurrent.atomic.AtomicBoolean java.util.concurrent.atomic.AtomicBoolean = new java.util.concurrent.atomic.AtomicBoolean ( ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; java.util.concurrent.locks.Lock . void ( ) ; java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . void ( ( ) { java.util.concurrent.locks.Lock java.util.concurrent.locks.Lock = org.springframework.integration.jdbc.lock.JdbcLockRegistry . obtain ( STRING ) ; try { java.util.concurrent.CountDownLatch . void ( ) ; java.util.concurrent.locks.Lock . void ( ) ; java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ; java.util.concurrent.atomic.AtomicBoolean . void ( true ) ; } catch ( java.lang.InterruptedException java.lang.InterruptedException ) { java.lang.Thread . java.lang.Thread ( ) . void ( ) ; } finally { java.util.concurrent.locks.Lock . void ( ) ; java.util.concurrent.CountDownLatch . void ( ) ; } } ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; assertFalse ( java.util.concurrent.atomic.AtomicBoolean . boolean ( ) ) ; java.util.concurrent.locks.Lock . void ( ) ; java.util.concurrent.CountDownLatch . void ( ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; assertTrue ( java.util.concurrent.atomic.AtomicBoolean . boolean ( ) ) ; } }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { for ( int int = NUMBER ; int < NUMBER ; int ++ ) { final JdbcLockRegistry org.springframework.integration.jdbc.lock.JdbcLockRegistry = this . org.springframework.integration.jdbc.lock.JdbcLockRegistry ; final JdbcLockRegistry org.springframework.integration.jdbc.lock.JdbcLockRegistry = this . org.springframework.integration.jdbc.lock.AnnotationConfigApplicationContext . getBean ( JdbcLockRegistry .class ) ; final java.util.List<java.lang.String> < java.lang.String > java.util.List<java.lang.String> = new java.util.ArrayList<java.lang.String> < java.lang.String > ( ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; java.util.concurrent.ExecutorService java.util.concurrent.ExecutorService = java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( NUMBER ) ; java.util.concurrent.ExecutorService . void ( ( ) { java.util.concurrent.locks.Lock java.util.concurrent.locks.Lock = org.springframework.integration.jdbc.lock.JdbcLockRegistry . obtain ( STRING ) ; try { java.util.concurrent.locks.Lock . void ( ) ; java.util.List<java.lang.String> . boolean ( STRING ) ; java.util.concurrent.CountDownLatch . void ( ) ; } catch ( java.lang.InterruptedException java.lang.InterruptedException ) { java.lang.Thread . java.lang.Thread ( ) . void ( ) ; } finally { try { java.util.concurrent.locks.Lock . void ( ) ; } catch ( java.lang.Exception java.lang.Exception ) { } } } ) ; java.util.concurrent.ExecutorService . void ( ( ) { java.util.concurrent.locks.Lock java.util.concurrent.locks.Lock = org.springframework.integration.jdbc.lock.JdbcLockRegistry . obtain ( STRING ) ; try { java.util.concurrent.locks.Lock . void ( ) ; java.util.List<java.lang.String> . boolean ( STRING ) ; java.util.concurrent.CountDownLatch . void ( ) ; } catch ( java.lang.InterruptedException java.lang.InterruptedException ) { java.lang.Thread . java.lang.Thread ( ) . void ( ) ; } finally { try { java.util.concurrent.locks.Lock . void ( ) ; } catch ( java.lang.Exception java.lang.Exception ) { } } } ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; assertTrue ( java.util.List<java.lang.String> . boolean ( STRING ) ) ; assertTrue ( java.util.List<java.lang.String> . boolean ( STRING ) ) ; } }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { for ( int int = NUMBER ; int < NUMBER ; int ++ ) { final java.util.List<java.lang.String> < java.lang.String > java.util.List<java.lang.String> = new java.util.ArrayList<java.lang.String> < java.lang.String > ( ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; java.util.concurrent.ExecutorService java.util.concurrent.ExecutorService = java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( NUMBER ) ; java.util.ArrayList<java.util.concurrent.Callable<java.lang.Boolean>> < java.util.concurrent.Callable<java.lang.Boolean> < java.lang.Boolean > > java.util.ArrayList<java.util.concurrent.Callable<java.lang.Boolean>> = new java.util.ArrayList<java.util.concurrent.Callable<java.lang.Boolean>> < java.util.concurrent.Callable<java.lang.Boolean> < java.lang.Boolean > > ( ) ; for ( int int = NUMBER ; int < NUMBER ; int ++ ) { final DefaultLockRepository org.springframework.integration.jdbc.lock.DefaultLockRepository = new DefaultLockRepository ( this . javax.sql.DataSource ) ; org.springframework.integration.jdbc.lock.DefaultLockRepository . afterPropertiesSet ( ) ; this . org.springframework.integration.jdbc.lock.ConfigurableApplicationContext . getAutowireCapableBeanFactory ( ) . autowireBean ( org.springframework.integration.jdbc.lock.DefaultLockRepository ) ; java.util.concurrent.Callable<java.lang.Boolean> < java.lang.Boolean > java.util.concurrent.Callable<java.lang.Boolean> = ( ) { java.util.concurrent.locks.Lock java.util.concurrent.locks.Lock = new JdbcLockRegistry ( org.springframework.integration.jdbc.lock.DefaultLockRepository ) . obtain ( STRING ) ; try { if ( java.util.List<java.lang.String> . boolean ( ) && java.util.concurrent.locks.Lock . boolean ( ) ) { if ( java.util.List<java.lang.String> . boolean ( ) ) { java.util.List<java.lang.String> . boolean ( STRING ) ; return true ; } } } finally { try { java.util.concurrent.locks.Lock . void ( ) ; } catch ( java.lang.Exception java.lang.Exception ) { } java.util.concurrent.CountDownLatch . void ( ) ; } return false ; } ; java.util.ArrayList<java.util.concurrent.Callable<java.lang.Boolean>> . boolean ( java.util.concurrent.Callable<java.lang.Boolean> ) ; } org.springframework.integration.jdbc.lock.Log . info ( STRING + int ) ; java.util.concurrent.ExecutorService . java.util.List<java.util.concurrent.Future<java.lang.Boolean>> ( java.util.ArrayList<java.util.concurrent.Callable<java.lang.Boolean>> ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; assertEquals ( NUMBER , java.util.List<java.lang.String> . int ( ) ) ; assertTrue ( java.util.List<java.lang.String> . boolean ( STRING ) ) ; } }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { DefaultLockRepository org.springframework.integration.jdbc.lock.DefaultLockRepository = new DefaultLockRepository ( javax.sql.DataSource ) ; org.springframework.integration.jdbc.lock.DefaultLockRepository . afterPropertiesSet ( ) ; final DefaultLockRepository org.springframework.integration.jdbc.lock.DefaultLockRepository = new DefaultLockRepository ( javax.sql.DataSource ) ; org.springframework.integration.jdbc.lock.DefaultLockRepository . afterPropertiesSet ( ) ; java.util.concurrent.locks.Lock java.util.concurrent.locks.Lock = new JdbcLockRegistry ( org.springframework.integration.jdbc.lock.DefaultLockRepository ) . obtain ( STRING ) ; final java.util.concurrent.BlockingQueue<java.lang.Integer> < java.lang.Integer > java.util.concurrent.BlockingQueue<java.lang.Integer> = new java.util.concurrent.LinkedBlockingQueue<java.lang.Integer> < java.lang.Integer > ( ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; java.util.concurrent.locks.Lock . void ( ) ; java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . void ( ( ) { java.util.concurrent.locks.Lock java.util.concurrent.locks.Lock = new JdbcLockRegistry ( org.springframework.integration.jdbc.lock.DefaultLockRepository ) . obtain ( STRING ) ; try { java.util.concurrent.CountDownLatch . void ( ) ; StopWatch org.springframework.integration.jdbc.lock.StopWatch = new StopWatch ( ) ; org.springframework.integration.jdbc.lock.StopWatch . start ( ) ; java.util.concurrent.locks.Lock . void ( ) ; org.springframework.integration.jdbc.lock.StopWatch . stop ( ) ; java.util.concurrent.BlockingQueue<java.lang.Integer> . boolean ( NUMBER ) ; java.lang.Thread . void ( NUMBER ) ; java.util.concurrent.BlockingQueue<java.lang.Integer> . boolean ( NUMBER ) ; java.lang.Thread . void ( NUMBER ) ; java.util.concurrent.BlockingQueue<java.lang.Integer> . boolean ( NUMBER ) ; } catch ( java.lang.InterruptedException java.lang.InterruptedException ) { java.lang.Thread . java.lang.Thread ( ) . void ( ) ; } finally { java.util.concurrent.locks.Lock . void ( ) ; } } ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; java.util.concurrent.BlockingQueue<java.lang.Integer> . boolean ( NUMBER ) ; java.lang.Thread . void ( NUMBER ) ; java.util.concurrent.BlockingQueue<java.lang.Integer> . boolean ( NUMBER ) ; java.lang.Thread . void ( NUMBER ) ; java.util.concurrent.BlockingQueue<java.lang.Integer> . boolean ( NUMBER ) ; java.util.concurrent.locks.Lock . void ( ) ; for ( int int = NUMBER ; int < NUMBER ; int ++ ) { java.lang.Integer java.lang.Integer = java.util.concurrent.BlockingQueue<java.lang.Integer> . java.lang.Integer ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ; assertNotNull ( java.lang.Integer ) ; assertEquals ( int + NUMBER , java.lang.Integer . int ( ) ) ; } }  <METHOD_END>
