<METHOD_START> @ Before public void void ( ) java.lang.Exception { MockitoAnnotations . initMocks ( this ) ; this . org.springframework.messaging.simp.stomp.StompSessionHandler = mock ( StompSessionHandler .class ) ; this . org.springframework.messaging.simp.stomp.StompHeaders = new StompHeaders ( ) ; this . org.springframework.messaging.simp.stomp.DefaultStompSession = new DefaultStompSession ( this . org.springframework.messaging.simp.stomp.StompSessionHandler , this . org.springframework.messaging.simp.stomp.StompHeaders ) ; this . org.springframework.messaging.simp.stomp.DefaultStompSession . setMessageConverter ( new StringMessageConverter ( ) ) ; SettableListenableFuture < java.lang.Void > org.springframework.messaging.simp.stomp.SettableListenableFuture<java.lang.Void> = new SettableListenableFuture <> ( ) ; org.springframework.messaging.simp.stomp.SettableListenableFuture<java.lang.Void> . set ( null ) ; when ( this . org.springframework.messaging.simp.stomp.TcpConnection<byte[]> . send ( this . org.springframework.messaging.simp.stomp.ArgumentCaptor<org.springframework.messaging.simp.stomp.Message<byte[]>> . capture ( ) ) ) . thenReturn ( org.springframework.messaging.simp.stomp.SettableListenableFuture<java.lang.Void> ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { assertFalse ( this . org.springframework.messaging.simp.stomp.DefaultStompSession . isConnected ( ) ) ; this . org.springframework.messaging.simp.stomp.StompHeaders . setHost ( STRING ) ; this . org.springframework.messaging.simp.stomp.StompHeaders . setHeartbeat ( new long [] { NUMBER , NUMBER } ) ; this . org.springframework.messaging.simp.stomp.DefaultStompSession . afterConnected ( this . org.springframework.messaging.simp.stomp.TcpConnection<byte[]> ) ; assertTrue ( this . org.springframework.messaging.simp.stomp.DefaultStompSession . isConnected ( ) ) ; Message < byte [] > org.springframework.messaging.simp.stomp.Message<byte[]> = this . org.springframework.messaging.simp.stomp.ArgumentCaptor<org.springframework.messaging.simp.stomp.Message<byte[]>> . getValue ( ) ; StompHeaderAccessor org.springframework.messaging.simp.stomp.StompHeaderAccessor = MessageHeaderAccessor . getAccessor ( org.springframework.messaging.simp.stomp.Message<byte[]> , StompHeaderAccessor .class ) ; assertEquals ( StompCommand . CONNECT , org.springframework.messaging.simp.stomp.StompHeaderAccessor . getCommand ( ) ) ; assertEquals ( STRING , org.springframework.messaging.simp.stomp.StompHeaderAccessor . getHost ( ) ) ; assertThat ( org.springframework.messaging.simp.stomp.StompHeaderAccessor . getAcceptVersion ( ) , containsInAnyOrder ( STRING , STRING ) ) ; assertArrayEquals ( new long [] { NUMBER , NUMBER } , org.springframework.messaging.simp.stomp.StompHeaderAccessor . getHeartbeat ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.lang.IllegalStateException java.lang.IllegalStateException = new java.lang.IllegalStateException ( STRING ) ; this . org.springframework.messaging.simp.stomp.DefaultStompSession . afterConnectFailure ( java.lang.IllegalStateException ) ; verify ( this . org.springframework.messaging.simp.stomp.StompSessionHandler ) . handleTransportError ( this . org.springframework.messaging.simp.stomp.DefaultStompSession , java.lang.IllegalStateException ) ; verifyNoMoreInteractions ( this . org.springframework.messaging.simp.stomp.StompSessionHandler ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { this . org.springframework.messaging.simp.stomp.DefaultStompSession . afterConnected ( this . org.springframework.messaging.simp.stomp.TcpConnection<byte[]> ) ; assertTrue ( this . org.springframework.messaging.simp.stomp.DefaultStompSession . isConnected ( ) ) ; this . org.springframework.messaging.simp.stomp.StompHeaders . setHeartbeat ( new long [] { NUMBER , NUMBER } ) ; StompHeaderAccessor org.springframework.messaging.simp.stomp.StompHeaderAccessor = StompHeaderAccessor . create ( StompCommand . CONNECTED ) ; org.springframework.messaging.simp.stomp.StompHeaderAccessor . setVersion ( STRING ) ; org.springframework.messaging.simp.stomp.StompHeaderAccessor . setHeartbeat ( NUMBER , NUMBER ) ; org.springframework.messaging.simp.stomp.StompHeaderAccessor . setLeaveMutable ( true ) ; this . org.springframework.messaging.simp.stomp.DefaultStompSession . handleMessage ( MessageBuilder . createMessage ( new byte [ NUMBER ] , org.springframework.messaging.simp.stomp.StompHeaderAccessor . getMessageHeaders ( ) ) ) ; StompHeaders org.springframework.messaging.simp.stomp.StompHeaders = StompHeaders . readOnlyStompHeaders ( org.springframework.messaging.simp.stomp.StompHeaderAccessor . getNativeHeaders ( ) ) ; verify ( this . org.springframework.messaging.simp.stomp.StompSessionHandler ) . afterConnected ( this . org.springframework.messaging.simp.stomp.DefaultStompSession , org.springframework.messaging.simp.stomp.StompHeaders ) ; verifyNoMoreInteractions ( this . org.springframework.messaging.simp.stomp.StompSessionHandler ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { this . org.springframework.messaging.simp.stomp.DefaultStompSession . afterConnected ( this . org.springframework.messaging.simp.stomp.TcpConnection<byte[]> ) ; assertTrue ( this . org.springframework.messaging.simp.stomp.DefaultStompSession . isConnected ( ) ) ; this . org.springframework.messaging.simp.stomp.StompHeaders . setHeartbeat ( new long [] { NUMBER , NUMBER } ) ; StompHeaderAccessor org.springframework.messaging.simp.stomp.StompHeaderAccessor = StompHeaderAccessor . create ( StompCommand . CONNECTED ) ; org.springframework.messaging.simp.stomp.StompHeaderAccessor . setVersion ( STRING ) ; org.springframework.messaging.simp.stomp.StompHeaderAccessor . setHeartbeat ( NUMBER , NUMBER ) ; org.springframework.messaging.simp.stomp.StompHeaderAccessor . setLeaveMutable ( true ) ; this . org.springframework.messaging.simp.stomp.DefaultStompSession . handleMessage ( MessageBuilder . createMessage ( new byte [ NUMBER ] , org.springframework.messaging.simp.stomp.StompHeaderAccessor . getMessageHeaders ( ) ) ) ; ArgumentCaptor < java.lang.Long > org.springframework.messaging.simp.stomp.ArgumentCaptor<java.lang.Long> = ArgumentCaptor . forClass ( java.lang.Long .class ) ; verify ( this . org.springframework.messaging.simp.stomp.TcpConnection<byte[]> ) . onWriteInactivity ( any ( java.lang.Runnable .class ) , org.springframework.messaging.simp.stomp.ArgumentCaptor<java.lang.Long> . capture ( ) ) ; assertEquals ( NUMBER , ( long ) org.springframework.messaging.simp.stomp.ArgumentCaptor<java.lang.Long> . getValue ( ) ) ; ArgumentCaptor < java.lang.Long > org.springframework.messaging.simp.stomp.ArgumentCaptor<java.lang.Long> = ArgumentCaptor . forClass ( java.lang.Long .class ) ; verify ( this . org.springframework.messaging.simp.stomp.TcpConnection<byte[]> ) . onReadInactivity ( any ( java.lang.Runnable .class ) , org.springframework.messaging.simp.stomp.ArgumentCaptor<java.lang.Long> . capture ( ) ) ; assertEquals ( NUMBER , ( long ) org.springframework.messaging.simp.stomp.ArgumentCaptor<java.lang.Long> . getValue ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { this . org.springframework.messaging.simp.stomp.DefaultStompSession . afterConnected ( this . org.springframework.messaging.simp.stomp.TcpConnection<byte[]> ) ; verify ( this . org.springframework.messaging.simp.stomp.TcpConnection<byte[]> ) . send ( any ( ) ) ; this . org.springframework.messaging.simp.stomp.StompHeaders . setHeartbeat ( new long [] { NUMBER , NUMBER } ) ; StompHeaderAccessor org.springframework.messaging.simp.stomp.StompHeaderAccessor = StompHeaderAccessor . create ( StompCommand . CONNECTED ) ; org.springframework.messaging.simp.stomp.StompHeaderAccessor . setVersion ( STRING ) ; org.springframework.messaging.simp.stomp.StompHeaderAccessor . setHeartbeat ( NUMBER , NUMBER ) ; org.springframework.messaging.simp.stomp.StompHeaderAccessor . setLeaveMutable ( true ) ; this . org.springframework.messaging.simp.stomp.DefaultStompSession . handleMessage ( MessageBuilder . createMessage ( new byte [ NUMBER ] , org.springframework.messaging.simp.stomp.StompHeaderAccessor . getMessageHeaders ( ) ) ) ; verifyNoMoreInteractions ( this . org.springframework.messaging.simp.stomp.TcpConnection<byte[]> ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { this . org.springframework.messaging.simp.stomp.DefaultStompSession . afterConnected ( this . org.springframework.messaging.simp.stomp.TcpConnection<byte[]> ) ; verify ( this . org.springframework.messaging.simp.stomp.TcpConnection<byte[]> ) . send ( any ( ) ) ; this . org.springframework.messaging.simp.stomp.StompHeaders . setHeartbeat ( new long [] { NUMBER , NUMBER } ) ; StompHeaderAccessor org.springframework.messaging.simp.stomp.StompHeaderAccessor = StompHeaderAccessor . create ( StompCommand . CONNECTED ) ; org.springframework.messaging.simp.stomp.StompHeaderAccessor . setVersion ( STRING ) ; org.springframework.messaging.simp.stomp.StompHeaderAccessor . setHeartbeat ( NUMBER , NUMBER ) ; org.springframework.messaging.simp.stomp.StompHeaderAccessor . setLeaveMutable ( true ) ; this . org.springframework.messaging.simp.stomp.DefaultStompSession . handleMessage ( MessageBuilder . createMessage ( new byte [ NUMBER ] , org.springframework.messaging.simp.stomp.StompHeaderAccessor . getMessageHeaders ( ) ) ) ; ArgumentCaptor < java.lang.Runnable > org.springframework.messaging.simp.stomp.ArgumentCaptor<java.lang.Runnable> = ArgumentCaptor . forClass ( java.lang.Runnable .class ) ; ArgumentCaptor < java.lang.Runnable > org.springframework.messaging.simp.stomp.ArgumentCaptor<java.lang.Runnable> = ArgumentCaptor . forClass ( java.lang.Runnable .class ) ; verify ( this . org.springframework.messaging.simp.stomp.TcpConnection<byte[]> ) . onWriteInactivity ( org.springframework.messaging.simp.stomp.ArgumentCaptor<java.lang.Runnable> . capture ( ) , any ( java.lang.Long .class ) ) ; verify ( this . org.springframework.messaging.simp.stomp.TcpConnection<byte[]> ) . onReadInactivity ( org.springframework.messaging.simp.stomp.ArgumentCaptor<java.lang.Runnable> . capture ( ) , any ( java.lang.Long .class ) ) ; java.lang.Runnable java.lang.Runnable = org.springframework.messaging.simp.stomp.ArgumentCaptor<java.lang.Runnable> . getValue ( ) ; java.lang.Runnable java.lang.Runnable = org.springframework.messaging.simp.stomp.ArgumentCaptor<java.lang.Runnable> . getValue ( ) ; assertNotNull ( java.lang.Runnable ) ; assertNotNull ( java.lang.Runnable ) ; java.lang.Runnable . void ( ) ; StompHeaderAccessor org.springframework.messaging.simp.stomp.StompHeaderAccessor = StompHeaderAccessor . createForHeartbeat ( ) ; Message < byte [] > org.springframework.messaging.simp.stomp.Message<byte[]> = MessageBuilder . createMessage ( new byte [] { '\n' } , org.springframework.messaging.simp.stomp.StompHeaderAccessor . getMessageHeaders ( ) ) ; verify ( this . org.springframework.messaging.simp.stomp.TcpConnection<byte[]> ) . send ( eq ( org.springframework.messaging.simp.stomp.Message<byte[]> ) ) ; verifyNoMoreInteractions ( this . org.springframework.messaging.simp.stomp.TcpConnection<byte[]> ) ; reset ( this . org.springframework.messaging.simp.stomp.StompSessionHandler ) ; java.lang.Runnable . void ( ) ; verify ( this . org.springframework.messaging.simp.stomp.StompSessionHandler ) . handleTransportError ( same ( this . org.springframework.messaging.simp.stomp.DefaultStompSession ) , any ( java.lang.IllegalStateException .class ) ) ; verifyNoMoreInteractions ( this . org.springframework.messaging.simp.stomp.StompSessionHandler ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { StompHeaderAccessor org.springframework.messaging.simp.stomp.StompHeaderAccessor = StompHeaderAccessor . create ( StompCommand . ERROR ) ; org.springframework.messaging.simp.stomp.StompHeaderAccessor . setContentType ( new MimeType ( STRING , STRING , java.nio.charset.StandardCharsets . java.nio.charset.Charset ) ) ; org.springframework.messaging.simp.stomp.StompHeaderAccessor . addNativeHeader ( STRING , STRING ) ; org.springframework.messaging.simp.stomp.StompHeaderAccessor . setLeaveMutable ( true ) ; java.lang.String java.lang.String = STRING ; StompHeaders org.springframework.messaging.simp.stomp.StompHeaders = StompHeaders . readOnlyStompHeaders ( org.springframework.messaging.simp.stomp.StompHeaderAccessor . getNativeHeaders ( ) ) ; when ( this . org.springframework.messaging.simp.stomp.StompSessionHandler . getPayloadType ( org.springframework.messaging.simp.stomp.StompHeaders ) ) . thenReturn ( java.lang.String .class ) ; this . org.springframework.messaging.simp.stomp.DefaultStompSession . handleMessage ( MessageBuilder . createMessage ( java.lang.String . byte[] ( java.nio.charset.StandardCharsets . java.nio.charset.Charset ) , org.springframework.messaging.simp.stomp.StompHeaderAccessor . getMessageHeaders ( ) ) ) ; verify ( this . org.springframework.messaging.simp.stomp.StompSessionHandler ) . getPayloadType ( org.springframework.messaging.simp.stomp.StompHeaders ) ; verify ( this . org.springframework.messaging.simp.stomp.StompSessionHandler ) . handleFrame ( org.springframework.messaging.simp.stomp.StompHeaders , java.lang.String ) ; verifyNoMoreInteractions ( this . org.springframework.messaging.simp.stomp.StompSessionHandler ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { StompHeaderAccessor org.springframework.messaging.simp.stomp.StompHeaderAccessor = StompHeaderAccessor . create ( StompCommand . ERROR ) ; org.springframework.messaging.simp.stomp.StompHeaderAccessor . addNativeHeader ( STRING , STRING ) ; org.springframework.messaging.simp.stomp.StompHeaderAccessor . setLeaveMutable ( true ) ; this . org.springframework.messaging.simp.stomp.DefaultStompSession . handleMessage ( MessageBuilder . createMessage ( new byte [ NUMBER ] , org.springframework.messaging.simp.stomp.StompHeaderAccessor . getMessageHeaders ( ) ) ) ; StompHeaders org.springframework.messaging.simp.stomp.StompHeaders = StompHeaders . readOnlyStompHeaders ( org.springframework.messaging.simp.stomp.StompHeaderAccessor . getNativeHeaders ( ) ) ; verify ( this . org.springframework.messaging.simp.stomp.StompSessionHandler ) . handleFrame ( org.springframework.messaging.simp.stomp.StompHeaders , null ) ; verifyNoMoreInteractions ( this . org.springframework.messaging.simp.stomp.StompSessionHandler ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { StompHeaderAccessor org.springframework.messaging.simp.stomp.StompHeaderAccessor = StompHeaderAccessor . create ( StompCommand . ERROR ) ; org.springframework.messaging.simp.stomp.StompHeaderAccessor . setContentType ( MimeTypeUtils . APPLICATION_JSON ) ; org.springframework.messaging.simp.stomp.StompHeaderAccessor . addNativeHeader ( STRING , STRING ) ; org.springframework.messaging.simp.stomp.StompHeaderAccessor . setLeaveMutable ( true ) ; byte [] byte[] = STRING . byte[] ( java.nio.charset.StandardCharsets . java.nio.charset.Charset ) ; StompHeaders org.springframework.messaging.simp.stomp.StompHeaders = StompHeaders . readOnlyStompHeaders ( org.springframework.messaging.simp.stomp.StompHeaderAccessor . getNativeHeaders ( ) ) ; when ( this . org.springframework.messaging.simp.stomp.StompSessionHandler . getPayloadType ( org.springframework.messaging.simp.stomp.StompHeaders ) ) . thenReturn ( java.util.Map .class ) ; this . org.springframework.messaging.simp.stomp.DefaultStompSession . handleMessage ( MessageBuilder . createMessage ( byte[] , org.springframework.messaging.simp.stomp.StompHeaderAccessor . getMessageHeaders ( ) ) ) ; verify ( this . org.springframework.messaging.simp.stomp.StompSessionHandler ) . getPayloadType ( org.springframework.messaging.simp.stomp.StompHeaders ) ; verify ( this . org.springframework.messaging.simp.stomp.StompSessionHandler ) . handleException ( same ( this . org.springframework.messaging.simp.stomp.DefaultStompSession ) , same ( StompCommand . ERROR ) , eq ( org.springframework.messaging.simp.stomp.StompHeaders ) , same ( byte[] ) , any ( MessageConversionException .class ) ) ; verifyNoMoreInteractions ( this . org.springframework.messaging.simp.stomp.StompSessionHandler ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { this . org.springframework.messaging.simp.stomp.DefaultStompSession . afterConnected ( this . org.springframework.messaging.simp.stomp.TcpConnection<byte[]> ) ; StompFrameHandler org.springframework.messaging.simp.stomp.StompFrameHandler = mock ( StompFrameHandler .class ) ; java.lang.String java.lang.String = STRING ; Subscription org.springframework.messaging.simp.stomp.Subscription = this . org.springframework.messaging.simp.stomp.DefaultStompSession . subscribe ( java.lang.String , org.springframework.messaging.simp.stomp.StompFrameHandler ) ; StompHeaderAccessor org.springframework.messaging.simp.stomp.StompHeaderAccessor = StompHeaderAccessor . create ( StompCommand . MESSAGE ) ; org.springframework.messaging.simp.stomp.StompHeaderAccessor . setDestination ( java.lang.String ) ; org.springframework.messaging.simp.stomp.StompHeaderAccessor . setSubscriptionId ( org.springframework.messaging.simp.stomp.Subscription . getSubscriptionId ( ) ) ; org.springframework.messaging.simp.stomp.StompHeaderAccessor . setContentType ( MimeTypeUtils . TEXT_PLAIN ) ; org.springframework.messaging.simp.stomp.StompHeaderAccessor . setMessageId ( STRING ) ; org.springframework.messaging.simp.stomp.StompHeaderAccessor . setLeaveMutable ( true ) ; java.lang.String java.lang.String = STRING ; StompHeaders org.springframework.messaging.simp.stomp.StompHeaders = StompHeaders . readOnlyStompHeaders ( org.springframework.messaging.simp.stomp.StompHeaderAccessor . getNativeHeaders ( ) ) ; when ( org.springframework.messaging.simp.stomp.StompFrameHandler . getPayloadType ( org.springframework.messaging.simp.stomp.StompHeaders ) ) . thenReturn ( java.lang.String .class ) ; this . org.springframework.messaging.simp.stomp.DefaultStompSession . handleMessage ( MessageBuilder . createMessage ( java.lang.String . byte[] ( java.nio.charset.StandardCharsets . java.nio.charset.Charset ) , org.springframework.messaging.simp.stomp.StompHeaderAccessor . getMessageHeaders ( ) ) ) ; verify ( org.springframework.messaging.simp.stomp.StompFrameHandler ) . getPayloadType ( org.springframework.messaging.simp.stomp.StompHeaders ) ; verify ( org.springframework.messaging.simp.stomp.StompFrameHandler ) . handleFrame ( org.springframework.messaging.simp.stomp.StompHeaders , java.lang.String ) ; verifyNoMoreInteractions ( org.springframework.messaging.simp.stomp.StompFrameHandler ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { this . org.springframework.messaging.simp.stomp.DefaultStompSession . afterConnected ( this . org.springframework.messaging.simp.stomp.TcpConnection<byte[]> ) ; assertTrue ( this . org.springframework.messaging.simp.stomp.DefaultStompSession . isConnected ( ) ) ; StompFrameHandler org.springframework.messaging.simp.stomp.StompFrameHandler = mock ( StompFrameHandler .class ) ; java.lang.String java.lang.String = STRING ; Subscription org.springframework.messaging.simp.stomp.Subscription = this . org.springframework.messaging.simp.stomp.DefaultStompSession . subscribe ( java.lang.String , org.springframework.messaging.simp.stomp.StompFrameHandler ) ; StompHeaderAccessor org.springframework.messaging.simp.stomp.StompHeaderAccessor = StompHeaderAccessor . create ( StompCommand . MESSAGE ) ; org.springframework.messaging.simp.stomp.StompHeaderAccessor . setDestination ( java.lang.String ) ; org.springframework.messaging.simp.stomp.StompHeaderAccessor . setSubscriptionId ( org.springframework.messaging.simp.stomp.Subscription . getSubscriptionId ( ) ) ; org.springframework.messaging.simp.stomp.StompHeaderAccessor . setContentType ( MimeTypeUtils . APPLICATION_JSON ) ; org.springframework.messaging.simp.stomp.StompHeaderAccessor . setMessageId ( STRING ) ; org.springframework.messaging.simp.stomp.StompHeaderAccessor . setLeaveMutable ( true ) ; byte [] byte[] = STRING . byte[] ( java.nio.charset.StandardCharsets . java.nio.charset.Charset ) ; StompHeaders org.springframework.messaging.simp.stomp.StompHeaders = StompHeaders . readOnlyStompHeaders ( org.springframework.messaging.simp.stomp.StompHeaderAccessor . getNativeHeaders ( ) ) ; when ( org.springframework.messaging.simp.stomp.StompFrameHandler . getPayloadType ( org.springframework.messaging.simp.stomp.StompHeaders ) ) . thenReturn ( java.util.Map .class ) ; this . org.springframework.messaging.simp.stomp.DefaultStompSession . handleMessage ( MessageBuilder . createMessage ( byte[] , org.springframework.messaging.simp.stomp.StompHeaderAccessor . getMessageHeaders ( ) ) ) ; verify ( org.springframework.messaging.simp.stomp.StompFrameHandler ) . getPayloadType ( org.springframework.messaging.simp.stomp.StompHeaders ) ; verifyNoMoreInteractions ( org.springframework.messaging.simp.stomp.StompFrameHandler ) ; verify ( this . org.springframework.messaging.simp.stomp.StompSessionHandler ) . handleException ( same ( this . org.springframework.messaging.simp.stomp.DefaultStompSession ) , same ( StompCommand . MESSAGE ) , eq ( org.springframework.messaging.simp.stomp.StompHeaders ) , same ( byte[] ) , any ( MessageConversionException .class ) ) ; verifyNoMoreInteractions ( this . org.springframework.messaging.simp.stomp.StompSessionHandler ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.lang.IllegalStateException java.lang.IllegalStateException = new java.lang.IllegalStateException ( STRING ) ; this . org.springframework.messaging.simp.stomp.DefaultStompSession . handleFailure ( java.lang.IllegalStateException ) ; verify ( this . org.springframework.messaging.simp.stomp.StompSessionHandler ) . handleTransportError ( this . org.springframework.messaging.simp.stomp.DefaultStompSession , java.lang.IllegalStateException ) ; verifyNoMoreInteractions ( this . org.springframework.messaging.simp.stomp.StompSessionHandler ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { this . org.springframework.messaging.simp.stomp.DefaultStompSession . afterConnectionClosed ( ) ; verify ( this . org.springframework.messaging.simp.stomp.StompSessionHandler ) . handleTransportError ( same ( this . org.springframework.messaging.simp.stomp.DefaultStompSession ) , any ( ConnectionLostException .class ) ) ; verifyNoMoreInteractions ( this . org.springframework.messaging.simp.stomp.StompSessionHandler ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { this . org.springframework.messaging.simp.stomp.DefaultStompSession . afterConnected ( this . org.springframework.messaging.simp.stomp.TcpConnection<byte[]> ) ; assertTrue ( this . org.springframework.messaging.simp.stomp.DefaultStompSession . isConnected ( ) ) ; java.lang.String java.lang.String = STRING ; java.lang.String java.lang.String = STRING ; this . org.springframework.messaging.simp.stomp.DefaultStompSession . send ( java.lang.String , java.lang.String ) ; Message < byte [] > org.springframework.messaging.simp.stomp.Message<byte[]> = this . org.springframework.messaging.simp.stomp.ArgumentCaptor<org.springframework.messaging.simp.stomp.Message<byte[]>> . getValue ( ) ; StompHeaderAccessor org.springframework.messaging.simp.stomp.StompHeaderAccessor = MessageHeaderAccessor . getAccessor ( org.springframework.messaging.simp.stomp.Message<byte[]> , StompHeaderAccessor .class ) ; assertEquals ( StompCommand . SEND , org.springframework.messaging.simp.stomp.StompHeaderAccessor . getCommand ( ) ) ; StompHeaders org.springframework.messaging.simp.stomp.StompHeaders = StompHeaders . readOnlyStompHeaders ( org.springframework.messaging.simp.stomp.StompHeaderAccessor . getNativeHeaders ( ) ) ; assertEquals ( org.springframework.messaging.simp.stomp.StompHeaders . toString ( ) , NUMBER , org.springframework.messaging.simp.stomp.StompHeaders . size ( ) ) ; assertEquals ( java.lang.String , org.springframework.messaging.simp.stomp.StompHeaders . getDestination ( ) ) ; assertEquals ( new MimeType ( STRING , STRING , java.nio.charset.StandardCharsets . java.nio.charset.Charset ) , org.springframework.messaging.simp.stomp.StompHeaders . getContentType ( ) ) ; assertEquals ( - NUMBER , org.springframework.messaging.simp.stomp.StompHeaders . getContentLength ( ) ) ; assertEquals ( java.lang.String , new java.lang.String ( org.springframework.messaging.simp.stomp.Message<byte[]> . getPayload ( ) , java.nio.charset.StandardCharsets . java.nio.charset.Charset ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { this . org.springframework.messaging.simp.stomp.DefaultStompSession . afterConnected ( this . org.springframework.messaging.simp.stomp.TcpConnection<byte[]> ) ; assertTrue ( this . org.springframework.messaging.simp.stomp.DefaultStompSession . isConnected ( ) ) ; this . org.springframework.messaging.simp.stomp.DefaultStompSession . setTaskScheduler ( mock ( TaskScheduler .class ) ) ; this . org.springframework.messaging.simp.stomp.DefaultStompSession . setAutoReceipt ( true ) ; this . org.springframework.messaging.simp.stomp.DefaultStompSession . send ( STRING , STRING ) ; Message < byte [] > org.springframework.messaging.simp.stomp.Message<byte[]> = this . org.springframework.messaging.simp.stomp.ArgumentCaptor<org.springframework.messaging.simp.stomp.Message<byte[]>> . getValue ( ) ; StompHeaderAccessor org.springframework.messaging.simp.stomp.StompHeaderAccessor = MessageHeaderAccessor . getAccessor ( org.springframework.messaging.simp.stomp.Message<byte[]> , StompHeaderAccessor .class ) ; assertNotNull ( org.springframework.messaging.simp.stomp.StompHeaderAccessor . getReceipt ( ) ) ; StompHeaders org.springframework.messaging.simp.stomp.StompHeaders = new StompHeaders ( ) ; org.springframework.messaging.simp.stomp.StompHeaders . setDestination ( STRING ) ; org.springframework.messaging.simp.stomp.StompHeaders . setReceipt ( STRING ) ; this . org.springframework.messaging.simp.stomp.DefaultStompSession . send ( org.springframework.messaging.simp.stomp.StompHeaders , STRING ) ; org.springframework.messaging.simp.stomp.Message<byte[]> = this . org.springframework.messaging.simp.stomp.ArgumentCaptor<org.springframework.messaging.simp.stomp.Message<byte[]>> . getValue ( ) ; org.springframework.messaging.simp.stomp.StompHeaderAccessor = MessageHeaderAccessor . getAccessor ( org.springframework.messaging.simp.stomp.Message<byte[]> , StompHeaderAccessor .class ) ; assertEquals ( STRING , org.springframework.messaging.simp.stomp.StompHeaderAccessor . getReceipt ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { this . org.springframework.messaging.simp.stomp.DefaultStompSession . afterConnected ( this . org.springframework.messaging.simp.stomp.TcpConnection<byte[]> ) ; assertTrue ( this . org.springframework.messaging.simp.stomp.DefaultStompSession . isConnected ( ) ) ; StompHeaders org.springframework.messaging.simp.stomp.StompHeaders = new StompHeaders ( ) ; org.springframework.messaging.simp.stomp.StompHeaders . setDestination ( STRING ) ; org.springframework.messaging.simp.stomp.StompHeaders . setContentType ( MimeTypeUtils . APPLICATION_JSON ) ; java.lang.String java.lang.String = STRING ; this . org.springframework.messaging.simp.stomp.ExpectedException . expect ( MessageConversionException .class ) ; this . org.springframework.messaging.simp.stomp.DefaultStompSession . send ( org.springframework.messaging.simp.stomp.StompHeaders , java.lang.String ) ; verifyNoMoreInteractions ( this . org.springframework.messaging.simp.stomp.TcpConnection<byte[]> ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { this . org.springframework.messaging.simp.stomp.DefaultStompSession . afterConnected ( this . org.springframework.messaging.simp.stomp.TcpConnection<byte[]> ) ; assertTrue ( this . org.springframework.messaging.simp.stomp.DefaultStompSession . isConnected ( ) ) ; java.lang.IllegalStateException java.lang.IllegalStateException = new java.lang.IllegalStateException ( STRING ) ; SettableListenableFuture < java.lang.Void > org.springframework.messaging.simp.stomp.SettableListenableFuture<java.lang.Void> = new SettableListenableFuture <> ( ) ; org.springframework.messaging.simp.stomp.SettableListenableFuture<java.lang.Void> . setException ( java.lang.IllegalStateException ) ; when ( this . org.springframework.messaging.simp.stomp.TcpConnection<byte[]> . send ( any ( ) ) ) . thenReturn ( org.springframework.messaging.simp.stomp.SettableListenableFuture<java.lang.Void> ) ; this . org.springframework.messaging.simp.stomp.ExpectedException . expect ( MessageDeliveryException .class ) ; this . org.springframework.messaging.simp.stomp.ExpectedException . expectCause ( Matchers . sameInstance ( java.lang.IllegalStateException ) ) ; this . org.springframework.messaging.simp.stomp.DefaultStompSession . send ( STRING , STRING . byte[] ( java.nio.charset.StandardCharsets . java.nio.charset.Charset ) ) ; verifyNoMoreInteractions ( this . org.springframework.messaging.simp.stomp.TcpConnection<byte[]> ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { this . org.springframework.messaging.simp.stomp.DefaultStompSession . afterConnected ( this . org.springframework.messaging.simp.stomp.TcpConnection<byte[]> ) ; assertTrue ( this . org.springframework.messaging.simp.stomp.DefaultStompSession . isConnected ( ) ) ; java.lang.String java.lang.String = STRING ; StompFrameHandler org.springframework.messaging.simp.stomp.StompFrameHandler = mock ( StompFrameHandler .class ) ; Subscription org.springframework.messaging.simp.stomp.Subscription = this . org.springframework.messaging.simp.stomp.DefaultStompSession . subscribe ( java.lang.String , org.springframework.messaging.simp.stomp.StompFrameHandler ) ; Message < byte [] > org.springframework.messaging.simp.stomp.Message<byte[]> = this . org.springframework.messaging.simp.stomp.ArgumentCaptor<org.springframework.messaging.simp.stomp.Message<byte[]>> . getValue ( ) ; StompHeaderAccessor org.springframework.messaging.simp.stomp.StompHeaderAccessor = MessageHeaderAccessor . getAccessor ( org.springframework.messaging.simp.stomp.Message<byte[]> , StompHeaderAccessor .class ) ; assertEquals ( StompCommand . SUBSCRIBE , org.springframework.messaging.simp.stomp.StompHeaderAccessor . getCommand ( ) ) ; StompHeaders org.springframework.messaging.simp.stomp.StompHeaders = StompHeaders . readOnlyStompHeaders ( org.springframework.messaging.simp.stomp.StompHeaderAccessor . getNativeHeaders ( ) ) ; assertEquals ( org.springframework.messaging.simp.stomp.StompHeaders . toString ( ) , NUMBER , org.springframework.messaging.simp.stomp.StompHeaders . size ( ) ) ; assertEquals ( java.lang.String , org.springframework.messaging.simp.stomp.StompHeaders . getDestination ( ) ) ; assertEquals ( org.springframework.messaging.simp.stomp.Subscription . getSubscriptionId ( ) , org.springframework.messaging.simp.stomp.StompHeaders . getId ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { this . org.springframework.messaging.simp.stomp.DefaultStompSession . afterConnected ( this . org.springframework.messaging.simp.stomp.TcpConnection<byte[]> ) ; assertTrue ( this . org.springframework.messaging.simp.stomp.DefaultStompSession . isConnected ( ) ) ; java.lang.String java.lang.String = STRING ; java.lang.String java.lang.String = STRING ; StompHeaders org.springframework.messaging.simp.stomp.StompHeaders = new StompHeaders ( ) ; org.springframework.messaging.simp.stomp.StompHeaders . setId ( java.lang.String ) ; org.springframework.messaging.simp.stomp.StompHeaders . setDestination ( java.lang.String ) ; StompFrameHandler org.springframework.messaging.simp.stomp.StompFrameHandler = mock ( StompFrameHandler .class ) ; Subscription org.springframework.messaging.simp.stomp.Subscription = this . org.springframework.messaging.simp.stomp.DefaultStompSession . subscribe ( org.springframework.messaging.simp.stomp.StompHeaders , org.springframework.messaging.simp.stomp.StompFrameHandler ) ; assertEquals ( java.lang.String , org.springframework.messaging.simp.stomp.Subscription . getSubscriptionId ( ) ) ; Message < byte [] > org.springframework.messaging.simp.stomp.Message<byte[]> = this . org.springframework.messaging.simp.stomp.ArgumentCaptor<org.springframework.messaging.simp.stomp.Message<byte[]>> . getValue ( ) ; StompHeaderAccessor org.springframework.messaging.simp.stomp.StompHeaderAccessor = MessageHeaderAccessor . getAccessor ( org.springframework.messaging.simp.stomp.Message<byte[]> , StompHeaderAccessor .class ) ; assertEquals ( StompCommand . SUBSCRIBE , org.springframework.messaging.simp.stomp.StompHeaderAccessor . getCommand ( ) ) ; org.springframework.messaging.simp.stomp.StompHeaders = StompHeaders . readOnlyStompHeaders ( org.springframework.messaging.simp.stomp.StompHeaderAccessor . getNativeHeaders ( ) ) ; assertEquals ( org.springframework.messaging.simp.stomp.StompHeaders . toString ( ) , NUMBER , org.springframework.messaging.simp.stomp.StompHeaders . size ( ) ) ; assertEquals ( java.lang.String , org.springframework.messaging.simp.stomp.StompHeaders . getDestination ( ) ) ; assertEquals ( java.lang.String , org.springframework.messaging.simp.stomp.StompHeaders . getId ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { this . org.springframework.messaging.simp.stomp.DefaultStompSession . afterConnected ( this . org.springframework.messaging.simp.stomp.TcpConnection<byte[]> ) ; assertTrue ( this . org.springframework.messaging.simp.stomp.DefaultStompSession . isConnected ( ) ) ; java.lang.String java.lang.String = STRING ; StompFrameHandler org.springframework.messaging.simp.stomp.StompFrameHandler = mock ( StompFrameHandler .class ) ; Subscription org.springframework.messaging.simp.stomp.Subscription = this . org.springframework.messaging.simp.stomp.DefaultStompSession . subscribe ( java.lang.String , org.springframework.messaging.simp.stomp.StompFrameHandler ) ; org.springframework.messaging.simp.stomp.Subscription . unsubscribe ( ) ; Message < byte [] > org.springframework.messaging.simp.stomp.Message<byte[]> = this . org.springframework.messaging.simp.stomp.ArgumentCaptor<org.springframework.messaging.simp.stomp.Message<byte[]>> . getValue ( ) ; StompHeaderAccessor org.springframework.messaging.simp.stomp.StompHeaderAccessor = MessageHeaderAccessor . getAccessor ( org.springframework.messaging.simp.stomp.Message<byte[]> , StompHeaderAccessor .class ) ; assertEquals ( StompCommand . UNSUBSCRIBE , org.springframework.messaging.simp.stomp.StompHeaderAccessor . getCommand ( ) ) ; StompHeaders org.springframework.messaging.simp.stomp.StompHeaders = StompHeaders . readOnlyStompHeaders ( org.springframework.messaging.simp.stomp.StompHeaderAccessor . getNativeHeaders ( ) ) ; assertEquals ( org.springframework.messaging.simp.stomp.StompHeaders . toString ( ) , NUMBER , org.springframework.messaging.simp.stomp.StompHeaders . size ( ) ) ; assertEquals ( org.springframework.messaging.simp.stomp.Subscription . getSubscriptionId ( ) , org.springframework.messaging.simp.stomp.StompHeaders . getId ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { this . org.springframework.messaging.simp.stomp.DefaultStompSession . afterConnected ( this . org.springframework.messaging.simp.stomp.TcpConnection<byte[]> ) ; assertTrue ( this . org.springframework.messaging.simp.stomp.DefaultStompSession . isConnected ( ) ) ; java.lang.String java.lang.String = STRING ; java.lang.String java.lang.String = STRING ; StompHeaders org.springframework.messaging.simp.stomp.StompHeaders = new StompHeaders ( ) ; org.springframework.messaging.simp.stomp.StompHeaders . setDestination ( STRING ) ; org.springframework.messaging.simp.stomp.StompHeaders . set ( java.lang.String , java.lang.String ) ; StompFrameHandler org.springframework.messaging.simp.stomp.StompFrameHandler = mock ( StompFrameHandler .class ) ; Subscription org.springframework.messaging.simp.stomp.Subscription = this . org.springframework.messaging.simp.stomp.DefaultStompSession . subscribe ( org.springframework.messaging.simp.stomp.StompHeaders , org.springframework.messaging.simp.stomp.StompFrameHandler ) ; StompHeaders org.springframework.messaging.simp.stomp.StompHeaders = new StompHeaders ( ) ; org.springframework.messaging.simp.stomp.StompHeaders . set ( java.lang.String , org.springframework.messaging.simp.stomp.Subscription . getSubscriptionHeaders ( ) . getFirst ( java.lang.String ) ) ; org.springframework.messaging.simp.stomp.Subscription . unsubscribe ( org.springframework.messaging.simp.stomp.StompHeaders ) ; Message < byte [] > org.springframework.messaging.simp.stomp.Message<byte[]> = this . org.springframework.messaging.simp.stomp.ArgumentCaptor<org.springframework.messaging.simp.stomp.Message<byte[]>> . getValue ( ) ; StompHeaderAccessor org.springframework.messaging.simp.stomp.StompHeaderAccessor = MessageHeaderAccessor . getAccessor ( org.springframework.messaging.simp.stomp.Message<byte[]> , StompHeaderAccessor .class ) ; assertEquals ( StompCommand . UNSUBSCRIBE , org.springframework.messaging.simp.stomp.StompHeaderAccessor . getCommand ( ) ) ; StompHeaders org.springframework.messaging.simp.stomp.StompHeaders = StompHeaders . readOnlyStompHeaders ( org.springframework.messaging.simp.stomp.StompHeaderAccessor . getNativeHeaders ( ) ) ; assertEquals ( org.springframework.messaging.simp.stomp.StompHeaders . toString ( ) , NUMBER , org.springframework.messaging.simp.stomp.StompHeaders . size ( ) ) ; assertEquals ( org.springframework.messaging.simp.stomp.Subscription . getSubscriptionId ( ) , org.springframework.messaging.simp.stomp.StompHeaders . getId ( ) ) ; assertEquals ( java.lang.String , org.springframework.messaging.simp.stomp.StompHeaders . getFirst ( java.lang.String ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { this . org.springframework.messaging.simp.stomp.DefaultStompSession . afterConnected ( this . org.springframework.messaging.simp.stomp.TcpConnection<byte[]> ) ; assertTrue ( this . org.springframework.messaging.simp.stomp.DefaultStompSession . isConnected ( ) ) ; java.lang.String java.lang.String = STRING ; this . org.springframework.messaging.simp.stomp.DefaultStompSession . acknowledge ( java.lang.String , true ) ; Message < byte [] > org.springframework.messaging.simp.stomp.Message<byte[]> = this . org.springframework.messaging.simp.stomp.ArgumentCaptor<org.springframework.messaging.simp.stomp.Message<byte[]>> . getValue ( ) ; StompHeaderAccessor org.springframework.messaging.simp.stomp.StompHeaderAccessor = MessageHeaderAccessor . getAccessor ( org.springframework.messaging.simp.stomp.Message<byte[]> , StompHeaderAccessor .class ) ; assertEquals ( StompCommand . ACK , org.springframework.messaging.simp.stomp.StompHeaderAccessor . getCommand ( ) ) ; StompHeaders org.springframework.messaging.simp.stomp.StompHeaders = StompHeaders . readOnlyStompHeaders ( org.springframework.messaging.simp.stomp.StompHeaderAccessor . getNativeHeaders ( ) ) ; assertEquals ( org.springframework.messaging.simp.stomp.StompHeaders . toString ( ) , NUMBER , org.springframework.messaging.simp.stomp.StompHeaders . size ( ) ) ; assertEquals ( java.lang.String , org.springframework.messaging.simp.stomp.StompHeaders . getId ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { this . org.springframework.messaging.simp.stomp.DefaultStompSession . afterConnected ( this . org.springframework.messaging.simp.stomp.TcpConnection<byte[]> ) ; assertTrue ( this . org.springframework.messaging.simp.stomp.DefaultStompSession . isConnected ( ) ) ; java.lang.String java.lang.String = STRING ; this . org.springframework.messaging.simp.stomp.DefaultStompSession . acknowledge ( java.lang.String , false ) ; Message < byte [] > org.springframework.messaging.simp.stomp.Message<byte[]> = this . org.springframework.messaging.simp.stomp.ArgumentCaptor<org.springframework.messaging.simp.stomp.Message<byte[]>> . getValue ( ) ; StompHeaderAccessor org.springframework.messaging.simp.stomp.StompHeaderAccessor = MessageHeaderAccessor . getAccessor ( org.springframework.messaging.simp.stomp.Message<byte[]> , StompHeaderAccessor .class ) ; assertEquals ( StompCommand . NACK , org.springframework.messaging.simp.stomp.StompHeaderAccessor . getCommand ( ) ) ; StompHeaders org.springframework.messaging.simp.stomp.StompHeaders = StompHeaders . readOnlyStompHeaders ( org.springframework.messaging.simp.stomp.StompHeaderAccessor . getNativeHeaders ( ) ) ; assertEquals ( org.springframework.messaging.simp.stomp.StompHeaders . toString ( ) , NUMBER , org.springframework.messaging.simp.stomp.StompHeaders . size ( ) ) ; assertEquals ( java.lang.String , org.springframework.messaging.simp.stomp.StompHeaders . getId ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { this . org.springframework.messaging.simp.stomp.DefaultStompSession . afterConnected ( this . org.springframework.messaging.simp.stomp.TcpConnection<byte[]> ) ; this . org.springframework.messaging.simp.stomp.DefaultStompSession . setTaskScheduler ( mock ( TaskScheduler .class ) ) ; java.util.concurrent.atomic.AtomicReference<java.lang.Boolean> < java.lang.Boolean > java.util.concurrent.atomic.AtomicReference<java.lang.Boolean> = new java.util.concurrent.atomic.AtomicReference<java.lang.Boolean> <> ( ) ; StompHeaders org.springframework.messaging.simp.stomp.StompHeaders = new StompHeaders ( ) ; org.springframework.messaging.simp.stomp.StompHeaders . setDestination ( STRING ) ; org.springframework.messaging.simp.stomp.StompHeaders . setReceipt ( STRING ) ; Subscription org.springframework.messaging.simp.stomp.Subscription = this . org.springframework.messaging.simp.stomp.DefaultStompSession . subscribe ( org.springframework.messaging.simp.stomp.StompHeaders , mock ( StompFrameHandler .class ) ) ; org.springframework.messaging.simp.stomp.Subscription . addReceiptTask ( ( ) received . set ( true ) ) ; assertNull ( java.util.concurrent.atomic.AtomicReference<java.lang.Boolean> . java.lang.Boolean ( ) ) ; StompHeaderAccessor org.springframework.messaging.simp.stomp.StompHeaderAccessor = StompHeaderAccessor . create ( StompCommand . RECEIPT ) ; org.springframework.messaging.simp.stomp.StompHeaderAccessor . setReceiptId ( STRING ) ; org.springframework.messaging.simp.stomp.StompHeaderAccessor . setLeaveMutable ( true ) ; this . org.springframework.messaging.simp.stomp.DefaultStompSession . handleMessage ( MessageBuilder . createMessage ( new byte [ NUMBER ] , org.springframework.messaging.simp.stomp.StompHeaderAccessor . getMessageHeaders ( ) ) ) ; assertNotNull ( java.util.concurrent.atomic.AtomicReference<java.lang.Boolean> . java.lang.Boolean ( ) ) ; assertTrue ( java.util.concurrent.atomic.AtomicReference<java.lang.Boolean> . java.lang.Boolean ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { this . org.springframework.messaging.simp.stomp.DefaultStompSession . afterConnected ( this . org.springframework.messaging.simp.stomp.TcpConnection<byte[]> ) ; this . org.springframework.messaging.simp.stomp.DefaultStompSession . setTaskScheduler ( mock ( TaskScheduler .class ) ) ; java.util.concurrent.atomic.AtomicReference<java.lang.Boolean> < java.lang.Boolean > java.util.concurrent.atomic.AtomicReference<java.lang.Boolean> = new java.util.concurrent.atomic.AtomicReference<java.lang.Boolean> <> ( ) ; StompHeaders org.springframework.messaging.simp.stomp.StompHeaders = new StompHeaders ( ) ; org.springframework.messaging.simp.stomp.StompHeaders . setDestination ( STRING ) ; org.springframework.messaging.simp.stomp.StompHeaders . setReceipt ( STRING ) ; Subscription org.springframework.messaging.simp.stomp.Subscription = this . org.springframework.messaging.simp.stomp.DefaultStompSession . subscribe ( org.springframework.messaging.simp.stomp.StompHeaders , mock ( StompFrameHandler .class ) ) ; StompHeaderAccessor org.springframework.messaging.simp.stomp.StompHeaderAccessor = StompHeaderAccessor . create ( StompCommand . RECEIPT ) ; org.springframework.messaging.simp.stomp.StompHeaderAccessor . setReceiptId ( STRING ) ; org.springframework.messaging.simp.stomp.StompHeaderAccessor . setLeaveMutable ( true ) ; this . org.springframework.messaging.simp.stomp.DefaultStompSession . handleMessage ( MessageBuilder . createMessage ( new byte [ NUMBER ] , org.springframework.messaging.simp.stomp.StompHeaderAccessor . getMessageHeaders ( ) ) ) ; org.springframework.messaging.simp.stomp.Subscription . addReceiptTask ( ( ) received . set ( true ) ) ; assertNotNull ( java.util.concurrent.atomic.AtomicReference<java.lang.Boolean> . java.lang.Boolean ( ) ) ; assertTrue ( java.util.concurrent.atomic.AtomicReference<java.lang.Boolean> . java.lang.Boolean ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test @ java.lang.SuppressWarnings ( { STRING , STRING } ) public void void ( ) java.lang.Exception { TaskScheduler org.springframework.messaging.simp.stomp.TaskScheduler = mock ( TaskScheduler .class ) ; this . org.springframework.messaging.simp.stomp.DefaultStompSession . afterConnected ( this . org.springframework.messaging.simp.stomp.TcpConnection<byte[]> ) ; this . org.springframework.messaging.simp.stomp.DefaultStompSession . setTaskScheduler ( org.springframework.messaging.simp.stomp.TaskScheduler ) ; java.util.concurrent.atomic.AtomicReference<java.lang.Boolean> < java.lang.Boolean > java.util.concurrent.atomic.AtomicReference<java.lang.Boolean> = new java.util.concurrent.atomic.AtomicReference<java.lang.Boolean> <> ( ) ; java.util.concurrent.ScheduledFuture java.util.concurrent.ScheduledFuture = mock ( java.util.concurrent.ScheduledFuture .class ) ; when ( org.springframework.messaging.simp.stomp.TaskScheduler . schedule ( any ( java.lang.Runnable .class ) , any ( java.util.Date .class ) ) ) . thenReturn ( java.util.concurrent.ScheduledFuture ) ; StompHeaders org.springframework.messaging.simp.stomp.StompHeaders = new StompHeaders ( ) ; org.springframework.messaging.simp.stomp.StompHeaders . setDestination ( STRING ) ; org.springframework.messaging.simp.stomp.StompHeaders . setReceipt ( STRING ) ; Receiptable org.springframework.messaging.simp.stomp.Receiptable = this . org.springframework.messaging.simp.stomp.DefaultStompSession . send ( org.springframework.messaging.simp.stomp.StompHeaders , STRING ) ; org.springframework.messaging.simp.stomp.Receiptable . addReceiptLostTask ( ( ) notReceived . set ( true ) ) ; ArgumentCaptor < java.lang.Runnable > org.springframework.messaging.simp.stomp.ArgumentCaptor<java.lang.Runnable> = ArgumentCaptor . forClass ( java.lang.Runnable .class ) ; verify ( org.springframework.messaging.simp.stomp.TaskScheduler ) . schedule ( org.springframework.messaging.simp.stomp.ArgumentCaptor<java.lang.Runnable> . capture ( ) , ( java.util.Date ) notNull ( ) ) ; java.lang.Runnable java.lang.Runnable = org.springframework.messaging.simp.stomp.ArgumentCaptor<java.lang.Runnable> . getValue ( ) ; assertNotNull ( java.lang.Runnable ) ; assertNull ( java.util.concurrent.atomic.AtomicReference<java.lang.Boolean> . java.lang.Boolean ( ) ) ; java.lang.Runnable . void ( ) ; assertTrue ( java.util.concurrent.atomic.AtomicReference<java.lang.Boolean> . java.lang.Boolean ( ) ) ; verify ( java.util.concurrent.ScheduledFuture ) . cancel ( true ) ; verifyNoMoreInteractions ( java.util.concurrent.ScheduledFuture ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { this . org.springframework.messaging.simp.stomp.DefaultStompSession . afterConnected ( this . org.springframework.messaging.simp.stomp.TcpConnection<byte[]> ) ; assertTrue ( this . org.springframework.messaging.simp.stomp.DefaultStompSession . isConnected ( ) ) ; this . org.springframework.messaging.simp.stomp.DefaultStompSession . disconnect ( ) ; assertFalse ( this . org.springframework.messaging.simp.stomp.DefaultStompSession . isConnected ( ) ) ; verifyNoMoreInteractions ( this . org.springframework.messaging.simp.stomp.StompSessionHandler ) ; }  <METHOD_END>
