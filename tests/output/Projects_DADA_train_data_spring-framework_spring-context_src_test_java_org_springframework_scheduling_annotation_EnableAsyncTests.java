<METHOD_START> @ Test public void void ( ) { AnnotationConfigApplicationContext org.springframework.scheduling.annotation.AnnotationConfigApplicationContext = new AnnotationConfigApplicationContext ( ) ; org.springframework.scheduling.annotation.AnnotationConfigApplicationContext . register ( org.springframework.scheduling.annotation.EnableAsyncTests.AsyncConfig .class ) ; org.springframework.scheduling.annotation.AnnotationConfigApplicationContext . refresh ( ) ; org.springframework.scheduling.annotation.EnableAsyncTests.AsyncBean org.springframework.scheduling.annotation.EnableAsyncTests.AsyncBean = org.springframework.scheduling.annotation.AnnotationConfigApplicationContext . getBean ( org.springframework.scheduling.annotation.EnableAsyncTests.AsyncBean .class ) ; assertThat ( AopUtils . isAopProxy ( org.springframework.scheduling.annotation.EnableAsyncTests.AsyncBean ) , is ( true ) ) ; org.springframework.scheduling.annotation.EnableAsyncTests.AsyncBean . void ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { AnnotationConfigApplicationContext org.springframework.scheduling.annotation.AnnotationConfigApplicationContext = new AnnotationConfigApplicationContext ( ) ; org.springframework.scheduling.annotation.AnnotationConfigApplicationContext . register ( org.springframework.scheduling.annotation.EnableAsyncTests.AsyncConfigWithMockito .class , org.springframework.scheduling.annotation.EnableAsyncTests.AsyncBeanUser .class ) ; org.springframework.scheduling.annotation.AnnotationConfigApplicationContext . refresh ( ) ; org.springframework.scheduling.annotation.EnableAsyncTests.AsyncBeanUser org.springframework.scheduling.annotation.EnableAsyncTests.AsyncBeanUser = org.springframework.scheduling.annotation.AnnotationConfigApplicationContext . getBean ( org.springframework.scheduling.annotation.EnableAsyncTests.AsyncBeanUser .class ) ; org.springframework.scheduling.annotation.EnableAsyncTests.AsyncBean org.springframework.scheduling.annotation.EnableAsyncTests.AsyncBean = org.springframework.scheduling.annotation.EnableAsyncTests.AsyncBeanUser . org.springframework.scheduling.annotation.EnableAsyncTests.AsyncBean ( ) ; assertThat ( AopUtils . isAopProxy ( org.springframework.scheduling.annotation.EnableAsyncTests.AsyncBean ) , is ( true ) ) ; org.springframework.scheduling.annotation.EnableAsyncTests.AsyncBean . void ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { AnnotationConfigApplicationContext org.springframework.scheduling.annotation.AnnotationConfigApplicationContext = new AnnotationConfigApplicationContext ( ) ; org.springframework.scheduling.annotation.AnnotationConfigApplicationContext . register ( org.springframework.scheduling.annotation.EnableAsyncTests.AsyncConfig .class , org.springframework.scheduling.annotation.EnableAsyncTests.AsyncBeanWithInterface .class , org.springframework.scheduling.annotation.EnableAsyncTests.AsyncBeanUser .class ) ; try { org.springframework.scheduling.annotation.AnnotationConfigApplicationContext . refresh ( ) ; fail ( STRING ) ; } catch ( UnsatisfiedDependencyException org.springframework.scheduling.annotation.UnsatisfiedDependencyException ) { org.springframework.scheduling.annotation.UnsatisfiedDependencyException . printStackTrace ( ) ; assertTrue ( org.springframework.scheduling.annotation.UnsatisfiedDependencyException . getCause ( ) instanceof BeanNotOfRequiredTypeException ) ; } }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { AnnotationConfigApplicationContext org.springframework.scheduling.annotation.AnnotationConfigApplicationContext = new AnnotationConfigApplicationContext ( ) ; org.springframework.scheduling.annotation.AnnotationConfigApplicationContext . register ( org.springframework.scheduling.annotation.EnableAsyncTests.AsyncConfig .class , org.springframework.scheduling.annotation.EnableAsyncTests.AsyncBeanUser .class , org.springframework.scheduling.annotation.EnableAsyncTests.AsyncBeanWithInterface .class ) ; try { org.springframework.scheduling.annotation.AnnotationConfigApplicationContext . refresh ( ) ; fail ( STRING ) ; } catch ( UnsatisfiedDependencyException org.springframework.scheduling.annotation.UnsatisfiedDependencyException ) { org.springframework.scheduling.annotation.UnsatisfiedDependencyException . printStackTrace ( ) ; assertTrue ( org.springframework.scheduling.annotation.UnsatisfiedDependencyException . getCause ( ) instanceof BeanNotOfRequiredTypeException ) ; } }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.util.concurrent.ExecutionException , java.lang.InterruptedException { AnnotationConfigApplicationContext org.springframework.scheduling.annotation.AnnotationConfigApplicationContext = new AnnotationConfigApplicationContext ( ) ; org.springframework.scheduling.annotation.AnnotationConfigApplicationContext . register ( org.springframework.scheduling.annotation.EnableAsyncTests.AsyncWithExecutorQualifiedByNameConfig .class ) ; org.springframework.scheduling.annotation.AnnotationConfigApplicationContext . refresh ( ) ; org.springframework.scheduling.annotation.EnableAsyncTests.AsyncBeanWithExecutorQualifiedByName org.springframework.scheduling.annotation.EnableAsyncTests.AsyncBeanWithExecutorQualifiedByName = org.springframework.scheduling.annotation.AnnotationConfigApplicationContext . getBean ( org.springframework.scheduling.annotation.EnableAsyncTests.AsyncBeanWithExecutorQualifiedByName .class ) ; java.util.concurrent.Future<java.lang.Thread> < java.lang.Thread > java.util.concurrent.Future<java.lang.Thread> = org.springframework.scheduling.annotation.EnableAsyncTests.AsyncBeanWithExecutorQualifiedByName . java.util.concurrent.Future<java.lang.Thread> ( ) ; assertThat ( java.util.concurrent.Future<java.lang.Thread> . java.lang.Thread ( ) . java.lang.String ( ) , not ( anyOf ( startsWith ( STRING ) , startsWith ( STRING ) ) ) ) ; java.util.concurrent.Future<java.lang.Thread> < java.lang.Thread > java.util.concurrent.Future<java.lang.Thread> = org.springframework.scheduling.annotation.EnableAsyncTests.AsyncBeanWithExecutorQualifiedByName . java.util.concurrent.Future<java.lang.Thread> ( ) ; assertThat ( java.util.concurrent.Future<java.lang.Thread> . java.lang.Thread ( ) . java.lang.String ( ) , startsWith ( STRING ) ) ; java.util.concurrent.Future<java.lang.Thread> < java.lang.Thread > java.util.concurrent.Future<java.lang.Thread> = org.springframework.scheduling.annotation.EnableAsyncTests.AsyncBeanWithExecutorQualifiedByName . java.util.concurrent.Future<java.lang.Thread> ( ) ; assertThat ( java.util.concurrent.Future<java.lang.Thread> . java.lang.Thread ( ) . java.lang.String ( ) , startsWith ( STRING ) ) ; java.util.concurrent.Future<java.lang.Thread> < java.lang.Thread > java.util.concurrent.Future<java.lang.Thread> = org.springframework.scheduling.annotation.EnableAsyncTests.AsyncBeanWithExecutorQualifiedByName . java.util.concurrent.Future<java.lang.Thread> ( ) ; assertThat ( java.util.concurrent.Future<java.lang.Thread> . java.lang.Thread ( ) . java.lang.String ( ) , startsWith ( STRING ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { AnnotationConfigApplicationContext org.springframework.scheduling.annotation.AnnotationConfigApplicationContext = new AnnotationConfigApplicationContext ( ) ; org.springframework.scheduling.annotation.AnnotationConfigApplicationContext . register ( org.springframework.scheduling.annotation.EnableAsyncTests.AsyncConfig .class ) ; org.springframework.scheduling.annotation.AnnotationConfigApplicationContext . refresh ( ) ; AsyncAnnotationBeanPostProcessor org.springframework.scheduling.annotation.AsyncAnnotationBeanPostProcessor = org.springframework.scheduling.annotation.AnnotationConfigApplicationContext . getBean ( AsyncAnnotationBeanPostProcessor .class ) ; assertThat ( org.springframework.scheduling.annotation.AsyncAnnotationBeanPostProcessor . getOrder ( ) , is ( Ordered . LOWEST_PRECEDENCE ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { AnnotationConfigApplicationContext org.springframework.scheduling.annotation.AnnotationConfigApplicationContext = new AnnotationConfigApplicationContext ( ) ; org.springframework.scheduling.annotation.AnnotationConfigApplicationContext . register ( org.springframework.scheduling.annotation.EnableAsyncTests.OrderedAsyncConfig .class ) ; org.springframework.scheduling.annotation.AnnotationConfigApplicationContext . refresh ( ) ; AsyncAnnotationBeanPostProcessor org.springframework.scheduling.annotation.AsyncAnnotationBeanPostProcessor = org.springframework.scheduling.annotation.AnnotationConfigApplicationContext . getBean ( AsyncAnnotationBeanPostProcessor .class ) ; assertThat ( org.springframework.scheduling.annotation.AsyncAnnotationBeanPostProcessor . getOrder ( ) , is ( Ordered . HIGHEST_PRECEDENCE ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { AnnotationConfigApplicationContext org.springframework.scheduling.annotation.AnnotationConfigApplicationContext = new AnnotationConfigApplicationContext ( ) ; org.springframework.scheduling.annotation.AnnotationConfigApplicationContext . register ( org.springframework.scheduling.annotation.EnableAsyncTests.CustomAsyncAnnotationConfig .class , org.springframework.scheduling.annotation.EnableAsyncTests.CustomAsyncBean .class ) ; org.springframework.scheduling.annotation.AnnotationConfigApplicationContext . refresh ( ) ; java.lang.Object java.lang.Object = org.springframework.scheduling.annotation.AnnotationConfigApplicationContext . getBean ( org.springframework.scheduling.annotation.EnableAsyncTests.CustomAsyncBean .class ) ; assertTrue ( AopUtils . isAopProxy ( java.lang.Object ) ) ; boolean boolean = false ; for ( Advisor org.springframework.scheduling.annotation.Advisor : ( ( Advised ) java.lang.Object ) . getAdvisors ( ) ) { if ( org.springframework.scheduling.annotation.Advisor instanceof AsyncAnnotationAdvisor ) { boolean = true ; break; } } assertTrue ( STRING , boolean ) ; }  <METHOD_END>
<METHOD_START> @ Test ( expected = BeanDefinitionStoreException .class ) public void void ( ) { AnnotationConfigApplicationContext org.springframework.scheduling.annotation.AnnotationConfigApplicationContext = new AnnotationConfigApplicationContext ( ) ; org.springframework.scheduling.annotation.AnnotationConfigApplicationContext . register ( org.springframework.scheduling.annotation.EnableAsyncTests.AspectJAsyncAnnotationConfig .class ) ; org.springframework.scheduling.annotation.AnnotationConfigApplicationContext . refresh ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.InterruptedException { AnnotationConfigApplicationContext org.springframework.scheduling.annotation.AnnotationConfigApplicationContext = new AnnotationConfigApplicationContext ( ) ; org.springframework.scheduling.annotation.AnnotationConfigApplicationContext . register ( org.springframework.scheduling.annotation.EnableAsyncTests.CustomExecutorAsyncConfig .class ) ; org.springframework.scheduling.annotation.AnnotationConfigApplicationContext . refresh ( ) ; org.springframework.scheduling.annotation.EnableAsyncTests.AsyncBean org.springframework.scheduling.annotation.EnableAsyncTests.AsyncBean = org.springframework.scheduling.annotation.AnnotationConfigApplicationContext . getBean ( org.springframework.scheduling.annotation.EnableAsyncTests.AsyncBean .class ) ; org.springframework.scheduling.annotation.EnableAsyncTests.AsyncBean . void ( ) ; java.lang.Thread . void ( NUMBER ) ; assertThat ( org.springframework.scheduling.annotation.EnableAsyncTests.AsyncBean . java.lang.Thread ( ) . java.lang.String ( ) , startsWith ( STRING ) ) ; TestableAsyncUncaughtExceptionHandler org.springframework.scheduling.annotation.TestableAsyncUncaughtExceptionHandler = ( TestableAsyncUncaughtExceptionHandler ) org.springframework.scheduling.annotation.AnnotationConfigApplicationContext . getBean ( STRING ) ; assertFalse ( STRING , org.springframework.scheduling.annotation.TestableAsyncUncaughtExceptionHandler . isCalled ( ) ) ; org.springframework.scheduling.annotation.EnableAsyncTests.AsyncBean . void ( ) ; java.lang.Thread . void ( NUMBER ) ; java.lang.reflect.Method java.lang.reflect.Method = ReflectionUtils . findMethod ( org.springframework.scheduling.annotation.EnableAsyncTests.AsyncBean .class , STRING ) ; org.springframework.scheduling.annotation.TestableAsyncUncaughtExceptionHandler . assertCalledWith ( java.lang.reflect.Method , java.lang.UnsupportedOperationException .class ) ; org.springframework.scheduling.annotation.AnnotationConfigApplicationContext . close ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.InterruptedException { AnnotationConfigApplicationContext org.springframework.scheduling.annotation.AnnotationConfigApplicationContext = new AnnotationConfigApplicationContext ( org.springframework.scheduling.annotation.EnableAsyncTests.Spr14949ConfigA .class ) ; org.springframework.scheduling.annotation.EnableAsyncTests.AsyncInterface org.springframework.scheduling.annotation.EnableAsyncTests.AsyncInterface = org.springframework.scheduling.annotation.AnnotationConfigApplicationContext . getBean ( org.springframework.scheduling.annotation.EnableAsyncTests.AsyncInterface .class ) ; org.springframework.scheduling.annotation.EnableAsyncTests.AsyncInterface . void ( ) ; java.lang.Thread . void ( NUMBER ) ; assertThat ( org.springframework.scheduling.annotation.EnableAsyncTests.AsyncInterface . java.lang.Thread ( ) . java.lang.String ( ) , startsWith ( STRING ) ) ; org.springframework.scheduling.annotation.AnnotationConfigApplicationContext . close ( ) ; }  <METHOD_END>
<METHOD_START> @ Test @ Ignore public void void ( ) java.lang.InterruptedException { AnnotationConfigApplicationContext org.springframework.scheduling.annotation.AnnotationConfigApplicationContext = new AnnotationConfigApplicationContext ( org.springframework.scheduling.annotation.EnableAsyncTests.Spr14949ConfigB .class ) ; org.springframework.scheduling.annotation.EnableAsyncTests.AsyncInterface org.springframework.scheduling.annotation.EnableAsyncTests.AsyncInterface = org.springframework.scheduling.annotation.AnnotationConfigApplicationContext . getBean ( org.springframework.scheduling.annotation.EnableAsyncTests.AsyncInterface .class ) ; org.springframework.scheduling.annotation.EnableAsyncTests.AsyncInterface . void ( ) ; java.lang.Thread . void ( NUMBER ) ; assertThat ( org.springframework.scheduling.annotation.EnableAsyncTests.AsyncInterface . java.lang.Thread ( ) . java.lang.String ( ) , startsWith ( STRING ) ) ; org.springframework.scheduling.annotation.AnnotationConfigApplicationContext . close ( ) ; }  <METHOD_END>
<METHOD_START> @ Async public java.util.concurrent.Future<java.lang.Thread> < java.lang.Thread > java.util.concurrent.Future<java.lang.Thread> ( ) { return new AsyncResult <> ( java.lang.Thread . java.lang.Thread ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Async ( STRING ) public java.util.concurrent.Future<java.lang.Thread> < java.lang.Thread > java.util.concurrent.Future<java.lang.Thread> ( ) { return new AsyncResult <> ( java.lang.Thread . java.lang.Thread ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Async ( STRING ) public java.util.concurrent.Future<java.lang.Thread> < java.lang.Thread > java.util.concurrent.Future<java.lang.Thread> ( ) { return new AsyncResult <> ( java.lang.Thread . java.lang.Thread ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Async ( STRING ) public java.util.concurrent.Future<java.lang.Thread> < java.lang.Thread > java.util.concurrent.Future<java.lang.Thread> ( ) { return new AsyncResult <> ( java.lang.Thread . java.lang.Thread ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Async public void void ( ) { this . java.lang.Thread = java.lang.Thread . java.lang.Thread ( ) ; }  <METHOD_END>
<METHOD_START> @ Async public void void ( ) { throw new java.lang.UnsupportedOperationException ( ) ; }  <METHOD_END>
<METHOD_START> public java.lang.Thread java.lang.Thread ( ) { return java.lang.Thread ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ) {		}  <METHOD_END>
<METHOD_START> public void ( org.springframework.scheduling.annotation.EnableAsyncTests.AsyncBean org.springframework.scheduling.annotation.EnableAsyncTests.AsyncBean ) { this . org.springframework.scheduling.annotation.EnableAsyncTests.AsyncBean = org.springframework.scheduling.annotation.EnableAsyncTests.AsyncBean ; }  <METHOD_END>
<METHOD_START> public org.springframework.scheduling.annotation.EnableAsyncTests.AsyncBean org.springframework.scheduling.annotation.EnableAsyncTests.AsyncBean ( ) { return org.springframework.scheduling.annotation.EnableAsyncTests.AsyncBean ; }  <METHOD_END>
<METHOD_START> @ org.springframework.scheduling.annotation.EnableAsyncTests.CustomAsync public void void ( ) {		}  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.scheduling.annotation.EnableAsyncTests.AsyncBean org.springframework.scheduling.annotation.EnableAsyncTests.AsyncBean ( ) { return new org.springframework.scheduling.annotation.EnableAsyncTests.AsyncBean ( ) ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.scheduling.annotation.EnableAsyncTests.AsyncBean org.springframework.scheduling.annotation.EnableAsyncTests.AsyncBean ( ) { return new org.springframework.scheduling.annotation.EnableAsyncTests.AsyncBean ( ) ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.scheduling.annotation.EnableAsyncTests.AsyncBean org.springframework.scheduling.annotation.EnableAsyncTests.AsyncBean ( ) { return new org.springframework.scheduling.annotation.EnableAsyncTests.AsyncBean ( ) ; }  <METHOD_END>
<METHOD_START> @ Bean @ Lazy public org.springframework.scheduling.annotation.EnableAsyncTests.AsyncBean org.springframework.scheduling.annotation.EnableAsyncTests.AsyncBean ( ) { return Mockito . mock ( org.springframework.scheduling.annotation.EnableAsyncTests.AsyncBean .class ) ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.scheduling.annotation.EnableAsyncTests.AsyncBeanWithExecutorQualifiedByName org.springframework.scheduling.annotation.EnableAsyncTests.AsyncBeanWithExecutorQualifiedByName ( ) { return new org.springframework.scheduling.annotation.EnableAsyncTests.AsyncBeanWithExecutorQualifiedByName ( ) ; }  <METHOD_END>
<METHOD_START> @ Bean public java.util.concurrent.Executor java.util.concurrent.Executor ( ) { return new ThreadPoolTaskExecutor ( ) ; }  <METHOD_END>
<METHOD_START> @ Bean @ Qualifier ( STRING ) public java.util.concurrent.Executor java.util.concurrent.Executor ( ) { return new ThreadPoolTaskExecutor ( ) ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.scheduling.annotation.EnableAsyncTests.AsyncBean org.springframework.scheduling.annotation.EnableAsyncTests.AsyncBean ( ) { return new org.springframework.scheduling.annotation.EnableAsyncTests.AsyncBean ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.util.concurrent.Executor java.util.concurrent.Executor ( ) { ThreadPoolTaskExecutor org.springframework.scheduling.annotation.ThreadPoolTaskExecutor = new ThreadPoolTaskExecutor ( ) ; org.springframework.scheduling.annotation.ThreadPoolTaskExecutor . setThreadNamePrefix ( STRING ) ; org.springframework.scheduling.annotation.ThreadPoolTaskExecutor . initialize ( ) ; return org.springframework.scheduling.annotation.ThreadPoolTaskExecutor ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.scheduling.annotation.AsyncUncaughtExceptionHandler org.springframework.scheduling.annotation.AsyncUncaughtExceptionHandler ( ) { return org.springframework.scheduling.annotation.AsyncUncaughtExceptionHandler ( ) ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.scheduling.annotation.AsyncUncaughtExceptionHandler org.springframework.scheduling.annotation.AsyncUncaughtExceptionHandler ( ) { return new TestableAsyncUncaughtExceptionHandler ( ) ; }  <METHOD_END>
<METHOD_START> @ Async void void ( )  <METHOD_END>
<METHOD_START> java.lang.Thread java.lang.Thread ( )  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ) { this . java.lang.Thread = java.lang.Thread . java.lang.Thread ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.Thread java.lang.Thread ( ) { return java.lang.Thread ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.scheduling.annotation.EnableAsyncTests.AsyncInterface org.springframework.scheduling.annotation.EnableAsyncTests.AsyncInterface ( ) { return new org.springframework.scheduling.annotation.EnableAsyncTests.AsyncService ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.util.concurrent.Executor java.util.concurrent.Executor ( ) { ThreadPoolTaskExecutor org.springframework.scheduling.annotation.ThreadPoolTaskExecutor = new ThreadPoolTaskExecutor ( ) ; org.springframework.scheduling.annotation.ThreadPoolTaskExecutor . setThreadNamePrefix ( STRING ) ; org.springframework.scheduling.annotation.ThreadPoolTaskExecutor . initialize ( ) ; return org.springframework.scheduling.annotation.ThreadPoolTaskExecutor ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.scheduling.annotation.AsyncUncaughtExceptionHandler org.springframework.scheduling.annotation.AsyncUncaughtExceptionHandler ( ) { return null ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.scheduling.annotation.EnableAsyncTests.AsyncInterface org.springframework.scheduling.annotation.EnableAsyncTests.AsyncInterface ( ) { return new org.springframework.scheduling.annotation.EnableAsyncTests.AsyncService ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.util.concurrent.Executor java.util.concurrent.Executor ( ) { ThreadPoolTaskExecutor org.springframework.scheduling.annotation.ThreadPoolTaskExecutor = new ThreadPoolTaskExecutor ( ) ; org.springframework.scheduling.annotation.ThreadPoolTaskExecutor . setThreadNamePrefix ( STRING ) ; org.springframework.scheduling.annotation.ThreadPoolTaskExecutor . initialize ( ) ; return org.springframework.scheduling.annotation.ThreadPoolTaskExecutor ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.scheduling.annotation.AsyncUncaughtExceptionHandler org.springframework.scheduling.annotation.AsyncUncaughtExceptionHandler ( ) { return null ; }  <METHOD_END>
