<METHOD_START> @ java.lang.Override @ Before public void void ( ) java.lang.Exception { super. setup ( ) ; this . org.springframework.web.reactive.result.method.annotation.WebClient = WebClient . create ( STRING + this . port + STRING ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected org.springframework.web.reactive.result.method.annotation.HttpHandler org.springframework.web.reactive.result.method.annotation.HttpHandler ( ) { this . org.springframework.web.reactive.result.method.annotation.AnnotationConfigApplicationContext = new AnnotationConfigApplicationContext ( ) ; this . org.springframework.web.reactive.result.method.annotation.AnnotationConfigApplicationContext . register ( org.springframework.web.reactive.result.method.annotation.SseIntegrationTests.TestConfiguration .class ) ; this . org.springframework.web.reactive.result.method.annotation.AnnotationConfigApplicationContext . refresh ( ) ; return WebHttpHandlerBuilder . webHandler ( new DispatcherHandler ( this . org.springframework.web.reactive.result.method.annotation.AnnotationConfigApplicationContext ) ) . build ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { Flux < java.lang.String > org.springframework.web.reactive.result.method.annotation.Flux<java.lang.String> = this . org.springframework.web.reactive.result.method.annotation.WebClient . get ( ) . uri ( STRING ) . accept ( TEXT_EVENT_STREAM ) . exchange ( ) . flatMap ( response -> response . bodyToFlux ( String .class ) ) ; StepVerifier . create ( org.springframework.web.reactive.result.method.annotation.Flux<java.lang.String> ) . expectNext ( STRING ) . expectNext ( STRING ) . thenCancel ( ) . verify ( java.time.Duration . java.time.Duration ( NUMBER ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { Flux < org.springframework.web.reactive.result.method.annotation.SseIntegrationTests.Person > org.springframework.web.reactive.result.method.annotation.Flux<org.springframework.web.reactive.result.method.annotation.SseIntegrationTests.Person> = this . org.springframework.web.reactive.result.method.annotation.WebClient . get ( ) . uri ( STRING ) . accept ( TEXT_EVENT_STREAM ) . exchange ( ) . flatMap ( response -> response . bodyToFlux ( Person .class ) ) ; StepVerifier . create ( org.springframework.web.reactive.result.method.annotation.Flux<org.springframework.web.reactive.result.method.annotation.SseIntegrationTests.Person> ) . expectNext ( new org.springframework.web.reactive.result.method.annotation.SseIntegrationTests.Person ( STRING ) ) . expectNext ( new org.springframework.web.reactive.result.method.annotation.SseIntegrationTests.Person ( STRING ) ) . thenCancel ( ) . verify ( java.time.Duration . java.time.Duration ( NUMBER ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { ResolvableType org.springframework.web.reactive.result.method.annotation.ResolvableType = forClassWithGenerics ( ServerSentEvent .class , java.lang.String .class ) ; Flux < ServerSentEvent < java.lang.String > > org.springframework.web.reactive.result.method.annotation.Flux<org.springframework.web.reactive.result.method.annotation.ServerSentEvent<java.lang.String>> = this . org.springframework.web.reactive.result.method.annotation.WebClient . get ( ) . uri ( STRING ) . accept ( TEXT_EVENT_STREAM ) . exchange ( ) . flatMap ( response -> response . body ( toFlux ( type ) ) ) ; StepVerifier . create ( org.springframework.web.reactive.result.method.annotation.Flux<org.springframework.web.reactive.result.method.annotation.ServerSentEvent<java.lang.String>> ) . consumeNextWith ( event -> { assertEquals ( STRING , event . id ( ) . get ( ) ) ; assertEquals ( STRING , event . data ( ) . get ( ) ) ; assertEquals ( STRING , event . comment ( ) . get ( ) ) ; assertFalse ( event . event ( ) . isPresent ( ) ) ; assertFalse ( event . retry ( ) . isPresent ( ) ) ; } ) . consumeNextWith ( event -> { assertEquals ( STRING , event . id ( ) . get ( ) ) ; assertEquals ( STRING , event . data ( ) . get ( ) ) ; assertEquals ( STRING , event . comment ( ) . get ( ) ) ; assertFalse ( event . event ( ) . isPresent ( ) ) ; assertFalse ( event . retry ( ) . isPresent ( ) ) ; } ) . thenCancel ( ) . verify ( java.time.Duration . java.time.Duration ( NUMBER ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { Flux < ServerSentEvent < java.lang.String > > org.springframework.web.reactive.result.method.annotation.Flux<org.springframework.web.reactive.result.method.annotation.ServerSentEvent<java.lang.String>> = this . org.springframework.web.reactive.result.method.annotation.WebClient . get ( ) . uri ( STRING ) . accept ( TEXT_EVENT_STREAM ) . exchange ( ) . flatMap ( response -> response . body ( toFlux ( forClassWithGenerics ( ServerSentEvent .class , String .class ) ) ) ) ; StepVerifier . create ( org.springframework.web.reactive.result.method.annotation.Flux<org.springframework.web.reactive.result.method.annotation.ServerSentEvent<java.lang.String>> ) . consumeNextWith ( event -> { assertEquals ( STRING , event . id ( ) . get ( ) ) ; assertEquals ( STRING , event . data ( ) . get ( ) ) ; assertEquals ( STRING , event . comment ( ) . get ( ) ) ; assertFalse ( event . event ( ) . isPresent ( ) ) ; assertFalse ( event . retry ( ) . isPresent ( ) ) ; } ) . consumeNextWith ( event -> { assertEquals ( STRING , event . id ( ) . get ( ) ) ; assertEquals ( STRING , event . data ( ) . get ( ) ) ; assertEquals ( STRING , event . comment ( ) . get ( ) ) ; assertFalse ( event . event ( ) . isPresent ( ) ) ; assertFalse ( event . retry ( ) . isPresent ( ) ) ; } ) . thenCancel ( ) . verify ( java.time.Duration . java.time.Duration ( NUMBER ) ) ; }  <METHOD_END>
<METHOD_START> @ RequestMapping ( STRING ) org.springframework.web.reactive.result.method.annotation.Flux<java.lang.String> < java.lang.String > org.springframework.web.reactive.result.method.annotation.Flux<java.lang.String> ( ) { return Flux . interval ( java.time.Duration . java.time.Duration ( NUMBER ) ) . map ( l -> STRING + l ) ; }  <METHOD_END>
<METHOD_START> @ RequestMapping ( STRING ) org.springframework.web.reactive.result.method.annotation.Flux<org.springframework.web.reactive.result.method.annotation.SseIntegrationTests.Person> < org.springframework.web.reactive.result.method.annotation.SseIntegrationTests.Person > org.springframework.web.reactive.result.method.annotation.Flux<org.springframework.web.reactive.result.method.annotation.SseIntegrationTests.Person> ( ) { return Flux . interval ( java.time.Duration . java.time.Duration ( NUMBER ) ) . map ( l -> new Person ( STRING + l ) ) ; }  <METHOD_END>
<METHOD_START> @ RequestMapping ( STRING ) org.springframework.web.reactive.result.method.annotation.Flux<org.springframework.web.reactive.result.method.annotation.ServerSentEvent<java.lang.String>> < ServerSentEvent < java.lang.String > > org.springframework.web.reactive.result.method.annotation.Flux<org.springframework.web.reactive.result.method.annotation.ServerSentEvent<java.lang.String>> ( ) { return Flux . interval ( java.time.Duration . java.time.Duration ( NUMBER ) ) . map ( l -> ServerSentEvent . builder ( STRING ) . id ( Long . toString ( l ) ) . comment ( STRING ) . build ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.web.reactive.result.method.annotation.SseIntegrationTests.SseController org.springframework.web.reactive.result.method.annotation.SseIntegrationTests.SseController ( ) { return new org.springframework.web.reactive.result.method.annotation.SseIntegrationTests.SseController ( ) ; }  <METHOD_END>
<METHOD_START> public void ( ) {		}  <METHOD_END>
<METHOD_START> public void ( java.lang.String java.lang.String ) { this . java.lang.String = java.lang.String ; }  <METHOD_END>
<METHOD_START> public java.lang.String java.lang.String ( ) { return java.lang.String ; }  <METHOD_END>
<METHOD_START> public void void ( java.lang.String java.lang.String ) { this . java.lang.String = java.lang.String ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( java.lang.Object java.lang.Object ) { if ( this == java.lang.Object ) { return true ; } if ( java.lang.Object == null || java.lang.Class<? extends org.springframework.web.reactive.result.method.annotation.SseIntegrationTests.Person> ( ) != java.lang.Object . java.lang.Class<? extends java.lang.Object> ( ) ) { return false ; } org.springframework.web.reactive.result.method.annotation.SseIntegrationTests.Person org.springframework.web.reactive.result.method.annotation.SseIntegrationTests.Person = ( org.springframework.web.reactive.result.method.annotation.SseIntegrationTests.Person ) java.lang.Object ; return ! ( this . java.lang.String != null ? ! this . java.lang.String . boolean ( org.springframework.web.reactive.result.method.annotation.SseIntegrationTests.Person . java.lang.String ) : org.springframework.web.reactive.result.method.annotation.SseIntegrationTests.Person . java.lang.String != null ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public int int ( ) { return this . java.lang.String != null ? this . java.lang.String . int ( ) : NUMBER ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.String java.lang.String ( ) { return STRING + this . java.lang.String + '\'' + '}' ; }  <METHOD_END>
