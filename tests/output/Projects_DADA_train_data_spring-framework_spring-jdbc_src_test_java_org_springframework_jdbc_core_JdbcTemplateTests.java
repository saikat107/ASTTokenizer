<METHOD_START> @ Before public void void ( ) java.lang.Exception { this . java.sql.Connection = mock ( java.sql.Connection .class ) ; this . javax.sql.DataSource = mock ( javax.sql.DataSource .class ) ; this . java.sql.PreparedStatement = mock ( java.sql.PreparedStatement .class ) ; this . java.sql.Statement = mock ( java.sql.Statement .class ) ; this . java.sql.ResultSet = mock ( java.sql.ResultSet .class ) ; this . org.springframework.jdbc.core.JdbcTemplate = new JdbcTemplate ( this . javax.sql.DataSource ) ; this . java.sql.CallableStatement = mock ( java.sql.CallableStatement .class ) ; given ( this . javax.sql.DataSource . java.sql.Connection ( ) ) . willReturn ( this . java.sql.Connection ) ; given ( this . java.sql.Connection . java.sql.PreparedStatement ( anyString ( ) ) ) . willReturn ( this . java.sql.PreparedStatement ) ; given ( this . java.sql.PreparedStatement . java.sql.ResultSet ( ) ) . willReturn ( this . java.sql.ResultSet ) ; given ( this . java.sql.PreparedStatement . java.sql.ResultSet ( anyString ( ) ) ) . willReturn ( this . java.sql.ResultSet ) ; given ( this . java.sql.PreparedStatement . java.sql.Connection ( ) ) . willReturn ( this . java.sql.Connection ) ; given ( this . java.sql.Statement . java.sql.Connection ( ) ) . willReturn ( this . java.sql.Connection ) ; given ( this . java.sql.Statement . java.sql.ResultSet ( anyString ( ) ) ) . willReturn ( this . java.sql.ResultSet ) ; given ( this . java.sql.Connection . java.sql.CallableStatement ( anyString ( ) ) ) . willReturn ( this . java.sql.CallableStatement ) ; given ( this . java.sql.CallableStatement . java.sql.ResultSet ( ) ) . willReturn ( this . java.sql.ResultSet ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { assertTrue ( STRING , this . org.springframework.jdbc.core.JdbcTemplate . getDataSource ( ) == this . javax.sql.DataSource ) ; assertTrue ( STRING , this . org.springframework.jdbc.core.JdbcTemplate . isIgnoreWarnings ( ) ) ; this . org.springframework.jdbc.core.JdbcTemplate . setIgnoreWarnings ( false ) ; assertTrue ( STRING , ! this . org.springframework.jdbc.core.JdbcTemplate . isIgnoreWarnings ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final java.lang.String java.lang.String = STRING ; int int = NUMBER ; given ( this . java.sql.PreparedStatement . int ( ) ) . willReturn ( NUMBER ) ; org.springframework.jdbc.core.JdbcTemplateTests.Dispatcher org.springframework.jdbc.core.JdbcTemplateTests.Dispatcher = new org.springframework.jdbc.core.JdbcTemplateTests.Dispatcher ( int , java.lang.String ) ; int int = this . org.springframework.jdbc.core.JdbcTemplate . update ( org.springframework.jdbc.core.JdbcTemplateTests.Dispatcher ) ; assertTrue ( STRING , int == NUMBER ) ; verify ( this . java.sql.PreparedStatement ) . setInt ( NUMBER , int ) ; verify ( this . java.sql.PreparedStatement ) . close ( ) ; verify ( this . java.sql.Connection ) . close ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final java.lang.String java.lang.String = STRING ; final int int = NUMBER ; java.sql.SQLException java.sql.SQLException = new java.sql.SQLException ( STRING ) ; given ( this . java.sql.PreparedStatement . int ( ) ) . willThrow ( java.sql.SQLException ) ; org.springframework.jdbc.core.JdbcTemplateTests.Dispatcher org.springframework.jdbc.core.JdbcTemplateTests.Dispatcher = new org.springframework.jdbc.core.JdbcTemplateTests.Dispatcher ( int , java.lang.String ) ; this . org.springframework.jdbc.core.ExpectedException . expect ( UncategorizedSQLException .class ) ; this . org.springframework.jdbc.core.ExpectedException . expect ( exceptionCause ( equalTo ( java.sql.SQLException ) ) ) ; try { this . org.springframework.jdbc.core.JdbcTemplate . update ( org.springframework.jdbc.core.JdbcTemplateTests.Dispatcher ) ; } finally { verify ( this . java.sql.PreparedStatement ) . setInt ( NUMBER , int ) ; verify ( this . java.sql.PreparedStatement ) . close ( ) ; verify ( this . java.sql.Connection , atLeastOnce ( ) ) . close ( ) ; } }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { void ( null , null , null , null , new org.springframework.jdbc.core.JdbcTemplateTests.JdbcTemplateCallback ( ) { @ java.lang.Override public void void ( JdbcTemplate org.springframework.jdbc.core.JdbcTemplate , java.lang.String java.lang.String , RowCallbackHandler org.springframework.jdbc.core.RowCallbackHandler ) { org.springframework.jdbc.core.JdbcTemplate . query ( java.lang.String , org.springframework.jdbc.core.RowCallbackHandler ) ; } } ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( JdbcTemplate org.springframework.jdbc.core.JdbcTemplate , java.lang.String java.lang.String , RowCallbackHandler org.springframework.jdbc.core.RowCallbackHandler ) { org.springframework.jdbc.core.JdbcTemplate . query ( java.lang.String , org.springframework.jdbc.core.RowCallbackHandler ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { void ( NUMBER , NUMBER , NUMBER , null , new org.springframework.jdbc.core.JdbcTemplateTests.JdbcTemplateCallback ( ) { @ java.lang.Override public void void ( JdbcTemplate org.springframework.jdbc.core.JdbcTemplate , java.lang.String java.lang.String , RowCallbackHandler org.springframework.jdbc.core.RowCallbackHandler ) { org.springframework.jdbc.core.JdbcTemplate . query ( java.lang.String , org.springframework.jdbc.core.RowCallbackHandler ) ; } } ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( JdbcTemplate org.springframework.jdbc.core.JdbcTemplate , java.lang.String java.lang.String , RowCallbackHandler org.springframework.jdbc.core.RowCallbackHandler ) { org.springframework.jdbc.core.JdbcTemplate . query ( java.lang.String , org.springframework.jdbc.core.RowCallbackHandler ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { void ( null , null , null , null , new org.springframework.jdbc.core.JdbcTemplateTests.JdbcTemplateCallback ( ) { @ java.lang.Override public void void ( JdbcTemplate org.springframework.jdbc.core.JdbcTemplate , java.lang.String java.lang.String , RowCallbackHandler org.springframework.jdbc.core.RowCallbackHandler ) { org.springframework.jdbc.core.JdbcTemplate . query ( java.lang.String , ( PreparedStatementSetter ) null , org.springframework.jdbc.core.RowCallbackHandler ) ; } } ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( JdbcTemplate org.springframework.jdbc.core.JdbcTemplate , java.lang.String java.lang.String , RowCallbackHandler org.springframework.jdbc.core.RowCallbackHandler ) { org.springframework.jdbc.core.JdbcTemplate . query ( java.lang.String , ( PreparedStatementSetter ) null , org.springframework.jdbc.core.RowCallbackHandler ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final java.lang.Integer java.lang.Integer = NUMBER ; void ( null , null , null , java.lang.Integer , new org.springframework.jdbc.core.JdbcTemplateTests.JdbcTemplateCallback ( ) { @ java.lang.Override public void void ( JdbcTemplate org.springframework.jdbc.core.JdbcTemplate , java.lang.String java.lang.String , RowCallbackHandler org.springframework.jdbc.core.RowCallbackHandler ) { org.springframework.jdbc.core.JdbcTemplate . query ( java.lang.String , new PreparedStatementSetter ( ) { @ java.lang.Override public void void ( java.sql.PreparedStatement java.sql.PreparedStatement ) throws java.sql.SQLException { java.sql.PreparedStatement . void ( NUMBER , java.lang.Integer ) ; } } , org.springframework.jdbc.core.RowCallbackHandler ) ; } } ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( JdbcTemplate org.springframework.jdbc.core.JdbcTemplate , java.lang.String java.lang.String , RowCallbackHandler org.springframework.jdbc.core.RowCallbackHandler ) { org.springframework.jdbc.core.JdbcTemplate . query ( java.lang.String , new PreparedStatementSetter ( ) { @ java.lang.Override public void void ( java.sql.PreparedStatement java.sql.PreparedStatement ) throws java.sql.SQLException { java.sql.PreparedStatement . void ( NUMBER , java.lang.Integer ) ; } } , org.springframework.jdbc.core.RowCallbackHandler ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( java.sql.PreparedStatement java.sql.PreparedStatement ) throws java.sql.SQLException { java.sql.PreparedStatement . void ( NUMBER , java.lang.Integer ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { void ( null , null , null , null , new org.springframework.jdbc.core.JdbcTemplateTests.JdbcTemplateCallback ( ) { @ java.lang.Override public void void ( JdbcTemplate org.springframework.jdbc.core.JdbcTemplate , java.lang.String java.lang.String , RowCallbackHandler org.springframework.jdbc.core.RowCallbackHandler ) { org.springframework.jdbc.core.JdbcTemplate . query ( java.lang.String , ( java.lang.Object [] ) null , org.springframework.jdbc.core.RowCallbackHandler ) ; } } ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( JdbcTemplate org.springframework.jdbc.core.JdbcTemplate , java.lang.String java.lang.String , RowCallbackHandler org.springframework.jdbc.core.RowCallbackHandler ) { org.springframework.jdbc.core.JdbcTemplate . query ( java.lang.String , ( java.lang.Object [] ) null , org.springframework.jdbc.core.RowCallbackHandler ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final java.lang.Integer java.lang.Integer = NUMBER ; void ( null , null , null , java.lang.Integer , new org.springframework.jdbc.core.JdbcTemplateTests.JdbcTemplateCallback ( ) { @ java.lang.Override public void void ( JdbcTemplate org.springframework.jdbc.core.JdbcTemplate , java.lang.String java.lang.String , RowCallbackHandler org.springframework.jdbc.core.RowCallbackHandler ) { org.springframework.jdbc.core.JdbcTemplate . query ( java.lang.String , new java.lang.Object [] { java.lang.Integer } , org.springframework.jdbc.core.RowCallbackHandler ) ; } } ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( JdbcTemplate org.springframework.jdbc.core.JdbcTemplate , java.lang.String java.lang.String , RowCallbackHandler org.springframework.jdbc.core.RowCallbackHandler ) { org.springframework.jdbc.core.JdbcTemplate . query ( java.lang.String , new java.lang.Object [] { java.lang.Integer } , org.springframework.jdbc.core.RowCallbackHandler ) ; }  <METHOD_END>
<METHOD_START> private void void ( java.lang.Integer java.lang.Integer , java.lang.Integer java.lang.Integer , java.lang.Integer java.lang.Integer , java.lang.Object java.lang.Object , org.springframework.jdbc.core.JdbcTemplateTests.JdbcTemplateCallback org.springframework.jdbc.core.JdbcTemplateTests.JdbcTemplateCallback ) throws java.lang.Exception { java.lang.String java.lang.String = STRING ; java.lang.String [] java.lang.String[] = { STRING , STRING , STRING } ; class StringHandler implements RowCallbackHandler { private java.util.List<java.lang.String> < java.lang.String > java.util.List<java.lang.String> = new java.util.LinkedList<java.lang.String> <> ( ) ; @ java.lang.Override public void void ( java.sql.ResultSet java.sql.ResultSet ) throws java.sql.SQLException { this . java.util.List<java.lang.String> . boolean ( java.sql.ResultSet . java.lang.String ( NUMBER ) ) ; } public java.lang.String [] java.lang.String[] ( ) { return this . java.util.List<java.lang.String> . java.lang.String[] ( new java.lang.String [ this . java.util.List<java.lang.String> . int ( ) ] ) ; } } given ( this . java.sql.ResultSet . boolean ( ) ) . willReturn ( true , true , true , false ) ; given ( this . java.sql.ResultSet . java.lang.String ( NUMBER ) ) . willReturn ( java.lang.String[] [ NUMBER ] , java.lang.String[] [ NUMBER ] , java.lang.String[] [ NUMBER ] ) ; given ( this . java.sql.Connection . java.sql.Statement ( ) ) . willReturn ( this . java.sql.PreparedStatement ) ; StringHandler sh = new StringHandler ( ) ; JdbcTemplate org.springframework.jdbc.core.JdbcTemplate = new JdbcTemplate ( ) ; org.springframework.jdbc.core.JdbcTemplate . setDataSource ( this . javax.sql.DataSource ) ; if ( java.lang.Integer != null ) { org.springframework.jdbc.core.JdbcTemplate . setFetchSize ( java.lang.Integer . int ( ) ) ; } if ( java.lang.Integer != null ) { org.springframework.jdbc.core.JdbcTemplate . setMaxRows ( java.lang.Integer . int ( ) ) ; } if ( java.lang.Integer != null ) { org.springframework.jdbc.core.JdbcTemplate . setQueryTimeout ( java.lang.Integer . int ( ) ) ; } org.springframework.jdbc.core.JdbcTemplateTests.JdbcTemplateCallback . void ( org.springframework.jdbc.core.JdbcTemplate , java.lang.String , sh ) ; java.lang.String [] java.lang.String[] = sh . java.lang.String[] ( ) ; assertTrue ( STRING , java.lang.String[] . int == java.lang.String[] . int ) ; for ( int int = NUMBER ; int < java.lang.String[] . int ; int ++ ) { assertTrue ( STRING + int + STRING , java.lang.String[] [ int ] . boolean ( java.lang.String[] [ int ] ) ) ; } if ( java.lang.Integer != null ) { verify ( this . java.sql.PreparedStatement ) . setFetchSize ( java.lang.Integer . int ( ) ) ; } if ( java.lang.Integer != null ) { verify ( this . java.sql.PreparedStatement ) . setMaxRows ( java.lang.Integer . int ( ) ) ; } if ( java.lang.Integer != null ) { verify ( this . java.sql.PreparedStatement ) . setQueryTimeout ( java.lang.Integer . int ( ) ) ; } if ( java.lang.Object != null ) { verify ( this . java.sql.PreparedStatement ) . setObject ( NUMBER , java.lang.Object ) ; } verify ( this . java.sql.ResultSet ) . close ( ) ; verify ( this . java.sql.PreparedStatement ) . close ( ) ; verify ( this . java.sql.Connection ) . close ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( java.sql.ResultSet java.sql.ResultSet ) throws java.sql.SQLException { this . java.util.List<java.lang.String> . boolean ( java.sql.ResultSet . java.lang.String ( NUMBER ) ) ; }  <METHOD_END>
<METHOD_START> public java.lang.String [] java.lang.String[] ( ) { return this . java.util.List<java.lang.String> . java.lang.String[] ( new java.lang.String [ this . java.util.List<java.lang.String> . int ( ) ] ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.lang.String java.lang.String = STRING ; given ( this . java.sql.ResultSet . boolean ( ) ) . willReturn ( false ) ; given ( this . java.sql.Connection . boolean ( ) ) . willReturn ( false ) ; given ( this . java.sql.Connection . java.sql.Statement ( ) ) . willReturn ( this . java.sql.PreparedStatement ) ; willThrow ( new java.lang.RuntimeException ( ) ) . given ( this . java.sql.Connection ) . close ( ) ; SingleConnectionDataSource org.springframework.jdbc.core.SingleConnectionDataSource = new SingleConnectionDataSource ( this . javax.sql.DataSource . java.sql.Connection ( ) , false ) ; this . org.springframework.jdbc.core.JdbcTemplate = new JdbcTemplate ( org.springframework.jdbc.core.SingleConnectionDataSource , false ) ; RowCountCallbackHandler org.springframework.jdbc.core.RowCountCallbackHandler = new RowCountCallbackHandler ( ) ; this . org.springframework.jdbc.core.JdbcTemplate . query ( java.lang.String , org.springframework.jdbc.core.RowCountCallbackHandler ) ; verify ( this . java.sql.ResultSet ) . close ( ) ; verify ( this . java.sql.PreparedStatement ) . close ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.lang.String java.lang.String = this . org.springframework.jdbc.core.JdbcTemplate . execute ( new ConnectionCallback < java.lang.String > ( ) { @ java.lang.Override public java.lang.String java.lang.String ( java.sql.Connection java.sql.Connection ) { assertTrue ( java.sql.Connection instanceof ConnectionProxy ) ; assertSame ( org.springframework.jdbc.core.JdbcTemplateTests .this . java.sql.Connection , ( ( ConnectionProxy ) java.sql.Connection ) . getTargetConnection ( ) ) ; return STRING ; } } ) ; assertEquals ( STRING , java.lang.String ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.String java.lang.String ( java.sql.Connection java.sql.Connection ) { assertTrue ( java.sql.Connection instanceof ConnectionProxy ) ; assertSame ( org.springframework.jdbc.core.JdbcTemplateTests .this . java.sql.Connection , ( ( ConnectionProxy ) java.sql.Connection ) . getTargetConnection ( ) ) ; return STRING ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.lang.String java.lang.String = this . org.springframework.jdbc.core.JdbcTemplate . execute ( new ConnectionCallback < java.lang.String > ( ) { @ java.lang.Override public java.lang.String java.lang.String ( java.sql.Connection java.sql.Connection ) throws java.sql.SQLException { java.sql.PreparedStatement java.sql.PreparedStatement = java.sql.Connection . java.sql.PreparedStatement ( STRING ) ; java.sql.PreparedStatement . void ( NUMBER ) ; java.sql.PreparedStatement . void ( NUMBER ) ; java.sql.PreparedStatement . void ( ) ; return STRING ; } } ) ; assertEquals ( STRING , java.lang.String ) ; verify ( this . java.sql.PreparedStatement ) . setFetchSize ( NUMBER ) ; verify ( this . java.sql.PreparedStatement ) . setMaxRows ( NUMBER ) ; verify ( this . java.sql.PreparedStatement ) . close ( ) ; verify ( this . java.sql.Connection ) . close ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.String java.lang.String ( java.sql.Connection java.sql.Connection ) throws java.sql.SQLException { java.sql.PreparedStatement java.sql.PreparedStatement = java.sql.Connection . java.sql.PreparedStatement ( STRING ) ; java.sql.PreparedStatement . void ( NUMBER ) ; java.sql.PreparedStatement . void ( NUMBER ) ; java.sql.PreparedStatement . void ( ) ; return STRING ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.lang.String java.lang.String = STRING ; given ( this . java.sql.ResultSet . boolean ( ) ) . willReturn ( false ) ; given ( this . java.sql.Connection . java.sql.Statement ( ) ) . willReturn ( this . java.sql.PreparedStatement ) ; RowCountCallbackHandler org.springframework.jdbc.core.RowCountCallbackHandler = new RowCountCallbackHandler ( ) ; this . org.springframework.jdbc.core.JdbcTemplate . query ( java.lang.String , org.springframework.jdbc.core.RowCountCallbackHandler ) ; verify ( this . java.sql.ResultSet ) . close ( ) ; verify ( this . java.sql.PreparedStatement ) . close ( ) ; verify ( this . java.sql.Connection ) . close ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final java.lang.String java.lang.String = STRING ; final java.lang.RuntimeException java.lang.RuntimeException = new java.lang.RuntimeException ( STRING ) ; given ( this . java.sql.ResultSet . boolean ( ) ) . willReturn ( true ) ; given ( this . java.sql.Connection . java.sql.Statement ( ) ) . willReturn ( this . java.sql.PreparedStatement ) ; this . org.springframework.jdbc.core.ExpectedException . expect ( sameInstance ( java.lang.RuntimeException ) ) ; try { this . org.springframework.jdbc.core.JdbcTemplate . query ( java.lang.String , new RowCallbackHandler ( ) { @ java.lang.Override public void void ( java.sql.ResultSet java.sql.ResultSet ) { throw java.lang.RuntimeException ; } } ) ; } finally { verify ( this . java.sql.ResultSet ) . close ( ) ; verify ( this . java.sql.PreparedStatement ) . close ( ) ; verify ( this . java.sql.Connection ) . close ( ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( java.sql.ResultSet java.sql.ResultSet ) { throw java.lang.RuntimeException ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final java.lang.String java.lang.String = STRING ; int int = NUMBER ; given ( this . java.sql.Statement . int ( java.lang.String ) ) . willReturn ( int ) ; given ( this . java.sql.Connection . java.sql.Statement ( ) ) . willReturn ( this . java.sql.Statement ) ; int int = this . org.springframework.jdbc.core.JdbcTemplate . update ( java.lang.String ) ; assertTrue ( STRING , int == int ) ; verify ( this . java.sql.Statement ) . close ( ) ; verify ( this . java.sql.Connection ) . close ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final java.lang.String java.lang.String = STRING ; int int = NUMBER ; given ( this . java.sql.PreparedStatement . int ( ) ) . willReturn ( int ) ; int int = this . org.springframework.jdbc.core.JdbcTemplate . update ( java.lang.String , new java.lang.Object [] { NUMBER , new SqlParameterValue ( java.sql.Types . int , NUMBER , new java.lang.Float ( NUMBER ) ) } ) ; assertTrue ( STRING , int == int ) ; verify ( this . java.sql.PreparedStatement ) . setObject ( NUMBER , NUMBER ) ; verify ( this . java.sql.PreparedStatement ) . setObject ( NUMBER , new java.lang.Float ( NUMBER ) , java.sql.Types . int , NUMBER ) ; verify ( this . java.sql.PreparedStatement ) . close ( ) ; verify ( this . java.sql.Connection ) . close ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.sql.SQLException java.sql.SQLException = new java.sql.SQLException ( STRING ) ; final java.lang.String java.lang.String = STRING ; given ( this . java.sql.Statement . int ( java.lang.String ) ) . willThrow ( java.sql.SQLException ) ; given ( this . java.sql.Connection . java.sql.Statement ( ) ) . willReturn ( this . java.sql.Statement ) ; this . org.springframework.jdbc.core.ExpectedException . expect ( exceptionCause ( sameInstance ( java.sql.SQLException ) ) ) ; try { this . org.springframework.jdbc.core.JdbcTemplate . update ( java.lang.String ) ; } finally { verify ( this . java.sql.Statement ) . close ( ) ; verify ( this . java.sql.Connection , atLeastOnce ( ) ) . close ( ) ; } }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final java.lang.String java.lang.String = STRING ; int int = NUMBER ; given ( this . java.sql.Statement . int ( java.lang.String ) ) . willReturn ( int ) ; given ( this . java.sql.Connection . java.sql.Statement ( ) ) . willReturn ( this . java.sql.Statement ) ; int int = this . org.springframework.jdbc.core.JdbcTemplate . update ( java.lang.String ) ; assertTrue ( STRING , int == int ) ; verify ( this . java.sql.Statement ) . close ( ) ; verify ( this . java.sql.Connection ) . close ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final java.lang.String [] java.lang.String[] = { STRING , STRING } ; given ( this . java.sql.Statement . int[] ( ) ) . willReturn ( new int [] { NUMBER , NUMBER } ) ; void ( true ) ; given ( this . java.sql.Connection . java.sql.Statement ( ) ) . willReturn ( this . java.sql.Statement ) ; JdbcTemplate org.springframework.jdbc.core.JdbcTemplate = new JdbcTemplate ( this . javax.sql.DataSource , false ) ; int [] int[] = org.springframework.jdbc.core.JdbcTemplate . batchUpdate ( java.lang.String[] ) ; assertTrue ( STRING , int[] . int == NUMBER ) ; verify ( this . java.sql.Statement ) . addBatch ( java.lang.String[] [ NUMBER ] ) ; verify ( this . java.sql.Statement ) . addBatch ( java.lang.String[] [ NUMBER ] ) ; verify ( this . java.sql.Statement ) . close ( ) ; verify ( this . java.sql.Connection , atLeastOnce ( ) ) . close ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final java.lang.String [] java.lang.String[] = { STRING , STRING , STRING , STRING } ; given ( this . java.sql.Statement . int[] ( ) ) . willThrow ( new java.sql.BatchUpdateException ( new int [] { NUMBER , java.sql.Statement . int , NUMBER , java.sql.Statement . int } ) ) ; void ( true ) ; given ( this . java.sql.Connection . java.sql.Statement ( ) ) . willReturn ( this . java.sql.Statement ) ; JdbcTemplate org.springframework.jdbc.core.JdbcTemplate = new JdbcTemplate ( this . javax.sql.DataSource , false ) ; try { org.springframework.jdbc.core.JdbcTemplate . batchUpdate ( java.lang.String[] ) ; } catch ( UncategorizedSQLException org.springframework.jdbc.core.UncategorizedSQLException ) { assertThat ( org.springframework.jdbc.core.UncategorizedSQLException . getSql ( ) , equalTo ( STRING ) ) ; } }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final java.lang.String [] java.lang.String[] = { STRING , STRING } ; given ( this . java.sql.Statement . boolean ( java.lang.String[] [ NUMBER ] ) ) . willReturn ( false ) ; given ( this . java.sql.Statement . int ( ) ) . willReturn ( NUMBER , NUMBER ) ; given ( this . java.sql.Statement . boolean ( java.lang.String[] [ NUMBER ] ) ) . willReturn ( false ) ; void ( false ) ; given ( this . java.sql.Connection . java.sql.Statement ( ) ) . willReturn ( this . java.sql.Statement ) ; JdbcTemplate org.springframework.jdbc.core.JdbcTemplate = new JdbcTemplate ( this . javax.sql.DataSource , false ) ; int [] int[] = org.springframework.jdbc.core.JdbcTemplate . batchUpdate ( java.lang.String[] ) ; assertTrue ( STRING , int[] . int == NUMBER ) ; verify ( this . java.sql.Statement , never ( ) ) . addBatch ( anyString ( ) ) ; verify ( this . java.sql.Statement ) . close ( ) ; verify ( this . java.sql.Connection , atLeastOnce ( ) ) . close ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final java.lang.String [] java.lang.String[] = { STRING , STRING } ; given ( this . java.sql.Statement . boolean ( java.lang.String[] [ NUMBER ] ) ) . willReturn ( false ) ; given ( this . java.sql.Statement . int ( ) ) . willReturn ( NUMBER ) ; given ( this . java.sql.Statement . boolean ( java.lang.String[] [ NUMBER ] ) ) . willReturn ( true ) ; void ( false ) ; given ( this . java.sql.Connection . java.sql.Statement ( ) ) . willReturn ( this . java.sql.Statement ) ; JdbcTemplate org.springframework.jdbc.core.JdbcTemplate = new JdbcTemplate ( this . javax.sql.DataSource , false ) ; this . org.springframework.jdbc.core.ExpectedException . expect ( InvalidDataAccessApiUsageException .class ) ; try { org.springframework.jdbc.core.JdbcTemplate . batchUpdate ( java.lang.String[] ) ; } finally { verify ( this . java.sql.Statement , never ( ) ) . addBatch ( anyString ( ) ) ; verify ( this . java.sql.Statement ) . close ( ) ; verify ( this . java.sql.Connection , atLeastOnce ( ) ) . close ( ) ; } }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final java.lang.String java.lang.String = STRING ; final int [] int[] = new int [] { NUMBER , NUMBER } ; final int [] int[] = new int [] { NUMBER , NUMBER } ; given ( this . java.sql.PreparedStatement . int[] ( ) ) . willReturn ( int[] ) ; void ( true ) ; BatchPreparedStatementSetter org.springframework.jdbc.core.BatchPreparedStatementSetter = new BatchPreparedStatementSetter ( ) { @ java.lang.Override public void void ( java.sql.PreparedStatement java.sql.PreparedStatement , int int )				throws java.sql.SQLException { java.sql.PreparedStatement . void ( NUMBER , int[] [ int ] ) ; } @ java.lang.Override public int int ( ) { return int[] . int ; } } ; JdbcTemplate org.springframework.jdbc.core.JdbcTemplate = new JdbcTemplate ( this . javax.sql.DataSource , false ) ; int [] int[] = org.springframework.jdbc.core.JdbcTemplate . batchUpdate ( java.lang.String , org.springframework.jdbc.core.BatchPreparedStatementSetter ) ; assertTrue ( STRING , int[] . int == NUMBER ) ; assertEquals ( int[] [ NUMBER ] , int[] [ NUMBER ] ) ; assertEquals ( int[] [ NUMBER ] , int[] [ NUMBER ] ) ; verify ( this . java.sql.PreparedStatement , times ( NUMBER ) ) . addBatch ( ) ; verify ( this . java.sql.PreparedStatement ) . setInt ( NUMBER , int[] [ NUMBER ] ) ; verify ( this . java.sql.PreparedStatement ) . setInt ( NUMBER , int[] [ NUMBER ] ) ; verify ( this . java.sql.PreparedStatement ) . close ( ) ; verify ( this . java.sql.Connection , atLeastOnce ( ) ) . close ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( java.sql.PreparedStatement java.sql.PreparedStatement , int int )				throws java.sql.SQLException { java.sql.PreparedStatement . void ( NUMBER , int[] [ int ] ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public int int ( ) { return int[] . int ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final java.lang.String java.lang.String = STRING ; final int [] int[] = new int [] { NUMBER , NUMBER } ; final int [] int[] = new int [] { NUMBER , NUMBER } ; given ( this . java.sql.PreparedStatement . int[] ( ) ) . willReturn ( int[] ) ; void ( true ) ; BatchPreparedStatementSetter org.springframework.jdbc.core.BatchPreparedStatementSetter = new InterruptibleBatchPreparedStatementSetter ( ) { @ java.lang.Override public void void ( java.sql.PreparedStatement java.sql.PreparedStatement , int int ) throws java.sql.SQLException { if ( int < int[] . int ) { java.sql.PreparedStatement . void ( NUMBER , int[] [ int ] ) ; } } @ java.lang.Override public int int ( ) { return NUMBER ; } @ java.lang.Override public boolean boolean ( int int ) { return ( int >= int[] . int ) ; } } ; JdbcTemplate org.springframework.jdbc.core.JdbcTemplate = new JdbcTemplate ( this . javax.sql.DataSource , false ) ; int [] int[] = org.springframework.jdbc.core.JdbcTemplate . batchUpdate ( java.lang.String , org.springframework.jdbc.core.BatchPreparedStatementSetter ) ; assertTrue ( STRING , int[] . int == NUMBER ) ; assertEquals ( int[] [ NUMBER ] , int[] [ NUMBER ] ) ; assertEquals ( int[] [ NUMBER ] , int[] [ NUMBER ] ) ; verify ( this . java.sql.PreparedStatement , times ( NUMBER ) ) . addBatch ( ) ; verify ( this . java.sql.PreparedStatement ) . setInt ( NUMBER , int[] [ NUMBER ] ) ; verify ( this . java.sql.PreparedStatement ) . setInt ( NUMBER , int[] [ NUMBER ] ) ; verify ( this . java.sql.PreparedStatement ) . close ( ) ; verify ( this . java.sql.Connection , atLeastOnce ( ) ) . close ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( java.sql.PreparedStatement java.sql.PreparedStatement , int int ) throws java.sql.SQLException { if ( int < int[] . int ) { java.sql.PreparedStatement . void ( NUMBER , int[] [ int ] ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public int int ( ) { return NUMBER ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( int int ) { return ( int >= int[] . int ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final java.lang.String java.lang.String = STRING ; final int [] int[] = new int [] { NUMBER , NUMBER } ; final int [] int[] = new int [] { NUMBER , NUMBER } ; given ( this . java.sql.PreparedStatement . int[] ( ) ) . willReturn ( int[] ) ; void ( true ) ; BatchPreparedStatementSetter org.springframework.jdbc.core.BatchPreparedStatementSetter = new AbstractInterruptibleBatchPreparedStatementSetter ( ) { @ java.lang.Override protected boolean boolean ( java.sql.PreparedStatement java.sql.PreparedStatement , int int ) throws java.sql.SQLException { if ( int < int[] . int ) { java.sql.PreparedStatement . void ( NUMBER , int[] [ int ] ) ; return true ; } else { return false ; } } } ; JdbcTemplate org.springframework.jdbc.core.JdbcTemplate = new JdbcTemplate ( this . javax.sql.DataSource , false ) ; int [] int[] = org.springframework.jdbc.core.JdbcTemplate . batchUpdate ( java.lang.String , org.springframework.jdbc.core.BatchPreparedStatementSetter ) ; assertTrue ( STRING , int[] . int == NUMBER ) ; assertEquals ( int[] [ NUMBER ] , int[] [ NUMBER ] ) ; assertEquals ( int[] [ NUMBER ] , int[] [ NUMBER ] ) ; verify ( this . java.sql.PreparedStatement , times ( NUMBER ) ) . addBatch ( ) ; verify ( this . java.sql.PreparedStatement ) . setInt ( NUMBER , int[] [ NUMBER ] ) ; verify ( this . java.sql.PreparedStatement ) . setInt ( NUMBER , int[] [ NUMBER ] ) ; verify ( this . java.sql.PreparedStatement ) . close ( ) ; verify ( this . java.sql.Connection , atLeastOnce ( ) ) . close ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected boolean boolean ( java.sql.PreparedStatement java.sql.PreparedStatement , int int ) throws java.sql.SQLException { if ( int < int[] . int ) { java.sql.PreparedStatement . void ( NUMBER , int[] [ int ] ) ; return true ; } else { return false ; } }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final java.lang.String java.lang.String = STRING ; final int [] int[] = new int [] { NUMBER , NUMBER } ; final int [] int[] = new int [] { NUMBER , NUMBER } ; given ( this . java.sql.PreparedStatement . int ( ) ) . willReturn ( int[] [ NUMBER ] , int[] [ NUMBER ] ) ; void ( false ) ; BatchPreparedStatementSetter org.springframework.jdbc.core.BatchPreparedStatementSetter = new AbstractInterruptibleBatchPreparedStatementSetter ( ) { @ java.lang.Override protected boolean boolean ( java.sql.PreparedStatement java.sql.PreparedStatement , int int ) throws java.sql.SQLException { if ( int < int[] . int ) { java.sql.PreparedStatement . void ( NUMBER , int[] [ int ] ) ; return true ; } else { return false ; } } } ; JdbcTemplate org.springframework.jdbc.core.JdbcTemplate = new JdbcTemplate ( this . javax.sql.DataSource , false ) ; int [] int[] = org.springframework.jdbc.core.JdbcTemplate . batchUpdate ( java.lang.String , org.springframework.jdbc.core.BatchPreparedStatementSetter ) ; assertTrue ( STRING , int[] . int == NUMBER ) ; assertEquals ( int[] [ NUMBER ] , int[] [ NUMBER ] ) ; assertEquals ( int[] [ NUMBER ] , int[] [ NUMBER ] ) ; verify ( this . java.sql.PreparedStatement , never ( ) ) . addBatch ( ) ; verify ( this . java.sql.PreparedStatement ) . setInt ( NUMBER , int[] [ NUMBER ] ) ; verify ( this . java.sql.PreparedStatement ) . setInt ( NUMBER , int[] [ NUMBER ] ) ; verify ( this . java.sql.PreparedStatement ) . close ( ) ; verify ( this . java.sql.Connection , atLeastOnce ( ) ) . close ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected boolean boolean ( java.sql.PreparedStatement java.sql.PreparedStatement , int int ) throws java.sql.SQLException { if ( int < int[] . int ) { java.sql.PreparedStatement . void ( NUMBER , int[] [ int ] ) ; return true ; } else { return false ; } }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final java.lang.String java.lang.String = STRING ; final int [] int[] = new int [] { NUMBER , NUMBER } ; final int [] int[] = new int [] { NUMBER , NUMBER } ; given ( this . java.sql.PreparedStatement . int ( ) ) . willReturn ( int[] [ NUMBER ] , int[] [ NUMBER ] ) ; BatchPreparedStatementSetter org.springframework.jdbc.core.BatchPreparedStatementSetter = new BatchPreparedStatementSetter ( ) { @ java.lang.Override public void void ( java.sql.PreparedStatement java.sql.PreparedStatement , int int ) throws java.sql.SQLException { java.sql.PreparedStatement . void ( NUMBER , int[] [ int ] ) ; } @ java.lang.Override public int int ( ) { return int[] . int ; } } ; int [] int[] = this . org.springframework.jdbc.core.JdbcTemplate . batchUpdate ( java.lang.String , org.springframework.jdbc.core.BatchPreparedStatementSetter ) ; assertTrue ( STRING , int[] . int == NUMBER ) ; assertEquals ( int[] [ NUMBER ] , int[] [ NUMBER ] ) ; assertEquals ( int[] [ NUMBER ] , int[] [ NUMBER ] ) ; verify ( this . java.sql.PreparedStatement , never ( ) ) . addBatch ( ) ; verify ( this . java.sql.PreparedStatement ) . setInt ( NUMBER , int[] [ NUMBER ] ) ; verify ( this . java.sql.PreparedStatement ) . setInt ( NUMBER , int[] [ NUMBER ] ) ; verify ( this . java.sql.PreparedStatement ) . close ( ) ; verify ( this . java.sql.Connection ) . close ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( java.sql.PreparedStatement java.sql.PreparedStatement , int int ) throws java.sql.SQLException { java.sql.PreparedStatement . void ( NUMBER , int[] [ int ] ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public int int ( ) { return int[] . int ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final java.lang.String java.lang.String = STRING ; final int [] int[] = new int [] { NUMBER , NUMBER } ; java.sql.SQLException java.sql.SQLException = new java.sql.SQLException ( ) ; given ( this . java.sql.PreparedStatement . int[] ( ) ) . willThrow ( java.sql.SQLException ) ; void ( true ) ; BatchPreparedStatementSetter org.springframework.jdbc.core.BatchPreparedStatementSetter = new BatchPreparedStatementSetter ( ) { @ java.lang.Override public void void ( java.sql.PreparedStatement java.sql.PreparedStatement , int int ) throws java.sql.SQLException { java.sql.PreparedStatement . void ( NUMBER , int[] [ int ] ) ; } @ java.lang.Override public int int ( ) { return int[] . int ; } } ; this . org.springframework.jdbc.core.ExpectedException . expect ( DataAccessException .class ) ; this . org.springframework.jdbc.core.ExpectedException . expect ( exceptionCause ( sameInstance ( java.sql.SQLException ) ) ) ; try { this . org.springframework.jdbc.core.JdbcTemplate . batchUpdate ( java.lang.String , org.springframework.jdbc.core.BatchPreparedStatementSetter ) ; } finally { verify ( this . java.sql.PreparedStatement , times ( NUMBER ) ) . addBatch ( ) ; verify ( this . java.sql.PreparedStatement ) . setInt ( NUMBER , int[] [ NUMBER ] ) ; verify ( this . java.sql.PreparedStatement ) . setInt ( NUMBER , int[] [ NUMBER ] ) ; verify ( this . java.sql.PreparedStatement ) . close ( ) ; verify ( this . java.sql.Connection , atLeastOnce ( ) ) . close ( ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( java.sql.PreparedStatement java.sql.PreparedStatement , int int ) throws java.sql.SQLException { java.sql.PreparedStatement . void ( NUMBER , int[] [ int ] ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public int int ( ) { return int[] . int ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final java.lang.String java.lang.String = STRING ; final java.util.List<java.lang.Object[]> < java.lang.Object [] > java.util.List<java.lang.Object[]> = new java.util.ArrayList<java.lang.Object[]> <> ( ) ; java.util.List<java.lang.Object[]> . boolean ( new java.lang.Object [] { NUMBER } ) ; java.util.List<java.lang.Object[]> . boolean ( new java.lang.Object [] { NUMBER } ) ; final int [] int[] = new int [] { NUMBER , NUMBER } ; given ( this . java.sql.PreparedStatement . int[] ( ) ) . willReturn ( int[] ) ; void ( true ) ; JdbcTemplate org.springframework.jdbc.core.JdbcTemplate = new JdbcTemplate ( this . javax.sql.DataSource , false ) ; int [] int[] = org.springframework.jdbc.core.JdbcTemplate . batchUpdate ( java.lang.String , java.util.List<java.lang.Object[]> ) ; assertTrue ( STRING , int[] . int == NUMBER ) ; assertEquals ( int[] [ NUMBER ] , int[] [ NUMBER ] ) ; assertEquals ( int[] [ NUMBER ] , int[] [ NUMBER ] ) ; verify ( this . java.sql.PreparedStatement , times ( NUMBER ) ) . addBatch ( ) ; verify ( this . java.sql.PreparedStatement ) . setObject ( NUMBER , NUMBER ) ; verify ( this . java.sql.PreparedStatement ) . setObject ( NUMBER , NUMBER ) ; verify ( this . java.sql.PreparedStatement ) . close ( ) ; verify ( this . java.sql.Connection , atLeastOnce ( ) ) . close ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final java.lang.String java.lang.String = STRING ; final java.util.List<java.lang.Object[]> < java.lang.Object [] > java.util.List<java.lang.Object[]> = new java.util.ArrayList<java.lang.Object[]> <> ( ) ; java.util.List<java.lang.Object[]> . boolean ( new java.lang.Object [] { NUMBER } ) ; java.util.List<java.lang.Object[]> . boolean ( new java.lang.Object [] { NUMBER } ) ; final int [] int[] = new int [] { java.sql.Types . int } ; final int [] int[] = new int [] { NUMBER , NUMBER } ; given ( this . java.sql.PreparedStatement . int[] ( ) ) . willReturn ( int[] ) ; void ( true ) ; this . org.springframework.jdbc.core.JdbcTemplate = new JdbcTemplate ( this . javax.sql.DataSource , false ) ; int [] int[] = this . org.springframework.jdbc.core.JdbcTemplate . batchUpdate ( java.lang.String , java.util.List<java.lang.Object[]> , int[] ) ; assertTrue ( STRING , int[] . int == NUMBER ) ; assertEquals ( int[] [ NUMBER ] , int[] [ NUMBER ] ) ; assertEquals ( int[] [ NUMBER ] , int[] [ NUMBER ] ) ; verify ( this . java.sql.PreparedStatement , times ( NUMBER ) ) . addBatch ( ) ; verify ( this . java.sql.PreparedStatement ) . setObject ( NUMBER , NUMBER , int[] [ NUMBER ] ) ; verify ( this . java.sql.PreparedStatement ) . setObject ( NUMBER , NUMBER , int[] [ NUMBER ] ) ; verify ( this . java.sql.PreparedStatement ) . close ( ) ; verify ( this . java.sql.Connection , atLeastOnce ( ) ) . close ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final java.lang.String java.lang.String = STRING ; final java.util.List<java.lang.Integer> < java.lang.Integer > java.util.List<java.lang.Integer> = java.util.Arrays . java.util.List<java.lang.Integer> ( NUMBER , NUMBER , NUMBER ) ; final int [] int[] = new int [] { NUMBER , NUMBER } ; final int [] int[] = new int [] { NUMBER } ; given ( this . java.sql.PreparedStatement . int[] ( ) ) . willReturn ( int[] , int[] ) ; void ( true ) ; ParameterizedPreparedStatementSetter < java.lang.Integer > org.springframework.jdbc.core.ParameterizedPreparedStatementSetter<java.lang.Integer> = new ParameterizedPreparedStatementSetter < java.lang.Integer > ( ) { @ java.lang.Override public void void ( java.sql.PreparedStatement java.sql.PreparedStatement , java.lang.Integer java.lang.Integer ) throws java.sql.SQLException { java.sql.PreparedStatement . void ( NUMBER , java.lang.Integer . int ( ) ) ; } } ; JdbcTemplate org.springframework.jdbc.core.JdbcTemplate = new JdbcTemplate ( this . javax.sql.DataSource , false ) ; int [] [] int[][] = org.springframework.jdbc.core.JdbcTemplate . batchUpdate ( java.lang.String , java.util.List<java.lang.Integer> , NUMBER , org.springframework.jdbc.core.ParameterizedPreparedStatementSetter<java.lang.Integer> ) ; assertTrue ( STRING , int[][] [ NUMBER ] . int == NUMBER ) ; assertEquals ( int[] [ NUMBER ] , int[][] [ NUMBER ] [ NUMBER ] ) ; assertEquals ( int[] [ NUMBER ] , int[][] [ NUMBER ] [ NUMBER ] ) ; assertEquals ( int[] [ NUMBER ] , int[][] [ NUMBER ] [ NUMBER ] ) ; verify ( this . java.sql.PreparedStatement , times ( NUMBER ) ) . addBatch ( ) ; verify ( this . java.sql.PreparedStatement ) . setInt ( NUMBER , java.util.List<java.lang.Integer> . java.lang.Integer ( NUMBER ) ) ; verify ( this . java.sql.PreparedStatement ) . setInt ( NUMBER , java.util.List<java.lang.Integer> . java.lang.Integer ( NUMBER ) ) ; verify ( this . java.sql.PreparedStatement ) . setInt ( NUMBER , java.util.List<java.lang.Integer> . java.lang.Integer ( NUMBER ) ) ; verify ( this . java.sql.PreparedStatement ) . close ( ) ; verify ( this . java.sql.Connection , atLeastOnce ( ) ) . close ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( java.sql.PreparedStatement java.sql.PreparedStatement , java.lang.Integer java.lang.Integer ) throws java.sql.SQLException { java.sql.PreparedStatement . void ( NUMBER , java.lang.Integer . int ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.sql.SQLException { java.sql.SQLException java.sql.SQLException = new java.sql.SQLException ( STRING , STRING ) ; this . javax.sql.DataSource = mock ( javax.sql.DataSource .class ) ; given ( this . javax.sql.DataSource . java.sql.Connection ( ) ) . willThrow ( java.sql.SQLException ) ; JdbcTemplate org.springframework.jdbc.core.JdbcTemplate = new JdbcTemplate ( this . javax.sql.DataSource , false ) ; RowCountCallbackHandler org.springframework.jdbc.core.RowCountCallbackHandler = new RowCountCallbackHandler ( ) ; this . org.springframework.jdbc.core.ExpectedException . expect ( CannotGetJdbcConnectionException .class ) ; this . org.springframework.jdbc.core.ExpectedException . expect ( exceptionCause ( sameInstance ( java.sql.SQLException ) ) ) ; org.springframework.jdbc.core.JdbcTemplate . query ( STRING , org.springframework.jdbc.core.RowCountCallbackHandler ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.sql.SQLException { java.sql.SQLException java.sql.SQLException = new java.sql.SQLException ( STRING , STRING ) ; this . javax.sql.DataSource = mock ( javax.sql.DataSource .class ) ; given ( this . javax.sql.DataSource . java.sql.Connection ( ) ) . willThrow ( java.sql.SQLException ) ; this . org.springframework.jdbc.core.JdbcTemplate = new JdbcTemplate ( ) ; this . org.springframework.jdbc.core.JdbcTemplate . setDataSource ( this . javax.sql.DataSource ) ; this . org.springframework.jdbc.core.JdbcTemplate . afterPropertiesSet ( ) ; RowCountCallbackHandler org.springframework.jdbc.core.RowCountCallbackHandler = new RowCountCallbackHandler ( ) ; this . org.springframework.jdbc.core.ExpectedException . expect ( CannotGetJdbcConnectionException .class ) ; this . org.springframework.jdbc.core.ExpectedException . expect ( exceptionCause ( sameInstance ( java.sql.SQLException ) ) ) ; this . org.springframework.jdbc.core.JdbcTemplate . query ( STRING , org.springframework.jdbc.core.RowCountCallbackHandler ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.sql.SQLException { void ( true ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.sql.SQLException { void ( false ) ; }  <METHOD_END>
<METHOD_START> private void void ( boolean boolean )			throws java.sql.SQLException { java.sql.SQLException java.sql.SQLException = new java.sql.SQLException ( STRING , STRING ) ; this . javax.sql.DataSource = mock ( javax.sql.DataSource .class ) ; given ( this . javax.sql.DataSource . java.sql.Connection ( ) ) . willThrow ( java.sql.SQLException ) ; this . org.springframework.jdbc.core.JdbcTemplate = new JdbcTemplate ( ) ; this . org.springframework.jdbc.core.JdbcTemplate . setDataSource ( this . javax.sql.DataSource ) ; this . org.springframework.jdbc.core.JdbcTemplate . setLazyInit ( false ) ; if ( boolean ) { this . org.springframework.jdbc.core.JdbcTemplate . setExceptionTranslator ( new SQLErrorCodeSQLExceptionTranslator ( this . javax.sql.DataSource ) ) ; } else { this . org.springframework.jdbc.core.JdbcTemplate . afterPropertiesSet ( ) ; } RowCountCallbackHandler org.springframework.jdbc.core.RowCountCallbackHandler = new RowCountCallbackHandler ( ) ; this . org.springframework.jdbc.core.ExpectedException . expect ( CannotGetJdbcConnectionException .class ) ; this . org.springframework.jdbc.core.ExpectedException . expect ( exceptionCause ( sameInstance ( java.sql.SQLException ) ) ) ; this . org.springframework.jdbc.core.JdbcTemplate . query ( STRING , org.springframework.jdbc.core.RowCountCallbackHandler ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final java.lang.String java.lang.String = STRING ; final java.lang.String java.lang.String = STRING ; int int = NUMBER ; given ( this . java.sql.PreparedStatement . int ( ) ) . willReturn ( int ) ; PreparedStatementSetter org.springframework.jdbc.core.PreparedStatementSetter = new PreparedStatementSetter ( ) { @ java.lang.Override public void void ( java.sql.PreparedStatement java.sql.PreparedStatement ) throws java.sql.SQLException { java.sql.PreparedStatement . void ( NUMBER , java.lang.String ) ; } } ; int int = new JdbcTemplate ( this . javax.sql.DataSource ) . update ( java.lang.String , org.springframework.jdbc.core.PreparedStatementSetter ) ; assertTrue ( STRING , int == int ) ; verify ( this . java.sql.PreparedStatement ) . setString ( NUMBER , java.lang.String ) ; verify ( this . java.sql.PreparedStatement ) . close ( ) ; verify ( this . java.sql.Connection ) . close ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( java.sql.PreparedStatement java.sql.PreparedStatement ) throws java.sql.SQLException { java.sql.PreparedStatement . void ( NUMBER , java.lang.String ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final java.lang.String java.lang.String = STRING ; final java.lang.String java.lang.String = STRING ; java.sql.SQLException java.sql.SQLException = new java.sql.SQLException ( ) ; given ( this . java.sql.PreparedStatement . int ( ) ) . willThrow ( java.sql.SQLException ) ; PreparedStatementSetter org.springframework.jdbc.core.PreparedStatementSetter = new PreparedStatementSetter ( ) { @ java.lang.Override public void void ( java.sql.PreparedStatement java.sql.PreparedStatement ) throws java.sql.SQLException { java.sql.PreparedStatement . void ( NUMBER , java.lang.String ) ; } } ; this . org.springframework.jdbc.core.ExpectedException . expect ( DataAccessException .class ) ; this . org.springframework.jdbc.core.ExpectedException . expect ( exceptionCause ( sameInstance ( java.sql.SQLException ) ) ) ; try { new JdbcTemplate ( this . javax.sql.DataSource ) . update ( java.lang.String , org.springframework.jdbc.core.PreparedStatementSetter ) ; } finally { verify ( this . java.sql.PreparedStatement ) . setString ( NUMBER , java.lang.String ) ; verify ( this . java.sql.PreparedStatement ) . close ( ) ; verify ( this . java.sql.Connection , atLeastOnce ( ) ) . close ( ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( java.sql.PreparedStatement java.sql.PreparedStatement ) throws java.sql.SQLException { java.sql.PreparedStatement . void ( NUMBER , java.lang.String ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.sql.SQLException java.sql.SQLException = new java.sql.SQLException ( STRING ) ; given ( this . java.sql.Connection . java.sql.Statement ( ) ) . willReturn ( this . java.sql.Statement ) ; given ( this . java.sql.ResultSet . boolean ( ) ) . willReturn ( false ) ; willThrow ( java.sql.SQLException ) . given ( this . java.sql.ResultSet ) . close ( ) ; willThrow ( java.sql.SQLException ) . given ( this . java.sql.Statement ) . close ( ) ; willThrow ( java.sql.SQLException ) . given ( this . java.sql.Connection ) . close ( ) ; RowCountCallbackHandler org.springframework.jdbc.core.RowCountCallbackHandler = new RowCountCallbackHandler ( ) ; this . org.springframework.jdbc.core.JdbcTemplate . query ( STRING , org.springframework.jdbc.core.RowCountCallbackHandler ) ; verify ( this . java.sql.Connection ) . close ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.lang.String java.lang.String = STRING ; java.sql.SQLWarning java.sql.SQLWarning = new java.sql.SQLWarning ( STRING ) ; given ( this . java.sql.ResultSet . boolean ( ) ) . willReturn ( false ) ; given ( this . java.sql.PreparedStatement . java.sql.SQLWarning ( ) ) . willReturn ( java.sql.SQLWarning ) ; given ( this . java.sql.Connection . java.sql.Statement ( ) ) . willReturn ( this . java.sql.PreparedStatement ) ; JdbcTemplate org.springframework.jdbc.core.JdbcTemplate = new JdbcTemplate ( this . javax.sql.DataSource ) ; org.springframework.jdbc.core.JdbcTemplate . setIgnoreWarnings ( false ) ; this . org.springframework.jdbc.core.ExpectedException . expect ( SQLWarningException .class ) ; this . org.springframework.jdbc.core.ExpectedException . expect ( exceptionCause ( sameInstance ( java.sql.SQLWarning ) ) ) ; try { org.springframework.jdbc.core.JdbcTemplate . query ( java.lang.String , new RowCallbackHandler ( ) { @ java.lang.Override public void void ( java.sql.ResultSet java.sql.ResultSet ) throws java.sql.SQLException { java.sql.ResultSet . byte ( NUMBER ) ; } } ) ; } finally { verify ( this . java.sql.ResultSet ) . close ( ) ; verify ( this . java.sql.PreparedStatement ) . close ( ) ; verify ( this . java.sql.Connection ) . close ( ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( java.sql.ResultSet java.sql.ResultSet ) throws java.sql.SQLException { java.sql.ResultSet . byte ( NUMBER ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.lang.String java.lang.String = STRING ; java.sql.SQLWarning java.sql.SQLWarning = new java.sql.SQLWarning ( STRING ) ; given ( this . java.sql.ResultSet . boolean ( ) ) . willReturn ( false ) ; given ( this . java.sql.Connection . java.sql.Statement ( ) ) . willReturn ( this . java.sql.PreparedStatement ) ; given ( this . java.sql.PreparedStatement . java.sql.SQLWarning ( ) ) . willReturn ( java.sql.SQLWarning ) ; this . org.springframework.jdbc.core.JdbcTemplate . setIgnoreWarnings ( true ) ; this . org.springframework.jdbc.core.JdbcTemplate . query ( java.lang.String , new RowCallbackHandler ( ) { @ java.lang.Override public void void ( java.sql.ResultSet java.sql.ResultSet ) throws java . sql . java.sql.SQLException { java.sql.ResultSet . byte ( NUMBER ) ; } } ) ; verify ( this . java.sql.ResultSet ) . close ( ) ; verify ( this . java.sql.PreparedStatement ) . close ( ) ; verify ( this . java.sql.Connection ) . close ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( java.sql.ResultSet java.sql.ResultSet ) throws java . sql . java.sql.SQLException { java.sql.ResultSet . byte ( NUMBER ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final java.sql.SQLException java.sql.SQLException = new java.sql.SQLException ( STRING , STRING , NUMBER ) ; final java.lang.String java.lang.String = STRING ; given ( this . java.sql.ResultSet . boolean ( ) ) . willReturn ( true ) ; void ( false ) ; given ( this . java.sql.Connection . java.sql.Statement ( ) ) . willReturn ( this . java.sql.PreparedStatement ) ; this . org.springframework.jdbc.core.ExpectedException . expect ( BadSqlGrammarException .class ) ; this . org.springframework.jdbc.core.ExpectedException . expect ( exceptionCause ( sameInstance ( java.sql.SQLException ) ) ) ; try { this . org.springframework.jdbc.core.JdbcTemplate . query ( java.lang.String , new RowCallbackHandler ( ) { @ java.lang.Override public void void ( java.sql.ResultSet java.sql.ResultSet ) throws java.sql.SQLException { throw java.sql.SQLException ; } } ) ; fail ( STRING ) ; } finally { verify ( this . java.sql.ResultSet ) . close ( ) ; verify ( this . java.sql.PreparedStatement ) . close ( ) ; verify ( this . java.sql.Connection , atLeastOnce ( ) ) . close ( ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( java.sql.ResultSet java.sql.ResultSet ) throws java.sql.SQLException { throw java.sql.SQLException ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final java.sql.SQLException java.sql.SQLException = new java.sql.SQLException ( STRING , STRING , NUMBER ) ; final java.lang.String java.lang.String = STRING ; given ( this . java.sql.ResultSet . boolean ( ) ) . willReturn ( true ) ; given ( this . java.sql.Connection . java.sql.Statement ( ) ) . willReturn ( this . java.sql.PreparedStatement ) ; JdbcTemplate org.springframework.jdbc.core.JdbcTemplate = new JdbcTemplate ( ) ; org.springframework.jdbc.core.JdbcTemplate . setDataSource ( this . javax.sql.DataSource ) ; org.springframework.jdbc.core.JdbcTemplate . setDatabaseProductName ( STRING ) ; org.springframework.jdbc.core.JdbcTemplate . afterPropertiesSet ( ) ; this . org.springframework.jdbc.core.ExpectedException . expect ( BadSqlGrammarException .class ) ; this . org.springframework.jdbc.core.ExpectedException . expect ( exceptionCause ( sameInstance ( java.sql.SQLException ) ) ) ; try { org.springframework.jdbc.core.JdbcTemplate . query ( java.lang.String , new RowCallbackHandler ( ) { @ java.lang.Override public void void ( java.sql.ResultSet java.sql.ResultSet ) throws java.sql.SQLException { throw java.sql.SQLException ; } } ) ; } finally { verify ( this . java.sql.ResultSet ) . close ( ) ; verify ( this . java.sql.PreparedStatement ) . close ( ) ; verify ( this . java.sql.Connection ) . close ( ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( java.sql.ResultSet java.sql.ResultSet ) throws java.sql.SQLException { throw java.sql.SQLException ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final java.sql.SQLException java.sql.SQLException = new java.sql.SQLException ( STRING , STRING , NUMBER ) ; final java.lang.String java.lang.String = STRING ; given ( this . java.sql.ResultSet . boolean ( ) ) . willReturn ( true ) ; given ( this . java.sql.Connection . java.sql.Statement ( ) ) . willReturn ( this . java.sql.PreparedStatement ) ; JdbcTemplate org.springframework.jdbc.core.JdbcTemplate = new JdbcTemplate ( ) ; org.springframework.jdbc.core.JdbcTemplate . setDataSource ( this . javax.sql.DataSource ) ; org.springframework.jdbc.core.JdbcTemplate . setExceptionTranslator ( new SQLStateSQLExceptionTranslator ( ) ) ; org.springframework.jdbc.core.JdbcTemplate . afterPropertiesSet ( ) ; this . org.springframework.jdbc.core.ExpectedException . expect ( BadSqlGrammarException .class ) ; this . org.springframework.jdbc.core.ExpectedException . expect ( exceptionCause ( sameInstance ( java.sql.SQLException ) ) ) ; try { org.springframework.jdbc.core.JdbcTemplate . query ( java.lang.String , new RowCallbackHandler ( ) { @ java.lang.Override public void void ( java.sql.ResultSet java.sql.ResultSet ) throws java.sql.SQLException { throw java.sql.SQLException ; } } ) ; } finally { verify ( this . java.sql.ResultSet ) . close ( ) ; verify ( this . java.sql.PreparedStatement ) . close ( ) ; verify ( this . java.sql.Connection ) . close ( ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( java.sql.ResultSet java.sql.ResultSet ) throws java.sql.SQLException { throw java.sql.SQLException ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.sql.ResultSet java.sql.ResultSet = mock ( java.sql.ResultSet .class ) ; reset ( this . java.sql.PreparedStatement ) ; given ( this . java.sql.PreparedStatement . java.sql.ResultSet ( ) ) . willReturn ( java.sql.ResultSet ) ; given ( this . java.sql.Connection . java.sql.Statement ( ) ) . willReturn ( this . java.sql.Statement ) ; try { this . org.springframework.jdbc.core.JdbcTemplate . query ( STRING , new ResultSetExtractor < java.lang.Object > ( ) { @ java.lang.Override public java.lang.Object java.lang.Object ( java.sql.ResultSet java.sql.ResultSet ) { throw new InvalidDataAccessApiUsageException ( STRING ) ; } } ) ; fail ( STRING ) ; } catch ( InvalidDataAccessApiUsageException org.springframework.jdbc.core.InvalidDataAccessApiUsageException ) { } try { this . org.springframework.jdbc.core.JdbcTemplate . query ( new PreparedStatementCreator ( ) { @ java.lang.Override public java.sql.PreparedStatement java.sql.PreparedStatement ( java.sql.Connection java.sql.Connection )						throws java.sql.SQLException { return java.sql.Connection . java.sql.PreparedStatement ( STRING ) ; } } , new ResultSetExtractor < java.lang.Object > ( ) { @ java.lang.Override public java.lang.Object java.lang.Object ( java.sql.ResultSet java.sql.ResultSet ) { throw new InvalidDataAccessApiUsageException ( STRING ) ; } } ) ; fail ( STRING ) ; } catch ( InvalidDataAccessApiUsageException org.springframework.jdbc.core.InvalidDataAccessApiUsageException ) { } verify ( this . java.sql.ResultSet ) . close ( ) ; verify ( java.sql.ResultSet ) . close ( ) ; verify ( this . java.sql.PreparedStatement ) . close ( ) ; verify ( this . java.sql.Connection , atLeastOnce ( ) ) . close ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.Object java.lang.Object ( java.sql.ResultSet java.sql.ResultSet ) { throw new InvalidDataAccessApiUsageException ( STRING ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.sql.PreparedStatement java.sql.PreparedStatement ( java.sql.Connection java.sql.Connection )						throws java.sql.SQLException { return java.sql.Connection . java.sql.PreparedStatement ( STRING ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.Object java.lang.Object ( java.sql.ResultSet java.sql.ResultSet ) { throw new InvalidDataAccessApiUsageException ( STRING ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { given ( this . java.sql.ResultSet . boolean ( ) ) . willReturn ( true ) ; given ( this . java.sql.CallableStatement . boolean ( ) ) . willReturn ( true ) ; given ( this . java.sql.CallableStatement . int ( ) ) . willReturn ( - NUMBER ) ; java.util.List<org.springframework.jdbc.core.SqlParameter> < SqlParameter > java.util.List<org.springframework.jdbc.core.SqlParameter> = new java.util.ArrayList<org.springframework.jdbc.core.SqlParameter> <> ( ) ; java.util.List<org.springframework.jdbc.core.SqlParameter> . add ( new SqlReturnResultSet ( STRING , new RowCallbackHandler ( ) { @ java.lang.Override public void void ( java.sql.ResultSet java.sql.ResultSet ) { throw new InvalidDataAccessApiUsageException ( STRING ) ; } } ) ) ; this . org.springframework.jdbc.core.ExpectedException . expect ( InvalidDataAccessApiUsageException .class ) ; try { this . org.springframework.jdbc.core.JdbcTemplate . call ( new CallableStatementCreator ( ) { @ java.lang.Override public java.sql.CallableStatement java.sql.CallableStatement ( java.sql.Connection java.sql.Connection )						throws java.sql.SQLException { return java.sql.Connection . java.sql.CallableStatement ( STRING ) ; } } , java.util.List<org.springframework.jdbc.core.SqlParameter> ) ; } finally { verify ( this . java.sql.ResultSet ) . close ( ) ; verify ( this . java.sql.CallableStatement ) . close ( ) ; verify ( this . java.sql.Connection ) . close ( ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( java.sql.ResultSet java.sql.ResultSet ) { throw new InvalidDataAccessApiUsageException ( STRING ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.sql.CallableStatement java.sql.CallableStatement ( java.sql.Connection java.sql.Connection )						throws java.sql.SQLException { return java.sql.Connection . java.sql.CallableStatement ( STRING ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { given ( this . java.sql.CallableStatement . boolean ( ) ) . willReturn ( false ) ; given ( this . java.sql.CallableStatement . int ( ) ) . willReturn ( - NUMBER ) ; given ( this . java.sql.CallableStatement . java.lang.Object ( NUMBER ) ) . willReturn ( STRING ) ; assertTrue ( STRING , ! this . org.springframework.jdbc.core.JdbcTemplate . isResultsMapCaseInsensitive ( ) ) ; this . org.springframework.jdbc.core.JdbcTemplate . setResultsMapCaseInsensitive ( true ) ; assertTrue ( STRING , this . org.springframework.jdbc.core.JdbcTemplate . isResultsMapCaseInsensitive ( ) ) ; java.util.List<org.springframework.jdbc.core.SqlParameter> < SqlParameter > java.util.List<org.springframework.jdbc.core.SqlParameter> = new java.util.ArrayList<org.springframework.jdbc.core.SqlParameter> <> ( ) ; java.util.List<org.springframework.jdbc.core.SqlParameter> . add ( new SqlOutParameter ( STRING , NUMBER ) ) ; java.util.Map<java.lang.String,java.lang.Object> < java.lang.String , java.lang.Object > java.util.Map<java.lang.String,java.lang.Object> = this . org.springframework.jdbc.core.JdbcTemplate . call ( new CallableStatementCreator ( ) { @ java.lang.Override public java.sql.CallableStatement java.sql.CallableStatement ( java.sql.Connection java.sql.Connection )					throws java.sql.SQLException { return java.sql.Connection . java.sql.CallableStatement ( STRING ) ; } } , java.util.List<org.springframework.jdbc.core.SqlParameter> ) ; assertThat ( java.util.Map<java.lang.String,java.lang.Object> , instanceOf ( LinkedCaseInsensitiveMap .class ) ) ; assertNotNull ( STRING , java.util.Map<java.lang.String,java.lang.Object> . java.lang.Object ( STRING ) ) ; assertNotNull ( STRING , java.util.Map<java.lang.String,java.lang.Object> . java.lang.Object ( STRING ) ) ; verify ( this . java.sql.CallableStatement ) . close ( ) ; verify ( this . java.sql.Connection ) . close ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.sql.CallableStatement java.sql.CallableStatement ( java.sql.Connection java.sql.Connection )					throws java.sql.SQLException { return java.sql.Connection . java.sql.CallableStatement ( STRING ) ; }  <METHOD_END>
<METHOD_START> private void void ( boolean boolean ) throws java.sql.SQLException { java.sql.DatabaseMetaData java.sql.DatabaseMetaData = mock ( java.sql.DatabaseMetaData .class ) ; given ( java.sql.DatabaseMetaData . java.lang.String ( ) ) . willReturn ( STRING ) ; given ( java.sql.DatabaseMetaData . boolean ( ) ) . willReturn ( boolean ) ; given ( this . java.sql.Connection . java.sql.DatabaseMetaData ( ) ) . willReturn ( java.sql.DatabaseMetaData ) ; }  <METHOD_END>
<METHOD_START> void void ( JdbcTemplate org.springframework.jdbc.core.JdbcTemplate , java.lang.String java.lang.String , RowCallbackHandler org.springframework.jdbc.core.RowCallbackHandler );  <METHOD_END>
<METHOD_START> public void ( int int , java.lang.String java.lang.String ) { this . int = int ; this . java.lang.String = java.lang.String ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.sql.PreparedStatement java.sql.PreparedStatement ( java.sql.Connection java.sql.Connection ) throws java.sql.SQLException { java.sql.PreparedStatement java.sql.PreparedStatement = java.sql.Connection . java.sql.PreparedStatement ( this . java.lang.String ) ; java.sql.PreparedStatement . void ( NUMBER , this . int ) ; return java.sql.PreparedStatement ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.String java.lang.String ( ) { return this . java.lang.String ; }  <METHOD_END>
