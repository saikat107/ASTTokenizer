<METHOD_START> @ Test @ RedisAvailable public void void ( ) java.lang.Exception { RedisTemplate < java.lang.String , ? > org.springframework.integration.file.filters.RedisTemplate<java.lang.String,?> = new RedisTemplate < java.lang.String , java.lang.Object > ( ) ; org.springframework.integration.file.filters.RedisTemplate<java.lang.String,> . setConnectionFactory ( this . getConnectionFactoryForTest ( ) ) ; org.springframework.integration.file.filters.RedisTemplate<java.lang.String,> . setKeySerializer ( new StringRedisSerializer ( ) ) ; org.springframework.integration.file.filters.RedisTemplate<java.lang.String,> . afterPropertiesSet ( ) ; org.springframework.integration.file.filters.RedisTemplate<java.lang.String,> . delete ( STRING ) ; try { this . void ( new RedisMetadataStore ( this . getConnectionFactoryForTest ( ) , STRING ) ) ; } finally { org.springframework.integration.file.filters.RedisTemplate<java.lang.String,> . delete ( STRING ) ; } }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { this . void ( new GemfireMetadataStore ( new CacheFactory ( ) . create ( ) ) ) ; }  <METHOD_END>
<METHOD_START> private void void ( ConcurrentMetadataStore org.springframework.integration.file.filters.ConcurrentMetadataStore ) throws java.lang.Exception { final java.util.concurrent.atomic.AtomicBoolean java.util.concurrent.atomic.AtomicBoolean = new java.util.concurrent.atomic.AtomicBoolean ( ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; org.springframework.integration.file.filters.ConcurrentMetadataStore = Mockito . spy ( org.springframework.integration.file.filters.ConcurrentMetadataStore ) ; Mockito . doAnswer ( invocation -> { if ( suspend . get ( ) ) { latch2 . countDown ( ) ; try { latch1 . await ( NUMBER , TimeUnit . SECONDS ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; } } return invocation . callRealMethod ( ) ; } ) . when ( org.springframework.integration.file.filters.ConcurrentMetadataStore ) . replace ( Mockito . anyString ( ) , Mockito . anyString ( ) , Mockito . anyString ( ) ) ; final FileSystemPersistentAcceptOnceFileListFilter org.springframework.integration.file.filters.FileSystemPersistentAcceptOnceFileListFilter = new FileSystemPersistentAcceptOnceFileListFilter ( org.springframework.integration.file.filters.ConcurrentMetadataStore , STRING ) ; final java.io.File java.io.File = java.io.File . java.io.File ( STRING , STRING ) ; assertEquals ( NUMBER , org.springframework.integration.file.filters.FileSystemPersistentAcceptOnceFileListFilter . filterFiles ( new java.io.File [] { java.io.File } ) . size ( ) ) ; java.lang.String java.lang.String = org.springframework.integration.file.filters.ConcurrentMetadataStore . get ( STRING + java.io.File . java.lang.String ( ) ) ; assertEquals ( java.lang.String . java.lang.String ( java.io.File . long ( ) ) , java.lang.String ) ; assertEquals ( NUMBER , org.springframework.integration.file.filters.FileSystemPersistentAcceptOnceFileListFilter . filterFiles ( new java.io.File [] { java.io.File } ) . size ( ) ) ; java.io.File . boolean ( java.io.File . long ( ) + NUMBER ) ; assertEquals ( NUMBER , org.springframework.integration.file.filters.FileSystemPersistentAcceptOnceFileListFilter . filterFiles ( new java.io.File [] { java.io.File } ) . size ( ) ) ; java.lang.String = org.springframework.integration.file.filters.ConcurrentMetadataStore . get ( STRING + java.io.File . java.lang.String ( ) ) ; assertEquals ( java.lang.String . java.lang.String ( java.io.File . long ( ) ) , java.lang.String ) ; assertEquals ( NUMBER , org.springframework.integration.file.filters.FileSystemPersistentAcceptOnceFileListFilter . filterFiles ( new java.io.File [] { java.io.File } ) . size ( ) ) ; java.util.concurrent.atomic.AtomicBoolean . void ( true ) ; java.io.File . boolean ( java.io.File . long ( ) + NUMBER ) ; java.util.concurrent.Future<java.lang.Integer> < java.lang.Integer > java.util.concurrent.Future<java.lang.Integer> = java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . java.util.concurrent.Future<?> ( ( ) org.springframework.integration.file.filters.FileSystemPersistentAcceptOnceFileListFilter . filterFiles ( new java.io.File [] { java.io.File } ) . size ( ) ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; org.springframework.integration.file.filters.ConcurrentMetadataStore . put ( STRING + java.io.File . java.lang.String ( ) , STRING ) ; java.util.concurrent.CountDownLatch . void ( ) ; java.lang.Integer java.lang.Integer = java.util.concurrent.Future<java.lang.Integer> . java.lang.Integer ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ; assertEquals ( java.lang.Integer . java.lang.Integer ( NUMBER ) , java.lang.Integer ) ; java.io.File . boolean ( ) ; org.springframework.integration.file.filters.FileSystemPersistentAcceptOnceFileListFilter . close ( ) ; }  <METHOD_END>
