<METHOD_START> public void ( ) { super( MimeTypeUtils . ALL ); }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( ResolvableType org.springframework.core.codec.ResolvableType , MimeType org.springframework.core.codec.MimeType ) { java.lang.Class<?> < ? > java.lang.Class<?> = org.springframework.core.codec.ResolvableType . getRawClass ( ) ; return ( super. canDecode ( org.springframework.core.codec.ResolvableType , org.springframework.core.codec.MimeType ) && byte [] .class == java.lang.Class<> ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.core.codec.Flux<byte[]> < byte [] > org.springframework.core.codec.Flux<byte[]> ( Publisher < DataBuffer > org.springframework.core.codec.Publisher<org.springframework.core.codec.DataBuffer> , ResolvableType org.springframework.core.codec.ResolvableType , MimeType org.springframework.core.codec.MimeType , java.util.Map<java.lang.String,java.lang.Object> < java.lang.String , java.lang.Object > java.util.Map<java.lang.String,java.lang.Object> ) { return Flux . from ( org.springframework.core.codec.Publisher<org.springframework.core.codec.DataBuffer> ) . map ( ( dataBuffer ) -> { byte [] result = new byte [ dataBuffer . readableByteCount ( ) ] ; dataBuffer . read ( result ) ; DataBufferUtils . release ( dataBuffer ) ; return result ; } ) ; }  <METHOD_END>
