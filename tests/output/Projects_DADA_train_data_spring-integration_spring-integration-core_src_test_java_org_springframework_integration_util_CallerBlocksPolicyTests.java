<METHOD_START> @ Test public void void ( ) java.lang.Exception { final ThreadPoolTaskExecutor org.springframework.integration.util.ThreadPoolTaskExecutor = new ThreadPoolTaskExecutor ( ) ; org.springframework.integration.util.ThreadPoolTaskExecutor . setCorePoolSize ( NUMBER ) ; org.springframework.integration.util.ThreadPoolTaskExecutor . setMaxPoolSize ( NUMBER ) ; org.springframework.integration.util.ThreadPoolTaskExecutor . setQueueCapacity ( NUMBER ) ; org.springframework.integration.util.ThreadPoolTaskExecutor . setRejectedExecutionHandler ( new CallerBlocksPolicy ( NUMBER ) ) ; org.springframework.integration.util.ThreadPoolTaskExecutor . initialize ( ) ; final java.util.concurrent.atomic.AtomicReference<java.lang.Throwable> < java.lang.Throwable > java.util.concurrent.atomic.AtomicReference<java.lang.Throwable> = new java.util.concurrent.atomic.AtomicReference<java.lang.Throwable> < java.lang.Throwable > ( ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; java.lang.Runnable java.lang.Runnable = new java.lang.Runnable ( ) { @ java.lang.Override public void void ( ) { try { org.springframework.integration.util.ThreadPoolTaskExecutor . execute ( this ) ; } catch ( TaskRejectedException org.springframework.integration.util.TaskRejectedException ) { java.util.concurrent.atomic.AtomicReference<java.lang.Throwable> . void ( org.springframework.integration.util.TaskRejectedException . getCause ( ) ) ; } java.util.concurrent.CountDownLatch . void ( ) ; } } ; org.springframework.integration.util.ThreadPoolTaskExecutor . execute ( java.lang.Runnable ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; assertThat ( java.util.concurrent.atomic.AtomicReference<java.lang.Throwable> . java.lang.Throwable ( ) , instanceOf ( java.util.concurrent.RejectedExecutionException .class ) ) ; assertEquals ( STRING , java.util.concurrent.atomic.AtomicReference<java.lang.Throwable> . java.lang.Throwable ( ) . java.lang.String ( ) ) ; org.springframework.integration.util.ThreadPoolTaskExecutor . destroy ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ) { try { org.springframework.integration.util.ThreadPoolTaskExecutor . execute ( this ) ; } catch ( TaskRejectedException org.springframework.integration.util.TaskRejectedException ) { java.util.concurrent.atomic.AtomicReference<java.lang.Throwable> . void ( org.springframework.integration.util.TaskRejectedException . getCause ( ) ) ; } java.util.concurrent.CountDownLatch . void ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final ThreadPoolTaskExecutor org.springframework.integration.util.ThreadPoolTaskExecutor = new ThreadPoolTaskExecutor ( ) ; org.springframework.integration.util.ThreadPoolTaskExecutor . setCorePoolSize ( NUMBER ) ; org.springframework.integration.util.ThreadPoolTaskExecutor . setMaxPoolSize ( NUMBER ) ; org.springframework.integration.util.ThreadPoolTaskExecutor . setQueueCapacity ( NUMBER ) ; org.springframework.integration.util.ThreadPoolTaskExecutor . setRejectedExecutionHandler ( new CallerBlocksPolicy ( NUMBER ) ) ; org.springframework.integration.util.ThreadPoolTaskExecutor . initialize ( ) ; final java.util.concurrent.atomic.AtomicReference<java.lang.Throwable> < java.lang.Throwable > java.util.concurrent.atomic.AtomicReference<java.lang.Throwable> = new java.util.concurrent.atomic.AtomicReference<java.lang.Throwable> < java.lang.Throwable > ( ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; org.springframework.integration.util.ThreadPoolTaskExecutor . execute ( ( ) { try { Runnable foo = new Runnable ( ) { @ Override public void run ( ) { try { Thread . sleep ( NUMBER ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; throw new RuntimeException ( ) ; } latch . countDown ( ) ; } } ; te . execute ( foo ) ; te . execute ( foo ) ; te . execute ( foo ) ; } catch ( TaskRejectedException tre ) { e . set ( tre . getCause ( ) ) ; } } ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; assertNull ( java.util.concurrent.atomic.AtomicReference<java.lang.Throwable> . java.lang.Throwable ( ) ) ; org.springframework.integration.util.ThreadPoolTaskExecutor . destroy ( ) ; }  <METHOD_END>
<METHOD_START> @ Override public void run ( ) { try { Thread . sleep ( NUMBER ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; throw new RuntimeException ( ) ; } latch . countDown ( ) ; }  <METHOD_END>
