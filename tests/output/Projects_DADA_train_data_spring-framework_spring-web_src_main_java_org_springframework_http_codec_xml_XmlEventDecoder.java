<METHOD_START> public void ( ) { super( MimeTypeUtils . APPLICATION_XML , MimeTypeUtils . TEXT_XML ); }  <METHOD_END>
<METHOD_START> @ java.lang.Override @ java.lang.SuppressWarnings ( STRING ) public org.springframework.http.codec.xml.Flux<javax.xml.stream.events.XMLEvent> < javax.xml.stream.events.XMLEvent > org.springframework.http.codec.xml.Flux<javax.xml.stream.events.XMLEvent> ( Publisher < DataBuffer > org.springframework.http.codec.xml.Publisher<org.springframework.http.codec.xml.DataBuffer> , ResolvableType org.springframework.http.codec.xml.ResolvableType , MimeType org.springframework.http.codec.xml.MimeType , java.util.Map<java.lang.String,java.lang.Object> < java.lang.String , java.lang.Object > java.util.Map<java.lang.String,java.lang.Object> ) { Flux < DataBuffer > org.springframework.http.codec.xml.Flux<org.springframework.http.codec.xml.DataBuffer> = Flux . from ( org.springframework.http.codec.xml.Publisher<org.springframework.http.codec.xml.DataBuffer> ) ; if ( boolean && boolean ) { return org.springframework.http.codec.xml.Flux<org.springframework.http.codec.xml.DataBuffer> . flatMap ( new org.springframework.http.codec.xml.XmlEventDecoder.AaltoDataBufferToXmlEvent ( ) ) ; } else { Mono < DataBuffer > org.springframework.http.codec.xml.Mono<org.springframework.http.codec.xml.DataBuffer> = org.springframework.http.codec.xml.Flux<org.springframework.http.codec.xml.DataBuffer> . reduce ( DataBuffer :: write ) ; return org.springframework.http.codec.xml.Mono<org.springframework.http.codec.xml.DataBuffer> . flatMap ( dataBuffer -> { try { InputStream is = dataBuffer . asInputStream ( ) ; XMLEventReader eventReader = inputFactory . createXMLEventReader ( is ) ; return Flux . fromIterable ( ( Iterable < XMLEvent > ) ( ) eventReader ) ; } catch ( XMLStreamException ex ) { return Mono . error ( ex ) ; } finally { DataBufferUtils . release ( dataBuffer ) ; } } ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.http.codec.xml.Publisher<? extends javax.xml.stream.events.XMLEvent> < ? extends javax.xml.stream.events.XMLEvent > org.springframework.http.codec.xml.Publisher<? extends javax.xml.stream.events.XMLEvent> ( DataBuffer org.springframework.http.codec.xml.DataBuffer ) { try { org.springframework.http.codec.xml.AsyncXMLStreamReader<org.springframework.http.codec.xml.AsyncByteBufferFeeder> . getInputFeeder ( ) . feedInput ( org.springframework.http.codec.xml.DataBuffer . asByteBuffer ( ) ) ; java.util.List<javax.xml.stream.events.XMLEvent> < javax.xml.stream.events.XMLEvent > java.util.List<javax.xml.stream.events.XMLEvent> = new java.util.ArrayList<javax.xml.stream.events.XMLEvent> <> ( ) ; while ( true ) { if ( org.springframework.http.codec.xml.AsyncXMLStreamReader<org.springframework.http.codec.xml.AsyncByteBufferFeeder> . next ( ) == AsyncXMLStreamReader . EVENT_INCOMPLETE ) { break; } else { javax.xml.stream.events.XMLEvent javax.xml.stream.events.XMLEvent = javax.xml.stream.util.XMLEventAllocator . javax.xml.stream.events.XMLEvent ( org.springframework.http.codec.xml.AsyncXMLStreamReader<org.springframework.http.codec.xml.AsyncByteBufferFeeder> ) ; java.util.List<javax.xml.stream.events.XMLEvent> . boolean ( javax.xml.stream.events.XMLEvent ) ; if ( javax.xml.stream.events.XMLEvent . boolean ( ) ) { break; } } } return Flux . fromIterable ( java.util.List<javax.xml.stream.events.XMLEvent> ) ; } catch ( javax.xml.stream.XMLStreamException javax.xml.stream.XMLStreamException ) { return Mono . error ( javax.xml.stream.XMLStreamException ) ; } finally { DataBufferUtils . release ( org.springframework.http.codec.xml.DataBuffer ) ; } }  <METHOD_END>
