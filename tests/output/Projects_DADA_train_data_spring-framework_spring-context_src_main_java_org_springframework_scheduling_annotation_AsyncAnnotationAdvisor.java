<METHOD_START> public void ( ) { this( null , null ); }  <METHOD_END>
<METHOD_START> @ java.lang.SuppressWarnings ( STRING ) public void ( java.util.concurrent.Executor java.util.concurrent.Executor , AsyncUncaughtExceptionHandler org.springframework.scheduling.annotation.AsyncUncaughtExceptionHandler ) { java.util.Set<java.lang.Class<? extends java.lang.annotation.Annotation>> < java.lang.Class<? extends java.lang.annotation.Annotation> < ? extends java.lang.annotation.Annotation > > java.util.Set<java.lang.Class<? extends java.lang.annotation.Annotation>> = new java.util.LinkedHashSet<java.lang.Class<? extends java.lang.annotation.Annotation>> <> ( NUMBER ) ; java.util.Set<java.lang.Class<? extends java.lang.annotation.Annotation>> . boolean ( Async .class ) ; try { java.util.Set<java.lang.Class<? extends java.lang.annotation.Annotation>> . boolean ( ( java.lang.Class<? extends java.lang.annotation.Annotation> < ? extends java.lang.annotation.Annotation > ) ClassUtils . forName ( STRING , org.springframework.scheduling.annotation.AsyncAnnotationAdvisor .class . java.lang.ClassLoader ( ) ) ) ; } catch ( java.lang.ClassNotFoundException java.lang.ClassNotFoundException ) { } if ( org.springframework.scheduling.annotation.AsyncUncaughtExceptionHandler != null ) { this . org.springframework.scheduling.annotation.AsyncUncaughtExceptionHandler = org.springframework.scheduling.annotation.AsyncUncaughtExceptionHandler ; } else { this . org.springframework.scheduling.annotation.AsyncUncaughtExceptionHandler = new SimpleAsyncUncaughtExceptionHandler ( ) ; } this . org.springframework.scheduling.annotation.Advice = org.springframework.scheduling.annotation.Advice ( java.util.concurrent.Executor , this . org.springframework.scheduling.annotation.AsyncUncaughtExceptionHandler ) ; this . org.springframework.scheduling.annotation.Pointcut = org.springframework.scheduling.annotation.Pointcut ( java.util.Set<java.lang.Class<? extends java.lang.annotation.Annotation>> ) ; }  <METHOD_END>
<METHOD_START> public void void ( java.util.concurrent.Executor java.util.concurrent.Executor ) { this . org.springframework.scheduling.annotation.Advice = org.springframework.scheduling.annotation.Advice ( java.util.concurrent.Executor , this . org.springframework.scheduling.annotation.AsyncUncaughtExceptionHandler ) ; }  <METHOD_END>
<METHOD_START> public void void ( java.lang.Class<? extends java.lang.annotation.Annotation> < ? extends java.lang.annotation.Annotation > java.lang.Class<? extends java.lang.annotation.Annotation> ) { Assert . notNull ( java.lang.Class<> , STRING ) ; java.util.Set<java.lang.Class<? extends java.lang.annotation.Annotation>> < java.lang.Class<? extends java.lang.annotation.Annotation> < ? extends java.lang.annotation.Annotation > > java.util.Set<java.lang.Class<? extends java.lang.annotation.Annotation>> = new java.util.HashSet<java.lang.Class<? extends java.lang.annotation.Annotation>> <> ( ) ; java.util.Set<java.lang.Class<? extends java.lang.annotation.Annotation>> . boolean ( java.lang.Class<> ) ; this . org.springframework.scheduling.annotation.Pointcut = org.springframework.scheduling.annotation.Pointcut ( java.util.Set<java.lang.Class<? extends java.lang.annotation.Annotation>> ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( BeanFactory org.springframework.scheduling.annotation.BeanFactory ) { if ( this . org.springframework.scheduling.annotation.Advice instanceof BeanFactoryAware ) { ( ( BeanFactoryAware ) this . org.springframework.scheduling.annotation.Advice ) . setBeanFactory ( org.springframework.scheduling.annotation.BeanFactory ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.scheduling.annotation.Advice org.springframework.scheduling.annotation.Advice ( ) { return this . org.springframework.scheduling.annotation.Advice ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.scheduling.annotation.Pointcut org.springframework.scheduling.annotation.Pointcut ( ) { return this . org.springframework.scheduling.annotation.Pointcut ; }  <METHOD_END>
<METHOD_START> protected org.springframework.scheduling.annotation.Advice org.springframework.scheduling.annotation.Advice ( java.util.concurrent.Executor java.util.concurrent.Executor , AsyncUncaughtExceptionHandler org.springframework.scheduling.annotation.AsyncUncaughtExceptionHandler ) { return new AnnotationAsyncExecutionInterceptor ( java.util.concurrent.Executor , org.springframework.scheduling.annotation.AsyncUncaughtExceptionHandler ) ; }  <METHOD_END>
<METHOD_START> protected org.springframework.scheduling.annotation.Pointcut org.springframework.scheduling.annotation.Pointcut ( java.util.Set<java.lang.Class<? extends java.lang.annotation.Annotation>> < java.lang.Class<? extends java.lang.annotation.Annotation> < ? extends java.lang.annotation.Annotation > > java.util.Set<java.lang.Class<? extends java.lang.annotation.Annotation>> ) { ComposablePointcut org.springframework.scheduling.annotation.ComposablePointcut = null ; for ( java.lang.Class<? extends java.lang.annotation.Annotation> < ? extends java.lang.annotation.Annotation > java.lang.Class<? extends java.lang.annotation.Annotation> : java.util.Set<java.lang.Class<? extends java.lang.annotation.Annotation>> ) { Pointcut org.springframework.scheduling.annotation.Pointcut = new AnnotationMatchingPointcut ( java.lang.Class<> , true ) ; Pointcut org.springframework.scheduling.annotation.Pointcut = AnnotationMatchingPointcut . forMethodAnnotation ( java.lang.Class<> ) ; if ( org.springframework.scheduling.annotation.ComposablePointcut == null ) { org.springframework.scheduling.annotation.ComposablePointcut = new ComposablePointcut ( org.springframework.scheduling.annotation.Pointcut ) ; } else { org.springframework.scheduling.annotation.ComposablePointcut . union ( org.springframework.scheduling.annotation.Pointcut ) ; } org.springframework.scheduling.annotation.ComposablePointcut = org.springframework.scheduling.annotation.ComposablePointcut . union ( org.springframework.scheduling.annotation.Pointcut ) ; } return org.springframework.scheduling.annotation.ComposablePointcut ; }  <METHOD_END>
