<METHOD_START> public void ( ) { this( org.springframework.web.reactive.socket.client.HttpClientOptions -> {} ); }  <METHOD_END>
<METHOD_START> public void ( java.util.function.Consumer<? super org.springframework.web.reactive.socket.client.HttpClientOptions> < ? super HttpClientOptions > java.util.function.Consumer<? super org.springframework.web.reactive.socket.client.HttpClientOptions> ) { this . org.springframework.web.reactive.socket.client.HttpClient = HttpClient . create ( java.util.function.Consumer<> ) ; }  <METHOD_END>
<METHOD_START> public org.springframework.web.reactive.socket.client.HttpClient org.springframework.web.reactive.socket.client.HttpClient ( ) { return this . org.springframework.web.reactive.socket.client.HttpClient ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.web.reactive.socket.client.Mono<java.lang.Void> < java.lang.Void > org.springframework.web.reactive.socket.client.Mono<java.lang.Void> ( java.net.URI java.net.URI , WebSocketHandler org.springframework.web.reactive.socket.client.WebSocketHandler ) { return org.springframework.web.reactive.socket.client.Mono<java.lang.Void> ( java.net.URI , new HttpHeaders ( ) , org.springframework.web.reactive.socket.client.WebSocketHandler ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.web.reactive.socket.client.Mono<java.lang.Void> < java.lang.Void > org.springframework.web.reactive.socket.client.Mono<java.lang.Void> ( java.net.URI java.net.URI , HttpHeaders org.springframework.web.reactive.socket.client.HttpHeaders , WebSocketHandler org.springframework.web.reactive.socket.client.WebSocketHandler ) { java.lang.String [] java.lang.String[] = beforeHandshake ( java.net.URI , org.springframework.web.reactive.socket.client.HttpHeaders , org.springframework.web.reactive.socket.client.WebSocketHandler ) ; return org.springframework.web.reactive.socket.client.HttpClient ( ) . ws ( java.net.URI . java.lang.String ( ) , nettyHeaders -> setNettyHeaders ( headers , nettyHeaders ) , StringUtils . arrayToCommaDelimitedString ( java.lang.String[] ) ) . then ( response -> { HandshakeInfo info = afterHandshake ( url , toHttpHeaders ( response ) ) ; ByteBufAllocator allocator = response . channel ( ) . alloc ( ) ; NettyDataBufferFactory factory = new NettyDataBufferFactory ( allocator ) ; return response . receiveWebsocket ( ( in , out ) -> { WebSocketSession session = new ReactorNettyWebSocketSession ( in , out , info , factory ) ; return handler . handle ( session ) ; } ) ; } ) ; }  <METHOD_END>
<METHOD_START> private void void ( HttpHeaders org.springframework.web.reactive.socket.client.HttpHeaders , io . io . io . io . io . io io.netty.handler.codec.http.HttpHeaders ) { org.springframework.web.reactive.socket.client.HttpHeaders . keySet ( ) . stream ( ) . forEach ( key -> nettyHeaders . set ( key , headers . get ( key ) ) ) ; }  <METHOD_END>
<METHOD_START> private org.springframework.web.reactive.socket.client.HttpHeaders org.springframework.web.reactive.socket.client.HttpHeaders ( HttpClientResponse org.springframework.web.reactive.socket.client.HttpClientResponse ) { HttpHeaders org.springframework.web.reactive.socket.client.HttpHeaders = new HttpHeaders ( ) ; org.springframework.web.reactive.socket.client.HttpClientResponse . responseHeaders ( ) . forEach ( entry -> { String name = entry . getKey ( ) ; headers . put ( name , response . responseHeaders ( ) . getAll ( name ) ) ; } ) ; return org.springframework.web.reactive.socket.client.HttpHeaders ; }  <METHOD_END>
