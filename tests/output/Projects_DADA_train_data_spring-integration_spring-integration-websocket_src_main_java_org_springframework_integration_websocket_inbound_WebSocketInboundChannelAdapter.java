<METHOD_START> public void ( IntegrationWebSocketContainer org.springframework.integration.websocket.inbound.IntegrationWebSocketContainer ) { this( org.springframework.integration.websocket.inbound.IntegrationWebSocketContainer , new SubProtocolHandlerRegistry ( new PassThruSubProtocolHandler ( ) ) ); }  <METHOD_END>
<METHOD_START> public void ( IntegrationWebSocketContainer org.springframework.integration.websocket.inbound.IntegrationWebSocketContainer , SubProtocolHandlerRegistry org.springframework.integration.websocket.inbound.SubProtocolHandlerRegistry ) { Assert . notNull ( org.springframework.integration.websocket.inbound.IntegrationWebSocketContainer , STRING ) ; Assert . notNull ( org.springframework.integration.websocket.inbound.SubProtocolHandlerRegistry , STRING ) ; this . org.springframework.integration.websocket.inbound.IntegrationWebSocketContainer = org.springframework.integration.websocket.inbound.IntegrationWebSocketContainer ; this . boolean = this . org.springframework.integration.websocket.inbound.IntegrationWebSocketContainer instanceof ServerWebSocketContainer ; this . org.springframework.integration.websocket.inbound.SubProtocolHandlerRegistry = org.springframework.integration.websocket.inbound.SubProtocolHandlerRegistry ; this . org.springframework.integration.websocket.inbound.MessageChannel = new FixedSubscriberChannel ( message -> { try { handleMessageAndSend ( message ) ; } catch ( Exception e ) { throw new MessageHandlingException ( message , e ) ; } } ) ; }  <METHOD_END>
<METHOD_START> public void void ( java.util.List<org.springframework.integration.websocket.inbound.MessageConverter> < MessageConverter > java.util.List<org.springframework.integration.websocket.inbound.MessageConverter> ) { Assert . noNullElements ( java.util.List<org.springframework.integration.websocket.inbound.MessageConverter> . toArray ( ) , STRING ) ; this . java.util.List<org.springframework.integration.websocket.inbound.MessageConverter> = new java.util.ArrayList<org.springframework.integration.websocket.inbound.MessageConverter> < MessageConverter > ( java.util.List<org.springframework.integration.websocket.inbound.MessageConverter> ) ; }  <METHOD_END>
<METHOD_START> public void void ( boolean boolean ) { this . boolean = boolean ; }  <METHOD_END>
<METHOD_START> public void void ( java.lang.Class<?> < ? > java.lang.Class<?> ) { Assert . notNull ( java.lang.Class<> , STRING ) ; this . java.util.concurrent.atomic.AtomicReference<java.lang.Class<?>> . void ( java.lang.Class<> ) ; }  <METHOD_END>
<METHOD_START> public void void ( boolean boolean ) { this . boolean = boolean ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ApplicationEventPublisher org.springframework.integration.websocket.inbound.ApplicationEventPublisher ) { this . org.springframework.integration.websocket.inbound.ApplicationEventPublisher = org.springframework.integration.websocket.inbound.ApplicationEventPublisher ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( ) { super. onInit ( ) ; this . org.springframework.integration.websocket.inbound.IntegrationWebSocketContainer . setMessageListener ( this ) ; if ( ! CollectionUtils . isEmpty ( this . java.util.List<org.springframework.integration.websocket.inbound.MessageConverter> ) ) { java.util.List<org.springframework.integration.websocket.inbound.MessageConverter> < MessageConverter > java.util.List<org.springframework.integration.websocket.inbound.MessageConverter> = this . org.springframework.integration.websocket.inbound.CompositeMessageConverter . getConverters ( ) ; if ( this . boolean ) { java.util.ListIterator<org.springframework.integration.websocket.inbound.MessageConverter> < MessageConverter > java.util.ListIterator<org.springframework.integration.websocket.inbound.MessageConverter> = this . java.util.List<org.springframework.integration.websocket.inbound.MessageConverter> . listIterator ( this . java.util.List<org.springframework.integration.websocket.inbound.MessageConverter> . size ( ) ) ; while ( java.util.ListIterator<org.springframework.integration.websocket.inbound.MessageConverter> . hasPrevious ( ) ) { MessageConverter org.springframework.integration.websocket.inbound.MessageConverter = java.util.ListIterator<org.springframework.integration.websocket.inbound.MessageConverter> . previous ( ) ; java.util.List<org.springframework.integration.websocket.inbound.MessageConverter> . add ( NUMBER , org.springframework.integration.websocket.inbound.MessageConverter ) ; } } else { java.util.List<org.springframework.integration.websocket.inbound.MessageConverter> . clear ( ) ; java.util.List<org.springframework.integration.websocket.inbound.MessageConverter> . addAll ( this . java.util.List<org.springframework.integration.websocket.inbound.MessageConverter> ) ; } } if ( this . boolean && this . boolean ) { java.util.Map<java.lang.String,org.springframework.integration.websocket.inbound.AbstractBrokerMessageHandler> < java.lang.String , AbstractBrokerMessageHandler > java.util.Map<java.lang.String,org.springframework.integration.websocket.inbound.AbstractBrokerMessageHandler> = getApplicationContext ( ) . getBeansOfType ( AbstractBrokerMessageHandler .class ) ; for ( AbstractBrokerMessageHandler org.springframework.integration.websocket.inbound.AbstractBrokerMessageHandler : java.util.Map<java.lang.String,org.springframework.integration.websocket.inbound.AbstractBrokerMessageHandler> . values ( ) ) { if ( org.springframework.integration.websocket.inbound.AbstractBrokerMessageHandler instanceof SimpleBrokerMessageHandler || org.springframework.integration.websocket.inbound.AbstractBrokerMessageHandler instanceof StompBrokerRelayMessageHandler ) { this . org.springframework.integration.websocket.inbound.AbstractBrokerMessageHandler = org.springframework.integration.websocket.inbound.AbstractBrokerMessageHandler ; break; } } Assert . state ( this . org.springframework.integration.websocket.inbound.AbstractBrokerMessageHandler != null , STRING + STRING ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.util.List<java.lang.String> < java.lang.String > java.util.List<java.lang.String> ( ) { return this . org.springframework.integration.websocket.inbound.SubProtocolHandlerRegistry . getSubProtocols ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( WebSocketSession org.springframework.integration.websocket.inbound.WebSocketSession ) throws java.lang.Exception { if ( boolean ( ) ) { this . org.springframework.integration.websocket.inbound.SubProtocolHandlerRegistry . findProtocolHandler ( org.springframework.integration.websocket.inbound.WebSocketSession ) . afterSessionStarted ( org.springframework.integration.websocket.inbound.WebSocketSession , this . org.springframework.integration.websocket.inbound.MessageChannel ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( WebSocketSession org.springframework.integration.websocket.inbound.WebSocketSession , CloseStatus org.springframework.integration.websocket.inbound.CloseStatus ) throws java.lang.Exception { if ( boolean ( ) ) { this . org.springframework.integration.websocket.inbound.SubProtocolHandlerRegistry . findProtocolHandler ( org.springframework.integration.websocket.inbound.WebSocketSession ) . afterSessionEnded ( org.springframework.integration.websocket.inbound.WebSocketSession , org.springframework.integration.websocket.inbound.CloseStatus , this . org.springframework.integration.websocket.inbound.MessageChannel ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( WebSocketSession org.springframework.integration.websocket.inbound.WebSocketSession , WebSocketMessage < ? > org.springframework.integration.websocket.inbound.WebSocketMessage<?> ) throws java.lang.Exception { if ( boolean ( ) ) { this . org.springframework.integration.websocket.inbound.SubProtocolHandlerRegistry . findProtocolHandler ( org.springframework.integration.websocket.inbound.WebSocketSession ) . handleMessageFromClient ( org.springframework.integration.websocket.inbound.WebSocketSession , org.springframework.integration.websocket.inbound.WebSocketMessage<> , this . org.springframework.integration.websocket.inbound.MessageChannel ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.String java.lang.String ( ) { return STRING ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( ) { this . boolean = true ; if ( this . org.springframework.integration.websocket.inbound.IntegrationWebSocketContainer instanceof Lifecycle ) { ( ( Lifecycle ) this . org.springframework.integration.websocket.inbound.IntegrationWebSocketContainer ) . start ( ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( ) { this . boolean = false ; }  <METHOD_END>
<METHOD_START> private boolean boolean ( ) { if ( ! this . boolean ) { logger . warn ( STRING + this + STRING ) ; } return this . boolean ; }  <METHOD_END>
<METHOD_START> @ java.lang.SuppressWarnings ( STRING ) private void void ( Message < ? > org.springframework.integration.websocket.inbound.Message<?> ) throws java.lang.Exception { SimpMessageHeaderAccessor org.springframework.integration.websocket.inbound.SimpMessageHeaderAccessor = SimpMessageHeaderAccessor . wrap ( org.springframework.integration.websocket.inbound.Message<> ) ; StompCommand org.springframework.integration.websocket.inbound.StompCommand = ( StompCommand ) org.springframework.integration.websocket.inbound.SimpMessageHeaderAccessor . getHeader ( STRING ) ; SimpMessageType org.springframework.integration.websocket.inbound.SimpMessageType = org.springframework.integration.websocket.inbound.SimpMessageHeaderAccessor . getMessageType ( ) ; if ( ( org.springframework.integration.websocket.inbound.SimpMessageType == null || SimpMessageType . MESSAGE . equals ( org.springframework.integration.websocket.inbound.SimpMessageType ) || ( SimpMessageType . CONNECT . equals ( org.springframework.integration.websocket.inbound.SimpMessageType ) && ! this . boolean ) || StompCommand . CONNECTED . equals ( org.springframework.integration.websocket.inbound.StompCommand ) || StompCommand . RECEIPT . equals ( org.springframework.integration.websocket.inbound.StompCommand ) ) && ! boolean ( org.springframework.integration.websocket.inbound.SimpMessageHeaderAccessor . getDestination ( ) ) ) { if ( SimpMessageType . CONNECT . equals ( org.springframework.integration.websocket.inbound.SimpMessageType ) ) { java.lang.String java.lang.String = org.springframework.integration.websocket.inbound.SimpMessageHeaderAccessor . getSessionId ( ) ; SimpMessageHeaderAccessor org.springframework.integration.websocket.inbound.SimpMessageHeaderAccessor = SimpMessageHeaderAccessor . create ( SimpMessageType . CONNECT_ACK ) ; org.springframework.integration.websocket.inbound.SimpMessageHeaderAccessor . setSessionId ( java.lang.String ) ; org.springframework.integration.websocket.inbound.SimpMessageHeaderAccessor . setHeader ( SimpMessageHeaderAccessor . CONNECT_MESSAGE_HEADER , org.springframework.integration.websocket.inbound.Message<> ) ; Message < byte [] > org.springframework.integration.websocket.inbound.Message<byte[]> = MessageBuilder . createMessage ( byte[] , org.springframework.integration.websocket.inbound.SimpMessageHeaderAccessor . getMessageHeaders ( ) ) ; WebSocketSession org.springframework.integration.websocket.inbound.WebSocketSession = this . org.springframework.integration.websocket.inbound.IntegrationWebSocketContainer . getSession ( java.lang.String ) ; this . org.springframework.integration.websocket.inbound.SubProtocolHandlerRegistry . findProtocolHandler ( org.springframework.integration.websocket.inbound.WebSocketSession ) . handleMessageToClient ( org.springframework.integration.websocket.inbound.WebSocketSession , org.springframework.integration.websocket.inbound.Message<byte[]> ) ; } else if ( StompCommand . CONNECTED . equals ( org.springframework.integration.websocket.inbound.StompCommand ) ) { this . org.springframework.integration.websocket.inbound.ApplicationEventPublisher . publishEvent ( new SessionConnectedEvent ( this , ( Message < byte [] > ) org.springframework.integration.websocket.inbound.Message<> ) ) ; } else if ( StompCommand . RECEIPT . equals ( org.springframework.integration.websocket.inbound.StompCommand ) ) { this . org.springframework.integration.websocket.inbound.ApplicationEventPublisher . publishEvent ( new ReceiptEvent ( this , ( Message < byte [] > ) org.springframework.integration.websocket.inbound.Message<> ) ) ; } else { org.springframework.integration.websocket.inbound.SimpMessageHeaderAccessor . removeHeader ( SimpMessageHeaderAccessor . NATIVE_HEADERS ) ; java.lang.Object java.lang.Object = this . org.springframework.integration.websocket.inbound.CompositeMessageConverter . fromMessage ( org.springframework.integration.websocket.inbound.Message<> , this . java.util.concurrent.atomic.AtomicReference<java.lang.Class<?>> . java.lang.Class<?> ( ) ) ; sendMessage ( getMessageBuilderFactory ( ) . withPayload ( java.lang.Object ) . copyHeaders ( org.springframework.integration.websocket.inbound.SimpMessageHeaderAccessor . toMap ( ) ) . build ( ) ) ; } } else { if ( this . boolean ) { this . org.springframework.integration.websocket.inbound.AbstractBrokerMessageHandler . handleMessage ( org.springframework.integration.websocket.inbound.Message<> ) ; } else if ( logger . isDebugEnabled ( ) ) { logger . debug ( STRING + STRING + STRING + STRING + org.springframework.integration.websocket.inbound.Message<> ) ; } } }  <METHOD_END>
<METHOD_START> private boolean boolean ( java.lang.String java.lang.String ) { if ( this . boolean ) { java.util.Collection<java.lang.String> < java.lang.String > java.util.Collection<java.lang.String> = this . org.springframework.integration.websocket.inbound.AbstractBrokerMessageHandler . getDestinationPrefixes ( ) ; if ( ( java.lang.String == null ) || CollectionUtils . isEmpty ( java.util.Collection<java.lang.String> ) ) { return false ; } for ( java.lang.String java.lang.String : java.util.Collection<java.lang.String> ) { if ( java.lang.String . boolean ( java.lang.String ) ) { return true ; } } } return false ; }  <METHOD_END>
