<METHOD_START> @ Test public void void ( ) java.lang.Exception { final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; final java.util.concurrent.atomic.AtomicBoolean java.util.concurrent.atomic.AtomicBoolean = new java.util.concurrent.atomic.AtomicBoolean ( ) ; final java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> < java.net.ServerSocket > java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> = new java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> < java.net.ServerSocket > ( ) ; java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . void ( ( ) { try { java.net.ServerSocket java.net.ServerSocket = javax.net.ServerSocketFactory . javax.net.ServerSocketFactory ( ) . java.net.ServerSocket ( NUMBER , NUMBER ) ; java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . void ( java.net.ServerSocket ) ; java.util.concurrent.CountDownLatch . void ( ) ; java.util.List<java.net.Socket> < java.net.Socket > java.util.List<java.net.Socket> = new java.util.ArrayList<java.net.Socket> < java.net.Socket > ( ) ; int int = NUMBER ; while ( true ) { java.net.Socket java.net.Socket = java.net.ServerSocket . java.net.Socket ( ) ; java.io.ObjectInputStream java.io.ObjectInputStream = new java.io.ObjectInputStream ( java.net.Socket . java.io.InputStream ( ) ) ; java.io.ObjectInputStream . java.lang.Object ( ) ; java.io.ObjectOutputStream java.io.ObjectOutputStream = new java.io.ObjectOutputStream ( java.net.Socket . java.io.OutputStream ( ) ) ; java.io.ObjectOutputStream . void ( STRING + ( int ++ ) ) ; java.util.List<java.net.Socket> . boolean ( java.net.Socket ) ; } } catch ( java.lang.Exception java.lang.Exception ) { if ( ! java.util.concurrent.atomic.AtomicBoolean . boolean ( ) ) { java.lang.Exception . void ( ) ; } } } ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; AbstractClientConnectionFactory org.springframework.integration.ip.tcp.AbstractClientConnectionFactory = new TcpNetClientConnectionFactory ( STRING , java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . java.net.ServerSocket ( ) . int ( ) ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . setSerializer ( new DefaultSerializer ( ) ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . setDeserializer ( new DefaultDeserializer ( ) ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . setSoTimeout ( NUMBER ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . setSingleUse ( true ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . start ( ) ; TcpOutboundGateway org.springframework.integration.ip.tcp.TcpOutboundGateway = new TcpOutboundGateway ( ) ; org.springframework.integration.ip.tcp.TcpOutboundGateway . setConnectionFactory ( org.springframework.integration.ip.tcp.AbstractClientConnectionFactory ) ; QueueChannel org.springframework.integration.ip.tcp.QueueChannel = new QueueChannel ( ) ; org.springframework.integration.ip.tcp.TcpOutboundGateway . setRequiresReply ( true ) ; org.springframework.integration.ip.tcp.TcpOutboundGateway . setOutputChannel ( org.springframework.integration.ip.tcp.QueueChannel ) ; assertEquals ( STRING , TestUtils . getPropertyValue ( org.springframework.integration.ip.tcp.TcpOutboundGateway , STRING ) ) ; org.springframework.integration.ip.tcp.TcpOutboundGateway . setSendTimeout ( NUMBER ) ; org.springframework.integration.ip.tcp.TcpOutboundGateway . setRemoteTimeout ( NUMBER ) ; org.springframework.integration.ip.tcp.TcpOutboundGateway . setSendTimeout ( NUMBER ) ; assertEquals ( STRING , TestUtils . getPropertyValue ( org.springframework.integration.ip.tcp.TcpOutboundGateway , STRING ) ) ; org.springframework.integration.ip.tcp.TcpOutboundGateway . setRequestTimeout ( NUMBER ) ; for ( int int = NUMBER ; int < NUMBER ; int ++ ) { org.springframework.integration.ip.tcp.TcpOutboundGateway . handleMessage ( MessageBuilder . withPayload ( STRING + int ) . build ( ) ) ; } java.util.Set<java.lang.String> < java.lang.String > java.util.Set<java.lang.String> = new java.util.HashSet<java.lang.String> < java.lang.String > ( ) ; for ( int int = NUMBER ; int < NUMBER ; int ++ ) { Message < ? > org.springframework.integration.ip.tcp.Message<?> = org.springframework.integration.ip.tcp.QueueChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.ip.tcp.Message<> ) ; java.util.Set<java.lang.String> . boolean ( ( java.lang.String ) org.springframework.integration.ip.tcp.Message<> . getPayload ( ) ) ; } for ( int int = NUMBER ; int < NUMBER ; int ++ ) { assertTrue ( java.util.Set<java.lang.String> . boolean ( STRING + int ) ) ; } java.util.concurrent.atomic.AtomicBoolean . void ( true ) ; java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . java.net.ServerSocket ( ) . void ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; final java.util.concurrent.atomic.AtomicBoolean java.util.concurrent.atomic.AtomicBoolean = new java.util.concurrent.atomic.AtomicBoolean ( ) ; final java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> < java.net.ServerSocket > java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> = new java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> < java.net.ServerSocket > ( ) ; java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . void ( ( ) { try { java.net.ServerSocket java.net.ServerSocket = javax.net.ServerSocketFactory . javax.net.ServerSocketFactory ( ) . java.net.ServerSocket ( NUMBER , NUMBER ) ; java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . void ( java.net.ServerSocket ) ; java.util.concurrent.CountDownLatch . void ( ) ; int int = NUMBER ; java.net.Socket java.net.Socket = java.net.ServerSocket . java.net.Socket ( ) ; while ( true ) { java.io.ObjectInputStream java.io.ObjectInputStream = new java.io.ObjectInputStream ( java.net.Socket . java.io.InputStream ( ) ) ; java.io.ObjectInputStream . java.lang.Object ( ) ; java.io.ObjectOutputStream java.io.ObjectOutputStream = new java.io.ObjectOutputStream ( java.net.Socket . java.io.OutputStream ( ) ) ; java.io.ObjectOutputStream . void ( STRING + ( int ++ ) ) ; } } catch ( java.lang.Exception java.lang.Exception ) { if ( ! java.util.concurrent.atomic.AtomicBoolean . boolean ( ) ) { java.lang.Exception . void ( ) ; } } } ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; AbstractClientConnectionFactory org.springframework.integration.ip.tcp.AbstractClientConnectionFactory = new TcpNetClientConnectionFactory ( STRING , java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . java.net.ServerSocket ( ) . int ( ) ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . setSerializer ( new DefaultSerializer ( ) ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . setDeserializer ( new DefaultDeserializer ( ) ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . setSoTimeout ( NUMBER ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . setSingleUse ( false ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . start ( ) ; TcpOutboundGateway org.springframework.integration.ip.tcp.TcpOutboundGateway = new TcpOutboundGateway ( ) ; org.springframework.integration.ip.tcp.TcpOutboundGateway . setConnectionFactory ( org.springframework.integration.ip.tcp.AbstractClientConnectionFactory ) ; QueueChannel org.springframework.integration.ip.tcp.QueueChannel = new QueueChannel ( ) ; org.springframework.integration.ip.tcp.TcpOutboundGateway . setRequiresReply ( true ) ; org.springframework.integration.ip.tcp.TcpOutboundGateway . setOutputChannel ( org.springframework.integration.ip.tcp.QueueChannel ) ; for ( int int = NUMBER ; int < NUMBER ; int ++ ) { org.springframework.integration.ip.tcp.TcpOutboundGateway . handleMessage ( MessageBuilder . withPayload ( STRING + int ) . build ( ) ) ; } java.util.Set<java.lang.String> < java.lang.String > java.util.Set<java.lang.String> = new java.util.HashSet<java.lang.String> < java.lang.String > ( ) ; for ( int int = NUMBER ; int < NUMBER ; int ++ ) { Message < ? > org.springframework.integration.ip.tcp.Message<?> = org.springframework.integration.ip.tcp.QueueChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.ip.tcp.Message<> ) ; java.util.Set<java.lang.String> . boolean ( ( java.lang.String ) org.springframework.integration.ip.tcp.Message<> . getPayload ( ) ) ; } for ( int int = NUMBER ; int < NUMBER ; int ++ ) { assertTrue ( java.util.Set<java.lang.String> . boolean ( STRING + int ) ) ; } java.util.concurrent.atomic.AtomicBoolean . void ( true ) ; org.springframework.integration.ip.tcp.TcpOutboundGateway . stop ( ) ; java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . java.net.ServerSocket ( ) . void ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; final java.util.concurrent.atomic.AtomicBoolean java.util.concurrent.atomic.AtomicBoolean = new java.util.concurrent.atomic.AtomicBoolean ( ) ; final java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> < java.net.ServerSocket > java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> = new java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> < java.net.ServerSocket > ( ) ; java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . void ( ( ) { try { java.net.ServerSocket java.net.ServerSocket = javax.net.ServerSocketFactory . javax.net.ServerSocketFactory ( ) . java.net.ServerSocket ( NUMBER ) ; java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . void ( java.net.ServerSocket ) ; java.util.concurrent.CountDownLatch . void ( ) ; int int = NUMBER ; java.net.Socket java.net.Socket = java.net.ServerSocket . java.net.Socket ( ) ; while ( true ) { java.io.ObjectInputStream java.io.ObjectInputStream = new java.io.ObjectInputStream ( java.net.Socket . java.io.InputStream ( ) ) ; java.io.ObjectInputStream . java.lang.Object ( ) ; java.io.ObjectOutputStream java.io.ObjectOutputStream = new java.io.ObjectOutputStream ( java.net.Socket . java.io.OutputStream ( ) ) ; java.lang.Thread . void ( NUMBER ) ; java.io.ObjectOutputStream . void ( STRING + ( int ++ ) ) ; } } catch ( java.lang.Exception java.lang.Exception ) { if ( ! java.util.concurrent.atomic.AtomicBoolean . boolean ( ) ) { java.lang.Exception . void ( ) ; } } } ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; AbstractClientConnectionFactory org.springframework.integration.ip.tcp.AbstractClientConnectionFactory = new TcpNetClientConnectionFactory ( STRING , java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . java.net.ServerSocket ( ) . int ( ) ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . setSerializer ( new DefaultSerializer ( ) ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . setDeserializer ( new DefaultDeserializer ( ) ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . setSoTimeout ( NUMBER ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . setSingleUse ( false ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . start ( ) ; final TcpOutboundGateway org.springframework.integration.ip.tcp.TcpOutboundGateway = new TcpOutboundGateway ( ) ; org.springframework.integration.ip.tcp.TcpOutboundGateway . setConnectionFactory ( org.springframework.integration.ip.tcp.AbstractClientConnectionFactory ) ; org.springframework.integration.ip.tcp.TcpOutboundGateway . setRequestTimeout ( NUMBER ) ; QueueChannel org.springframework.integration.ip.tcp.QueueChannel = new QueueChannel ( ) ; org.springframework.integration.ip.tcp.TcpOutboundGateway . setRequiresReply ( true ) ; org.springframework.integration.ip.tcp.TcpOutboundGateway . setOutputChannel ( org.springframework.integration.ip.tcp.QueueChannel ) ; @ java.lang.SuppressWarnings ( STRING ) java.util.concurrent.Future<java.lang.Integer> < java.lang.Integer > [] java.util.concurrent.Future<java.lang.Integer>[] = ( java.util.concurrent.Future<java.lang.Integer> < java.lang.Integer > [] ) new java.util.concurrent.Future<?> < ? > [ NUMBER ] ; for ( int int = NUMBER ; int < NUMBER ; int ++ ) { final int int = int ; java.util.concurrent.Future<java.lang.Integer>[] [ int ] = ( java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . java.util.concurrent.Future<java.lang.Integer> ( ( ) { org.springframework.integration.ip.tcp.TcpOutboundGateway . handleMessage ( MessageBuilder . withPayload ( STRING + int ) . build ( ) ) ; return NUMBER ; } ) ) ; } java.util.Set<java.lang.String> < java.lang.String > java.util.Set<java.lang.String> = new java.util.HashSet<java.lang.String> < java.lang.String > ( ) ; int int = NUMBER ; for ( int int = NUMBER ; int < NUMBER ; int ++ ) { try { java.util.concurrent.Future<java.lang.Integer>[] [ int ] . java.lang.Integer ( ) ; } catch ( java.util.concurrent.ExecutionException java.util.concurrent.ExecutionException ) { if ( int > NUMBER ) { fail ( STRING + java.util.concurrent.ExecutionException . java.lang.String ( ) ) ; } else { assertNotNull ( java.util.concurrent.ExecutionException . java.lang.Throwable ( ) ) ; assertTrue ( java.util.concurrent.ExecutionException . java.lang.Throwable ( ) instanceof MessageTimeoutException ) ; } int ++ ; continue; } Message < ? > org.springframework.integration.ip.tcp.Message<?> = org.springframework.integration.ip.tcp.QueueChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.ip.tcp.Message<> ) ; java.util.Set<java.lang.String> . boolean ( ( java.lang.String ) org.springframework.integration.ip.tcp.Message<> . getPayload ( ) ) ; } if ( int < NUMBER ) { fail ( STRING ) ; } for ( int int = NUMBER ; int < NUMBER ; int ++ ) { assertTrue ( java.util.Set<java.lang.String> . boolean ( STRING + int ) ) ; } java.util.concurrent.atomic.AtomicBoolean . void ( true ) ; org.springframework.integration.ip.tcp.TcpOutboundGateway . stop ( ) ; java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . java.net.ServerSocket ( ) . void ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.net.ServerSocket java.net.ServerSocket = javax.net.ServerSocketFactory . javax.net.ServerSocketFactory ( ) . java.net.ServerSocket ( NUMBER ) ; final int int = java.net.ServerSocket . int ( ) ; AbstractClientConnectionFactory org.springframework.integration.ip.tcp.AbstractClientConnectionFactory = org.springframework.integration.ip.tcp.AbstractClientConnectionFactory ( int ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . start ( ) ; void ( int , org.springframework.integration.ip.tcp.AbstractClientConnectionFactory , java.net.ServerSocket ) ; java.net.ServerSocket . void ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.net.ServerSocket java.net.ServerSocket = javax.net.ServerSocketFactory . javax.net.ServerSocketFactory ( ) . java.net.ServerSocket ( NUMBER ) ; final int int = java.net.ServerSocket . int ( ) ; AbstractClientConnectionFactory org.springframework.integration.ip.tcp.AbstractClientConnectionFactory = org.springframework.integration.ip.tcp.AbstractClientConnectionFactory ( int ) ; CachingClientConnectionFactory org.springframework.integration.ip.tcp.CachingClientConnectionFactory = new CachingClientConnectionFactory ( org.springframework.integration.ip.tcp.AbstractClientConnectionFactory , NUMBER ) ; org.springframework.integration.ip.tcp.CachingClientConnectionFactory . start ( ) ; void ( int , org.springframework.integration.ip.tcp.CachingClientConnectionFactory , java.net.ServerSocket ) ; java.net.ServerSocket . void ( ) ; }  <METHOD_END>
<METHOD_START> private org.springframework.integration.ip.tcp.AbstractClientConnectionFactory org.springframework.integration.ip.tcp.AbstractClientConnectionFactory ( final int int ) { AbstractClientConnectionFactory org.springframework.integration.ip.tcp.AbstractClientConnectionFactory = new TcpNetClientConnectionFactory ( STRING , int ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . setSerializer ( new DefaultSerializer ( ) ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . setDeserializer ( new DefaultDeserializer ( ) ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . setSoTimeout ( NUMBER ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . setSingleUse ( false ) ; return org.springframework.integration.ip.tcp.AbstractClientConnectionFactory ; }  <METHOD_END>
<METHOD_START> private void void ( final int int , AbstractClientConnectionFactory org.springframework.integration.ip.tcp.AbstractClientConnectionFactory , final java.net.ServerSocket java.net.ServerSocket ) throws java.lang.InterruptedException { final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; final java.util.concurrent.atomic.AtomicBoolean java.util.concurrent.atomic.AtomicBoolean = new java.util.concurrent.atomic.AtomicBoolean ( ) ; final java.util.concurrent.atomic.AtomicReference<java.lang.String> < java.lang.String > java.util.concurrent.atomic.AtomicReference<java.lang.String> = new java.util.concurrent.atomic.AtomicReference<java.lang.String> < java.lang.String > ( ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . void ( ( ) { try { java.util.concurrent.CountDownLatch . void ( ) ; int int = NUMBER ; while ( ! java.util.concurrent.atomic.AtomicBoolean . boolean ( ) ) { java.net.Socket java.net.Socket = java.net.ServerSocket . java.net.Socket ( ) ; int ++ ; while ( ! java.net.Socket . boolean ( ) ) { try { java.io.ObjectInputStream java.io.ObjectInputStream = new java.io.ObjectInputStream ( java.net.Socket . java.io.InputStream ( ) ) ; java.lang.String java.lang.String = ( java.lang.String ) java.io.ObjectInputStream . java.lang.Object ( ) ; logger . debug ( STRING + java.lang.String ) ; java.io.ObjectOutputStream java.io.ObjectOutputStream = new java.io.ObjectOutputStream ( java.net.Socket . java.io.OutputStream ( ) ) ; if ( int < NUMBER ) { java.lang.Thread . void ( NUMBER ) ; } java.io.ObjectOutputStream . void ( java.lang.String . java.lang.String ( STRING , STRING ) ) ; logger . debug ( STRING + java.lang.String ) ; java.util.concurrent.atomic.AtomicReference<java.lang.String> . void ( java.lang.String ) ; java.util.concurrent.CountDownLatch . void ( ) ; } catch ( java.io.IOException java.io.IOException ) { logger . debug ( STRING + java.io.IOException . java.lang.Class<? extends java.io.IOException> ( ) . java.lang.String ( ) ) ; java.net.Socket . void ( ) ; } } } } catch ( java.lang.Exception java.lang.Exception ) { if ( ! java.util.concurrent.atomic.AtomicBoolean . boolean ( ) ) { java.lang.Exception . void ( ) ; } } } ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; final TcpOutboundGateway org.springframework.integration.ip.tcp.TcpOutboundGateway = new TcpOutboundGateway ( ) ; org.springframework.integration.ip.tcp.TcpOutboundGateway . setConnectionFactory ( org.springframework.integration.ip.tcp.AbstractClientConnectionFactory ) ; org.springframework.integration.ip.tcp.TcpOutboundGateway . setRequestTimeout ( java.lang.Integer . int ) ; QueueChannel org.springframework.integration.ip.tcp.QueueChannel = new QueueChannel ( ) ; org.springframework.integration.ip.tcp.TcpOutboundGateway . setRequiresReply ( true ) ; org.springframework.integration.ip.tcp.TcpOutboundGateway . setOutputChannel ( org.springframework.integration.ip.tcp.QueueChannel ) ; Expression org.springframework.integration.ip.tcp.Expression = Mockito . mock ( Expression .class ) ; when ( org.springframework.integration.ip.tcp.Expression . getValue ( Mockito . any ( EvaluationContext .class ) , Mockito . any ( Message .class ) , Mockito . eq ( java.lang.Long .class ) ) ) . thenReturn ( NUMBER , NUMBER ) ; org.springframework.integration.ip.tcp.TcpOutboundGateway . setRemoteTimeoutExpression ( org.springframework.integration.ip.tcp.Expression ) ; @ java.lang.SuppressWarnings ( STRING ) java.util.concurrent.Future<java.lang.Integer> < java.lang.Integer > [] java.util.concurrent.Future<java.lang.Integer>[] = ( java.util.concurrent.Future<java.lang.Integer> < java.lang.Integer > [] ) new java.util.concurrent.Future<?> < ? > [ NUMBER ] ; for ( int int = NUMBER ; int < NUMBER ; int ++ ) { final int int = int ; java.util.concurrent.Future<java.lang.Integer>[] [ int ] = ( java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . java.util.concurrent.Future<java.lang.Integer> ( ( ) { org.springframework.integration.ip.tcp.TcpOutboundGateway . handleMessage ( MessageBuilder . withPayload ( STRING + int ) . build ( ) ) ; return int ; } ) ) ; } assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; java.util.List<java.lang.String> < java.lang.String > java.util.List<java.lang.String> = new java.util.ArrayList<java.lang.String> < java.lang.String > ( ) ; int int = NUMBER ; for ( int int = NUMBER ; int < NUMBER ; int ++ ) { try { int int = java.util.concurrent.Future<java.lang.Integer>[] [ int ] . java.lang.Integer ( ) ; java.lang.String java.lang.String = ( java.lang.String ) org.springframework.integration.ip.tcp.QueueChannel . receive ( NUMBER ) . getPayload ( ) ; logger . debug ( int + STRING + int + STRING + java.lang.String ) ; java.util.List<java.lang.String> . boolean ( java.lang.String ) ; } catch ( java.util.concurrent.ExecutionException java.util.concurrent.ExecutionException ) { if ( int >= NUMBER ) { fail ( STRING + java.util.concurrent.ExecutionException . java.lang.String ( ) ) ; } else { assertNotNull ( java.util.concurrent.ExecutionException . java.lang.Throwable ( ) ) ; assertThat ( java.util.concurrent.ExecutionException . java.lang.Throwable ( ) , instanceOf ( MessageTimeoutException .class ) ) ; } int ++ ; continue; } } assertEquals ( STRING , NUMBER , int ) ; assertEquals ( NUMBER , java.util.List<java.lang.String> . int ( ) ) ; assertEquals ( java.util.concurrent.atomic.AtomicReference<java.lang.String> . java.lang.String ( ) . java.lang.String ( STRING , STRING ) , java.util.List<java.lang.String> . java.lang.String ( NUMBER ) ) ; java.util.concurrent.atomic.AtomicBoolean . void ( true ) ; assertEquals ( NUMBER , TestUtils . getPropertyValue ( org.springframework.integration.ip.tcp.TcpOutboundGateway , STRING , java.util.Map .class ) . size ( ) ) ; org.springframework.integration.ip.tcp.TcpOutboundGateway . stop ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> < java.net.ServerSocket > java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> = new java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> < java.net.ServerSocket > ( ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; final java.util.concurrent.atomic.AtomicBoolean java.util.concurrent.atomic.AtomicBoolean = new java.util.concurrent.atomic.AtomicBoolean ( ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . void ( ( ) { try { java.net.ServerSocket java.net.ServerSocket = javax.net.ServerSocketFactory . javax.net.ServerSocketFactory ( ) . java.net.ServerSocket ( NUMBER ) ; java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . void ( java.net.ServerSocket ) ; java.util.concurrent.CountDownLatch . void ( ) ; while ( ! java.util.concurrent.atomic.AtomicBoolean . boolean ( ) ) { java.net.Socket java.net.Socket = java.net.ServerSocket . java.net.Socket ( ) ; while ( ! java.net.Socket . boolean ( ) ) { try { java.io.ObjectInputStream java.io.ObjectInputStream = new java.io.ObjectInputStream ( java.net.Socket . java.io.InputStream ( ) ) ; java.lang.String java.lang.String = ( java.lang.String ) java.io.ObjectInputStream . java.lang.Object ( ) ; logger . debug ( STRING + java.lang.String ) ; java.io.ObjectOutputStream java.io.ObjectOutputStream = new java.io.ObjectOutputStream ( java.net.Socket . java.io.OutputStream ( ) ) ; java.io.ObjectOutputStream . void ( STRING ) ; logger . debug ( STRING + java.lang.String ) ; java.util.concurrent.CountDownLatch . void ( ) ; } catch ( java.io.IOException java.io.IOException ) { logger . debug ( STRING + java.io.IOException . java.lang.Class<? extends java.io.IOException> ( ) . java.lang.String ( ) ) ; java.net.Socket . void ( ) ; } } } } catch ( java.lang.Exception java.lang.Exception ) { if ( ! java.util.concurrent.atomic.AtomicBoolean . boolean ( ) ) { java.lang.Exception . void ( ) ; } } } ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; AbstractClientConnectionFactory org.springframework.integration.ip.tcp.AbstractClientConnectionFactory = mock ( AbstractClientConnectionFactory .class ) ; TcpConnectionSupport org.springframework.integration.ip.tcp.TcpConnectionSupport = org.springframework.integration.ip.tcp.TcpConnectionSupport ( ) ; when ( org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . getConnection ( ) ) . thenReturn ( org.springframework.integration.ip.tcp.TcpConnectionSupport ) ; doThrow ( new java.io.IOException ( STRING ) ) . when ( org.springframework.integration.ip.tcp.TcpConnectionSupport ) . send ( Mockito . any ( Message .class ) ) ; AbstractClientConnectionFactory org.springframework.integration.ip.tcp.AbstractClientConnectionFactory = new TcpNetClientConnectionFactory ( STRING , java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . java.net.ServerSocket ( ) . int ( ) ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . setSerializer ( new DefaultSerializer ( ) ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . setDeserializer ( new DefaultDeserializer ( ) ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . setSoTimeout ( NUMBER ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . setSingleUse ( false ) ; java.util.List<org.springframework.integration.ip.tcp.AbstractClientConnectionFactory> < AbstractClientConnectionFactory > java.util.List<org.springframework.integration.ip.tcp.AbstractClientConnectionFactory> = new java.util.ArrayList<org.springframework.integration.ip.tcp.AbstractClientConnectionFactory> < AbstractClientConnectionFactory > ( ) ; java.util.List<org.springframework.integration.ip.tcp.AbstractClientConnectionFactory> . add ( org.springframework.integration.ip.tcp.AbstractClientConnectionFactory ) ; java.util.List<org.springframework.integration.ip.tcp.AbstractClientConnectionFactory> . add ( org.springframework.integration.ip.tcp.AbstractClientConnectionFactory ) ; FailoverClientConnectionFactory org.springframework.integration.ip.tcp.FailoverClientConnectionFactory = new FailoverClientConnectionFactory ( java.util.List<org.springframework.integration.ip.tcp.AbstractClientConnectionFactory> ) ; org.springframework.integration.ip.tcp.FailoverClientConnectionFactory . start ( ) ; CachingClientConnectionFactory org.springframework.integration.ip.tcp.CachingClientConnectionFactory = new CachingClientConnectionFactory ( org.springframework.integration.ip.tcp.FailoverClientConnectionFactory , NUMBER ) ; org.springframework.integration.ip.tcp.CachingClientConnectionFactory . start ( ) ; TcpOutboundGateway org.springframework.integration.ip.tcp.TcpOutboundGateway = new TcpOutboundGateway ( ) ; org.springframework.integration.ip.tcp.TcpOutboundGateway . setConnectionFactory ( org.springframework.integration.ip.tcp.CachingClientConnectionFactory ) ; PollableChannel org.springframework.integration.ip.tcp.PollableChannel = new QueueChannel ( ) ; org.springframework.integration.ip.tcp.TcpOutboundGateway . setOutputChannel ( org.springframework.integration.ip.tcp.PollableChannel ) ; org.springframework.integration.ip.tcp.TcpOutboundGateway . setBeanFactory ( mock ( BeanFactory .class ) ) ; org.springframework.integration.ip.tcp.TcpOutboundGateway . afterPropertiesSet ( ) ; org.springframework.integration.ip.tcp.TcpOutboundGateway . start ( ) ; GenericMessage < java.lang.String > org.springframework.integration.ip.tcp.GenericMessage<java.lang.String> = new GenericMessage < java.lang.String > ( STRING ) ; org.springframework.integration.ip.tcp.TcpOutboundGateway . handleMessage ( org.springframework.integration.ip.tcp.GenericMessage<java.lang.String> ) ; Message < ? > org.springframework.integration.ip.tcp.Message<?> = org.springframework.integration.ip.tcp.PollableChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.ip.tcp.Message<> ) ; assertEquals ( STRING , org.springframework.integration.ip.tcp.Message<> . getPayload ( ) ) ; java.util.concurrent.atomic.AtomicBoolean . void ( true ) ; org.springframework.integration.ip.tcp.TcpOutboundGateway . stop ( ) ; verify ( org.springframework.integration.ip.tcp.TcpConnectionSupport ) . send ( Mockito . any ( Message .class ) ) ; java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . java.net.ServerSocket ( ) . void ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> < java.net.ServerSocket > java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> = new java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> < java.net.ServerSocket > ( ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; final java.util.concurrent.atomic.AtomicBoolean java.util.concurrent.atomic.AtomicBoolean = new java.util.concurrent.atomic.AtomicBoolean ( ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . void ( ( ) { try { java.net.ServerSocket java.net.ServerSocket = javax.net.ServerSocketFactory . javax.net.ServerSocketFactory ( ) . java.net.ServerSocket ( NUMBER ) ; java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . void ( java.net.ServerSocket ) ; java.util.concurrent.CountDownLatch . void ( ) ; while ( ! java.util.concurrent.atomic.AtomicBoolean . boolean ( ) ) { java.net.Socket java.net.Socket = java.net.ServerSocket . java.net.Socket ( ) ; while ( ! java.net.Socket . boolean ( ) ) { try { java.io.ObjectInputStream java.io.ObjectInputStream = new java.io.ObjectInputStream ( java.net.Socket . java.io.InputStream ( ) ) ; java.lang.String java.lang.String = ( java.lang.String ) java.io.ObjectInputStream . java.lang.Object ( ) ; logger . debug ( STRING + java.lang.String ) ; java.io.ObjectOutputStream java.io.ObjectOutputStream = new java.io.ObjectOutputStream ( java.net.Socket . java.io.OutputStream ( ) ) ; java.io.ObjectOutputStream . void ( STRING ) ; logger . debug ( STRING + java.lang.String ) ; java.util.concurrent.CountDownLatch . void ( ) ; } catch ( java.io.IOException java.io.IOException ) { logger . debug ( STRING + java.io.IOException . java.lang.Class<? extends java.io.IOException> ( ) . java.lang.String ( ) ) ; java.net.Socket . void ( ) ; } } } } catch ( java.lang.Exception java.lang.Exception ) { if ( ! java.util.concurrent.atomic.AtomicBoolean . boolean ( ) ) { java.lang.Exception . void ( ) ; } } } ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; AbstractClientConnectionFactory org.springframework.integration.ip.tcp.AbstractClientConnectionFactory = mock ( AbstractClientConnectionFactory .class ) ; TcpConnectionSupport org.springframework.integration.ip.tcp.TcpConnectionSupport = org.springframework.integration.ip.tcp.TcpConnectionSupport ( ) ; when ( org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . getConnection ( ) ) . thenReturn ( org.springframework.integration.ip.tcp.TcpConnectionSupport ) ; when ( org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . isSingleUse ( ) ) . thenReturn ( true ) ; doThrow ( new java.io.IOException ( STRING ) ) . when ( org.springframework.integration.ip.tcp.TcpConnectionSupport ) . send ( Mockito . any ( Message .class ) ) ; CachingClientConnectionFactory org.springframework.integration.ip.tcp.CachingClientConnectionFactory = new CachingClientConnectionFactory ( org.springframework.integration.ip.tcp.AbstractClientConnectionFactory , NUMBER ) ; AbstractClientConnectionFactory org.springframework.integration.ip.tcp.AbstractClientConnectionFactory = new TcpNetClientConnectionFactory ( STRING , java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . java.net.ServerSocket ( ) . int ( ) ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . setSerializer ( new DefaultSerializer ( ) ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . setDeserializer ( new DefaultDeserializer ( ) ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . setSoTimeout ( NUMBER ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . setSingleUse ( true ) ; CachingClientConnectionFactory org.springframework.integration.ip.tcp.CachingClientConnectionFactory = new CachingClientConnectionFactory ( org.springframework.integration.ip.tcp.AbstractClientConnectionFactory , NUMBER ) ; java.util.List<org.springframework.integration.ip.tcp.AbstractClientConnectionFactory> < AbstractClientConnectionFactory > java.util.List<org.springframework.integration.ip.tcp.AbstractClientConnectionFactory> = new java.util.ArrayList<org.springframework.integration.ip.tcp.AbstractClientConnectionFactory> < AbstractClientConnectionFactory > ( ) ; java.util.List<org.springframework.integration.ip.tcp.AbstractClientConnectionFactory> . add ( org.springframework.integration.ip.tcp.CachingClientConnectionFactory ) ; java.util.List<org.springframework.integration.ip.tcp.AbstractClientConnectionFactory> . add ( org.springframework.integration.ip.tcp.CachingClientConnectionFactory ) ; FailoverClientConnectionFactory org.springframework.integration.ip.tcp.FailoverClientConnectionFactory = new FailoverClientConnectionFactory ( java.util.List<org.springframework.integration.ip.tcp.AbstractClientConnectionFactory> ) ; org.springframework.integration.ip.tcp.FailoverClientConnectionFactory . setSingleUse ( true ) ; org.springframework.integration.ip.tcp.FailoverClientConnectionFactory . afterPropertiesSet ( ) ; org.springframework.integration.ip.tcp.FailoverClientConnectionFactory . start ( ) ; TcpOutboundGateway org.springframework.integration.ip.tcp.TcpOutboundGateway = new TcpOutboundGateway ( ) ; org.springframework.integration.ip.tcp.TcpOutboundGateway . setConnectionFactory ( org.springframework.integration.ip.tcp.FailoverClientConnectionFactory ) ; PollableChannel org.springframework.integration.ip.tcp.PollableChannel = new QueueChannel ( ) ; org.springframework.integration.ip.tcp.TcpOutboundGateway . setOutputChannel ( org.springframework.integration.ip.tcp.PollableChannel ) ; org.springframework.integration.ip.tcp.TcpOutboundGateway . setBeanFactory ( mock ( BeanFactory .class ) ) ; org.springframework.integration.ip.tcp.TcpOutboundGateway . afterPropertiesSet ( ) ; org.springframework.integration.ip.tcp.TcpOutboundGateway . start ( ) ; GenericMessage < java.lang.String > org.springframework.integration.ip.tcp.GenericMessage<java.lang.String> = new GenericMessage < java.lang.String > ( STRING ) ; org.springframework.integration.ip.tcp.TcpOutboundGateway . handleMessage ( org.springframework.integration.ip.tcp.GenericMessage<java.lang.String> ) ; Message < ? > org.springframework.integration.ip.tcp.Message<?> = org.springframework.integration.ip.tcp.PollableChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.ip.tcp.Message<> ) ; assertEquals ( STRING , org.springframework.integration.ip.tcp.Message<> . getPayload ( ) ) ; java.util.concurrent.atomic.AtomicBoolean . void ( true ) ; org.springframework.integration.ip.tcp.TcpOutboundGateway . stop ( ) ; verify ( org.springframework.integration.ip.tcp.TcpConnectionSupport ) . send ( Mockito . any ( Message .class ) ) ; java.util.concurrent.atomic.AtomicReference<java.net.ServerSocket> . java.net.ServerSocket ( ) . void ( ) ; }  <METHOD_END>
<METHOD_START> public org.springframework.integration.ip.tcp.TcpConnectionSupport org.springframework.integration.ip.tcp.TcpConnectionSupport ( ) { TcpConnectionSupport org.springframework.integration.ip.tcp.TcpConnectionSupport = mock ( TcpConnectionSupport .class ) ; when ( org.springframework.integration.ip.tcp.TcpConnectionSupport . isOpen ( ) ) . thenReturn ( true ) ; return org.springframework.integration.ip.tcp.TcpConnectionSupport ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.net.ServerSocket java.net.ServerSocket = javax.net.ServerSocketFactory . javax.net.ServerSocketFactory ( ) . java.net.ServerSocket ( NUMBER ) ; final int int = java.net.ServerSocket . int ( ) ; AbstractClientConnectionFactory org.springframework.integration.ip.tcp.AbstractClientConnectionFactory = new TcpNetClientConnectionFactory ( STRING , int ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . setSerializer ( new DefaultSerializer ( ) ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . setDeserializer ( new DefaultDeserializer ( ) ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . setSoTimeout ( NUMBER ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . setSingleUse ( false ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . start ( ) ; void ( int , org.springframework.integration.ip.tcp.AbstractClientConnectionFactory , java.net.ServerSocket ) ; java.net.ServerSocket . void ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.net.ServerSocket java.net.ServerSocket = javax.net.ServerSocketFactory . javax.net.ServerSocketFactory ( ) . java.net.ServerSocket ( NUMBER ) ; final int int = java.net.ServerSocket . int ( ) ; AbstractClientConnectionFactory org.springframework.integration.ip.tcp.AbstractClientConnectionFactory = new TcpNioClientConnectionFactory ( STRING , int ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . setSerializer ( new DefaultSerializer ( ) ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . setDeserializer ( new DefaultDeserializer ( ) ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . setSoTimeout ( NUMBER ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . setSingleUse ( false ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . start ( ) ; void ( int , org.springframework.integration.ip.tcp.AbstractClientConnectionFactory , java.net.ServerSocket ) ; java.net.ServerSocket . void ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.net.ServerSocket java.net.ServerSocket = javax.net.ServerSocketFactory . javax.net.ServerSocketFactory ( ) . java.net.ServerSocket ( NUMBER ) ; final int int = java.net.ServerSocket . int ( ) ; AbstractClientConnectionFactory org.springframework.integration.ip.tcp.AbstractClientConnectionFactory = new TcpNetClientConnectionFactory ( STRING , int ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . setSerializer ( new DefaultSerializer ( ) ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . setDeserializer ( new DefaultDeserializer ( ) ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . setSoTimeout ( NUMBER ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . setSingleUse ( false ) ; CachingClientConnectionFactory org.springframework.integration.ip.tcp.CachingClientConnectionFactory = new CachingClientConnectionFactory ( org.springframework.integration.ip.tcp.AbstractClientConnectionFactory , NUMBER ) ; org.springframework.integration.ip.tcp.CachingClientConnectionFactory . start ( ) ; void ( int , org.springframework.integration.ip.tcp.CachingClientConnectionFactory , java.net.ServerSocket ) ; java.net.ServerSocket . void ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.net.ServerSocket java.net.ServerSocket = javax.net.ServerSocketFactory . javax.net.ServerSocketFactory ( ) . java.net.ServerSocket ( NUMBER ) ; final int int = java.net.ServerSocket . int ( ) ; AbstractClientConnectionFactory org.springframework.integration.ip.tcp.AbstractClientConnectionFactory = new TcpNetClientConnectionFactory ( STRING , int ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . setSerializer ( new DefaultSerializer ( ) ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . setDeserializer ( new DefaultDeserializer ( ) ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . setSoTimeout ( NUMBER ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . setSingleUse ( false ) ; FailoverClientConnectionFactory org.springframework.integration.ip.tcp.FailoverClientConnectionFactory = new FailoverClientConnectionFactory ( java.util.Collections . java.util.List ( org.springframework.integration.ip.tcp.AbstractClientConnectionFactory ) ) ; org.springframework.integration.ip.tcp.FailoverClientConnectionFactory . start ( ) ; void ( int , org.springframework.integration.ip.tcp.FailoverClientConnectionFactory , java.net.ServerSocket ) ; java.net.ServerSocket . void ( ) ; }  <METHOD_END>
<METHOD_START> private void void ( final int int , AbstractClientConnectionFactory org.springframework.integration.ip.tcp.AbstractClientConnectionFactory , final java.net.ServerSocket java.net.ServerSocket ) throws java.lang.Exception { final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; final java.util.concurrent.atomic.AtomicBoolean java.util.concurrent.atomic.AtomicBoolean = new java.util.concurrent.atomic.AtomicBoolean ( ) ; final java.util.concurrent.atomic.AtomicReference<java.lang.String> < java.lang.String > java.util.concurrent.atomic.AtomicReference<java.lang.String> = new java.util.concurrent.atomic.AtomicReference<java.lang.String> < java.lang.String > ( ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . void ( ( ) { java.util.List<java.net.Socket> < java.net.Socket > java.util.List<java.net.Socket> = new java.util.ArrayList<java.net.Socket> < java.net.Socket > ( ) ; try { java.util.concurrent.CountDownLatch . void ( ) ; while ( ! java.util.concurrent.atomic.AtomicBoolean . boolean ( ) ) { java.net.Socket java.net.Socket = java.net.ServerSocket . java.net.Socket ( ) ; java.util.List<java.net.Socket> . boolean ( java.net.Socket ) ; while ( ! java.net.Socket . boolean ( ) ) { try { java.io.ObjectInputStream java.io.ObjectInputStream = new java.io.ObjectInputStream ( java.net.Socket . java.io.InputStream ( ) ) ; java.lang.String java.lang.String = ( java.lang.String ) java.io.ObjectInputStream . java.lang.Object ( ) ; logger . debug ( STRING + java.lang.String + STRING ) ; java.net.Socket . void ( ) ; java.util.concurrent.atomic.AtomicReference<java.lang.String> . void ( java.lang.String ) ; java.util.concurrent.CountDownLatch . void ( ) ; } catch ( java.io.IOException java.io.IOException ) { java.net.Socket . void ( ) ; } } } } catch ( java.lang.Exception java.lang.Exception ) { if ( ! java.util.concurrent.atomic.AtomicBoolean . boolean ( ) ) { java.lang.Exception . void ( ) ; } } for ( java.net.Socket java.net.Socket : java.util.List<java.net.Socket> ) { try { java.net.Socket . void ( ) ; } catch ( java.io.IOException java.io.IOException ) {				} } } ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; final TcpOutboundGateway org.springframework.integration.ip.tcp.TcpOutboundGateway = new TcpOutboundGateway ( ) ; org.springframework.integration.ip.tcp.TcpOutboundGateway . setConnectionFactory ( org.springframework.integration.ip.tcp.AbstractClientConnectionFactory ) ; org.springframework.integration.ip.tcp.TcpOutboundGateway . setRequestTimeout ( java.lang.Integer . int ) ; QueueChannel org.springframework.integration.ip.tcp.QueueChannel = new QueueChannel ( ) ; org.springframework.integration.ip.tcp.TcpOutboundGateway . setRequiresReply ( true ) ; org.springframework.integration.ip.tcp.TcpOutboundGateway . setOutputChannel ( org.springframework.integration.ip.tcp.QueueChannel ) ; org.springframework.integration.ip.tcp.TcpOutboundGateway . setRemoteTimeoutExpression ( new SpelExpressionParser ( ) . parseExpression ( STRING ) ) ; org.springframework.integration.ip.tcp.TcpOutboundGateway . setBeanFactory ( mock ( BeanFactory .class ) ) ; org.springframework.integration.ip.tcp.TcpOutboundGateway . afterPropertiesSet ( ) ; org.springframework.integration.ip.tcp.TcpOutboundGateway . start ( ) ; try { org.springframework.integration.ip.tcp.TcpOutboundGateway . handleMessage ( MessageBuilder . withPayload ( STRING ) . build ( ) ) ; fail ( STRING ) ; } catch ( java.lang.Exception java.lang.Exception ) { assertThat ( java.lang.Exception . java.lang.Throwable ( ) , instanceOf ( java.io.EOFException .class ) ) ; } assertEquals ( NUMBER , TestUtils . getPropertyValue ( org.springframework.integration.ip.tcp.TcpOutboundGateway , STRING , java.util.Map .class ) . size ( ) ) ; Message < ? > org.springframework.integration.ip.tcp.Message<?> = org.springframework.integration.ip.tcp.QueueChannel . receive ( NUMBER ) ; assertNull ( org.springframework.integration.ip.tcp.Message<> ) ; java.util.concurrent.atomic.AtomicBoolean . void ( true ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . getConnection ( ) ; org.springframework.integration.ip.tcp.TcpOutboundGateway . stop ( ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . stop ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.net.ServerSocket java.net.ServerSocket = javax.net.ServerSocketFactory . javax.net.ServerSocketFactory ( ) . java.net.ServerSocket ( NUMBER ) ; final int int = java.net.ServerSocket . int ( ) ; AbstractClientConnectionFactory org.springframework.integration.ip.tcp.AbstractClientConnectionFactory = new TcpNetClientConnectionFactory ( STRING , int ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . setSerializer ( new DefaultSerializer ( ) ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . setDeserializer ( new DefaultDeserializer ( ) ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . setSoTimeout ( NUMBER ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . setSingleUse ( false ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . start ( ) ; void ( int , org.springframework.integration.ip.tcp.AbstractClientConnectionFactory , java.net.ServerSocket ) ; java.net.ServerSocket . void ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.net.ServerSocket java.net.ServerSocket = javax.net.ServerSocketFactory . javax.net.ServerSocketFactory ( ) . java.net.ServerSocket ( NUMBER ) ; final int int = java.net.ServerSocket . int ( ) ; AbstractClientConnectionFactory org.springframework.integration.ip.tcp.AbstractClientConnectionFactory = new TcpNioClientConnectionFactory ( STRING , int ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . setSerializer ( new DefaultSerializer ( ) ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . setDeserializer ( new DefaultDeserializer ( ) ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . setSoTimeout ( NUMBER ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . setSingleUse ( false ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . start ( ) ; void ( int , org.springframework.integration.ip.tcp.AbstractClientConnectionFactory , java.net.ServerSocket ) ; java.net.ServerSocket . void ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.net.ServerSocket java.net.ServerSocket = javax.net.ServerSocketFactory . javax.net.ServerSocketFactory ( ) . java.net.ServerSocket ( NUMBER ) ; final int int = java.net.ServerSocket . int ( ) ; AbstractClientConnectionFactory org.springframework.integration.ip.tcp.AbstractClientConnectionFactory = new TcpNetClientConnectionFactory ( STRING , int ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . setSerializer ( new DefaultSerializer ( ) ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . setDeserializer ( new DefaultDeserializer ( ) ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . setSoTimeout ( NUMBER ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . setSingleUse ( true ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . start ( ) ; void ( int , org.springframework.integration.ip.tcp.AbstractClientConnectionFactory , java.net.ServerSocket ) ; java.net.ServerSocket . void ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.net.ServerSocket java.net.ServerSocket = javax.net.ServerSocketFactory . javax.net.ServerSocketFactory ( ) . java.net.ServerSocket ( NUMBER ) ; final int int = java.net.ServerSocket . int ( ) ; AbstractClientConnectionFactory org.springframework.integration.ip.tcp.AbstractClientConnectionFactory = new TcpNioClientConnectionFactory ( STRING , int ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . setSerializer ( new DefaultSerializer ( ) ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . setDeserializer ( new DefaultDeserializer ( ) ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . setSoTimeout ( NUMBER ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . setSingleUse ( true ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . start ( ) ; void ( int , org.springframework.integration.ip.tcp.AbstractClientConnectionFactory , java.net.ServerSocket ) ; java.net.ServerSocket . void ( ) ; }  <METHOD_END>
<METHOD_START> private void void ( final int int , AbstractClientConnectionFactory org.springframework.integration.ip.tcp.AbstractClientConnectionFactory , final java.net.ServerSocket java.net.ServerSocket ) throws java.lang.Exception { final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; final java.util.concurrent.atomic.AtomicBoolean java.util.concurrent.atomic.AtomicBoolean = new java.util.concurrent.atomic.AtomicBoolean ( ) ; java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . void ( ( ) { java.util.List<java.net.Socket> < java.net.Socket > java.util.List<java.net.Socket> = new java.util.ArrayList<java.net.Socket> < java.net.Socket > ( ) ; try { java.util.concurrent.CountDownLatch . void ( ) ; while ( ! java.util.concurrent.atomic.AtomicBoolean . boolean ( ) ) { java.util.List<java.net.Socket> . boolean ( java.net.ServerSocket . java.net.Socket ( ) ) ; } } catch ( java.lang.Exception java.lang.Exception ) { if ( ! java.util.concurrent.atomic.AtomicBoolean . boolean ( ) ) { java.lang.Exception . void ( ) ; } } for ( java.net.Socket java.net.Socket : java.util.List<java.net.Socket> ) { try { java.net.Socket . void ( ) ; } catch ( java.io.IOException java.io.IOException ) {				} } } ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; final TcpOutboundGateway org.springframework.integration.ip.tcp.TcpOutboundGateway = new TcpOutboundGateway ( ) ; org.springframework.integration.ip.tcp.TcpOutboundGateway . setConnectionFactory ( org.springframework.integration.ip.tcp.AbstractClientConnectionFactory ) ; org.springframework.integration.ip.tcp.TcpOutboundGateway . setRequestTimeout ( java.lang.Integer . int ) ; QueueChannel org.springframework.integration.ip.tcp.QueueChannel = new QueueChannel ( ) ; org.springframework.integration.ip.tcp.TcpOutboundGateway . setRequiresReply ( true ) ; org.springframework.integration.ip.tcp.TcpOutboundGateway . setOutputChannel ( org.springframework.integration.ip.tcp.QueueChannel ) ; org.springframework.integration.ip.tcp.TcpOutboundGateway . setRemoteTimeoutExpression ( new SpelExpressionParser ( ) . parseExpression ( STRING ) ) ; org.springframework.integration.ip.tcp.TcpOutboundGateway . setBeanFactory ( mock ( BeanFactory .class ) ) ; org.springframework.integration.ip.tcp.TcpOutboundGateway . afterPropertiesSet ( ) ; org.springframework.integration.ip.tcp.TcpOutboundGateway . start ( ) ; try { org.springframework.integration.ip.tcp.TcpOutboundGateway . handleMessage ( MessageBuilder . withPayload ( STRING ) . build ( ) ) ; fail ( STRING ) ; } catch ( java.lang.Exception java.lang.Exception ) { assertThat ( java.lang.Exception . java.lang.Throwable ( ) , instanceOf ( java.net.SocketTimeoutException .class ) ) ; } assertEquals ( NUMBER , TestUtils . getPropertyValue ( org.springframework.integration.ip.tcp.TcpOutboundGateway , STRING , java.util.Map .class ) . size ( ) ) ; Message < ? > org.springframework.integration.ip.tcp.Message<?> = org.springframework.integration.ip.tcp.QueueChannel . receive ( NUMBER ) ; assertNull ( org.springframework.integration.ip.tcp.Message<> ) ; java.util.concurrent.atomic.AtomicBoolean . void ( true ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . getConnection ( ) ; org.springframework.integration.ip.tcp.TcpOutboundGateway . stop ( ) ; org.springframework.integration.ip.tcp.AbstractClientConnectionFactory . stop ( ) ; }  <METHOD_END>
