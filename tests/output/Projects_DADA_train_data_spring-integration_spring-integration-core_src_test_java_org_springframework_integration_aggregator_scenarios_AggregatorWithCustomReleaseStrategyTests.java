<METHOD_START> @ java.lang.Override public org.springframework.integration.aggregator.scenarios.Statement org.springframework.integration.aggregator.scenarios.Statement ( Statement org.springframework.integration.aggregator.scenarios.Statement , Description org.springframework.integration.aggregator.scenarios.Description ) { if ( ! this . boolean ) { return new Statement ( ) { @ java.lang.Override public void void ( ) java.lang.Throwable { Assume . assumeTrue ( false ) ; } } ; } else { return super. apply ( org.springframework.integration.aggregator.scenarios.Statement , org.springframework.integration.aggregator.scenarios.Description ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ) java.lang.Throwable { Assume . assumeTrue ( false ) ; }  <METHOD_END>
<METHOD_START> @ AfterClass public static void void ( ) { java.util.concurrent.ExecutorService . java.util.List<java.lang.Runnable> ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { for ( int int = NUMBER ; int < NUMBER ; int ++ ) { this . void ( ) ; } for ( int int = NUMBER ; int < NUMBER ; int ++ ) { this . void ( ) ; } }  <METHOD_END>
<METHOD_START> public void void ( ) java.lang.Exception { AbstractApplicationContext org.springframework.integration.aggregator.scenarios.AbstractApplicationContext = new ClassPathXmlApplicationContext ( STRING , this . java.lang.Class<? extends org.springframework.integration.aggregator.scenarios.AggregatorWithCustomReleaseStrategyTests> ( ) ) ; final MessageChannel org.springframework.integration.aggregator.scenarios.MessageChannel = org.springframework.integration.aggregator.scenarios.AbstractApplicationContext . getBean ( STRING , MessageChannel .class ) ; QueueChannel org.springframework.integration.aggregator.scenarios.QueueChannel = org.springframework.integration.aggregator.scenarios.AbstractApplicationContext . getBean ( STRING , QueueChannel .class ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; for ( int int = NUMBER ; int < NUMBER ; int ++ ) { final int int = int ; java.util.concurrent.ExecutorService . void ( ( ) { org.springframework.integration.aggregator.scenarios.MessageChannel . send ( MessageBuilder . withPayload ( STRING ) . setHeader ( STRING , STRING + int ) . build ( ) ) ; java.util.concurrent.CountDownLatch . void ( ) ; } ) ; java.util.concurrent.ExecutorService . void ( ( ) { org.springframework.integration.aggregator.scenarios.MessageChannel . send ( MessageBuilder . withPayload ( STRING ) . setHeader ( STRING , STRING + int ) . build ( ) ) ; java.util.concurrent.CountDownLatch . void ( ) ; } ) ; java.util.concurrent.ExecutorService . void ( ( ) { org.springframework.integration.aggregator.scenarios.MessageChannel . send ( MessageBuilder . withPayload ( STRING ) . setHeader ( STRING , STRING + int ) . build ( ) ) ; java.util.concurrent.CountDownLatch . void ( ) ; } ) ; } assertTrue ( STRING + java.util.concurrent.CountDownLatch . long ( ) + STRING , java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; Message < ? > org.springframework.integration.aggregator.scenarios.Message<?> = org.springframework.integration.aggregator.scenarios.QueueChannel . receive ( NUMBER ) ; int int = NUMBER ; while ( org.springframework.integration.aggregator.scenarios.Message<> != null ) { int ++ ; org.springframework.integration.aggregator.scenarios.Message<?> = org.springframework.integration.aggregator.scenarios.QueueChannel . receive ( NUMBER ) ; } assertEquals ( NUMBER , int ) ; org.springframework.integration.aggregator.scenarios.AbstractApplicationContext . close ( ) ; }  <METHOD_END>
<METHOD_START> public void void ( ) java.lang.Exception { AbstractApplicationContext org.springframework.integration.aggregator.scenarios.AbstractApplicationContext = new ClassPathXmlApplicationContext ( STRING , this . java.lang.Class<? extends org.springframework.integration.aggregator.scenarios.AggregatorWithCustomReleaseStrategyTests> ( ) ) ; final MessageChannel org.springframework.integration.aggregator.scenarios.MessageChannel = org.springframework.integration.aggregator.scenarios.AbstractApplicationContext . getBean ( STRING , MessageChannel .class ) ; QueueChannel org.springframework.integration.aggregator.scenarios.QueueChannel = org.springframework.integration.aggregator.scenarios.AbstractApplicationContext . getBean ( STRING , QueueChannel .class ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; for ( int int = NUMBER ; int < NUMBER ; int ++ ) { java.util.concurrent.ExecutorService . void ( ( ) { org.springframework.integration.aggregator.scenarios.MessageChannel . send ( MessageBuilder . withPayload ( new java.lang.Integer [] { NUMBER , NUMBER , NUMBER , NUMBER , NUMBER , NUMBER , NUMBER , NUMBER } ) . build ( ) ) ; java.util.concurrent.CountDownLatch . void ( ) ; } ) ; java.util.concurrent.ExecutorService . void ( ( ) { org.springframework.integration.aggregator.scenarios.MessageChannel . send ( MessageBuilder . withPayload ( new java.lang.Integer [] { NUMBER , NUMBER , NUMBER , NUMBER , NUMBER , NUMBER , NUMBER , NUMBER } ) . build ( ) ) ; java.util.concurrent.CountDownLatch . void ( ) ; } ) ; java.util.concurrent.ExecutorService . void ( ( ) { org.springframework.integration.aggregator.scenarios.MessageChannel . send ( MessageBuilder . withPayload ( new java.lang.Integer [] { NUMBER , NUMBER , NUMBER , NUMBER , NUMBER , NUMBER , NUMBER , NUMBER } ) . build ( ) ) ; java.util.concurrent.CountDownLatch . void ( ) ; } ) ; } assertTrue ( STRING + java.util.concurrent.CountDownLatch . long ( ) + STRING , java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; Message < ? > org.springframework.integration.aggregator.scenarios.Message<?> = org.springframework.integration.aggregator.scenarios.QueueChannel . receive ( NUMBER ) ; int int = NUMBER ; while ( org.springframework.integration.aggregator.scenarios.Message<> != null && ++ int < NUMBER ) { org.springframework.integration.aggregator.scenarios.Message<?> = org.springframework.integration.aggregator.scenarios.QueueChannel . receive ( NUMBER ) ; } assertEquals ( NUMBER , int ) ; org.springframework.integration.aggregator.scenarios.AbstractApplicationContext . close ( ) ; }  <METHOD_END>
