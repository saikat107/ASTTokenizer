<METHOD_START> @ java.lang.SuppressWarnings ( STRING ) @ Before public void void ( ) java.lang.Exception { Mockito . reset ( java.util.List<java.lang.Exception> ) ; Mockito . reset ( org.springframework.integration.channel.MessageHandler ) ; Mockito . reset ( org.springframework.integration.channel.MessageHandler ) ; Mockito . reset ( org.springframework.integration.channel.MessageHandler ) ; org.springframework.integration.channel.ApplicationContext = new ClassPathXmlApplicationContext ( STRING , org.springframework.integration.channel.MixedDispatcherConfigurationScenarioTests .class ) ; java.util.concurrent.ExecutorService = org.springframework.integration.channel.ApplicationContext . getBean ( STRING , java.util.concurrent.ExecutorService .class ) ; java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( int ) ; java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; java.util.concurrent.atomic.AtomicBoolean = new java.util.concurrent.atomic.AtomicBoolean ( false ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { DirectChannel org.springframework.integration.channel.DirectChannel = ( DirectChannel ) org.springframework.integration.channel.ApplicationContext . getBean ( STRING ) ; doThrow ( new MessageRejectedException ( org.springframework.integration.channel.Message<> , null ) ) . when ( org.springframework.integration.channel.MessageHandler ) . handleMessage ( org.springframework.integration.channel.Message<> ) ; UnicastingDispatcher org.springframework.integration.channel.UnicastingDispatcher = org.springframework.integration.channel.DirectChannel . getDispatcher ( ) ; org.springframework.integration.channel.UnicastingDispatcher . addHandler ( org.springframework.integration.channel.MessageHandler ) ; org.springframework.integration.channel.UnicastingDispatcher . addHandler ( org.springframework.integration.channel.MessageHandler ) ; try { org.springframework.integration.channel.DirectChannel . send ( org.springframework.integration.channel.Message<> ) ; } catch ( java.lang.Exception java.lang.Exception ) { } try { org.springframework.integration.channel.DirectChannel . send ( org.springframework.integration.channel.Message<> ) ; } catch ( java.lang.Exception java.lang.Exception ) { } verify ( org.springframework.integration.channel.MessageHandler , times ( NUMBER ) ) . handleMessage ( org.springframework.integration.channel.Message<> ) ; verify ( org.springframework.integration.channel.MessageHandler , times ( NUMBER ) ) . handleMessage ( org.springframework.integration.channel.Message<> ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final DirectChannel org.springframework.integration.channel.DirectChannel = ( DirectChannel ) org.springframework.integration.channel.ApplicationContext . getBean ( STRING ) ; doThrow ( new MessageRejectedException ( org.springframework.integration.channel.Message<> , null ) ) . when ( org.springframework.integration.channel.MessageHandler ) . handleMessage ( org.springframework.integration.channel.Message<> ) ; UnicastingDispatcher org.springframework.integration.channel.UnicastingDispatcher = org.springframework.integration.channel.DirectChannel . getDispatcher ( ) ; org.springframework.integration.channel.UnicastingDispatcher . addHandler ( org.springframework.integration.channel.MessageHandler ) ; org.springframework.integration.channel.UnicastingDispatcher . addHandler ( org.springframework.integration.channel.MessageHandler ) ; java.lang.Runnable java.lang.Runnable = ( ) { try { java.util.concurrent.CountDownLatch . void ( ) ; } catch ( java.lang.InterruptedException java.lang.InterruptedException ) { java.lang.Thread . java.lang.Thread ( ) . void ( ) ; } boolean boolean = false ; try { boolean = org.springframework.integration.channel.DirectChannel . send ( org.springframework.integration.channel.Message<> ) ; } catch ( java.lang.Exception java.lang.Exception ) { java.util.List<java.lang.Exception> . boolean ( java.lang.Exception ) ; } if ( ! boolean ) { java.util.concurrent.atomic.AtomicBoolean . void ( true ) ; } java.util.concurrent.CountDownLatch . void ( ) ; } ; for ( int int = NUMBER ; int < int ; int ++ ) { java.util.concurrent.ExecutorService . void ( java.lang.Runnable ) ; } java.util.concurrent.CountDownLatch . void ( ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; java.util.concurrent.ExecutorService . void ( ) ; java.util.concurrent.ExecutorService . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ; assertTrue ( STRING , java.util.concurrent.atomic.AtomicBoolean . boolean ( ) ) ; verify ( org.springframework.integration.channel.MessageHandler , times ( int ) ) . handleMessage ( org.springframework.integration.channel.Message<> ) ; verify ( org.springframework.integration.channel.MessageHandler , times ( NUMBER ) ) . handleMessage ( org.springframework.integration.channel.Message<> ) ; verify ( java.util.List<java.lang.Exception> , times ( int ) ) . add ( any ( java.lang.Exception .class ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final ExecutorChannel org.springframework.integration.channel.ExecutorChannel = ( ExecutorChannel ) org.springframework.integration.channel.ApplicationContext . getBean ( STRING ) ; UnicastingDispatcher org.springframework.integration.channel.UnicastingDispatcher = org.springframework.integration.channel.ExecutorChannel . getDispatcher ( ) ; org.springframework.integration.channel.UnicastingDispatcher . addHandler ( org.springframework.integration.channel.MessageHandler ) ; org.springframework.integration.channel.UnicastingDispatcher . addHandler ( org.springframework.integration.channel.MessageHandler ) ; doAnswer ( invocation -> { RuntimeException e = new RuntimeException ( ) ; allDone . countDown ( ) ; failed . set ( true ) ; exceptionRegistry . add ( e ) ; throw e ; } ) . when ( org.springframework.integration.channel.MessageHandler ) . handleMessage ( org.springframework.integration.channel.Message<> ) ; java.lang.Runnable java.lang.Runnable = ( ) { try { java.util.concurrent.CountDownLatch . void ( ) ; } catch ( java.lang.InterruptedException java.lang.InterruptedException ) { java.lang.Thread . java.lang.Thread ( ) . void ( ) ; } org.springframework.integration.channel.ExecutorChannel . send ( org.springframework.integration.channel.Message<> ) ; } ; for ( int int = NUMBER ; int < int ; int ++ ) { java.util.concurrent.ExecutorService . void ( java.lang.Runnable ) ; } java.util.concurrent.CountDownLatch . void ( ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; java.util.concurrent.ExecutorService . void ( ) ; java.util.concurrent.ExecutorService . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ; assertTrue ( STRING , java.util.concurrent.atomic.AtomicBoolean . boolean ( ) ) ; verify ( org.springframework.integration.channel.MessageHandler , times ( int ) ) . handleMessage ( org.springframework.integration.channel.Message<> ) ; verify ( org.springframework.integration.channel.MessageHandler , times ( NUMBER ) ) . handleMessage ( org.springframework.integration.channel.Message<> ) ; verify ( java.util.List<java.lang.Exception> , times ( int ) ) . add ( any ( java.lang.Exception .class ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { DirectChannel org.springframework.integration.channel.DirectChannel = ( DirectChannel ) org.springframework.integration.channel.ApplicationContext . getBean ( STRING ) ; doThrow ( new MessageRejectedException ( org.springframework.integration.channel.Message<> , null ) ) . when ( org.springframework.integration.channel.MessageHandler ) . handleMessage ( org.springframework.integration.channel.Message<> ) ; UnicastingDispatcher org.springframework.integration.channel.UnicastingDispatcher = org.springframework.integration.channel.DirectChannel . getDispatcher ( ) ; org.springframework.integration.channel.UnicastingDispatcher . setLoadBalancingStrategy ( new RoundRobinLoadBalancingStrategy ( ) ) ; org.springframework.integration.channel.UnicastingDispatcher . addHandler ( org.springframework.integration.channel.MessageHandler ) ; org.springframework.integration.channel.UnicastingDispatcher . addHandler ( org.springframework.integration.channel.MessageHandler ) ; org.springframework.integration.channel.UnicastingDispatcher . addHandler ( org.springframework.integration.channel.MessageHandler ) ; InOrder org.springframework.integration.channel.InOrder = inOrder ( org.springframework.integration.channel.MessageHandler , org.springframework.integration.channel.MessageHandler , org.springframework.integration.channel.MessageHandler ) ; try { org.springframework.integration.channel.DirectChannel . send ( org.springframework.integration.channel.Message<> ) ; } catch ( java.lang.Exception java.lang.Exception ) { } org.springframework.integration.channel.InOrder . verify ( org.springframework.integration.channel.MessageHandler ) . handleMessage ( org.springframework.integration.channel.Message<> ) ; try { org.springframework.integration.channel.DirectChannel . send ( org.springframework.integration.channel.Message<> ) ; } catch ( java.lang.Exception java.lang.Exception ) { } org.springframework.integration.channel.InOrder . verify ( org.springframework.integration.channel.MessageHandler ) . handleMessage ( org.springframework.integration.channel.Message<> ) ; try { org.springframework.integration.channel.DirectChannel . send ( org.springframework.integration.channel.Message<> ) ; } catch ( java.lang.Exception java.lang.Exception ) { } org.springframework.integration.channel.InOrder . verify ( org.springframework.integration.channel.MessageHandler ) . handleMessage ( org.springframework.integration.channel.Message<> ) ; verify ( org.springframework.integration.channel.MessageHandler , times ( NUMBER ) ) . handleMessage ( org.springframework.integration.channel.Message<> ) ; verify ( org.springframework.integration.channel.MessageHandler , times ( NUMBER ) ) . handleMessage ( org.springframework.integration.channel.Message<> ) ; verify ( org.springframework.integration.channel.MessageHandler , times ( NUMBER ) ) . handleMessage ( org.springframework.integration.channel.Message<> ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final DirectChannel org.springframework.integration.channel.DirectChannel = ( DirectChannel ) org.springframework.integration.channel.ApplicationContext . getBean ( STRING ) ; doThrow ( new MessageRejectedException ( org.springframework.integration.channel.Message<> , null ) ) . when ( org.springframework.integration.channel.MessageHandler ) . handleMessage ( org.springframework.integration.channel.Message<> ) ; UnicastingDispatcher org.springframework.integration.channel.UnicastingDispatcher = org.springframework.integration.channel.DirectChannel . getDispatcher ( ) ; org.springframework.integration.channel.UnicastingDispatcher . addHandler ( org.springframework.integration.channel.MessageHandler ) ; org.springframework.integration.channel.UnicastingDispatcher . addHandler ( org.springframework.integration.channel.MessageHandler ) ; org.springframework.integration.channel.UnicastingDispatcher . addHandler ( org.springframework.integration.channel.MessageHandler ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( int ) ; final Message < ? > org.springframework.integration.channel.Message<?> = this . org.springframework.integration.channel.Message<> ; final java.util.concurrent.atomic.AtomicBoolean java.util.concurrent.atomic.AtomicBoolean = new java.util.concurrent.atomic.AtomicBoolean ( false ) ; java.lang.Runnable java.lang.Runnable = ( ) { try { java.util.concurrent.CountDownLatch . void ( ) ; } catch ( java.lang.InterruptedException java.lang.InterruptedException ) { java.lang.Thread . java.lang.Thread ( ) . void ( ) ; } boolean boolean = false ; try { boolean = org.springframework.integration.channel.DirectChannel . send ( org.springframework.integration.channel.Message<> ) ; } catch ( java.lang.Exception java.lang.Exception ) { java.util.List<java.lang.Exception> . boolean ( java.lang.Exception ) ; } if ( ! boolean ) { java.util.concurrent.atomic.AtomicBoolean . void ( true ) ; } java.util.concurrent.CountDownLatch . void ( ) ; } ; for ( int int = NUMBER ; int < int ; int ++ ) { java.util.concurrent.ExecutorService . void ( java.lang.Runnable ) ; } java.util.concurrent.CountDownLatch . void ( ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; java.util.concurrent.ExecutorService . void ( ) ; java.util.concurrent.ExecutorService . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ; assertTrue ( STRING , java.util.concurrent.atomic.AtomicBoolean . boolean ( ) ) ; verify ( org.springframework.integration.channel.MessageHandler , times ( NUMBER ) ) . handleMessage ( org.springframework.integration.channel.Message<> ) ; verify ( org.springframework.integration.channel.MessageHandler , times ( NUMBER ) ) . handleMessage ( org.springframework.integration.channel.Message<> ) ; verify ( org.springframework.integration.channel.MessageHandler , times ( NUMBER ) ) . handleMessage ( org.springframework.integration.channel.Message<> ) ; verify ( java.util.List<java.lang.Exception> , times ( NUMBER ) ) . add ( any ( java.lang.Exception .class ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final ExecutorChannel org.springframework.integration.channel.ExecutorChannel = ( ExecutorChannel ) org.springframework.integration.channel.ApplicationContext . getBean ( STRING ) ; UnicastingDispatcher org.springframework.integration.channel.UnicastingDispatcher = org.springframework.integration.channel.ExecutorChannel . getDispatcher ( ) ; org.springframework.integration.channel.UnicastingDispatcher . addHandler ( org.springframework.integration.channel.MessageHandler ) ; org.springframework.integration.channel.UnicastingDispatcher . addHandler ( org.springframework.integration.channel.MessageHandler ) ; org.springframework.integration.channel.UnicastingDispatcher . addHandler ( org.springframework.integration.channel.MessageHandler ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( int ) ; final Message < ? > org.springframework.integration.channel.Message<?> = this . org.springframework.integration.channel.Message<> ; final java.util.concurrent.atomic.AtomicBoolean java.util.concurrent.atomic.AtomicBoolean = new java.util.concurrent.atomic.AtomicBoolean ( false ) ; doAnswer ( invocation -> { failed . set ( true ) ; RuntimeException e = new RuntimeException ( ) ; exceptionRegistry . add ( e ) ; allDone . countDown ( ) ; throw e ; } ) . when ( org.springframework.integration.channel.MessageHandler ) . handleMessage ( org.springframework.integration.channel.Message<> ) ; doAnswer ( invocation -> { allDone . countDown ( ) ; return null ; } ) . when ( org.springframework.integration.channel.MessageHandler ) . handleMessage ( org.springframework.integration.channel.Message<> ) ; doAnswer ( invocation -> { allDone . countDown ( ) ; return null ; } ) . when ( org.springframework.integration.channel.MessageHandler ) . handleMessage ( org.springframework.integration.channel.Message<> ) ; java.lang.Runnable java.lang.Runnable = ( ) { try { java.util.concurrent.CountDownLatch . void ( ) ; } catch ( java.lang.InterruptedException java.lang.InterruptedException ) { java.lang.Thread . java.lang.Thread ( ) . void ( ) ; } org.springframework.integration.channel.ExecutorChannel . send ( org.springframework.integration.channel.Message<> ) ; } ; for ( int int = NUMBER ; int < int ; int ++ ) { java.util.concurrent.ExecutorService . void ( java.lang.Runnable ) ; } java.util.concurrent.CountDownLatch . void ( ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; java.util.concurrent.ExecutorService . void ( ) ; java.util.concurrent.ExecutorService . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ; assertTrue ( STRING , java.util.concurrent.atomic.AtomicBoolean . boolean ( ) ) ; verify ( org.springframework.integration.channel.MessageHandler , times ( NUMBER ) ) . handleMessage ( org.springframework.integration.channel.Message<> ) ; verify ( org.springframework.integration.channel.MessageHandler , times ( NUMBER ) ) . handleMessage ( org.springframework.integration.channel.Message<> ) ; verify ( org.springframework.integration.channel.MessageHandler , times ( NUMBER ) ) . handleMessage ( org.springframework.integration.channel.Message<> ) ; verify ( java.util.List<java.lang.Exception> , times ( NUMBER ) ) . add ( any ( java.lang.Exception .class ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { DirectChannel org.springframework.integration.channel.DirectChannel = ( DirectChannel ) org.springframework.integration.channel.ApplicationContext . getBean ( STRING ) ; doThrow ( new MessageRejectedException ( org.springframework.integration.channel.Message<> , null ) ) . when ( org.springframework.integration.channel.MessageHandler ) . handleMessage ( org.springframework.integration.channel.Message<> ) ; UnicastingDispatcher org.springframework.integration.channel.UnicastingDispatcher = org.springframework.integration.channel.DirectChannel . getDispatcher ( ) ; org.springframework.integration.channel.UnicastingDispatcher . addHandler ( org.springframework.integration.channel.MessageHandler ) ; org.springframework.integration.channel.UnicastingDispatcher . addHandler ( org.springframework.integration.channel.MessageHandler ) ; InOrder org.springframework.integration.channel.InOrder = inOrder ( org.springframework.integration.channel.MessageHandler , org.springframework.integration.channel.MessageHandler ) ; try { org.springframework.integration.channel.DirectChannel . send ( org.springframework.integration.channel.Message<> ) ; } catch ( java.lang.Exception java.lang.Exception ) { } org.springframework.integration.channel.InOrder . verify ( org.springframework.integration.channel.MessageHandler ) . handleMessage ( org.springframework.integration.channel.Message<> ) ; org.springframework.integration.channel.InOrder . verify ( org.springframework.integration.channel.MessageHandler ) . handleMessage ( org.springframework.integration.channel.Message<> ) ; try { org.springframework.integration.channel.DirectChannel . send ( org.springframework.integration.channel.Message<> ) ; } catch ( java.lang.Exception java.lang.Exception ) { } org.springframework.integration.channel.InOrder . verify ( org.springframework.integration.channel.MessageHandler ) . handleMessage ( org.springframework.integration.channel.Message<> ) ; org.springframework.integration.channel.InOrder . verify ( org.springframework.integration.channel.MessageHandler ) . handleMessage ( org.springframework.integration.channel.Message<> ) ; verify ( org.springframework.integration.channel.MessageHandler , times ( NUMBER ) ) . handleMessage ( org.springframework.integration.channel.Message<> ) ; verify ( org.springframework.integration.channel.MessageHandler , times ( NUMBER ) ) . handleMessage ( org.springframework.integration.channel.Message<> ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final DirectChannel org.springframework.integration.channel.DirectChannel = ( DirectChannel ) org.springframework.integration.channel.ApplicationContext . getBean ( STRING ) ; doThrow ( new MessageRejectedException ( org.springframework.integration.channel.Message<> , null ) ) . when ( org.springframework.integration.channel.MessageHandler ) . handleMessage ( org.springframework.integration.channel.Message<> ) ; UnicastingDispatcher org.springframework.integration.channel.UnicastingDispatcher = org.springframework.integration.channel.DirectChannel . getDispatcher ( ) ; org.springframework.integration.channel.UnicastingDispatcher . addHandler ( org.springframework.integration.channel.MessageHandler ) ; org.springframework.integration.channel.UnicastingDispatcher . addHandler ( org.springframework.integration.channel.MessageHandler ) ; org.springframework.integration.channel.UnicastingDispatcher . addHandler ( org.springframework.integration.channel.MessageHandler ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( int ) ; final Message < ? > org.springframework.integration.channel.Message<?> = this . org.springframework.integration.channel.Message<> ; final java.util.concurrent.atomic.AtomicBoolean java.util.concurrent.atomic.AtomicBoolean = new java.util.concurrent.atomic.AtomicBoolean ( false ) ; java.lang.Runnable java.lang.Runnable = ( ) { try { java.util.concurrent.CountDownLatch . void ( ) ; } catch ( java.lang.InterruptedException java.lang.InterruptedException ) { java.lang.Thread . java.lang.Thread ( ) . void ( ) ; } boolean boolean = false ; try { boolean = org.springframework.integration.channel.DirectChannel . send ( org.springframework.integration.channel.Message<> ) ; } catch ( java.lang.Exception java.lang.Exception ) { java.util.List<java.lang.Exception> . boolean ( java.lang.Exception ) ; } if ( ! boolean ) { java.util.concurrent.atomic.AtomicBoolean . void ( true ) ; } java.util.concurrent.CountDownLatch . void ( ) ; } ; for ( int int = NUMBER ; int < int ; int ++ ) { java.util.concurrent.ExecutorService . void ( java.lang.Runnable ) ; } java.util.concurrent.CountDownLatch . void ( ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; java.util.concurrent.ExecutorService . void ( ) ; java.util.concurrent.ExecutorService . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ; assertFalse ( STRING , java.util.concurrent.atomic.AtomicBoolean . boolean ( ) ) ; verify ( org.springframework.integration.channel.MessageHandler , times ( int ) ) . handleMessage ( org.springframework.integration.channel.Message<> ) ; verify ( org.springframework.integration.channel.MessageHandler , times ( int ) ) . handleMessage ( org.springframework.integration.channel.Message<> ) ; verify ( org.springframework.integration.channel.MessageHandler , never ( ) ) . handleMessage ( org.springframework.integration.channel.Message<> ) ; verify ( java.util.List<java.lang.Exception> , never ( ) ) . add ( any ( java.lang.Exception .class ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final ExecutorChannel org.springframework.integration.channel.ExecutorChannel = ( ExecutorChannel ) org.springframework.integration.channel.ApplicationContext . getBean ( STRING ) ; final UnicastingDispatcher org.springframework.integration.channel.UnicastingDispatcher = org.springframework.integration.channel.ExecutorChannel . getDispatcher ( ) ; org.springframework.integration.channel.UnicastingDispatcher . addHandler ( org.springframework.integration.channel.MessageHandler ) ; org.springframework.integration.channel.UnicastingDispatcher . addHandler ( org.springframework.integration.channel.MessageHandler ) ; org.springframework.integration.channel.UnicastingDispatcher . addHandler ( org.springframework.integration.channel.MessageHandler ) ; doAnswer ( invocation -> { RuntimeException e = new RuntimeException ( ) ; failed . set ( true ) ; throw e ; } ) . when ( org.springframework.integration.channel.MessageHandler ) . handleMessage ( org.springframework.integration.channel.Message<> ) ; doAnswer ( invocation -> { allDone . countDown ( ) ; return null ; } ) . when ( org.springframework.integration.channel.MessageHandler ) . handleMessage ( org.springframework.integration.channel.Message<> ) ; java.lang.Runnable java.lang.Runnable = ( ) { try { java.util.concurrent.CountDownLatch . void ( ) ; } catch ( java.lang.InterruptedException java.lang.InterruptedException ) { java.lang.Thread . java.lang.Thread ( ) . void ( ) ; } org.springframework.integration.channel.ExecutorChannel . send ( org.springframework.integration.channel.Message<> ) ; } ; for ( int int = NUMBER ; int < int ; int ++ ) { java.util.concurrent.ExecutorService . void ( java.lang.Runnable ) ; } java.util.concurrent.CountDownLatch . void ( ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; java.util.concurrent.ExecutorService . void ( ) ; java.util.concurrent.ExecutorService . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ; verify ( org.springframework.integration.channel.MessageHandler , times ( int ) ) . handleMessage ( org.springframework.integration.channel.Message<> ) ; verify ( org.springframework.integration.channel.MessageHandler , times ( int ) ) . handleMessage ( org.springframework.integration.channel.Message<> ) ; verify ( org.springframework.integration.channel.MessageHandler , never ( ) ) . handleMessage ( org.springframework.integration.channel.Message<> ) ; }  <METHOD_END>
