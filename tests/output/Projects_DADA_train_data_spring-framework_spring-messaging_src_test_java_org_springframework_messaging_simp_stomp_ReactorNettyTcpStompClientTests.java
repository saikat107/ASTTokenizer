<METHOD_START> @ Before public void void ( ) java.lang.Exception { org.springframework.messaging.simp.stomp.Log . debug ( STRING + this . org.springframework.messaging.simp.stomp.TestName . getMethodName ( ) + STRING ) ; int int = SocketUtils . findAvailableTcpPort ( NUMBER ) ; this . org.springframework.messaging.simp.stomp.BrokerService = new BrokerService ( ) ; this . org.springframework.messaging.simp.stomp.BrokerService . addConnector ( STRING + int ) ; this . org.springframework.messaging.simp.stomp.BrokerService . setStartAsync ( false ) ; this . org.springframework.messaging.simp.stomp.BrokerService . setPersistent ( false ) ; this . org.springframework.messaging.simp.stomp.BrokerService . setUseJmx ( false ) ; this . org.springframework.messaging.simp.stomp.BrokerService . getSystemUsage ( ) . getMemoryUsage ( ) . setLimit ( NUMBER * NUMBER * NUMBER ) ; this . org.springframework.messaging.simp.stomp.BrokerService . getSystemUsage ( ) . getTempUsage ( ) . setLimit ( NUMBER * NUMBER * NUMBER ) ; this . org.springframework.messaging.simp.stomp.BrokerService . start ( ) ; ThreadPoolTaskScheduler org.springframework.messaging.simp.stomp.ThreadPoolTaskScheduler = new ThreadPoolTaskScheduler ( ) ; org.springframework.messaging.simp.stomp.ThreadPoolTaskScheduler . afterPropertiesSet ( ) ; this . org.springframework.messaging.simp.stomp.ReactorNettyTcpStompClient = new ReactorNettyTcpStompClient ( STRING , int ) ; this . org.springframework.messaging.simp.stomp.ReactorNettyTcpStompClient . setMessageConverter ( new StringMessageConverter ( ) ) ; this . org.springframework.messaging.simp.stomp.ReactorNettyTcpStompClient . setTaskScheduler ( org.springframework.messaging.simp.stomp.ThreadPoolTaskScheduler ) ; }  <METHOD_END>
<METHOD_START> @ After public void void ( ) java.lang.Exception { try { this . org.springframework.messaging.simp.stomp.ReactorNettyTcpStompClient . shutdown ( ) ; } catch ( java.lang.Throwable java.lang.Throwable ) { org.springframework.messaging.simp.stomp.Log . error ( STRING , java.lang.Throwable ) ; } final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; this . org.springframework.messaging.simp.stomp.BrokerService . addShutdownHook ( java.util.concurrent.CountDownLatch :: void ) ; org.springframework.messaging.simp.stomp.Log . debug ( STRING ) ; this . org.springframework.messaging.simp.stomp.BrokerService . stop ( ) ; if ( ! java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) { org.springframework.messaging.simp.stomp.Log . debug ( STRING ) ; } }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.lang.String java.lang.String = STRING ; org.springframework.messaging.simp.stomp.ReactorNettyTcpStompClientTests.ConsumingHandler org.springframework.messaging.simp.stomp.ReactorNettyTcpStompClientTests.ConsumingHandler = new org.springframework.messaging.simp.stomp.ReactorNettyTcpStompClientTests.ConsumingHandler ( java.lang.String ) ; ListenableFuture < StompSession > org.springframework.messaging.simp.stomp.ListenableFuture<org.springframework.messaging.simp.stomp.StompSession> = this . org.springframework.messaging.simp.stomp.ReactorNettyTcpStompClient . connect ( org.springframework.messaging.simp.stomp.ReactorNettyTcpStompClientTests.ConsumingHandler ) ; org.springframework.messaging.simp.stomp.ReactorNettyTcpStompClientTests.ConsumingHandler org.springframework.messaging.simp.stomp.ReactorNettyTcpStompClientTests.ConsumingHandler = new org.springframework.messaging.simp.stomp.ReactorNettyTcpStompClientTests.ConsumingHandler ( java.lang.String ) ; ListenableFuture < StompSession > org.springframework.messaging.simp.stomp.ListenableFuture<org.springframework.messaging.simp.stomp.StompSession> = this . org.springframework.messaging.simp.stomp.ReactorNettyTcpStompClient . connect ( org.springframework.messaging.simp.stomp.ReactorNettyTcpStompClientTests.ConsumingHandler ) ; assertTrue ( org.springframework.messaging.simp.stomp.ReactorNettyTcpStompClientTests.ConsumingHandler . boolean ( NUMBER ) ) ; assertTrue ( org.springframework.messaging.simp.stomp.ReactorNettyTcpStompClientTests.ConsumingHandler . boolean ( NUMBER ) ) ; org.springframework.messaging.simp.stomp.ReactorNettyTcpStompClientTests.ProducingHandler org.springframework.messaging.simp.stomp.ReactorNettyTcpStompClientTests.ProducingHandler = new org.springframework.messaging.simp.stomp.ReactorNettyTcpStompClientTests.ProducingHandler ( ) ; org.springframework.messaging.simp.stomp.ReactorNettyTcpStompClientTests.ProducingHandler . org.springframework.messaging.simp.stomp.ReactorNettyTcpStompClientTests.ProducingHandler ( java.lang.String , STRING ) ; org.springframework.messaging.simp.stomp.ReactorNettyTcpStompClientTests.ProducingHandler . org.springframework.messaging.simp.stomp.ReactorNettyTcpStompClientTests.ProducingHandler ( java.lang.String , STRING ) ; ListenableFuture < StompSession > org.springframework.messaging.simp.stomp.ListenableFuture<org.springframework.messaging.simp.stomp.StompSession> = this . org.springframework.messaging.simp.stomp.ReactorNettyTcpStompClient . connect ( org.springframework.messaging.simp.stomp.ReactorNettyTcpStompClientTests.ProducingHandler ) ; assertTrue ( org.springframework.messaging.simp.stomp.ReactorNettyTcpStompClientTests.ConsumingHandler . boolean ( NUMBER , NUMBER ) ) ; assertThat ( org.springframework.messaging.simp.stomp.ReactorNettyTcpStompClientTests.ConsumingHandler . java.util.List<java.lang.String> ( ) , containsInAnyOrder ( STRING , STRING ) ) ; assertTrue ( org.springframework.messaging.simp.stomp.ReactorNettyTcpStompClientTests.ConsumingHandler . boolean ( NUMBER , NUMBER ) ) ; assertThat ( org.springframework.messaging.simp.stomp.ReactorNettyTcpStompClientTests.ConsumingHandler . java.util.List<java.lang.String> ( ) , containsInAnyOrder ( STRING , STRING ) ) ; org.springframework.messaging.simp.stomp.ListenableFuture<org.springframework.messaging.simp.stomp.StompSession> . get ( ) . disconnect ( ) ; org.springframework.messaging.simp.stomp.ListenableFuture<org.springframework.messaging.simp.stomp.StompSession> . get ( ) . disconnect ( ) ; org.springframework.messaging.simp.stomp.ListenableFuture<org.springframework.messaging.simp.stomp.StompSession> . get ( ) . disconnect ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( StompSession org.springframework.messaging.simp.stomp.StompSession , StompCommand org.springframework.messaging.simp.stomp.StompCommand , StompHeaders org.springframework.messaging.simp.stomp.StompHeaders , byte [] byte[] , java.lang.Throwable java.lang.Throwable ) { org.springframework.messaging.simp.stomp.Log . error ( org.springframework.messaging.simp.stomp.StompCommand + STRING + org.springframework.messaging.simp.stomp.StompHeaders , java.lang.Throwable ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( StompHeaders org.springframework.messaging.simp.stomp.StompHeaders , java.lang.Object java.lang.Object ) { org.springframework.messaging.simp.stomp.Log . error ( STRING + org.springframework.messaging.simp.stomp.StompHeaders + STRING + java.lang.Object ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( StompSession org.springframework.messaging.simp.stomp.StompSession , java.lang.Throwable java.lang.Throwable ) { org.springframework.messaging.simp.stomp.Log . error ( java.lang.Throwable ) ; }  <METHOD_END>
<METHOD_START> public void ( java.lang.String ... java.lang.String[] ) { Assert . notEmpty ( java.lang.String[] , STRING ) ; this . java.util.List<java.lang.String> = java.util.Arrays . java.util.List<java.lang.String> ( java.lang.String[] ) ; this . java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( this . java.util.List<java.lang.String> . int ( ) ) ; }  <METHOD_END>
<METHOD_START> public java.util.List<java.lang.String> < java.lang.String > java.util.List<java.lang.String> ( ) { return this . java.util.List<java.lang.String> ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( StompSession org.springframework.messaging.simp.stomp.StompSession , StompHeaders org.springframework.messaging.simp.stomp.StompHeaders ) { for ( java.lang.String java.lang.String : this . java.util.List<java.lang.String> ) { org.springframework.messaging.simp.stomp.StompSession . setAutoReceipt ( true ) ; Subscription org.springframework.messaging.simp.stomp.Subscription = org.springframework.messaging.simp.stomp.StompSession . subscribe ( java.lang.String , new StompFrameHandler ( ) { @ java.lang.Override public java.lang.reflect.Type java.lang.reflect.Type ( StompHeaders org.springframework.messaging.simp.stomp.StompHeaders ) { return java.lang.String .class ; } @ java.lang.Override public void void ( StompHeaders org.springframework.messaging.simp.stomp.StompHeaders , java.lang.Object java.lang.Object ) { java.util.List<java.lang.String> . boolean ( ( java.lang.String ) java.lang.Object ) ; } } ) ; org.springframework.messaging.simp.stomp.Subscription . addReceiptTask ( java.util.concurrent.CountDownLatch :: void ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.reflect.Type java.lang.reflect.Type ( StompHeaders org.springframework.messaging.simp.stomp.StompHeaders ) { return java.lang.String .class ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( StompHeaders org.springframework.messaging.simp.stomp.StompHeaders , java.lang.Object java.lang.Object ) { java.util.List<java.lang.String> . boolean ( ( java.lang.String ) java.lang.Object ) ; }  <METHOD_END>
<METHOD_START> public boolean boolean ( long long ) throws java.lang.InterruptedException { if ( org.springframework.messaging.simp.stomp.Log . isDebugEnabled ( ) ) { org.springframework.messaging.simp.stomp.Log . debug ( STRING ) ; } return this . java.util.concurrent.CountDownLatch . boolean ( long , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ; }  <METHOD_END>
<METHOD_START> public boolean boolean ( int int , long long ) throws java.lang.InterruptedException { if ( org.springframework.messaging.simp.stomp.Log . isDebugEnabled ( ) ) { org.springframework.messaging.simp.stomp.Log . debug ( STRING + int ) ; } long long = java.lang.System . long ( ) ; while ( this . java.util.List<java.lang.String> . int ( ) < int ) { java.lang.Thread . void ( NUMBER ) ; if ( ( java.lang.System . long ( ) - long ) > long ) { return false ; } } return true ; }  <METHOD_END>
<METHOD_START> public org.springframework.messaging.simp.stomp.ReactorNettyTcpStompClientTests.ProducingHandler org.springframework.messaging.simp.stomp.ReactorNettyTcpStompClientTests.ProducingHandler ( java.lang.String java.lang.String , java.lang.Object java.lang.Object ) { this . java.util.List<java.lang.String> . boolean ( java.lang.String ) ; this . java.util.List<java.lang.Object> . boolean ( java.lang.Object ) ; return this ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( StompSession org.springframework.messaging.simp.stomp.StompSession , StompHeaders org.springframework.messaging.simp.stomp.StompHeaders ) { for ( int int = NUMBER ; int < this . java.util.List<java.lang.String> . int ( ) ; int ++ ) { org.springframework.messaging.simp.stomp.StompSession . send ( this . java.util.List<java.lang.String> . java.lang.String ( int ) , this . java.util.List<java.lang.Object> . java.lang.Object ( int ) ) ; } }  <METHOD_END>
