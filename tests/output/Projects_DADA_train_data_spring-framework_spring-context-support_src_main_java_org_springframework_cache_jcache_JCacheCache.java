<METHOD_START> public JCacheCache ( javax . javax.cache . javax.cache < java.lang.Object , java.lang.Object > jcache ) { this( jcache , true ); }  <METHOD_END>
<METHOD_START> public JCacheCache ( javax . javax.cache . javax.cache < java.lang.Object , java.lang.Object > jcache , boolean boolean ) { super( boolean ); Assert . notNull ( jcache , STRING ) ; this . cache = jcache ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public final java.lang.String java.lang.String ( ) { return this . cache . getName ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public final javax . javax.cache . javax.cache < java.lang.Object , java.lang.Object > getNativeCache ( ) { return this . cache ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected java.lang.Object java.lang.Object ( java.lang.Object java.lang.Object ) { return this . cache . get ( java.lang.Object ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public < T > T T ( java.lang.Object java.lang.Object , java.util.concurrent.Callable<T> < T > java.util.concurrent.Callable<T> ) { try { return this . cache . invoke ( java.lang.Object , new org.springframework.cache.jcache.JCacheCache.ValueLoaderEntryProcessor<T> < T > ( ) , java.util.concurrent.Callable<T> ) ; } catch ( EntryProcessorException org.springframework.cache.jcache.EntryProcessorException ) { throw new ValueRetrievalException ( java.lang.Object , java.util.concurrent.Callable<T> , org.springframework.cache.jcache.EntryProcessorException . getCause ( ) ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( java.lang.Object java.lang.Object , java.lang.Object java.lang.Object ) { this . cache . put ( java.lang.Object , toStoreValue ( java.lang.Object ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.cache.jcache.ValueWrapper org.springframework.cache.jcache.ValueWrapper ( java.lang.Object java.lang.Object , java.lang.Object java.lang.Object ) { boolean boolean = this . cache . putIfAbsent ( java.lang.Object , toStoreValue ( java.lang.Object ) ) ; return ( boolean ? null : T ( java.lang.Object ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( java.lang.Object java.lang.Object ) { this . cache . remove ( java.lang.Object ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ) { this . cache . removeAll ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.SuppressWarnings ( STRING ) @ java.lang.Override public T T ( MutableEntry < java.lang.Object , java.lang.Object > org.springframework.cache.jcache.MutableEntry<java.lang.Object,java.lang.Object> , java.lang.Object ... java.lang.Object[] )				throws org.springframework.cache.jcache.EntryProcessorException { java.util.concurrent.Callable<T> < T > java.util.concurrent.Callable<T> = ( java.util.concurrent.Callable<T> < T > ) java.lang.Object[] [ NUMBER ] ; if ( org.springframework.cache.jcache.MutableEntry<java.lang.Object,java.lang.Object> . exists ( ) ) { return ( T ) fromStoreValue ( org.springframework.cache.jcache.MutableEntry<java.lang.Object,java.lang.Object> . getValue ( ) ) ; } else { T T ; try { T = java.util.concurrent.Callable<T> . T ( ) ; } catch ( java.lang.Exception java.lang.Exception ) { throw new EntryProcessorException ( STRING + java.util.concurrent.Callable<T> + STRING + STRING + org.springframework.cache.jcache.MutableEntry<java.lang.Object,java.lang.Object> . getKey ( ) + STRING , java.lang.Exception ) ; } org.springframework.cache.jcache.MutableEntry<java.lang.Object,java.lang.Object> . setValue ( toStoreValue ( T ) ) ; return T ; } }  <METHOD_END>
