<METHOD_START> @ Before public void void ( ) java.lang.Exception { java.sql.Connection = mock ( java.sql.Connection .class ) ; javax.sql.DataSource = mock ( javax.sql.DataSource .class ) ; org.springframework.jdbc.datasource.UserTransaction = mock ( UserTransaction .class ) ; org.springframework.jdbc.datasource.TransactionManager = mock ( TransactionManager .class ) ; org.springframework.jdbc.datasource.Transaction = mock ( Transaction .class ) ; given ( javax.sql.DataSource . java.sql.Connection ( ) ) . willReturn ( java.sql.Connection ) ; }  <METHOD_END>
<METHOD_START> @ After public void void ( ) { assertTrue ( TransactionSynchronizationManager . getResourceMap ( ) . isEmpty ( ) ) ; assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertNull ( TransactionSynchronizationManager . getCurrentTransactionName ( ) ) ; assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly ( ) ) ; assertNull ( TransactionSynchronizationManager . getCurrentTransactionIsolationLevel ( ) ) ; assertFalse ( TransactionSynchronizationManager . isActualTransactionActive ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { void ( false ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { void ( true ) ; }  <METHOD_END>
<METHOD_START> private void void ( final boolean boolean ) throws java.lang.Exception { if ( boolean ) { given ( org.springframework.jdbc.datasource.UserTransaction . getStatus ( ) ) . willReturn ( Status . STATUS_NO_TRANSACTION , Status . STATUS_ACTIVE ) ; } else { given ( org.springframework.jdbc.datasource.UserTransaction . getStatus ( ) ) . willReturn ( Status . STATUS_NO_TRANSACTION , Status . STATUS_ACTIVE , Status . STATUS_ACTIVE ) ; } JtaTransactionManager org.springframework.jdbc.datasource.JtaTransactionManager = new JtaTransactionManager ( org.springframework.jdbc.datasource.UserTransaction ) ; TransactionTemplate org.springframework.jdbc.datasource.TransactionTemplate = new TransactionTemplate ( org.springframework.jdbc.datasource.JtaTransactionManager ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; java.sql.Connection java.sql.Connection = DataSourceUtils . getConnection ( javax.sql.DataSource ) ; assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; DataSourceUtils . releaseConnection ( java.sql.Connection , javax.sql.DataSource ) ; java.sql.Connection = DataSourceUtils . getConnection ( javax.sql.DataSource ) ; assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; DataSourceUtils . releaseConnection ( java.sql.Connection , javax.sql.DataSource ) ; if ( boolean ) { org.springframework.jdbc.datasource.TransactionStatus . setRollbackOnly ( ) ; } } } ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; verify ( org.springframework.jdbc.datasource.UserTransaction ) . begin ( ) ; if ( boolean ) { verify ( org.springframework.jdbc.datasource.UserTransaction ) . rollback ( ) ; } verify ( java.sql.Connection ) . close ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; java.sql.Connection java.sql.Connection = DataSourceUtils . getConnection ( javax.sql.DataSource ) ; assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; DataSourceUtils . releaseConnection ( java.sql.Connection , javax.sql.DataSource ) ; java.sql.Connection = DataSourceUtils . getConnection ( javax.sql.DataSource ) ; assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; DataSourceUtils . releaseConnection ( java.sql.Connection , javax.sql.DataSource ) ; if ( boolean ) { org.springframework.jdbc.datasource.TransactionStatus . setRollbackOnly ( ) ; } }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { void ( false , false , false , false ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { void ( false , false , true , false ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { void ( false , true , false , false ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { void ( false , true , true , false ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { void ( false , false , true , true ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { void ( true , false , false , false ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { void ( true , false , true , false ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { void ( true , true , false , false ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { void ( true , true , true , false ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { void ( true , false , true , true ) ; }  <METHOD_END>
<METHOD_START> private void void ( final boolean boolean , final boolean boolean , final boolean boolean , final boolean boolean ) throws java.lang.Exception { given ( org.springframework.jdbc.datasource.TransactionManager . suspend ( ) ) . willReturn ( org.springframework.jdbc.datasource.Transaction ) ; if ( boolean ) { given ( org.springframework.jdbc.datasource.UserTransaction . getStatus ( ) ) . willReturn ( Status . STATUS_NO_TRANSACTION , Status . STATUS_ACTIVE ) ; } else { given ( org.springframework.jdbc.datasource.UserTransaction . getStatus ( ) ) . willReturn ( Status . STATUS_NO_TRANSACTION , Status . STATUS_ACTIVE , Status . STATUS_ACTIVE ) ; } given ( java.sql.Connection . boolean ( ) ) . willReturn ( true ) ; final javax.sql.DataSource javax.sql.DataSource = boolean ? new TransactionAwareDataSourceProxy ( javax.sql.DataSource ) : javax.sql.DataSource ; JtaTransactionManager org.springframework.jdbc.datasource.JtaTransactionManager = new JtaTransactionManager ( org.springframework.jdbc.datasource.UserTransaction , org.springframework.jdbc.datasource.TransactionManager ) ; final TransactionTemplate org.springframework.jdbc.datasource.TransactionTemplate = new TransactionTemplate ( org.springframework.jdbc.datasource.JtaTransactionManager ) ; org.springframework.jdbc.datasource.TransactionTemplate . setPropagationBehavior ( TransactionDefinition . PROPAGATION_REQUIRES_NEW ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; java.sql.Connection java.sql.Connection = DataSourceUtils . getConnection ( javax.sql.DataSource ) ; try { assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; java.sql.Connection . boolean ( ) ; DataSourceUtils . releaseConnection ( java.sql.Connection , javax.sql.DataSource ) ; java.sql.Connection = DataSourceUtils . getConnection ( javax.sql.DataSource ) ; assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; if ( ! boolean ) { DataSourceUtils . releaseConnection ( java.sql.Connection , javax.sql.DataSource ) ; } } catch ( java.sql.SQLException java.sql.SQLException ) {				} for ( int int = NUMBER ; int < NUMBER ; int ++ ) { org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; try { java.sql.Connection java.sql.Connection = DataSourceUtils . getConnection ( javax.sql.DataSource ) ; java.sql.Connection . boolean ( ) ; assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; DataSourceUtils . releaseConnection ( java.sql.Connection , javax.sql.DataSource ) ; java.sql.Connection = DataSourceUtils . getConnection ( javax.sql.DataSource ) ; assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; DataSourceUtils . releaseConnection ( java.sql.Connection , javax.sql.DataSource ) ; } catch ( java.sql.SQLException java.sql.SQLException ) {							} } } ) ; } if ( boolean ) { org.springframework.jdbc.datasource.TransactionStatus . setRollbackOnly ( ) ; } if ( boolean ) { try { if ( ! boolean ) { java.sql.Connection = DataSourceUtils . getConnection ( javax.sql.DataSource ) ; } assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; java.sql.Connection . boolean ( ) ; DataSourceUtils . releaseConnection ( java.sql.Connection , javax.sql.DataSource ) ; java.sql.Connection = DataSourceUtils . getConnection ( javax.sql.DataSource ) ; assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; DataSourceUtils . releaseConnection ( java.sql.Connection , javax.sql.DataSource ) ; } catch ( java.sql.SQLException java.sql.SQLException ) {					} } else { if ( boolean ) { DataSourceUtils . releaseConnection ( java.sql.Connection , javax.sql.DataSource ) ; } } } } ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; verify ( org.springframework.jdbc.datasource.UserTransaction , times ( NUMBER ) ) . begin ( ) ; verify ( org.springframework.jdbc.datasource.TransactionManager , times ( NUMBER ) ) . resume ( org.springframework.jdbc.datasource.Transaction ) ; if ( boolean ) { verify ( org.springframework.jdbc.datasource.UserTransaction , times ( NUMBER ) ) . commit ( ) ; verify ( org.springframework.jdbc.datasource.UserTransaction ) . rollback ( ) ; } else { verify ( org.springframework.jdbc.datasource.UserTransaction , times ( NUMBER ) ) . commit ( ) ; } if ( boolean && ! boolean ) { verify ( java.sql.Connection , times ( NUMBER ) ) . close ( ) ; } else { verify ( java.sql.Connection , times ( NUMBER ) ) . close ( ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; java.sql.Connection java.sql.Connection = DataSourceUtils . getConnection ( javax.sql.DataSource ) ; try { assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; java.sql.Connection . boolean ( ) ; DataSourceUtils . releaseConnection ( java.sql.Connection , javax.sql.DataSource ) ; java.sql.Connection = DataSourceUtils . getConnection ( javax.sql.DataSource ) ; assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; if ( ! boolean ) { DataSourceUtils . releaseConnection ( java.sql.Connection , javax.sql.DataSource ) ; } } catch ( java.sql.SQLException java.sql.SQLException ) {				} for ( int int = NUMBER ; int < NUMBER ; int ++ ) { org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; try { java.sql.Connection java.sql.Connection = DataSourceUtils . getConnection ( javax.sql.DataSource ) ; java.sql.Connection . boolean ( ) ; assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; DataSourceUtils . releaseConnection ( java.sql.Connection , javax.sql.DataSource ) ; java.sql.Connection = DataSourceUtils . getConnection ( javax.sql.DataSource ) ; assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; DataSourceUtils . releaseConnection ( java.sql.Connection , javax.sql.DataSource ) ; } catch ( java.sql.SQLException java.sql.SQLException ) {							} } } ) ; } if ( boolean ) { org.springframework.jdbc.datasource.TransactionStatus . setRollbackOnly ( ) ; } if ( boolean ) { try { if ( ! boolean ) { java.sql.Connection = DataSourceUtils . getConnection ( javax.sql.DataSource ) ; } assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; java.sql.Connection . boolean ( ) ; DataSourceUtils . releaseConnection ( java.sql.Connection , javax.sql.DataSource ) ; java.sql.Connection = DataSourceUtils . getConnection ( javax.sql.DataSource ) ; assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; DataSourceUtils . releaseConnection ( java.sql.Connection , javax.sql.DataSource ) ; } catch ( java.sql.SQLException java.sql.SQLException ) {					} } else { if ( boolean ) { DataSourceUtils . releaseConnection ( java.sql.Connection , javax.sql.DataSource ) ; } } }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; try { java.sql.Connection java.sql.Connection = DataSourceUtils . getConnection ( javax.sql.DataSource ) ; java.sql.Connection . boolean ( ) ; assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; DataSourceUtils . releaseConnection ( java.sql.Connection , javax.sql.DataSource ) ; java.sql.Connection = DataSourceUtils . getConnection ( javax.sql.DataSource ) ; assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; DataSourceUtils . releaseConnection ( java.sql.Connection , javax.sql.DataSource ) ; } catch ( java.sql.SQLException java.sql.SQLException ) {							} }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { void ( false , false ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { void ( false , true ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { void ( true , false ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { void ( true , true ) ; }  <METHOD_END>
<METHOD_START> private void void ( final boolean boolean , boolean boolean ) throws java.lang.Exception { if ( boolean ) { given ( org.springframework.jdbc.datasource.UserTransaction . getStatus ( ) ) . willReturn ( Status . STATUS_ACTIVE , Status . STATUS_NO_TRANSACTION , Status . STATUS_ACTIVE , Status . STATUS_ACTIVE ) ; given ( org.springframework.jdbc.datasource.TransactionManager . suspend ( ) ) . willReturn ( org.springframework.jdbc.datasource.Transaction ) ; } else { given ( org.springframework.jdbc.datasource.UserTransaction . getStatus ( ) ) . willReturn ( Status . STATUS_NO_TRANSACTION , Status . STATUS_NO_TRANSACTION , Status . STATUS_ACTIVE , Status . STATUS_ACTIVE ) ; } final javax.sql.DataSource javax.sql.DataSource = mock ( javax.sql.DataSource .class ) ; final java.sql.Connection java.sql.Connection = mock ( java.sql.Connection .class ) ; final java.sql.Connection java.sql.Connection = mock ( java.sql.Connection .class ) ; given ( javax.sql.DataSource . java.sql.Connection ( ) ) . willReturn ( java.sql.Connection , java.sql.Connection ) ; final JtaTransactionManager org.springframework.jdbc.datasource.JtaTransactionManager = new JtaTransactionManager ( org.springframework.jdbc.datasource.UserTransaction , org.springframework.jdbc.datasource.TransactionManager ) ; TransactionTemplate org.springframework.jdbc.datasource.TransactionTemplate = new TransactionTemplate ( org.springframework.jdbc.datasource.JtaTransactionManager ) ; org.springframework.jdbc.datasource.TransactionTemplate . setPropagationBehavior ( boolean ? TransactionDefinition . PROPAGATION_NOT_SUPPORTED : TransactionDefinition . PROPAGATION_SUPPORTS ) ; assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) { assertTrue ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly ( ) ) ; assertFalse ( TransactionSynchronizationManager . isActualTransactionActive ( ) ) ; assertSame ( java.sql.Connection , DataSourceUtils . getConnection ( javax.sql.DataSource ) ) ; assertSame ( java.sql.Connection , DataSourceUtils . getConnection ( javax.sql.DataSource ) ) ; TransactionTemplate org.springframework.jdbc.datasource.TransactionTemplate = new TransactionTemplate ( org.springframework.jdbc.datasource.JtaTransactionManager ) ; org.springframework.jdbc.datasource.TransactionTemplate . setPropagationBehavior ( boolean ? TransactionDefinition . PROPAGATION_REQUIRES_NEW : TransactionDefinition . PROPAGATION_REQUIRED ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) { assertTrue ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly ( ) ) ; assertTrue ( TransactionSynchronizationManager . isActualTransactionActive ( ) ) ; assertSame ( java.sql.Connection , DataSourceUtils . getConnection ( javax.sql.DataSource ) ) ; assertSame ( java.sql.Connection , DataSourceUtils . getConnection ( javax.sql.DataSource ) ) ; } } ) ; assertTrue ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly ( ) ) ; assertFalse ( TransactionSynchronizationManager . isActualTransactionActive ( ) ) ; assertSame ( java.sql.Connection , DataSourceUtils . getConnection ( javax.sql.DataSource ) ) ; } } ) ; assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; verify ( org.springframework.jdbc.datasource.UserTransaction ) . begin ( ) ; verify ( org.springframework.jdbc.datasource.UserTransaction ) . commit ( ) ; if ( boolean ) { verify ( org.springframework.jdbc.datasource.TransactionManager ) . resume ( org.springframework.jdbc.datasource.Transaction ) ; } verify ( java.sql.Connection ) . close ( ) ; verify ( java.sql.Connection ) . close ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) { assertTrue ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly ( ) ) ; assertFalse ( TransactionSynchronizationManager . isActualTransactionActive ( ) ) ; assertSame ( java.sql.Connection , DataSourceUtils . getConnection ( javax.sql.DataSource ) ) ; assertSame ( java.sql.Connection , DataSourceUtils . getConnection ( javax.sql.DataSource ) ) ; TransactionTemplate org.springframework.jdbc.datasource.TransactionTemplate = new TransactionTemplate ( org.springframework.jdbc.datasource.JtaTransactionManager ) ; org.springframework.jdbc.datasource.TransactionTemplate . setPropagationBehavior ( boolean ? TransactionDefinition . PROPAGATION_REQUIRES_NEW : TransactionDefinition . PROPAGATION_REQUIRED ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) { assertTrue ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly ( ) ) ; assertTrue ( TransactionSynchronizationManager . isActualTransactionActive ( ) ) ; assertSame ( java.sql.Connection , DataSourceUtils . getConnection ( javax.sql.DataSource ) ) ; assertSame ( java.sql.Connection , DataSourceUtils . getConnection ( javax.sql.DataSource ) ) ; } } ) ; assertTrue ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly ( ) ) ; assertFalse ( TransactionSynchronizationManager . isActualTransactionActive ( ) ) ; assertSame ( java.sql.Connection , DataSourceUtils . getConnection ( javax.sql.DataSource ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) { assertTrue ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly ( ) ) ; assertTrue ( TransactionSynchronizationManager . isActualTransactionActive ( ) ) ; assertSame ( java.sql.Connection , DataSourceUtils . getConnection ( javax.sql.DataSource ) ) ; assertSame ( java.sql.Connection , DataSourceUtils . getConnection ( javax.sql.DataSource ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { void ( true , false , false ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { void ( true , true , false ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { void ( true , false , true ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { void ( true , true , true ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { void ( false , false , false ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { void ( false , true , false ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { void ( false , true , true ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { void ( false , false , true ) ; }  <METHOD_END>
<METHOD_START> private void void ( boolean boolean , final boolean boolean , final boolean boolean ) throws java.lang.Exception { given ( org.springframework.jdbc.datasource.UserTransaction . getStatus ( ) ) . willReturn ( Status . STATUS_NO_TRANSACTION , Status . STATUS_ACTIVE , Status . STATUS_ACTIVE ) ; if ( boolean ) { given ( org.springframework.jdbc.datasource.TransactionManager . suspend ( ) ) . willThrow ( new SystemException ( ) ) ; } else { given ( org.springframework.jdbc.datasource.TransactionManager . suspend ( ) ) . willReturn ( org.springframework.jdbc.datasource.Transaction ) ; willThrow ( new SystemException ( ) ) . given ( org.springframework.jdbc.datasource.UserTransaction ) . begin ( ) ; } given ( java.sql.Connection . boolean ( ) ) . willReturn ( true ) ; final javax.sql.DataSource javax.sql.DataSource = boolean ? new TransactionAwareDataSourceProxy ( javax.sql.DataSource ) : javax.sql.DataSource ; if ( javax.sql.DataSource instanceof TransactionAwareDataSourceProxy ) { ( ( TransactionAwareDataSourceProxy ) javax.sql.DataSource ) . setReobtainTransactionalConnections ( true ) ; } JtaTransactionManager org.springframework.jdbc.datasource.JtaTransactionManager = new JtaTransactionManager ( org.springframework.jdbc.datasource.UserTransaction , org.springframework.jdbc.datasource.TransactionManager ) ; final TransactionTemplate org.springframework.jdbc.datasource.TransactionTemplate = new TransactionTemplate ( org.springframework.jdbc.datasource.JtaTransactionManager ) ; org.springframework.jdbc.datasource.TransactionTemplate . setPropagationBehavior ( TransactionDefinition . PROPAGATION_REQUIRES_NEW ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; try { org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; java.sql.Connection java.sql.Connection = DataSourceUtils . getConnection ( javax.sql.DataSource ) ; try { assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; java.sql.Connection . boolean ( ) ; DataSourceUtils . releaseConnection ( java.sql.Connection , javax.sql.DataSource ) ; java.sql.Connection = DataSourceUtils . getConnection ( javax.sql.DataSource ) ; assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; if ( ! boolean ) { DataSourceUtils . releaseConnection ( java.sql.Connection , javax.sql.DataSource ) ; } } catch ( java.sql.SQLException java.sql.SQLException ) {					} try { org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; java.sql.Connection java.sql.Connection = DataSourceUtils . getConnection ( javax.sql.DataSource ) ; assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; DataSourceUtils . releaseConnection ( java.sql.Connection , javax.sql.DataSource ) ; java.sql.Connection = DataSourceUtils . getConnection ( javax.sql.DataSource ) ; assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; DataSourceUtils . releaseConnection ( java.sql.Connection , javax.sql.DataSource ) ; } } ) ; } finally { if ( boolean ) { try { java.sql.Connection . boolean ( ) ; DataSourceUtils . releaseConnection ( java.sql.Connection , javax.sql.DataSource ) ; } catch ( java.sql.SQLException java.sql.SQLException ) {							} } } } } ) ; fail ( STRING ) ; } catch ( TransactionException org.springframework.jdbc.datasource.TransactionException ) { } assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; verify ( org.springframework.jdbc.datasource.UserTransaction ) . begin ( ) ; if ( boolean ) { verify ( org.springframework.jdbc.datasource.UserTransaction ) . rollback ( ) ; } if ( boolean ) { verify ( java.sql.Connection , atLeastOnce ( ) ) . close ( ) ; } else { verify ( java.sql.Connection , never ( ) ) . close ( ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; java.sql.Connection java.sql.Connection = DataSourceUtils . getConnection ( javax.sql.DataSource ) ; try { assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; java.sql.Connection . boolean ( ) ; DataSourceUtils . releaseConnection ( java.sql.Connection , javax.sql.DataSource ) ; java.sql.Connection = DataSourceUtils . getConnection ( javax.sql.DataSource ) ; assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; if ( ! boolean ) { DataSourceUtils . releaseConnection ( java.sql.Connection , javax.sql.DataSource ) ; } } catch ( java.sql.SQLException java.sql.SQLException ) {					} try { org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; java.sql.Connection java.sql.Connection = DataSourceUtils . getConnection ( javax.sql.DataSource ) ; assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; DataSourceUtils . releaseConnection ( java.sql.Connection , javax.sql.DataSource ) ; java.sql.Connection = DataSourceUtils . getConnection ( javax.sql.DataSource ) ; assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; DataSourceUtils . releaseConnection ( java.sql.Connection , javax.sql.DataSource ) ; } } ) ; } finally { if ( boolean ) { try { java.sql.Connection . boolean ( ) ; DataSourceUtils . releaseConnection ( java.sql.Connection , javax.sql.DataSource ) ; } catch ( java.sql.SQLException java.sql.SQLException ) {							} } } }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; java.sql.Connection java.sql.Connection = DataSourceUtils . getConnection ( javax.sql.DataSource ) ; assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; DataSourceUtils . releaseConnection ( java.sql.Connection , javax.sql.DataSource ) ; java.sql.Connection = DataSourceUtils . getConnection ( javax.sql.DataSource ) ; assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; DataSourceUtils . releaseConnection ( java.sql.Connection , javax.sql.DataSource ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { @ java.lang.SuppressWarnings ( STRING ) JtaTransactionManager org.springframework.jdbc.datasource.JtaTransactionManager = new JtaTransactionManager ( org.springframework.jdbc.datasource.UserTransaction ) { @ java.lang.Override protected void void ( JtaTransactionObject org.springframework.jdbc.datasource.JtaTransactionObject , final java.util.List<org.springframework.jdbc.datasource.TransactionSynchronization> < TransactionSynchronization > java.util.List<org.springframework.jdbc.datasource.TransactionSynchronization> )					throws org.springframework.jdbc.datasource.RollbackException , org.springframework.jdbc.datasource.SystemException { java.lang.Thread java.lang.Thread = new java.lang.Thread ( ) { @ java.lang.Override public void void ( ) { invokeAfterCompletion ( java.util.List<org.springframework.jdbc.datasource.TransactionSynchronization> , TransactionSynchronization . STATUS_COMMITTED ) ; } } ; java.lang.Thread . void ( ) ; try { java.lang.Thread . void ( ) ; } catch ( java.lang.InterruptedException java.lang.InterruptedException ) { java.lang.InterruptedException . void ( ) ; } } } ; TransactionTemplate org.springframework.jdbc.datasource.TransactionTemplate = new TransactionTemplate ( org.springframework.jdbc.datasource.JtaTransactionManager ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; given ( org.springframework.jdbc.datasource.UserTransaction . getStatus ( ) ) . willReturn ( Status . STATUS_ACTIVE ) ; for ( int int = NUMBER ; int < NUMBER ; int ++ ) { final boolean boolean = ( int != NUMBER ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; java.sql.Connection java.sql.Connection = DataSourceUtils . getConnection ( javax.sql.DataSource ) ; assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; DataSourceUtils . releaseConnection ( java.sql.Connection , javax.sql.DataSource ) ; java.sql.Connection = DataSourceUtils . getConnection ( javax.sql.DataSource ) ; assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; if ( boolean ) { DataSourceUtils . releaseConnection ( java.sql.Connection , javax.sql.DataSource ) ; } } } ) ; if ( ! boolean ) { assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; } else { assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; } assertTrue ( STRING , ! TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; } verify ( java.sql.Connection , times ( NUMBER ) ) . close ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( JtaTransactionObject org.springframework.jdbc.datasource.JtaTransactionObject , final java.util.List<org.springframework.jdbc.datasource.TransactionSynchronization> < TransactionSynchronization > java.util.List<org.springframework.jdbc.datasource.TransactionSynchronization> )					throws org.springframework.jdbc.datasource.RollbackException , org.springframework.jdbc.datasource.SystemException { java.lang.Thread java.lang.Thread = new java.lang.Thread ( ) { @ java.lang.Override public void void ( ) { invokeAfterCompletion ( java.util.List<org.springframework.jdbc.datasource.TransactionSynchronization> , TransactionSynchronization . STATUS_COMMITTED ) ; } } ; java.lang.Thread . void ( ) ; try { java.lang.Thread . void ( ) ; } catch ( java.lang.InterruptedException java.lang.InterruptedException ) { java.lang.InterruptedException . void ( ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ) { invokeAfterCompletion ( java.util.List<org.springframework.jdbc.datasource.TransactionSynchronization> , TransactionSynchronization . STATUS_COMMITTED ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; java.sql.Connection java.sql.Connection = DataSourceUtils . getConnection ( javax.sql.DataSource ) ; assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; DataSourceUtils . releaseConnection ( java.sql.Connection , javax.sql.DataSource ) ; java.sql.Connection = DataSourceUtils . getConnection ( javax.sql.DataSource ) ; assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; if ( boolean ) { DataSourceUtils . releaseConnection ( java.sql.Connection , javax.sql.DataSource ) ; } }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { given ( org.springframework.jdbc.datasource.UserTransaction . getStatus ( ) ) . willReturn ( Status . STATUS_NO_TRANSACTION , Status . STATUS_ACTIVE , Status . STATUS_ACTIVE , Status . STATUS_NO_TRANSACTION , Status . STATUS_ACTIVE , Status . STATUS_ACTIVE ) ; final IsolationLevelDataSourceAdapter org.springframework.jdbc.datasource.IsolationLevelDataSourceAdapter = new IsolationLevelDataSourceAdapter ( ) ; org.springframework.jdbc.datasource.IsolationLevelDataSourceAdapter . setTargetDataSource ( javax.sql.DataSource ) ; org.springframework.jdbc.datasource.IsolationLevelDataSourceAdapter . afterPropertiesSet ( ) ; JtaTransactionManager org.springframework.jdbc.datasource.JtaTransactionManager = new JtaTransactionManager ( org.springframework.jdbc.datasource.UserTransaction ) ; org.springframework.jdbc.datasource.JtaTransactionManager . setAllowCustomIsolationLevels ( true ) ; TransactionTemplate org.springframework.jdbc.datasource.TransactionTemplate = new TransactionTemplate ( org.springframework.jdbc.datasource.JtaTransactionManager ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { java.sql.Connection java.sql.Connection = DataSourceUtils . getConnection ( org.springframework.jdbc.datasource.IsolationLevelDataSourceAdapter ) ; assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( org.springframework.jdbc.datasource.IsolationLevelDataSourceAdapter ) ) ; assertSame ( java.sql.Connection , java.sql.Connection ) ; DataSourceUtils . releaseConnection ( java.sql.Connection , org.springframework.jdbc.datasource.IsolationLevelDataSourceAdapter ) ; } } ) ; org.springframework.jdbc.datasource.TransactionTemplate . setIsolationLevel ( TransactionDefinition . ISOLATION_REPEATABLE_READ ) ; org.springframework.jdbc.datasource.TransactionTemplate . setReadOnly ( true ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { java.sql.Connection java.sql.Connection = DataSourceUtils . getConnection ( org.springframework.jdbc.datasource.IsolationLevelDataSourceAdapter ) ; assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( org.springframework.jdbc.datasource.IsolationLevelDataSourceAdapter ) ) ; assertSame ( java.sql.Connection , java.sql.Connection ) ; DataSourceUtils . releaseConnection ( java.sql.Connection , org.springframework.jdbc.datasource.IsolationLevelDataSourceAdapter ) ; } } ) ; verify ( org.springframework.jdbc.datasource.UserTransaction , times ( NUMBER ) ) . begin ( ) ; verify ( org.springframework.jdbc.datasource.UserTransaction , times ( NUMBER ) ) . commit ( ) ; verify ( java.sql.Connection ) . setReadOnly ( true ) ; verify ( java.sql.Connection ) . setTransactionIsolation ( java.sql.Connection . int ) ; verify ( java.sql.Connection , times ( NUMBER ) ) . close ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { java.sql.Connection java.sql.Connection = DataSourceUtils . getConnection ( org.springframework.jdbc.datasource.IsolationLevelDataSourceAdapter ) ; assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( org.springframework.jdbc.datasource.IsolationLevelDataSourceAdapter ) ) ; assertSame ( java.sql.Connection , java.sql.Connection ) ; DataSourceUtils . releaseConnection ( java.sql.Connection , org.springframework.jdbc.datasource.IsolationLevelDataSourceAdapter ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { java.sql.Connection java.sql.Connection = DataSourceUtils . getConnection ( org.springframework.jdbc.datasource.IsolationLevelDataSourceAdapter ) ; assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( org.springframework.jdbc.datasource.IsolationLevelDataSourceAdapter ) ) ; assertSame ( java.sql.Connection , java.sql.Connection ) ; DataSourceUtils . releaseConnection ( java.sql.Connection , org.springframework.jdbc.datasource.IsolationLevelDataSourceAdapter ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { void ( false ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { void ( true ) ; }  <METHOD_END>
<METHOD_START> private void void ( boolean boolean ) throws java.lang.Exception { given ( org.springframework.jdbc.datasource.UserTransaction . getStatus ( ) ) . willReturn ( Status . STATUS_NO_TRANSACTION , Status . STATUS_ACTIVE , Status . STATUS_ACTIVE , Status . STATUS_NO_TRANSACTION , Status . STATUS_ACTIVE , Status . STATUS_ACTIVE ) ; final javax.sql.DataSource javax.sql.DataSource = mock ( javax.sql.DataSource .class ) ; final java.sql.Connection java.sql.Connection = mock ( java.sql.Connection .class ) ; given ( javax.sql.DataSource . java.sql.Connection ( ) ) . willReturn ( java.sql.Connection ) ; final javax.sql.DataSource javax.sql.DataSource = mock ( javax.sql.DataSource .class ) ; final java.sql.Connection java.sql.Connection = mock ( java.sql.Connection .class ) ; given ( javax.sql.DataSource . java.sql.Connection ( ) ) . willReturn ( java.sql.Connection ) ; final IsolationLevelDataSourceRouter org.springframework.jdbc.datasource.IsolationLevelDataSourceRouter = new IsolationLevelDataSourceRouter ( ) ; java.util.Map<java.lang.Object,java.lang.Object> < java.lang.Object , java.lang.Object > java.util.Map<java.lang.Object,java.lang.Object> = new java.util.HashMap<java.lang.Object,java.lang.Object> <> ( ) ; if ( boolean ) { java.util.Map<java.lang.Object,java.lang.Object> . java.lang.Object ( STRING , STRING ) ; org.springframework.jdbc.datasource.IsolationLevelDataSourceRouter . setDefaultTargetDataSource ( STRING ) ; StaticListableBeanFactory org.springframework.jdbc.datasource.StaticListableBeanFactory = new StaticListableBeanFactory ( ) ; org.springframework.jdbc.datasource.StaticListableBeanFactory . addBean ( STRING , javax.sql.DataSource ) ; org.springframework.jdbc.datasource.StaticListableBeanFactory . addBean ( STRING , javax.sql.DataSource ) ; org.springframework.jdbc.datasource.IsolationLevelDataSourceRouter . setDataSourceLookup ( new BeanFactoryDataSourceLookup ( org.springframework.jdbc.datasource.StaticListableBeanFactory ) ) ; } else { java.util.Map<java.lang.Object,java.lang.Object> . java.lang.Object ( STRING , javax.sql.DataSource ) ; org.springframework.jdbc.datasource.IsolationLevelDataSourceRouter . setDefaultTargetDataSource ( javax.sql.DataSource ) ; } org.springframework.jdbc.datasource.IsolationLevelDataSourceRouter . setTargetDataSources ( java.util.Map<java.lang.Object,java.lang.Object> ) ; org.springframework.jdbc.datasource.IsolationLevelDataSourceRouter . afterPropertiesSet ( ) ; JtaTransactionManager org.springframework.jdbc.datasource.JtaTransactionManager = new JtaTransactionManager ( org.springframework.jdbc.datasource.UserTransaction ) ; org.springframework.jdbc.datasource.JtaTransactionManager . setAllowCustomIsolationLevels ( true ) ; TransactionTemplate org.springframework.jdbc.datasource.TransactionTemplate = new TransactionTemplate ( org.springframework.jdbc.datasource.JtaTransactionManager ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { java.sql.Connection java.sql.Connection = DataSourceUtils . getConnection ( org.springframework.jdbc.datasource.IsolationLevelDataSourceRouter ) ; assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( org.springframework.jdbc.datasource.IsolationLevelDataSourceRouter ) ) ; assertSame ( java.sql.Connection , java.sql.Connection ) ; DataSourceUtils . releaseConnection ( java.sql.Connection , org.springframework.jdbc.datasource.IsolationLevelDataSourceRouter ) ; } } ) ; org.springframework.jdbc.datasource.TransactionTemplate . setIsolationLevel ( TransactionDefinition . ISOLATION_REPEATABLE_READ ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { java.sql.Connection java.sql.Connection = DataSourceUtils . getConnection ( org.springframework.jdbc.datasource.IsolationLevelDataSourceRouter ) ; assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( org.springframework.jdbc.datasource.IsolationLevelDataSourceRouter ) ) ; assertSame ( java.sql.Connection , java.sql.Connection ) ; DataSourceUtils . releaseConnection ( java.sql.Connection , org.springframework.jdbc.datasource.IsolationLevelDataSourceRouter ) ; } } ) ; verify ( org.springframework.jdbc.datasource.UserTransaction , times ( NUMBER ) ) . begin ( ) ; verify ( org.springframework.jdbc.datasource.UserTransaction , times ( NUMBER ) ) . commit ( ) ; verify ( java.sql.Connection ) . close ( ) ; verify ( java.sql.Connection ) . close ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { java.sql.Connection java.sql.Connection = DataSourceUtils . getConnection ( org.springframework.jdbc.datasource.IsolationLevelDataSourceRouter ) ; assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( org.springframework.jdbc.datasource.IsolationLevelDataSourceRouter ) ) ; assertSame ( java.sql.Connection , java.sql.Connection ) ; DataSourceUtils . releaseConnection ( java.sql.Connection , org.springframework.jdbc.datasource.IsolationLevelDataSourceRouter ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { java.sql.Connection java.sql.Connection = DataSourceUtils . getConnection ( org.springframework.jdbc.datasource.IsolationLevelDataSourceRouter ) ; assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( org.springframework.jdbc.datasource.IsolationLevelDataSourceRouter ) ) ; assertSame ( java.sql.Connection , java.sql.Connection ) ; DataSourceUtils . releaseConnection ( java.sql.Connection , org.springframework.jdbc.datasource.IsolationLevelDataSourceRouter ) ; }  <METHOD_END>
