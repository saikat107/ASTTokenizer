<METHOD_START> public void ( Decoder < T > org.springframework.http.codec.Decoder<T> ) { Assert . notNull ( org.springframework.http.codec.Decoder<T> , STRING ) ; this . org.springframework.http.codec.Decoder<T> = org.springframework.http.codec.Decoder<T> ; this . java.util.List<org.springframework.http.codec.MediaType> = MediaType . asMediaTypes ( org.springframework.http.codec.Decoder<T> . getDecodableMimeTypes ( ) ) ; }  <METHOD_END>
<METHOD_START> public org.springframework.http.codec.Decoder<T> < T > org.springframework.http.codec.Decoder<T> ( ) { return this . org.springframework.http.codec.Decoder<T> ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.util.List<org.springframework.http.codec.MediaType> < MediaType > java.util.List<org.springframework.http.codec.MediaType> ( ) { return this . java.util.List<org.springframework.http.codec.MediaType> ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( ResolvableType org.springframework.http.codec.ResolvableType , MediaType org.springframework.http.codec.MediaType ) { return this . org.springframework.http.codec.Decoder<T> . canDecode ( org.springframework.http.codec.ResolvableType , org.springframework.http.codec.MediaType ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.http.codec.Flux<T> < T > org.springframework.http.codec.Flux<T> ( ResolvableType org.springframework.http.codec.ResolvableType , ReactiveHttpInputMessage org.springframework.http.codec.ReactiveHttpInputMessage , java.util.Map<java.lang.String,java.lang.Object> < java.lang.String , java.lang.Object > java.util.Map<java.lang.String,java.lang.Object> ) { MediaType org.springframework.http.codec.MediaType = org.springframework.http.codec.MediaType ( org.springframework.http.codec.ReactiveHttpInputMessage ) ; return this . org.springframework.http.codec.Decoder<T> . decode ( org.springframework.http.codec.ReactiveHttpInputMessage . getBody ( ) , org.springframework.http.codec.ResolvableType , org.springframework.http.codec.MediaType , java.util.Map<java.lang.String,java.lang.Object> ) . mapError ( this :: java.lang.Throwable ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.http.codec.Mono<T> < T > org.springframework.http.codec.Mono<T> ( ResolvableType org.springframework.http.codec.ResolvableType , ReactiveHttpInputMessage org.springframework.http.codec.ReactiveHttpInputMessage , java.util.Map<java.lang.String,java.lang.Object> < java.lang.String , java.lang.Object > java.util.Map<java.lang.String,java.lang.Object> ) { MediaType org.springframework.http.codec.MediaType = org.springframework.http.codec.MediaType ( org.springframework.http.codec.ReactiveHttpInputMessage ) ; return this . org.springframework.http.codec.Decoder<T> . decodeToMono ( org.springframework.http.codec.ReactiveHttpInputMessage . getBody ( ) , org.springframework.http.codec.ResolvableType , org.springframework.http.codec.MediaType , java.util.Map<java.lang.String,java.lang.Object> ) . mapError ( this :: java.lang.Throwable ) ; }  <METHOD_END>
<METHOD_START> private org.springframework.http.codec.MediaType org.springframework.http.codec.MediaType ( HttpMessage org.springframework.http.codec.HttpMessage ) { MediaType org.springframework.http.codec.MediaType = org.springframework.http.codec.HttpMessage . getHeaders ( ) . getContentType ( ) ; return ( org.springframework.http.codec.MediaType != null ? org.springframework.http.codec.MediaType : MediaType . APPLICATION_OCTET_STREAM ) ; }  <METHOD_END>
<METHOD_START> private java.lang.Throwable java.lang.Throwable ( java.lang.Throwable java.lang.Throwable ) { if ( java.lang.Throwable instanceof ResponseStatusException ) { return java.lang.Throwable ; } else if ( java.lang.Throwable instanceof CodecException ) { return new ResponseStatusException ( HttpStatus . BAD_REQUEST , STRING , java.lang.Throwable ) ; } return new ResponseStatusException ( HttpStatus . INTERNAL_SERVER_ERROR , STRING , java.lang.Throwable ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.http.codec.Flux<T> < T > org.springframework.http.codec.Flux<T> ( ResolvableType org.springframework.http.codec.ResolvableType , ResolvableType org.springframework.http.codec.ResolvableType , ServerHttpRequest org.springframework.http.codec.ServerHttpRequest , ServerHttpResponse org.springframework.http.codec.ServerHttpResponse , java.util.Map<java.lang.String,java.lang.Object> < java.lang.String , java.lang.Object > java.util.Map<java.lang.String,java.lang.Object> ) { java.util.Map<java.lang.String,java.lang.Object> < java.lang.String , java.lang.Object > java.util.Map<java.lang.String,java.lang.Object> = new java.util.HashMap<java.lang.String,java.lang.Object> <> ( NUMBER ) ; java.util.Map<java.lang.String,java.lang.Object> . void ( java.util.Map<java.lang.String,java.lang.Object> ( org.springframework.http.codec.ResolvableType , org.springframework.http.codec.ResolvableType , org.springframework.http.codec.ServerHttpRequest , org.springframework.http.codec.ServerHttpResponse ) ) ; java.util.Map<java.lang.String,java.lang.Object> . void ( java.util.Map<java.lang.String,java.lang.Object> ) ; return org.springframework.http.codec.Flux<T> ( org.springframework.http.codec.ResolvableType , org.springframework.http.codec.ServerHttpRequest , java.util.Map<java.lang.String,java.lang.Object> ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.http.codec.Mono<T> < T > org.springframework.http.codec.Mono<T> ( ResolvableType org.springframework.http.codec.ResolvableType , ResolvableType org.springframework.http.codec.ResolvableType , ServerHttpRequest org.springframework.http.codec.ServerHttpRequest , ServerHttpResponse org.springframework.http.codec.ServerHttpResponse , java.util.Map<java.lang.String,java.lang.Object> < java.lang.String , java.lang.Object > java.util.Map<java.lang.String,java.lang.Object> ) { java.util.Map<java.lang.String,java.lang.Object> < java.lang.String , java.lang.Object > java.util.Map<java.lang.String,java.lang.Object> = new java.util.HashMap<java.lang.String,java.lang.Object> <> ( NUMBER ) ; java.util.Map<java.lang.String,java.lang.Object> . void ( java.util.Map<java.lang.String,java.lang.Object> ( org.springframework.http.codec.ResolvableType , org.springframework.http.codec.ResolvableType , org.springframework.http.codec.ServerHttpRequest , org.springframework.http.codec.ServerHttpResponse ) ) ; java.util.Map<java.lang.String,java.lang.Object> . void ( java.util.Map<java.lang.String,java.lang.Object> ) ; return org.springframework.http.codec.Mono<T> ( org.springframework.http.codec.ResolvableType , org.springframework.http.codec.ServerHttpRequest , java.util.Map<java.lang.String,java.lang.Object> ) ; }  <METHOD_END>
<METHOD_START> protected java.util.Map<java.lang.String,java.lang.Object> < java.lang.String , java.lang.Object > java.util.Map<java.lang.String,java.lang.Object> ( ResolvableType org.springframework.http.codec.ResolvableType , ResolvableType org.springframework.http.codec.ResolvableType , ServerHttpRequest org.springframework.http.codec.ServerHttpRequest , ServerHttpResponse org.springframework.http.codec.ServerHttpResponse ) { if ( this . org.springframework.http.codec.Decoder<T> instanceof HttpMessageDecoder ) { HttpMessageDecoder < ? > org.springframework.http.codec.HttpMessageDecoder<?> = ( HttpMessageDecoder < ? > ) this . org.springframework.http.codec.Decoder<T> ; return org.springframework.http.codec.HttpMessageDecoder<> . getDecodeHints ( org.springframework.http.codec.ResolvableType , org.springframework.http.codec.ResolvableType , org.springframework.http.codec.ServerHttpRequest , org.springframework.http.codec.ServerHttpResponse ) ; } return java.util.Collections . java.util.Map<java.lang.String,java.lang.Object> ( ) ; }  <METHOD_END>
