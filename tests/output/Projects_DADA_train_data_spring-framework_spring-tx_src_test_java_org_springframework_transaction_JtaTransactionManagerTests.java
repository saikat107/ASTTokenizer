<METHOD_START> @ Test public void void ( ) java.lang.Exception { UserTransaction org.springframework.transaction.UserTransaction = mock ( UserTransaction .class ) ; given ( org.springframework.transaction.UserTransaction . getStatus ( ) ) . willReturn ( Status . STATUS_NO_TRANSACTION , Status . STATUS_ACTIVE , Status . STATUS_ACTIVE ) ; final TransactionSynchronization org.springframework.transaction.TransactionSynchronization = mock ( TransactionSynchronization .class ) ; JtaTransactionManager org.springframework.transaction.JtaTransactionManager = org.springframework.transaction.JtaTransactionManager ( org.springframework.transaction.UserTransaction ) ; TransactionTemplate org.springframework.transaction.TransactionTemplate = new TransactionTemplate ( org.springframework.transaction.JtaTransactionManager ) ; org.springframework.transaction.TransactionTemplate . setName ( STRING ) ; assertEquals ( JtaTransactionManager . SYNCHRONIZATION_ALWAYS , org.springframework.transaction.JtaTransactionManager . getTransactionSynchronization ( ) ) ; assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertNull ( TransactionSynchronizationManager . getCurrentTransactionName ( ) ) ; assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly ( ) ) ; org.springframework.transaction.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { assertTrue ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; TransactionSynchronizationManager . registerSynchronization ( org.springframework.transaction.TransactionSynchronization ) ; assertEquals ( STRING , TransactionSynchronizationManager . getCurrentTransactionName ( ) ) ; assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly ( ) ) ; } } ) ; assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertNull ( TransactionSynchronizationManager . getCurrentTransactionName ( ) ) ; assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly ( ) ) ; verify ( org.springframework.transaction.UserTransaction ) . begin ( ) ; verify ( org.springframework.transaction.UserTransaction ) . commit ( ) ; verify ( org.springframework.transaction.TransactionSynchronization ) . beforeCommit ( false ) ; verify ( org.springframework.transaction.TransactionSynchronization ) . beforeCompletion ( ) ; verify ( org.springframework.transaction.TransactionSynchronization ) . afterCommit ( ) ; verify ( org.springframework.transaction.TransactionSynchronization ) . afterCompletion ( TransactionSynchronization . STATUS_COMMITTED ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { assertTrue ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; TransactionSynchronizationManager . registerSynchronization ( org.springframework.transaction.TransactionSynchronization ) ; assertEquals ( STRING , TransactionSynchronizationManager . getCurrentTransactionName ( ) ) ; assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { UserTransaction org.springframework.transaction.UserTransaction = mock ( UserTransaction .class ) ; given ( org.springframework.transaction.UserTransaction . getStatus ( ) ) . willReturn ( Status . STATUS_NO_TRANSACTION , Status . STATUS_ACTIVE , Status . STATUS_ACTIVE ) ; final TransactionSynchronization org.springframework.transaction.TransactionSynchronization = mock ( TransactionSynchronization .class ) ; JtaTransactionManager org.springframework.transaction.JtaTransactionManager = org.springframework.transaction.JtaTransactionManager ( org.springframework.transaction.UserTransaction ) ; TransactionTemplate org.springframework.transaction.TransactionTemplate = new TransactionTemplate ( org.springframework.transaction.JtaTransactionManager ) ; org.springframework.transaction.JtaTransactionManager . setTransactionSynchronization ( JtaTransactionManager . SYNCHRONIZATION_ON_ACTUAL_TRANSACTION ) ; assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; org.springframework.transaction.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { assertTrue ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; TransactionSynchronizationManager . registerSynchronization ( org.springframework.transaction.TransactionSynchronization ) ; } } ) ; assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; verify ( org.springframework.transaction.UserTransaction ) . begin ( ) ; verify ( org.springframework.transaction.UserTransaction ) . commit ( ) ; verify ( org.springframework.transaction.TransactionSynchronization ) . beforeCommit ( false ) ; verify ( org.springframework.transaction.TransactionSynchronization ) . beforeCompletion ( ) ; verify ( org.springframework.transaction.TransactionSynchronization ) . afterCommit ( ) ; verify ( org.springframework.transaction.TransactionSynchronization ) . afterCompletion ( TransactionSynchronization . STATUS_COMMITTED ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { assertTrue ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; TransactionSynchronizationManager . registerSynchronization ( org.springframework.transaction.TransactionSynchronization ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { UserTransaction org.springframework.transaction.UserTransaction = mock ( UserTransaction .class ) ; given ( org.springframework.transaction.UserTransaction . getStatus ( ) ) . willReturn ( Status . STATUS_NO_TRANSACTION , Status . STATUS_ACTIVE , Status . STATUS_ACTIVE ) ; JtaTransactionManager org.springframework.transaction.JtaTransactionManager = org.springframework.transaction.JtaTransactionManager ( org.springframework.transaction.UserTransaction ) ; TransactionTemplate org.springframework.transaction.TransactionTemplate = new TransactionTemplate ( org.springframework.transaction.JtaTransactionManager ) ; org.springframework.transaction.JtaTransactionManager . setTransactionSynchronization ( JtaTransactionManager . SYNCHRONIZATION_NEVER ) ; org.springframework.transaction.JtaTransactionManager . afterPropertiesSet ( ) ; assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; org.springframework.transaction.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; } } ) ; assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; verify ( org.springframework.transaction.UserTransaction ) . begin ( ) ; verify ( org.springframework.transaction.UserTransaction ) . commit ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { UserTransaction org.springframework.transaction.UserTransaction = mock ( UserTransaction .class ) ; given ( org.springframework.transaction.UserTransaction . getStatus ( ) ) . willReturn ( Status . STATUS_NO_TRANSACTION , Status . STATUS_ACTIVE ) ; final TransactionSynchronization org.springframework.transaction.TransactionSynchronization = mock ( TransactionSynchronization .class ) ; JtaTransactionManager org.springframework.transaction.JtaTransactionManager = org.springframework.transaction.JtaTransactionManager ( org.springframework.transaction.UserTransaction ) ; TransactionTemplate org.springframework.transaction.TransactionTemplate = new TransactionTemplate ( org.springframework.transaction.JtaTransactionManager ) ; org.springframework.transaction.TransactionTemplate . setTimeout ( NUMBER ) ; org.springframework.transaction.TransactionTemplate . setName ( STRING ) ; assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertNull ( TransactionSynchronizationManager . getCurrentTransactionName ( ) ) ; assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly ( ) ) ; org.springframework.transaction.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { assertTrue ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; TransactionSynchronizationManager . registerSynchronization ( org.springframework.transaction.TransactionSynchronization ) ; assertEquals ( STRING , TransactionSynchronizationManager . getCurrentTransactionName ( ) ) ; assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly ( ) ) ; org.springframework.transaction.TransactionStatus . setRollbackOnly ( ) ; } } ) ; assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertNull ( TransactionSynchronizationManager . getCurrentTransactionName ( ) ) ; assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly ( ) ) ; verify ( org.springframework.transaction.UserTransaction ) . setTransactionTimeout ( NUMBER ) ; verify ( org.springframework.transaction.UserTransaction ) . begin ( ) ; verify ( org.springframework.transaction.UserTransaction ) . rollback ( ) ; verify ( org.springframework.transaction.TransactionSynchronization ) . beforeCompletion ( ) ; verify ( org.springframework.transaction.TransactionSynchronization ) . afterCompletion ( TransactionSynchronization . STATUS_ROLLED_BACK ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { assertTrue ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; TransactionSynchronizationManager . registerSynchronization ( org.springframework.transaction.TransactionSynchronization ) ; assertEquals ( STRING , TransactionSynchronizationManager . getCurrentTransactionName ( ) ) ; assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly ( ) ) ; org.springframework.transaction.TransactionStatus . setRollbackOnly ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { UserTransaction org.springframework.transaction.UserTransaction = mock ( UserTransaction .class ) ; given ( org.springframework.transaction.UserTransaction . getStatus ( ) ) . willReturn ( Status . STATUS_NO_TRANSACTION , Status . STATUS_ACTIVE ) ; final TransactionSynchronization org.springframework.transaction.TransactionSynchronization = mock ( TransactionSynchronization .class ) ; JtaTransactionManager org.springframework.transaction.JtaTransactionManager = org.springframework.transaction.JtaTransactionManager ( org.springframework.transaction.UserTransaction ) ; TransactionTemplate org.springframework.transaction.TransactionTemplate = new TransactionTemplate ( org.springframework.transaction.JtaTransactionManager ) ; org.springframework.transaction.JtaTransactionManager . setTransactionSynchronization ( JtaTransactionManager . SYNCHRONIZATION_ON_ACTUAL_TRANSACTION ) ; org.springframework.transaction.TransactionTemplate . setTimeout ( NUMBER ) ; assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; org.springframework.transaction.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { assertTrue ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; TransactionSynchronizationManager . registerSynchronization ( org.springframework.transaction.TransactionSynchronization ) ; org.springframework.transaction.TransactionStatus . setRollbackOnly ( ) ; } } ) ; assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; verify ( org.springframework.transaction.UserTransaction ) . setTransactionTimeout ( NUMBER ) ; verify ( org.springframework.transaction.UserTransaction ) . begin ( ) ; verify ( org.springframework.transaction.UserTransaction ) . rollback ( ) ; verify ( org.springframework.transaction.TransactionSynchronization ) . beforeCompletion ( ) ; verify ( org.springframework.transaction.TransactionSynchronization ) . afterCompletion ( TransactionSynchronization . STATUS_ROLLED_BACK ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { assertTrue ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; TransactionSynchronizationManager . registerSynchronization ( org.springframework.transaction.TransactionSynchronization ) ; org.springframework.transaction.TransactionStatus . setRollbackOnly ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { UserTransaction org.springframework.transaction.UserTransaction = mock ( UserTransaction .class ) ; given ( org.springframework.transaction.UserTransaction . getStatus ( ) ) . willReturn ( Status . STATUS_NO_TRANSACTION , Status . STATUS_ACTIVE ) ; JtaTransactionManager org.springframework.transaction.JtaTransactionManager = org.springframework.transaction.JtaTransactionManager ( org.springframework.transaction.UserTransaction ) ; TransactionTemplate org.springframework.transaction.TransactionTemplate = new TransactionTemplate ( org.springframework.transaction.JtaTransactionManager ) ; org.springframework.transaction.JtaTransactionManager . setTransactionSynchronizationName ( STRING ) ; org.springframework.transaction.TransactionTemplate . setTimeout ( NUMBER ) ; org.springframework.transaction.JtaTransactionManager . afterPropertiesSet ( ) ; assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; org.springframework.transaction.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; org.springframework.transaction.TransactionStatus . setRollbackOnly ( ) ; } } ) ; assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; verify ( org.springframework.transaction.UserTransaction ) . setTransactionTimeout ( NUMBER ) ; verify ( org.springframework.transaction.UserTransaction ) . begin ( ) ; verify ( org.springframework.transaction.UserTransaction , atLeastOnce ( ) ) . getStatus ( ) ; verify ( org.springframework.transaction.UserTransaction ) . rollback ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; org.springframework.transaction.TransactionStatus . setRollbackOnly ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { UserTransaction org.springframework.transaction.UserTransaction = mock ( UserTransaction .class ) ; given ( org.springframework.transaction.UserTransaction . getStatus ( ) ) . willReturn ( Status . STATUS_ACTIVE ) ; final TransactionSynchronization org.springframework.transaction.TransactionSynchronization = mock ( TransactionSynchronization .class ) ; JtaTransactionManager org.springframework.transaction.JtaTransactionManager = org.springframework.transaction.JtaTransactionManager ( org.springframework.transaction.UserTransaction ) ; TransactionTemplate org.springframework.transaction.TransactionTemplate = new TransactionTemplate ( org.springframework.transaction.JtaTransactionManager ) ; assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; org.springframework.transaction.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { assertTrue ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; TransactionSynchronizationManager . registerSynchronization ( org.springframework.transaction.TransactionSynchronization ) ; org.springframework.transaction.TransactionStatus . setRollbackOnly ( ) ; } } ) ; assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; verify ( org.springframework.transaction.UserTransaction ) . setRollbackOnly ( ) ; verify ( org.springframework.transaction.TransactionSynchronization ) . beforeCompletion ( ) ; verify ( org.springframework.transaction.TransactionSynchronization ) . afterCompletion ( TransactionSynchronization . STATUS_UNKNOWN ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { assertTrue ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; TransactionSynchronizationManager . registerSynchronization ( org.springframework.transaction.TransactionSynchronization ) ; org.springframework.transaction.TransactionStatus . setRollbackOnly ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { UserTransaction org.springframework.transaction.UserTransaction = mock ( UserTransaction .class ) ; given ( org.springframework.transaction.UserTransaction . getStatus ( ) ) . willReturn ( Status . STATUS_ACTIVE ) ; final TransactionSynchronization org.springframework.transaction.TransactionSynchronization = mock ( TransactionSynchronization .class ) ; JtaTransactionManager org.springframework.transaction.JtaTransactionManager = org.springframework.transaction.JtaTransactionManager ( org.springframework.transaction.UserTransaction ) ; TransactionTemplate org.springframework.transaction.TransactionTemplate = new TransactionTemplate ( org.springframework.transaction.JtaTransactionManager ) ; assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; try { org.springframework.transaction.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { assertTrue ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; TransactionSynchronizationManager . registerSynchronization ( org.springframework.transaction.TransactionSynchronization ) ; throw new java.lang.IllegalStateException ( STRING ) ; } } ) ; fail ( STRING ) ; } catch ( java.lang.IllegalStateException java.lang.IllegalStateException ) { } assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; verify ( org.springframework.transaction.UserTransaction ) . setRollbackOnly ( ) ; verify ( org.springframework.transaction.TransactionSynchronization ) . beforeCompletion ( ) ; verify ( org.springframework.transaction.TransactionSynchronization ) . afterCompletion ( TransactionSynchronization . STATUS_UNKNOWN ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { assertTrue ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; TransactionSynchronizationManager . registerSynchronization ( org.springframework.transaction.TransactionSynchronization ) ; throw new java.lang.IllegalStateException ( STRING ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { UserTransaction org.springframework.transaction.UserTransaction = mock ( UserTransaction .class ) ; given ( org.springframework.transaction.UserTransaction . getStatus ( ) ) . willReturn ( Status . STATUS_ACTIVE ) ; final TransactionSynchronization org.springframework.transaction.TransactionSynchronization = mock ( TransactionSynchronization .class ) ; willThrow ( new OptimisticLockingFailureException ( STRING ) ) . given ( org.springframework.transaction.TransactionSynchronization ) . beforeCommit ( false ) ; JtaTransactionManager org.springframework.transaction.JtaTransactionManager = org.springframework.transaction.JtaTransactionManager ( org.springframework.transaction.UserTransaction ) ; TransactionTemplate org.springframework.transaction.TransactionTemplate = new TransactionTemplate ( org.springframework.transaction.JtaTransactionManager ) ; assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; try { org.springframework.transaction.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { assertTrue ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; TransactionSynchronizationManager . registerSynchronization ( org.springframework.transaction.TransactionSynchronization ) ; } } ) ; fail ( STRING ) ; } catch ( OptimisticLockingFailureException org.springframework.transaction.OptimisticLockingFailureException ) { } assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; verify ( org.springframework.transaction.UserTransaction ) . setRollbackOnly ( ) ; verify ( org.springframework.transaction.TransactionSynchronization ) . beforeCompletion ( ) ; verify ( org.springframework.transaction.TransactionSynchronization ) . afterCompletion ( TransactionSynchronization . STATUS_UNKNOWN ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { assertTrue ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; TransactionSynchronizationManager . registerSynchronization ( org.springframework.transaction.TransactionSynchronization ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { UserTransaction org.springframework.transaction.UserTransaction = mock ( UserTransaction .class ) ; given ( org.springframework.transaction.UserTransaction . getStatus ( ) ) . willReturn ( Status . STATUS_ACTIVE ) ; final TransactionSynchronization org.springframework.transaction.TransactionSynchronization = mock ( TransactionSynchronization .class ) ; JtaTransactionManager org.springframework.transaction.JtaTransactionManager = org.springframework.transaction.JtaTransactionManager ( org.springframework.transaction.UserTransaction ) ; org.springframework.transaction.JtaTransactionManager . setGlobalRollbackOnParticipationFailure ( false ) ; TransactionTemplate org.springframework.transaction.TransactionTemplate = new TransactionTemplate ( org.springframework.transaction.JtaTransactionManager ) ; assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; org.springframework.transaction.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { assertTrue ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; TransactionSynchronizationManager . registerSynchronization ( org.springframework.transaction.TransactionSynchronization ) ; org.springframework.transaction.TransactionStatus . setRollbackOnly ( ) ; } } ) ; assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; verify ( org.springframework.transaction.UserTransaction ) . setRollbackOnly ( ) ; verify ( org.springframework.transaction.TransactionSynchronization ) . beforeCompletion ( ) ; verify ( org.springframework.transaction.TransactionSynchronization ) . afterCompletion ( TransactionSynchronization . STATUS_UNKNOWN ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { assertTrue ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; TransactionSynchronizationManager . registerSynchronization ( org.springframework.transaction.TransactionSynchronization ) ; org.springframework.transaction.TransactionStatus . setRollbackOnly ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { UserTransaction org.springframework.transaction.UserTransaction = mock ( UserTransaction .class ) ; given ( org.springframework.transaction.UserTransaction . getStatus ( ) ) . willReturn ( Status . STATUS_ACTIVE ) ; final TransactionSynchronization org.springframework.transaction.TransactionSynchronization = mock ( TransactionSynchronization .class ) ; JtaTransactionManager org.springframework.transaction.JtaTransactionManager = org.springframework.transaction.JtaTransactionManager ( org.springframework.transaction.UserTransaction ) ; org.springframework.transaction.JtaTransactionManager . setGlobalRollbackOnParticipationFailure ( false ) ; TransactionTemplate org.springframework.transaction.TransactionTemplate = new TransactionTemplate ( org.springframework.transaction.JtaTransactionManager ) ; assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; try { org.springframework.transaction.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { assertTrue ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; TransactionSynchronizationManager . registerSynchronization ( org.springframework.transaction.TransactionSynchronization ) ; throw new java.lang.IllegalStateException ( STRING ) ; } } ) ; fail ( STRING ) ; } catch ( java.lang.IllegalStateException java.lang.IllegalStateException ) { } assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; verify ( org.springframework.transaction.TransactionSynchronization ) . beforeCompletion ( ) ; verify ( org.springframework.transaction.TransactionSynchronization ) . afterCompletion ( TransactionSynchronization . STATUS_UNKNOWN ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { assertTrue ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; TransactionSynchronizationManager . registerSynchronization ( org.springframework.transaction.TransactionSynchronization ) ; throw new java.lang.IllegalStateException ( STRING ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { UserTransaction org.springframework.transaction.UserTransaction = mock ( UserTransaction .class ) ; TransactionManager org.springframework.transaction.TransactionManager = mock ( TransactionManager .class ) ; MockJtaTransaction org.springframework.transaction.MockJtaTransaction = new MockJtaTransaction ( ) ; given ( org.springframework.transaction.UserTransaction . getStatus ( ) ) . willReturn ( Status . STATUS_ACTIVE ) ; given ( org.springframework.transaction.TransactionManager . getTransaction ( ) ) . willReturn ( org.springframework.transaction.MockJtaTransaction ) ; final TransactionSynchronization org.springframework.transaction.TransactionSynchronization = mock ( TransactionSynchronization .class ) ; JtaTransactionManager org.springframework.transaction.JtaTransactionManager = org.springframework.transaction.JtaTransactionManager ( org.springframework.transaction.UserTransaction , org.springframework.transaction.TransactionManager ) ; TransactionTemplate org.springframework.transaction.TransactionTemplate = new TransactionTemplate ( org.springframework.transaction.JtaTransactionManager ) ; assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; org.springframework.transaction.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { assertTrue ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; TransactionSynchronizationManager . registerSynchronization ( org.springframework.transaction.TransactionSynchronization ) ; org.springframework.transaction.TransactionStatus . setRollbackOnly ( ) ; } } ) ; assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertNotNull ( org.springframework.transaction.MockJtaTransaction . getSynchronization ( ) ) ; org.springframework.transaction.MockJtaTransaction . getSynchronization ( ) . beforeCompletion ( ) ; org.springframework.transaction.MockJtaTransaction . getSynchronization ( ) . afterCompletion ( Status . STATUS_ROLLEDBACK ) ; verify ( org.springframework.transaction.UserTransaction ) . setRollbackOnly ( ) ; verify ( org.springframework.transaction.TransactionSynchronization ) . beforeCompletion ( ) ; verify ( org.springframework.transaction.TransactionSynchronization ) . afterCompletion ( TransactionSynchronization . STATUS_ROLLED_BACK ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { assertTrue ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; TransactionSynchronizationManager . registerSynchronization ( org.springframework.transaction.TransactionSynchronization ) ; org.springframework.transaction.TransactionStatus . setRollbackOnly ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { UserTransaction org.springframework.transaction.UserTransaction = mock ( UserTransaction .class ) ; given ( org.springframework.transaction.UserTransaction . getStatus ( ) ) . willReturn ( Status . STATUS_ACTIVE ) ; final TransactionSynchronization org.springframework.transaction.TransactionSynchronization = mock ( TransactionSynchronization .class ) ; JtaTransactionManager org.springframework.transaction.JtaTransactionManager = org.springframework.transaction.JtaTransactionManager ( org.springframework.transaction.UserTransaction ) ; TransactionTemplate org.springframework.transaction.TransactionTemplate = new TransactionTemplate ( org.springframework.transaction.JtaTransactionManager ) ; org.springframework.transaction.JtaTransactionManager . setTransactionSynchronization ( JtaTransactionManager . SYNCHRONIZATION_ON_ACTUAL_TRANSACTION ) ; assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; org.springframework.transaction.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { assertTrue ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; TransactionSynchronizationManager . registerSynchronization ( org.springframework.transaction.TransactionSynchronization ) ; org.springframework.transaction.TransactionStatus . setRollbackOnly ( ) ; } } ) ; assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; verify ( org.springframework.transaction.UserTransaction ) . setRollbackOnly ( ) ; verify ( org.springframework.transaction.TransactionSynchronization ) . beforeCompletion ( ) ; verify ( org.springframework.transaction.TransactionSynchronization ) . afterCompletion ( TransactionSynchronization . STATUS_UNKNOWN ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { assertTrue ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; TransactionSynchronizationManager . registerSynchronization ( org.springframework.transaction.TransactionSynchronization ) ; org.springframework.transaction.TransactionStatus . setRollbackOnly ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { UserTransaction org.springframework.transaction.UserTransaction = mock ( UserTransaction .class ) ; given ( org.springframework.transaction.UserTransaction . getStatus ( ) ) . willReturn ( Status . STATUS_ACTIVE ) ; JtaTransactionManager org.springframework.transaction.JtaTransactionManager = org.springframework.transaction.JtaTransactionManager ( org.springframework.transaction.UserTransaction ) ; TransactionTemplate org.springframework.transaction.TransactionTemplate = new TransactionTemplate ( org.springframework.transaction.JtaTransactionManager ) ; org.springframework.transaction.JtaTransactionManager . setTransactionSynchronization ( JtaTransactionManager . SYNCHRONIZATION_NEVER ) ; org.springframework.transaction.JtaTransactionManager . afterPropertiesSet ( ) ; assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; org.springframework.transaction.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; org.springframework.transaction.TransactionStatus . setRollbackOnly ( ) ; } } ) ; assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; verify ( org.springframework.transaction.UserTransaction ) . setRollbackOnly ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; org.springframework.transaction.TransactionStatus . setRollbackOnly ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { UserTransaction org.springframework.transaction.UserTransaction = mock ( UserTransaction .class ) ; given ( org.springframework.transaction.UserTransaction . getStatus ( ) ) . willReturn ( Status . STATUS_ACTIVE ) ; final TransactionSynchronization org.springframework.transaction.TransactionSynchronization = mock ( TransactionSynchronization .class ) ; JtaTransactionManager org.springframework.transaction.JtaTransactionManager = org.springframework.transaction.JtaTransactionManager ( org.springframework.transaction.UserTransaction ) ; TransactionTemplate org.springframework.transaction.TransactionTemplate = new TransactionTemplate ( org.springframework.transaction.JtaTransactionManager ) ; org.springframework.transaction.TransactionTemplate . setPropagationBehavior ( TransactionDefinition . PROPAGATION_SUPPORTS ) ; assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; org.springframework.transaction.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { assertTrue ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; TransactionSynchronizationManager . registerSynchronization ( org.springframework.transaction.TransactionSynchronization ) ; org.springframework.transaction.TransactionStatus . setRollbackOnly ( ) ; } } ) ; assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; verify ( org.springframework.transaction.UserTransaction ) . setRollbackOnly ( ) ; verify ( org.springframework.transaction.TransactionSynchronization ) . beforeCompletion ( ) ; verify ( org.springframework.transaction.TransactionSynchronization ) . afterCompletion ( TransactionSynchronization . STATUS_UNKNOWN ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { assertTrue ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; TransactionSynchronizationManager . registerSynchronization ( org.springframework.transaction.TransactionSynchronization ) ; org.springframework.transaction.TransactionStatus . setRollbackOnly ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { UserTransaction org.springframework.transaction.UserTransaction = mock ( UserTransaction .class ) ; given ( org.springframework.transaction.UserTransaction . getStatus ( ) ) . willReturn ( Status . STATUS_NO_TRANSACTION ) ; final TransactionSynchronization org.springframework.transaction.TransactionSynchronization = mock ( TransactionSynchronization .class ) ; JtaTransactionManager org.springframework.transaction.JtaTransactionManager = org.springframework.transaction.JtaTransactionManager ( org.springframework.transaction.UserTransaction ) ; TransactionTemplate org.springframework.transaction.TransactionTemplate = new TransactionTemplate ( org.springframework.transaction.JtaTransactionManager ) ; org.springframework.transaction.TransactionTemplate . setPropagationBehavior ( TransactionDefinition . PROPAGATION_SUPPORTS ) ; assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; org.springframework.transaction.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { assertTrue ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; TransactionSynchronizationManager . registerSynchronization ( org.springframework.transaction.TransactionSynchronization ) ; org.springframework.transaction.TransactionStatus . setRollbackOnly ( ) ; } } ) ; assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; verify ( org.springframework.transaction.TransactionSynchronization ) . beforeCompletion ( ) ; verify ( org.springframework.transaction.TransactionSynchronization ) . afterCompletion ( TransactionSynchronization . STATUS_ROLLED_BACK ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { assertTrue ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; TransactionSynchronizationManager . registerSynchronization ( org.springframework.transaction.TransactionSynchronization ) ; org.springframework.transaction.TransactionStatus . setRollbackOnly ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { UserTransaction org.springframework.transaction.UserTransaction = mock ( UserTransaction .class ) ; given ( org.springframework.transaction.UserTransaction . getStatus ( ) ) . willReturn ( Status . STATUS_NO_TRANSACTION ) ; JtaTransactionManager org.springframework.transaction.JtaTransactionManager = org.springframework.transaction.JtaTransactionManager ( org.springframework.transaction.UserTransaction ) ; TransactionTemplate org.springframework.transaction.TransactionTemplate = new TransactionTemplate ( org.springframework.transaction.JtaTransactionManager ) ; org.springframework.transaction.JtaTransactionManager . setTransactionSynchronization ( JtaTransactionManager . SYNCHRONIZATION_ON_ACTUAL_TRANSACTION ) ; org.springframework.transaction.TransactionTemplate . setPropagationBehavior ( TransactionDefinition . PROPAGATION_SUPPORTS ) ; org.springframework.transaction.JtaTransactionManager . afterPropertiesSet ( ) ; assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; org.springframework.transaction.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; org.springframework.transaction.TransactionStatus . setRollbackOnly ( ) ; } } ) ; assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; org.springframework.transaction.TransactionStatus . setRollbackOnly ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { UserTransaction org.springframework.transaction.UserTransaction = mock ( UserTransaction .class ) ; given ( org.springframework.transaction.UserTransaction . getStatus ( ) ) . willReturn ( Status . STATUS_NO_TRANSACTION ) ; JtaTransactionManager org.springframework.transaction.JtaTransactionManager = org.springframework.transaction.JtaTransactionManager ( org.springframework.transaction.UserTransaction ) ; TransactionTemplate org.springframework.transaction.TransactionTemplate = new TransactionTemplate ( org.springframework.transaction.JtaTransactionManager ) ; org.springframework.transaction.JtaTransactionManager . setTransactionSynchronization ( JtaTransactionManager . SYNCHRONIZATION_NEVER ) ; org.springframework.transaction.TransactionTemplate . setPropagationBehavior ( TransactionDefinition . PROPAGATION_SUPPORTS ) ; org.springframework.transaction.JtaTransactionManager . afterPropertiesSet ( ) ; assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; org.springframework.transaction.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; org.springframework.transaction.TransactionStatus . setRollbackOnly ( ) ; } } ) ; assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; org.springframework.transaction.TransactionStatus . setRollbackOnly ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { UserTransaction org.springframework.transaction.UserTransaction = mock ( UserTransaction .class ) ; TransactionManager org.springframework.transaction.TransactionManager = mock ( TransactionManager .class ) ; Transaction org.springframework.transaction.Transaction = mock ( Transaction .class ) ; given ( org.springframework.transaction.UserTransaction . getStatus ( ) ) . willReturn ( Status . STATUS_ACTIVE ) ; given ( org.springframework.transaction.TransactionManager . suspend ( ) ) . willReturn ( org.springframework.transaction.Transaction ) ; JtaTransactionManager org.springframework.transaction.JtaTransactionManager = org.springframework.transaction.JtaTransactionManager ( org.springframework.transaction.UserTransaction , org.springframework.transaction.TransactionManager ) ; TransactionTemplate org.springframework.transaction.TransactionTemplate = new TransactionTemplate ( org.springframework.transaction.JtaTransactionManager ) ; org.springframework.transaction.TransactionTemplate . setPropagationBehavior ( TransactionDefinition . PROPAGATION_NOT_SUPPORTED ) ; assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; org.springframework.transaction.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { assertTrue ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; org.springframework.transaction.TransactionStatus . setRollbackOnly ( ) ; } } ) ; assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; verify ( org.springframework.transaction.TransactionManager ) . resume ( org.springframework.transaction.Transaction ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { assertTrue ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; org.springframework.transaction.TransactionStatus . setRollbackOnly ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { UserTransaction org.springframework.transaction.UserTransaction = mock ( UserTransaction .class ) ; TransactionManager org.springframework.transaction.TransactionManager = mock ( TransactionManager .class ) ; Transaction org.springframework.transaction.Transaction = mock ( Transaction .class ) ; given ( org.springframework.transaction.UserTransaction . getStatus ( ) ) . willReturn ( Status . STATUS_NO_TRANSACTION , Status . STATUS_ACTIVE , Status . STATUS_ACTIVE , Status . STATUS_ACTIVE , Status . STATUS_ACTIVE , Status . STATUS_ACTIVE ) ; given ( org.springframework.transaction.TransactionManager . suspend ( ) ) . willReturn ( org.springframework.transaction.Transaction ) ; final JtaTransactionManager org.springframework.transaction.JtaTransactionManager = org.springframework.transaction.JtaTransactionManager ( org.springframework.transaction.UserTransaction , org.springframework.transaction.TransactionManager ) ; TransactionTemplate org.springframework.transaction.TransactionTemplate = new TransactionTemplate ( org.springframework.transaction.JtaTransactionManager ) ; org.springframework.transaction.TransactionTemplate . setPropagationBehavior ( TransactionDefinition . PROPAGATION_REQUIRES_NEW ) ; org.springframework.transaction.TransactionTemplate . setName ( STRING ) ; assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; org.springframework.transaction.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { assertTrue ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertEquals ( STRING , TransactionSynchronizationManager . getCurrentTransactionName ( ) ) ; assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly ( ) ) ; TransactionTemplate org.springframework.transaction.TransactionTemplate = new TransactionTemplate ( org.springframework.transaction.JtaTransactionManager ) ; org.springframework.transaction.TransactionTemplate . setPropagationBehavior ( TransactionDefinition . PROPAGATION_REQUIRES_NEW ) ; org.springframework.transaction.TransactionTemplate . setReadOnly ( true ) ; org.springframework.transaction.TransactionTemplate . setName ( STRING ) ; org.springframework.transaction.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { assertTrue ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertEquals ( STRING , TransactionSynchronizationManager . getCurrentTransactionName ( ) ) ; assertTrue ( TransactionSynchronizationManager . isCurrentTransactionReadOnly ( ) ) ; } } ) ; assertTrue ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertEquals ( STRING , TransactionSynchronizationManager . getCurrentTransactionName ( ) ) ; assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly ( ) ) ; } } ) ; assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; verify ( org.springframework.transaction.UserTransaction , times ( NUMBER ) ) . begin ( ) ; verify ( org.springframework.transaction.UserTransaction , times ( NUMBER ) ) . commit ( ) ; verify ( org.springframework.transaction.TransactionManager ) . resume ( org.springframework.transaction.Transaction ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { assertTrue ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertEquals ( STRING , TransactionSynchronizationManager . getCurrentTransactionName ( ) ) ; assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly ( ) ) ; TransactionTemplate org.springframework.transaction.TransactionTemplate = new TransactionTemplate ( org.springframework.transaction.JtaTransactionManager ) ; org.springframework.transaction.TransactionTemplate . setPropagationBehavior ( TransactionDefinition . PROPAGATION_REQUIRES_NEW ) ; org.springframework.transaction.TransactionTemplate . setReadOnly ( true ) ; org.springframework.transaction.TransactionTemplate . setName ( STRING ) ; org.springframework.transaction.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { assertTrue ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertEquals ( STRING , TransactionSynchronizationManager . getCurrentTransactionName ( ) ) ; assertTrue ( TransactionSynchronizationManager . isCurrentTransactionReadOnly ( ) ) ; } } ) ; assertTrue ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertEquals ( STRING , TransactionSynchronizationManager . getCurrentTransactionName ( ) ) ; assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly ( ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { assertTrue ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertEquals ( STRING , TransactionSynchronizationManager . getCurrentTransactionName ( ) ) ; assertTrue ( TransactionSynchronizationManager . isCurrentTransactionReadOnly ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { UserTransaction org.springframework.transaction.UserTransaction = mock ( UserTransaction .class ) ; given ( org.springframework.transaction.UserTransaction . getStatus ( ) ) . willReturn ( Status . STATUS_NO_TRANSACTION , Status . STATUS_NO_TRANSACTION , Status . STATUS_ACTIVE , Status . STATUS_ACTIVE ) ; final JtaTransactionManager org.springframework.transaction.JtaTransactionManager = org.springframework.transaction.JtaTransactionManager ( org.springframework.transaction.UserTransaction ) ; TransactionTemplate org.springframework.transaction.TransactionTemplate = new TransactionTemplate ( org.springframework.transaction.JtaTransactionManager ) ; org.springframework.transaction.TransactionTemplate . setPropagationBehavior ( TransactionDefinition . PROPAGATION_SUPPORTS ) ; assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; org.springframework.transaction.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { assertTrue ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly ( ) ) ; assertFalse ( TransactionSynchronizationManager . isActualTransactionActive ( ) ) ; TransactionTemplate org.springframework.transaction.TransactionTemplate = new TransactionTemplate ( org.springframework.transaction.JtaTransactionManager ) ; org.springframework.transaction.TransactionTemplate . setPropagationBehavior ( TransactionDefinition . PROPAGATION_REQUIRES_NEW ) ; org.springframework.transaction.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { assertTrue ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly ( ) ) ; assertTrue ( TransactionSynchronizationManager . isActualTransactionActive ( ) ) ; } } ) ; assertTrue ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly ( ) ) ; assertFalse ( TransactionSynchronizationManager . isActualTransactionActive ( ) ) ; } } ) ; assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; verify ( org.springframework.transaction.UserTransaction ) . begin ( ) ; verify ( org.springframework.transaction.UserTransaction ) . commit ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { assertTrue ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly ( ) ) ; assertFalse ( TransactionSynchronizationManager . isActualTransactionActive ( ) ) ; TransactionTemplate org.springframework.transaction.TransactionTemplate = new TransactionTemplate ( org.springframework.transaction.JtaTransactionManager ) ; org.springframework.transaction.TransactionTemplate . setPropagationBehavior ( TransactionDefinition . PROPAGATION_REQUIRES_NEW ) ; org.springframework.transaction.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { assertTrue ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly ( ) ) ; assertTrue ( TransactionSynchronizationManager . isActualTransactionActive ( ) ) ; } } ) ; assertTrue ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly ( ) ) ; assertFalse ( TransactionSynchronizationManager . isActualTransactionActive ( ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { assertTrue ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly ( ) ) ; assertTrue ( TransactionSynchronizationManager . isActualTransactionActive ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { UserTransaction org.springframework.transaction.UserTransaction = mock ( UserTransaction .class ) ; TransactionManager org.springframework.transaction.TransactionManager = mock ( TransactionManager .class ) ; Transaction org.springframework.transaction.Transaction = mock ( Transaction .class ) ; given ( org.springframework.transaction.UserTransaction . getStatus ( ) ) . willReturn ( Status . STATUS_ACTIVE ) ; given ( org.springframework.transaction.TransactionManager . suspend ( ) ) . willReturn ( org.springframework.transaction.Transaction ) ; JtaTransactionManager org.springframework.transaction.JtaTransactionManager = org.springframework.transaction.JtaTransactionManager ( org.springframework.transaction.UserTransaction , org.springframework.transaction.TransactionManager ) ; TransactionTemplate org.springframework.transaction.TransactionTemplate = new TransactionTemplate ( org.springframework.transaction.JtaTransactionManager ) ; org.springframework.transaction.TransactionTemplate . setPropagationBehavior ( TransactionDefinition . PROPAGATION_REQUIRES_NEW ) ; assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; org.springframework.transaction.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { assertTrue ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; } } ) ; assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; verify ( org.springframework.transaction.UserTransaction ) . begin ( ) ; verify ( org.springframework.transaction.UserTransaction ) . commit ( ) ; verify ( org.springframework.transaction.TransactionManager ) . resume ( org.springframework.transaction.Transaction ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { assertTrue ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { UserTransaction org.springframework.transaction.UserTransaction = mock ( UserTransaction .class ) ; TransactionManager org.springframework.transaction.TransactionManager = mock ( TransactionManager .class ) ; given ( org.springframework.transaction.UserTransaction . getStatus ( ) ) . willReturn ( Status . STATUS_ACTIVE ) ; willThrow ( new SystemException ( ) ) . given ( org.springframework.transaction.TransactionManager ) . suspend ( ) ; JtaTransactionManager org.springframework.transaction.JtaTransactionManager = org.springframework.transaction.JtaTransactionManager ( org.springframework.transaction.UserTransaction , org.springframework.transaction.TransactionManager ) ; TransactionTemplate org.springframework.transaction.TransactionTemplate = new TransactionTemplate ( org.springframework.transaction.JtaTransactionManager ) ; org.springframework.transaction.TransactionTemplate . setPropagationBehavior ( TransactionDefinition . PROPAGATION_REQUIRES_NEW ) ; assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; try { org.springframework.transaction.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { assertTrue ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; } } ) ; fail ( STRING ) ; } catch ( TransactionSystemException org.springframework.transaction.TransactionSystemException ) { } assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { assertTrue ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { UserTransaction org.springframework.transaction.UserTransaction = mock ( UserTransaction .class ) ; TransactionManager org.springframework.transaction.TransactionManager = mock ( TransactionManager .class ) ; Transaction org.springframework.transaction.Transaction = mock ( Transaction .class ) ; given ( org.springframework.transaction.UserTransaction . getStatus ( ) ) . willReturn ( Status . STATUS_ACTIVE ) ; given ( org.springframework.transaction.TransactionManager . suspend ( ) ) . willReturn ( org.springframework.transaction.Transaction ) ; willThrow ( new SystemException ( ) ) . given ( org.springframework.transaction.UserTransaction ) . begin ( ) ; JtaTransactionManager org.springframework.transaction.JtaTransactionManager = org.springframework.transaction.JtaTransactionManager ( org.springframework.transaction.UserTransaction , org.springframework.transaction.TransactionManager ) ; TransactionTemplate org.springframework.transaction.TransactionTemplate = new TransactionTemplate ( org.springframework.transaction.JtaTransactionManager ) ; org.springframework.transaction.TransactionTemplate . setPropagationBehavior ( TransactionDefinition . PROPAGATION_REQUIRES_NEW ) ; assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; try { org.springframework.transaction.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { assertTrue ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; } } ) ; fail ( STRING ) ; } catch ( CannotCreateTransactionException org.springframework.transaction.CannotCreateTransactionException ) { } assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; verify ( org.springframework.transaction.TransactionManager ) . resume ( org.springframework.transaction.Transaction ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { assertTrue ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { TransactionManager org.springframework.transaction.TransactionManager = mock ( TransactionManager .class ) ; Transaction org.springframework.transaction.Transaction = mock ( Transaction .class ) ; given ( org.springframework.transaction.TransactionManager . getStatus ( ) ) . willReturn ( Status . STATUS_ACTIVE ) ; given ( org.springframework.transaction.TransactionManager . suspend ( ) ) . willReturn ( org.springframework.transaction.Transaction ) ; JtaTransactionManager org.springframework.transaction.JtaTransactionManager = org.springframework.transaction.JtaTransactionManager ( org.springframework.transaction.TransactionManager ) ; TransactionTemplate org.springframework.transaction.TransactionTemplate = new TransactionTemplate ( org.springframework.transaction.JtaTransactionManager ) ; org.springframework.transaction.TransactionTemplate . setPropagationBehavior ( TransactionDefinition . PROPAGATION_REQUIRES_NEW ) ; assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; org.springframework.transaction.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { assertTrue ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; } } ) ; assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; verify ( org.springframework.transaction.TransactionManager ) . begin ( ) ; verify ( org.springframework.transaction.TransactionManager ) . commit ( ) ; verify ( org.springframework.transaction.TransactionManager ) . resume ( org.springframework.transaction.Transaction ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { assertTrue ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { UserTransaction org.springframework.transaction.UserTransaction = mock ( UserTransaction .class ) ; given ( org.springframework.transaction.UserTransaction . getStatus ( ) ) . willReturn ( Status . STATUS_ACTIVE ) ; JtaTransactionManager org.springframework.transaction.JtaTransactionManager = org.springframework.transaction.JtaTransactionManager ( org.springframework.transaction.UserTransaction ) ; TransactionTemplate org.springframework.transaction.TransactionTemplate = new TransactionTemplate ( org.springframework.transaction.JtaTransactionManager ) ; org.springframework.transaction.TransactionTemplate . setPropagationBehavior ( TransactionDefinition . PROPAGATION_REQUIRES_NEW ) ; assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; try { org.springframework.transaction.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) {				} } ) ; fail ( STRING ) ; } catch ( TransactionSuspensionNotSupportedException org.springframework.transaction.TransactionSuspensionNotSupportedException ) { } assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) {				}  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { UserTransaction org.springframework.transaction.UserTransaction = mock ( UserTransaction .class ) ; given ( org.springframework.transaction.UserTransaction . getStatus ( ) ) . willReturn ( Status . STATUS_NO_TRANSACTION ) ; try { JtaTransactionManager org.springframework.transaction.JtaTransactionManager = org.springframework.transaction.JtaTransactionManager ( org.springframework.transaction.UserTransaction ) ; TransactionTemplate org.springframework.transaction.TransactionTemplate = new TransactionTemplate ( org.springframework.transaction.JtaTransactionManager ) ; org.springframework.transaction.TransactionTemplate . setIsolationLevel ( TransactionDefinition . ISOLATION_SERIALIZABLE ) ; org.springframework.transaction.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { } } ) ; fail ( STRING ) ; } catch ( InvalidIsolationLevelException org.springframework.transaction.InvalidIsolationLevelException ) { } }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { UserTransaction org.springframework.transaction.UserTransaction = mock ( UserTransaction .class ) ; given ( org.springframework.transaction.UserTransaction . getStatus ( ) ) . willThrow ( new SystemException ( STRING ) ) ; try { JtaTransactionManager org.springframework.transaction.JtaTransactionManager = org.springframework.transaction.JtaTransactionManager ( org.springframework.transaction.UserTransaction ) ; TransactionTemplate org.springframework.transaction.TransactionTemplate = new TransactionTemplate ( org.springframework.transaction.JtaTransactionManager ) ; org.springframework.transaction.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { } } ) ; fail ( STRING ) ; } catch ( TransactionSystemException org.springframework.transaction.TransactionSystemException ) { } }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { UserTransaction org.springframework.transaction.UserTransaction = mock ( UserTransaction .class ) ; given ( org.springframework.transaction.UserTransaction . getStatus ( ) ) . willReturn ( Status . STATUS_ACTIVE ) ; JtaTransactionManager org.springframework.transaction.JtaTransactionManager = org.springframework.transaction.JtaTransactionManager ( org.springframework.transaction.UserTransaction ) ; TransactionTemplate org.springframework.transaction.TransactionTemplate = new TransactionTemplate ( org.springframework.transaction.JtaTransactionManager ) ; org.springframework.transaction.TransactionTemplate . setPropagationBehavior ( TransactionDefinition . PROPAGATION_NESTED ) ; org.springframework.transaction.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { } } ) ; verify ( org.springframework.transaction.UserTransaction ) . begin ( ) ; verify ( org.springframework.transaction.UserTransaction ) . commit ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { UserTransaction org.springframework.transaction.UserTransaction = mock ( UserTransaction .class ) ; given ( org.springframework.transaction.UserTransaction . getStatus ( ) ) . willReturn ( Status . STATUS_ACTIVE ) ; willThrow ( new NotSupportedException ( STRING ) ) . given ( org.springframework.transaction.UserTransaction ) . begin ( ) ; try { JtaTransactionManager org.springframework.transaction.JtaTransactionManager = org.springframework.transaction.JtaTransactionManager ( org.springframework.transaction.UserTransaction ) ; TransactionTemplate org.springframework.transaction.TransactionTemplate = new TransactionTemplate ( org.springframework.transaction.JtaTransactionManager ) ; org.springframework.transaction.TransactionTemplate . setPropagationBehavior ( TransactionDefinition . PROPAGATION_NESTED ) ; org.springframework.transaction.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { } } ) ; fail ( STRING ) ; } catch ( NestedTransactionNotSupportedException org.springframework.transaction.NestedTransactionNotSupportedException ) { } }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { UserTransaction org.springframework.transaction.UserTransaction = mock ( UserTransaction .class ) ; given ( org.springframework.transaction.UserTransaction . getStatus ( ) ) . willReturn ( Status . STATUS_ACTIVE ) ; willThrow ( new java.lang.UnsupportedOperationException ( STRING ) ) . given ( org.springframework.transaction.UserTransaction ) . begin ( ) ; try { JtaTransactionManager org.springframework.transaction.JtaTransactionManager = org.springframework.transaction.JtaTransactionManager ( org.springframework.transaction.UserTransaction ) ; TransactionTemplate org.springframework.transaction.TransactionTemplate = new TransactionTemplate ( org.springframework.transaction.JtaTransactionManager ) ; org.springframework.transaction.TransactionTemplate . setPropagationBehavior ( TransactionDefinition . PROPAGATION_NESTED ) ; org.springframework.transaction.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { } } ) ; fail ( STRING ) ; } catch ( NestedTransactionNotSupportedException org.springframework.transaction.NestedTransactionNotSupportedException ) { } }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { UserTransaction org.springframework.transaction.UserTransaction = mock ( UserTransaction .class ) ; given ( org.springframework.transaction.UserTransaction . getStatus ( ) ) . willReturn ( Status . STATUS_NO_TRANSACTION ) ; willThrow ( new SystemException ( STRING ) ) . given ( org.springframework.transaction.UserTransaction ) . begin ( ) ; try { JtaTransactionManager org.springframework.transaction.JtaTransactionManager = org.springframework.transaction.JtaTransactionManager ( org.springframework.transaction.UserTransaction ) ; TransactionTemplate org.springframework.transaction.TransactionTemplate = new TransactionTemplate ( org.springframework.transaction.JtaTransactionManager ) ; org.springframework.transaction.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { } } ) ; fail ( STRING ) ; } catch ( CannotCreateTransactionException org.springframework.transaction.CannotCreateTransactionException ) { } }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { UserTransaction org.springframework.transaction.UserTransaction = mock ( UserTransaction .class ) ; given ( org.springframework.transaction.UserTransaction . getStatus ( ) ) . willReturn ( Status . STATUS_NO_TRANSACTION , Status . STATUS_ACTIVE , Status . STATUS_ACTIVE ) ; willThrow ( new RollbackException ( STRING ) ) . given ( org.springframework.transaction.UserTransaction ) . commit ( ) ; try { JtaTransactionManager org.springframework.transaction.JtaTransactionManager = org.springframework.transaction.JtaTransactionManager ( org.springframework.transaction.UserTransaction ) ; TransactionTemplate org.springframework.transaction.TransactionTemplate = new TransactionTemplate ( org.springframework.transaction.JtaTransactionManager ) ; org.springframework.transaction.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { TransactionSynchronizationManager . registerSynchronization ( new TransactionSynchronizationAdapter ( ) { @ java.lang.Override public void void ( int int ) { assertTrue ( STRING , int == TransactionSynchronization . STATUS_ROLLED_BACK ) ; } } ) ; } } ) ; fail ( STRING ) ; } catch ( UnexpectedRollbackException org.springframework.transaction.UnexpectedRollbackException ) { } verify ( org.springframework.transaction.UserTransaction ) . begin ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { TransactionSynchronizationManager . registerSynchronization ( new TransactionSynchronizationAdapter ( ) { @ java.lang.Override public void void ( int int ) { assertTrue ( STRING , int == TransactionSynchronization . STATUS_ROLLED_BACK ) ; } } ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( int int ) { assertTrue ( STRING , int == TransactionSynchronization . STATUS_ROLLED_BACK ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { void ( false ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { void ( true ) ; }  <METHOD_END>
<METHOD_START> private void void ( boolean boolean ) throws java.lang.Exception { UserTransaction org.springframework.transaction.UserTransaction = mock ( UserTransaction .class ) ; given ( org.springframework.transaction.UserTransaction . getStatus ( ) ) . willReturn ( Status . STATUS_NO_TRANSACTION , Status . STATUS_MARKED_ROLLBACK , Status . STATUS_MARKED_ROLLBACK , Status . STATUS_MARKED_ROLLBACK ) ; JtaTransactionManager org.springframework.transaction.JtaTransactionManager = org.springframework.transaction.JtaTransactionManager ( org.springframework.transaction.UserTransaction ) ; if ( boolean ) { org.springframework.transaction.JtaTransactionManager . setFailEarlyOnGlobalRollbackOnly ( true ) ; } TransactionStatus org.springframework.transaction.TransactionStatus = org.springframework.transaction.JtaTransactionManager . getTransaction ( new DefaultTransactionDefinition ( ) ) ; boolean boolean = false ; try { assertTrue ( STRING , org.springframework.transaction.TransactionStatus . isNewTransaction ( ) ) ; TransactionTemplate org.springframework.transaction.TransactionTemplate = new TransactionTemplate ( org.springframework.transaction.JtaTransactionManager ) ; org.springframework.transaction.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { TransactionSynchronizationManager . registerSynchronization ( new TransactionSynchronizationAdapter ( ) { @ java.lang.Override public void void ( int int ) { assertTrue ( STRING , int == TransactionSynchronization . STATUS_ROLLED_BACK ) ; } } ) ; } } ) ; boolean = true ; org.springframework.transaction.JtaTransactionManager . commit ( org.springframework.transaction.TransactionStatus ) ; fail ( STRING ) ; } catch ( UnexpectedRollbackException org.springframework.transaction.UnexpectedRollbackException ) { if ( ! boolean ) { org.springframework.transaction.JtaTransactionManager . rollback ( org.springframework.transaction.TransactionStatus ) ; } if ( boolean ) { assertFalse ( boolean ) ; } else { assertTrue ( boolean ) ; } } verify ( org.springframework.transaction.UserTransaction ) . begin ( ) ; if ( boolean ) { verify ( org.springframework.transaction.UserTransaction ) . rollback ( ) ; } else { verify ( org.springframework.transaction.UserTransaction ) . commit ( ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { TransactionSynchronizationManager . registerSynchronization ( new TransactionSynchronizationAdapter ( ) { @ java.lang.Override public void void ( int int ) { assertTrue ( STRING , int == TransactionSynchronization . STATUS_ROLLED_BACK ) ; } } ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( int int ) { assertTrue ( STRING , int == TransactionSynchronization . STATUS_ROLLED_BACK ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { UserTransaction org.springframework.transaction.UserTransaction = mock ( UserTransaction .class ) ; given ( org.springframework.transaction.UserTransaction . getStatus ( ) ) . willReturn ( Status . STATUS_NO_TRANSACTION , Status . STATUS_ACTIVE , Status . STATUS_ACTIVE ) ; willThrow ( new HeuristicMixedException ( STRING ) ) . given ( org.springframework.transaction.UserTransaction ) . commit ( ) ; try { JtaTransactionManager org.springframework.transaction.JtaTransactionManager = org.springframework.transaction.JtaTransactionManager ( org.springframework.transaction.UserTransaction ) ; TransactionTemplate org.springframework.transaction.TransactionTemplate = new TransactionTemplate ( org.springframework.transaction.JtaTransactionManager ) ; org.springframework.transaction.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { TransactionSynchronizationManager . registerSynchronization ( new TransactionSynchronizationAdapter ( ) { @ java.lang.Override public void void ( int int ) { assertTrue ( STRING , int == TransactionSynchronization . STATUS_UNKNOWN ) ; } } ) ; } } ) ; fail ( STRING ) ; } catch ( HeuristicCompletionException org.springframework.transaction.HeuristicCompletionException ) { assertTrue ( org.springframework.transaction.HeuristicCompletionException . getOutcomeState ( ) == HeuristicCompletionException . STATE_MIXED ) ; } verify ( org.springframework.transaction.UserTransaction ) . begin ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { TransactionSynchronizationManager . registerSynchronization ( new TransactionSynchronizationAdapter ( ) { @ java.lang.Override public void void ( int int ) { assertTrue ( STRING , int == TransactionSynchronization . STATUS_UNKNOWN ) ; } } ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( int int ) { assertTrue ( STRING , int == TransactionSynchronization . STATUS_UNKNOWN ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { UserTransaction org.springframework.transaction.UserTransaction = mock ( UserTransaction .class ) ; given ( org.springframework.transaction.UserTransaction . getStatus ( ) ) . willReturn ( Status . STATUS_NO_TRANSACTION , Status . STATUS_ACTIVE , Status . STATUS_ACTIVE ) ; willThrow ( new HeuristicRollbackException ( STRING ) ) . given ( org.springframework.transaction.UserTransaction ) . commit ( ) ; try { JtaTransactionManager org.springframework.transaction.JtaTransactionManager = org.springframework.transaction.JtaTransactionManager ( org.springframework.transaction.UserTransaction ) ; TransactionTemplate org.springframework.transaction.TransactionTemplate = new TransactionTemplate ( org.springframework.transaction.JtaTransactionManager ) ; org.springframework.transaction.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { TransactionSynchronizationManager . registerSynchronization ( new TransactionSynchronizationAdapter ( ) { @ java.lang.Override public void void ( int int ) { assertTrue ( STRING , int == TransactionSynchronization . STATUS_UNKNOWN ) ; } } ) ; } } ) ; fail ( STRING ) ; } catch ( HeuristicCompletionException org.springframework.transaction.HeuristicCompletionException ) { assertTrue ( org.springframework.transaction.HeuristicCompletionException . getOutcomeState ( ) == HeuristicCompletionException . STATE_ROLLED_BACK ) ; } verify ( org.springframework.transaction.UserTransaction ) . begin ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { TransactionSynchronizationManager . registerSynchronization ( new TransactionSynchronizationAdapter ( ) { @ java.lang.Override public void void ( int int ) { assertTrue ( STRING , int == TransactionSynchronization . STATUS_UNKNOWN ) ; } } ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( int int ) { assertTrue ( STRING , int == TransactionSynchronization . STATUS_UNKNOWN ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { UserTransaction org.springframework.transaction.UserTransaction = mock ( UserTransaction .class ) ; given ( org.springframework.transaction.UserTransaction . getStatus ( ) ) . willReturn ( Status . STATUS_NO_TRANSACTION , Status . STATUS_ACTIVE , Status . STATUS_ACTIVE ) ; willThrow ( new SystemException ( STRING ) ) . given ( org.springframework.transaction.UserTransaction ) . commit ( ) ; try { JtaTransactionManager org.springframework.transaction.JtaTransactionManager = org.springframework.transaction.JtaTransactionManager ( org.springframework.transaction.UserTransaction ) ; TransactionTemplate org.springframework.transaction.TransactionTemplate = new TransactionTemplate ( org.springframework.transaction.JtaTransactionManager ) ; org.springframework.transaction.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { TransactionSynchronizationManager . registerSynchronization ( new TransactionSynchronizationAdapter ( ) { @ java.lang.Override public void void ( int int ) { assertTrue ( STRING , int == TransactionSynchronization . STATUS_UNKNOWN ) ; } } ) ; } } ) ; fail ( STRING ) ; } catch ( TransactionSystemException org.springframework.transaction.TransactionSystemException ) { } verify ( org.springframework.transaction.UserTransaction ) . begin ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { TransactionSynchronizationManager . registerSynchronization ( new TransactionSynchronizationAdapter ( ) { @ java.lang.Override public void void ( int int ) { assertTrue ( STRING , int == TransactionSynchronization . STATUS_UNKNOWN ) ; } } ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( int int ) { assertTrue ( STRING , int == TransactionSynchronization . STATUS_UNKNOWN ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { UserTransaction org.springframework.transaction.UserTransaction = mock ( UserTransaction .class ) ; given ( org.springframework.transaction.UserTransaction . getStatus ( ) ) . willReturn ( Status . STATUS_NO_TRANSACTION , Status . STATUS_ACTIVE ) ; willThrow ( new SystemException ( STRING ) ) . given ( org.springframework.transaction.UserTransaction ) . rollback ( ) ; try { JtaTransactionManager org.springframework.transaction.JtaTransactionManager = org.springframework.transaction.JtaTransactionManager ( org.springframework.transaction.UserTransaction ) ; TransactionTemplate org.springframework.transaction.TransactionTemplate = new TransactionTemplate ( org.springframework.transaction.JtaTransactionManager ) ; org.springframework.transaction.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { TransactionSynchronizationManager . registerSynchronization ( new TransactionSynchronizationAdapter ( ) { @ java.lang.Override public void void ( int int ) { assertTrue ( STRING , int == TransactionSynchronization . STATUS_UNKNOWN ) ; } } ) ; org.springframework.transaction.TransactionStatus . setRollbackOnly ( ) ; } } ) ; fail ( STRING ) ; } catch ( TransactionSystemException org.springframework.transaction.TransactionSystemException ) { } verify ( org.springframework.transaction.UserTransaction ) . begin ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { TransactionSynchronizationManager . registerSynchronization ( new TransactionSynchronizationAdapter ( ) { @ java.lang.Override public void void ( int int ) { assertTrue ( STRING , int == TransactionSynchronization . STATUS_UNKNOWN ) ; } } ) ; org.springframework.transaction.TransactionStatus . setRollbackOnly ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( int int ) { assertTrue ( STRING , int == TransactionSynchronization . STATUS_UNKNOWN ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { UserTransaction org.springframework.transaction.UserTransaction = mock ( UserTransaction .class ) ; given ( org.springframework.transaction.UserTransaction . getStatus ( ) ) . willReturn ( Status . STATUS_ACTIVE ) ; willThrow ( new java.lang.IllegalStateException ( STRING ) ) . given ( org.springframework.transaction.UserTransaction ) . setRollbackOnly ( ) ; try { JtaTransactionManager org.springframework.transaction.JtaTransactionManager = org.springframework.transaction.JtaTransactionManager ( org.springframework.transaction.UserTransaction ) ; TransactionTemplate org.springframework.transaction.TransactionTemplate = new TransactionTemplate ( org.springframework.transaction.JtaTransactionManager ) ; org.springframework.transaction.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { org.springframework.transaction.TransactionStatus . setRollbackOnly ( ) ; } } ) ; fail ( STRING ) ; } catch ( TransactionSystemException org.springframework.transaction.TransactionSystemException ) { } }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { org.springframework.transaction.TransactionStatus . setRollbackOnly ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { UserTransaction org.springframework.transaction.UserTransaction = mock ( UserTransaction .class ) ; given ( org.springframework.transaction.UserTransaction . getStatus ( ) ) . willReturn ( Status . STATUS_ACTIVE ) ; willThrow ( new SystemException ( STRING ) ) . given ( org.springframework.transaction.UserTransaction ) . setRollbackOnly ( ) ; try { JtaTransactionManager org.springframework.transaction.JtaTransactionManager = org.springframework.transaction.JtaTransactionManager ( org.springframework.transaction.UserTransaction ) ; TransactionTemplate org.springframework.transaction.TransactionTemplate = new TransactionTemplate ( org.springframework.transaction.JtaTransactionManager ) ; org.springframework.transaction.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { org.springframework.transaction.TransactionStatus . setRollbackOnly ( ) ; TransactionSynchronizationManager . registerSynchronization ( new TransactionSynchronizationAdapter ( ) { @ java.lang.Override public void void ( int int ) { assertTrue ( STRING , int == TransactionSynchronization . STATUS_UNKNOWN ) ; } } ) ; } } ) ; fail ( STRING ) ; } catch ( TransactionSystemException org.springframework.transaction.TransactionSystemException ) { } }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.transaction.TransactionStatus ) { org.springframework.transaction.TransactionStatus . setRollbackOnly ( ) ; TransactionSynchronizationManager . registerSynchronization ( new TransactionSynchronizationAdapter ( ) { @ java.lang.Override public void void ( int int ) { assertTrue ( STRING , int == TransactionSynchronization . STATUS_UNKNOWN ) ; } } ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( int int ) { assertTrue ( STRING , int == TransactionSynchronization . STATUS_UNKNOWN ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { UserTransaction org.springframework.transaction.UserTransaction = mock ( UserTransaction .class ) ; given ( org.springframework.transaction.UserTransaction . getStatus ( ) ) . willReturn ( Status . STATUS_NO_TRANSACTION , Status . STATUS_ACTIVE , Status . STATUS_ACTIVE ) ; JtaTransactionManager org.springframework.transaction.JtaTransactionManager = org.springframework.transaction.JtaTransactionManager ( org.springframework.transaction.UserTransaction ) ; assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; TransactionStatus org.springframework.transaction.TransactionStatus = org.springframework.transaction.JtaTransactionManager . getTransaction ( new DefaultTransactionDefinition ( ) ) ; assertTrue ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; org.springframework.transaction.JtaTransactionManager . commit ( org.springframework.transaction.TransactionStatus ) ; assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; try { org.springframework.transaction.JtaTransactionManager . commit ( org.springframework.transaction.TransactionStatus ) ; fail ( STRING ) ; } catch ( IllegalTransactionStateException org.springframework.transaction.IllegalTransactionStateException ) { } verify ( org.springframework.transaction.UserTransaction ) . begin ( ) ; verify ( org.springframework.transaction.UserTransaction ) . commit ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { UserTransaction org.springframework.transaction.UserTransaction = mock ( UserTransaction .class ) ; given ( org.springframework.transaction.UserTransaction . getStatus ( ) ) . willReturn ( Status . STATUS_NO_TRANSACTION , Status . STATUS_ACTIVE ) ; JtaTransactionManager org.springframework.transaction.JtaTransactionManager = org.springframework.transaction.JtaTransactionManager ( org.springframework.transaction.UserTransaction ) ; assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; TransactionStatus org.springframework.transaction.TransactionStatus = org.springframework.transaction.JtaTransactionManager . getTransaction ( new DefaultTransactionDefinition ( ) ) ; assertTrue ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; org.springframework.transaction.JtaTransactionManager . rollback ( org.springframework.transaction.TransactionStatus ) ; assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; try { org.springframework.transaction.JtaTransactionManager . rollback ( org.springframework.transaction.TransactionStatus ) ; fail ( STRING ) ; } catch ( IllegalTransactionStateException org.springframework.transaction.IllegalTransactionStateException ) { } verify ( org.springframework.transaction.UserTransaction ) . begin ( ) ; verify ( org.springframework.transaction.UserTransaction ) . rollback ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { UserTransaction org.springframework.transaction.UserTransaction = mock ( UserTransaction .class ) ; given ( org.springframework.transaction.UserTransaction . getStatus ( ) ) . willReturn ( Status . STATUS_NO_TRANSACTION , Status . STATUS_ACTIVE ) ; JtaTransactionManager org.springframework.transaction.JtaTransactionManager = org.springframework.transaction.JtaTransactionManager ( org.springframework.transaction.UserTransaction ) ; assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; TransactionStatus org.springframework.transaction.TransactionStatus = org.springframework.transaction.JtaTransactionManager . getTransaction ( new DefaultTransactionDefinition ( ) ) ; assertTrue ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; org.springframework.transaction.JtaTransactionManager . rollback ( org.springframework.transaction.TransactionStatus ) ; assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; try { org.springframework.transaction.JtaTransactionManager . commit ( org.springframework.transaction.TransactionStatus ) ; fail ( STRING ) ; } catch ( IllegalTransactionStateException org.springframework.transaction.IllegalTransactionStateException ) { } verify ( org.springframework.transaction.UserTransaction ) . begin ( ) ; verify ( org.springframework.transaction.UserTransaction ) . rollback ( ) ; }  <METHOD_END>
<METHOD_START> protected org.springframework.transaction.JtaTransactionManager org.springframework.transaction.JtaTransactionManager ( UserTransaction org.springframework.transaction.UserTransaction ) { return new JtaTransactionManager ( org.springframework.transaction.UserTransaction ) ; }  <METHOD_END>
<METHOD_START> protected org.springframework.transaction.JtaTransactionManager org.springframework.transaction.JtaTransactionManager ( TransactionManager org.springframework.transaction.TransactionManager ) { return new JtaTransactionManager ( org.springframework.transaction.TransactionManager ) ; }  <METHOD_END>
<METHOD_START> protected org.springframework.transaction.JtaTransactionManager org.springframework.transaction.JtaTransactionManager ( UserTransaction org.springframework.transaction.UserTransaction , TransactionManager org.springframework.transaction.TransactionManager ) { return new JtaTransactionManager ( org.springframework.transaction.UserTransaction , org.springframework.transaction.TransactionManager ) ; }  <METHOD_END>
<METHOD_START> @ After public void void ( ) { assertTrue ( TransactionSynchronizationManager . getResourceMap ( ) . isEmpty ( ) ) ; assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertNull ( TransactionSynchronizationManager . getCurrentTransactionName ( ) ) ; assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly ( ) ) ; assertNull ( TransactionSynchronizationManager . getCurrentTransactionIsolationLevel ( ) ) ; assertFalse ( TransactionSynchronizationManager . isActualTransactionActive ( ) ) ; }  <METHOD_END>
