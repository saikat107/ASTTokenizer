<METHOD_START> public void ( Property org.springframework.data.mapping.model.Property , PersistentEntity < ? , P > org.springframework.data.mapping.model.PersistentEntity<?,P> , SimpleTypeHolder org.springframework.data.mapping.model.SimpleTypeHolder ) { super( org.springframework.data.mapping.model.Property , org.springframework.data.mapping.model.PersistentEntity<,P> , org.springframework.data.mapping.model.SimpleTypeHolder ); void ( org.springframework.data.mapping.model.Property ) ; this . java.util.Optional<org.springframework.data.mapping.model.Value> = java.util.Optional<A> ( Value .class ) ; }  <METHOD_END>
<METHOD_START> private void void ( Property org.springframework.data.mapping.model.Property ) { Optionals . toStream ( org.springframework.data.mapping.model.Property . getGetter ( ) , org.springframework.data.mapping.model.Property . getSetter ( ) ) . forEach ( it -> { for ( Annotation annotation : it . getAnnotations ( ) ) { Class < ? extends Annotation > annotationType = annotation . annotationType ( ) ; validateAnnotation ( annotation , STRING + STRING , annotationType . getSimpleName ( ) , getName ( ) , getOwner ( ) . getType ( ) . getSimpleName ( ) ) ; annotationCache . put ( annotationType , Optional . of ( AnnotatedElementUtils . findMergedAnnotation ( it , annotationType ) ) ) ; } } ) ; org.springframework.data.mapping.model.Property . getField ( ) . ifPresent ( it -> { for ( Annotation annotation : it . getAnnotations ( ) ) { Class < ? extends Annotation > annotationType = annotation . annotationType ( ) ; validateAnnotation ( annotation , STRING + STRING , annotationType . getSimpleName ( ) , it . getName ( ) , getOwner ( ) . getType ( ) . getSimpleName ( ) ) ; annotationCache . put ( annotationType , Optional . of ( AnnotatedElementUtils . findMergedAnnotation ( it , annotationType ) ) ) ; } } ) ; }  <METHOD_END>
<METHOD_START> private void void ( java.lang.annotation.Annotation java.lang.annotation.Annotation , java.lang.String java.lang.String , java.lang.Object ... java.lang.Object[] ) { java.lang.Class<? extends java.lang.annotation.Annotation> < ? extends java.lang.annotation.Annotation > java.lang.Class<? extends java.lang.annotation.Annotation> = java.lang.annotation.Annotation . java.lang.Class<? extends java.lang.annotation.Annotation> ( ) ; if ( ! java.lang.Class<> . java.lang.String ( ) . boolean ( java.lang.String ) ) { return; } if ( java.util.Map<java.lang.Class<? extends java.lang.annotation.Annotation>,java.util.Optional<? extends java.lang.annotation.Annotation>> . boolean ( java.lang.Class<> ) && ! java.util.Map<java.lang.Class<? extends java.lang.annotation.Annotation>,java.util.Optional<? extends java.lang.annotation.Annotation>> . java.util.Optional<? extends java.lang.annotation.Annotation> ( java.lang.Class<> ) . boolean ( java.util.Optional . java.util.Optional<java.lang.annotation.Annotation> ( java.lang.annotation.Annotation ) ) ) { throw new MappingException ( java.lang.String . java.lang.String ( java.lang.String , java.lang.Object[] ) ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.util.Optional<java.lang.String> < java.lang.String > java.util.Optional<java.lang.String> ( ) { return java.util.Optional<org.springframework.data.mapping.model.Value> . map ( Value :: value ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( ) { return org.springframework.data.mapping.model.Lazy<java.lang.Boolean> . get ( ) ; }  <METHOD_END>
<METHOD_START> public boolean boolean ( ) { return boolean ( Id .class ) ; }  <METHOD_END>
<METHOD_START> public boolean boolean ( ) { return boolean ( Version .class ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( ) { return ! boolean ( ) && boolean ( Reference .class ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( ) { return ! boolean ( ) && ! boolean ( ReadOnlyProperty .class ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.SuppressWarnings ( STRING ) public < A extends java.lang.annotation.Annotation > java.util.Optional<A> < A > java.util.Optional<A> ( java.lang.Class<A> < A > java.lang.Class<A> ) { Assert . notNull ( java.lang.Class<A> , STRING ) ; if ( java.util.Map<java.lang.Class<? extends java.lang.annotation.Annotation>,java.util.Optional<? extends java.lang.annotation.Annotation>> != null && java.util.Map<java.lang.Class<? extends java.lang.annotation.Annotation>,java.util.Optional<? extends java.lang.annotation.Annotation>> . boolean ( java.lang.Class<A> ) ) { return ( java.util.Optional<A> < A > ) java.util.Map<java.lang.Class<? extends java.lang.annotation.Annotation>,java.util.Optional<? extends java.lang.annotation.Annotation>> . java.util.Optional<? extends java.lang.annotation.Annotation> ( java.lang.Class<A> ) ; } return java.util.Optional ( java.lang.Class<A> , java.util.stream.Stream<java.util.Optional<? extends java.lang.reflect.AnnotatedElement>> ( ) . java.util.stream.Stream<java.lang.Object> ( java.util.Optional<? extends java.lang.reflect.AnnotatedElement> -> java.util.Optional<> . java.util.Optional<java.lang.Object> ( inner -> AnnotatedElementUtils . findMergedAnnotation ( inner , java.lang.Class<A> ) ) ) . flatMap ( Optionals :: toStream ) . findFirst ( ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public < A extends java.lang.annotation.Annotation > java.util.Optional<A> < A > java.util.Optional<A> ( java.lang.Class<A> < A > java.lang.Class<A> ) { java.util.Optional<A> < A > java.util.Optional<A> = java.util.Optional<A> ( java.lang.Class<A> ) ; return java.util.Optional<A> . boolean ( ) ? java.util.Optional<A> : getOwner ( ) . findAnnotation ( java.lang.Class<A> ) ; }  <METHOD_END>
<METHOD_START> private < A extends java.lang.annotation.Annotation > java.util.Optional<A> < A > java.util.Optional<A> ( java.lang.Class<? extends A> < ? extends A > java.lang.Class<? extends A> , java.util.Optional<A> < A > java.util.Optional<A> ) { if ( java.util.Map<java.lang.Class<? extends java.lang.annotation.Annotation>,java.util.Optional<? extends java.lang.annotation.Annotation>> != null ) { java.util.Map<java.lang.Class<? extends java.lang.annotation.Annotation>,java.util.Optional<? extends java.lang.annotation.Annotation>> . java.util.Optional<? extends java.lang.annotation.Annotation> ( java.lang.Class<> , java.util.Optional<A> ) ; } return java.util.Optional<A> ; }  <METHOD_END>
<METHOD_START> public boolean boolean ( java.lang.Class<? extends java.lang.annotation.Annotation> < ? extends java.lang.annotation.Annotation > java.lang.Class<? extends java.lang.annotation.Annotation> ) { return java.util.Optional<> ( java.lang.Class<> ) . boolean ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( ) { return org.springframework.data.mapping.model.Lazy<java.lang.Boolean> . get ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.String java.lang.String ( ) { if ( java.util.Map<java.lang.Class<? extends java.lang.annotation.Annotation>,java.util.Optional<? extends java.lang.annotation.Annotation>> . boolean ( ) ) { void ( getProperty ( ) ) ; } java.lang.String java.lang.String = java.util.Map<java.lang.Class<? extends java.lang.annotation.Annotation>,java.util.Optional<? extends java.lang.annotation.Annotation>> . java.util.Collection<java.util.Optional<? extends java.lang.annotation.Annotation>> ( ) . java.util.stream.Stream<java.util.Optional<? extends java.lang.annotation.Annotation>> ( ) . java.util.stream.Stream<java.lang.Object> ( java.util.Optional<? extends java.lang.annotation.Annotation> -> Optionals . toStream ( java.util.Optional<> ) ) . map ( java.lang.Object :: java.lang.String ) . collect ( java.util.stream.Collectors . java.util.stream.Collector<java.lang.CharSequence,?,java.lang.String> ( STRING ) ) ; return java.lang.String + super. java.lang.String ( ) ; }  <METHOD_END>
<METHOD_START> private java.util.stream.Stream<java.util.Optional<? extends java.lang.reflect.AnnotatedElement>> < java.util.Optional<? extends java.lang.reflect.AnnotatedElement> < ? extends java.lang.reflect.AnnotatedElement > > java.util.stream.Stream<java.util.Optional<? extends java.lang.reflect.AnnotatedElement>> ( ) { return java.util.Arrays .< java.util.Optional<? extends java.lang.reflect.AnnotatedElement> < ? extends java.lang.reflect.AnnotatedElement > > java.util.List<java.util.Optional<? extends java.lang.reflect.AnnotatedElement>> ( getGetter ( ) , getSetter ( ) , getField ( ) ) . stream ( ) ; }  <METHOD_END>
