<METHOD_START> @ Test public void void ( ) java.lang.Exception { BeanFactory org.springframework.integration.jms.BeanFactory = mock ( BeanFactory .class ) ; when ( org.springframework.integration.jms.BeanFactory . containsBean ( IntegrationContextUtils . TASK_SCHEDULER_BEAN_NAME ) ) . thenReturn ( true ) ; ThreadPoolTaskScheduler org.springframework.integration.jms.ThreadPoolTaskScheduler = new ThreadPoolTaskScheduler ( ) ; org.springframework.integration.jms.ThreadPoolTaskScheduler . initialize ( ) ; when ( org.springframework.integration.jms.BeanFactory . getBean ( IntegrationContextUtils . TASK_SCHEDULER_BEAN_NAME , TaskScheduler .class ) ) . thenReturn ( org.springframework.integration.jms.ThreadPoolTaskScheduler ) ; final JmsOutboundGateway org.springframework.integration.jms.JmsOutboundGateway = new JmsOutboundGateway ( ) ; org.springframework.integration.jms.JmsOutboundGateway . setBeanFactory ( org.springframework.integration.jms.BeanFactory ) ; ConnectionFactory org.springframework.integration.jms.ConnectionFactory = org.springframework.integration.jms.ConnectionFactory ( ) ; org.springframework.integration.jms.JmsOutboundGateway . setConnectionFactory ( org.springframework.integration.jms.ConnectionFactory ) ; org.springframework.integration.jms.JmsOutboundGateway . setRequestDestination ( org.springframework.integration.jms.Destination ) ; org.springframework.integration.jms.JmsOutboundGateway . setReplyDestination ( org.springframework.integration.jms.Destination ) ; org.springframework.integration.jms.JmsOutboundGateway . setCorrelationKey ( STRING ) ; org.springframework.integration.jms.JmsOutboundGateway . setUseReplyContainer ( true ) ; org.springframework.integration.jms.JmsOutboundGateway . afterPropertiesSet ( ) ; org.springframework.integration.jms.JmsOutboundGateway . start ( ) ; final java.util.concurrent.atomic.AtomicReference<java.lang.Object> < java.lang.Object > java.util.concurrent.atomic.AtomicReference<java.lang.Object> = new java.util.concurrent.atomic.AtomicReference<java.lang.Object> < java.lang.Object > ( ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . void ( ( ) { java.util.concurrent.CountDownLatch . void ( ) ; try { java.util.concurrent.atomic.AtomicReference<java.lang.Object> . void ( org.springframework.integration.jms.JmsOutboundGateway . handleRequestMessage ( new GenericMessage < java.lang.String > ( STRING ) ) ) ; } finally { java.util.concurrent.CountDownLatch . void ( ) ; } } ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; JmsTemplate org.springframework.integration.jms.JmsTemplate = new JmsTemplate ( ) ; org.springframework.integration.jms.JmsTemplate . setConnectionFactory ( org.springframework.integration.jms.ConnectionFactory ) ; org.springframework.integration.jms.JmsTemplate . setReceiveTimeout ( NUMBER ) ; javax . javax.jms . javax.jms javax.jms.Message = org.springframework.integration.jms.JmsTemplate . receive ( org.springframework.integration.jms.Destination ) ; assertNotNull ( javax.jms.Message ) ; final javax . javax.jms . javax.jms javax.jms.Message = javax.jms.Message ; org.springframework.integration.jms.JmsTemplate . send ( javax.jms.Message . getJMSReplyTo ( ) , ( MessageCreator ) session -> jmsReply ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; assertNotNull ( java.util.concurrent.atomic.AtomicReference<java.lang.Object> . java.lang.Object ( ) ) ; org.springframework.integration.jms.JmsOutboundGateway . stop ( ) ; org.springframework.integration.jms.ThreadPoolTaskScheduler . destroy ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { BeanFactory org.springframework.integration.jms.BeanFactory = mock ( BeanFactory .class ) ; when ( org.springframework.integration.jms.BeanFactory . containsBean ( IntegrationContextUtils . TASK_SCHEDULER_BEAN_NAME ) ) . thenReturn ( true ) ; ThreadPoolTaskScheduler org.springframework.integration.jms.ThreadPoolTaskScheduler = new ThreadPoolTaskScheduler ( ) ; org.springframework.integration.jms.ThreadPoolTaskScheduler . initialize ( ) ; when ( org.springframework.integration.jms.BeanFactory . getBean ( IntegrationContextUtils . TASK_SCHEDULER_BEAN_NAME , TaskScheduler .class ) ) . thenReturn ( org.springframework.integration.jms.ThreadPoolTaskScheduler ) ; final JmsOutboundGateway org.springframework.integration.jms.JmsOutboundGateway = new JmsOutboundGateway ( ) ; org.springframework.integration.jms.JmsOutboundGateway . setBeanFactory ( org.springframework.integration.jms.BeanFactory ) ; org.springframework.integration.jms.JmsOutboundGateway . setConnectionFactory ( org.springframework.integration.jms.ConnectionFactory ( ) ) ; org.springframework.integration.jms.JmsOutboundGateway . setRequestDestination ( org.springframework.integration.jms.Destination ) ; org.springframework.integration.jms.JmsOutboundGateway . setReplyDestination ( org.springframework.integration.jms.Destination ) ; org.springframework.integration.jms.JmsOutboundGateway . setUseReplyContainer ( true ) ; org.springframework.integration.jms.JmsOutboundGateway . afterPropertiesSet ( ) ; org.springframework.integration.jms.JmsOutboundGateway . start ( ) ; final java.util.concurrent.atomic.AtomicReference<java.lang.Object> < java.lang.Object > java.util.concurrent.atomic.AtomicReference<java.lang.Object> = new java.util.concurrent.atomic.AtomicReference<java.lang.Object> < java.lang.Object > ( ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . void ( ( ) { java.util.concurrent.CountDownLatch . void ( ) ; try { java.util.concurrent.atomic.AtomicReference<java.lang.Object> . void ( org.springframework.integration.jms.JmsOutboundGateway . handleRequestMessage ( new GenericMessage < java.lang.String > ( STRING ) ) ) ; } finally { java.util.concurrent.CountDownLatch . void ( ) ; } } ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; JmsTemplate org.springframework.integration.jms.JmsTemplate = new JmsTemplate ( ) ; org.springframework.integration.jms.JmsTemplate . setConnectionFactory ( org.springframework.integration.jms.ConnectionFactory ( ) ) ; org.springframework.integration.jms.JmsTemplate . setReceiveTimeout ( NUMBER ) ; javax . javax.jms . javax.jms javax.jms.Message = org.springframework.integration.jms.JmsTemplate . receive ( org.springframework.integration.jms.Destination ) ; assertNotNull ( javax.jms.Message ) ; final javax . javax.jms . javax.jms javax.jms.Message = javax.jms.Message ; org.springframework.integration.jms.JmsTemplate . send ( javax.jms.Message . getJMSReplyTo ( ) , ( MessageCreator ) session -> { jmsReply . setJMSCorrelationID ( jmsReply . getJMSMessageID ( ) ) ; return jmsReply ; } ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; assertNotNull ( java.util.concurrent.atomic.AtomicReference<java.lang.Object> . java.lang.Object ( ) ) ; org.springframework.integration.jms.JmsOutboundGateway . stop ( ) ; org.springframework.integration.jms.ThreadPoolTaskScheduler . destroy ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { BeanFactory org.springframework.integration.jms.BeanFactory = mock ( BeanFactory .class ) ; when ( org.springframework.integration.jms.BeanFactory . containsBean ( IntegrationContextUtils . TASK_SCHEDULER_BEAN_NAME ) ) . thenReturn ( true ) ; ThreadPoolTaskScheduler org.springframework.integration.jms.ThreadPoolTaskScheduler = new ThreadPoolTaskScheduler ( ) ; org.springframework.integration.jms.ThreadPoolTaskScheduler . initialize ( ) ; when ( org.springframework.integration.jms.BeanFactory . getBean ( IntegrationContextUtils . TASK_SCHEDULER_BEAN_NAME , TaskScheduler .class ) ) . thenReturn ( org.springframework.integration.jms.ThreadPoolTaskScheduler ) ; final JmsOutboundGateway org.springframework.integration.jms.JmsOutboundGateway = new JmsOutboundGateway ( ) ; org.springframework.integration.jms.JmsOutboundGateway . setBeanFactory ( org.springframework.integration.jms.BeanFactory ) ; org.springframework.integration.jms.JmsOutboundGateway . setConnectionFactory ( org.springframework.integration.jms.ConnectionFactory ( ) ) ; org.springframework.integration.jms.JmsOutboundGateway . setRequestDestination ( org.springframework.integration.jms.Destination ) ; org.springframework.integration.jms.JmsOutboundGateway . setReplyDestinationName ( STRING ) ; org.springframework.integration.jms.JmsOutboundGateway . setCorrelationKey ( STRING ) ; org.springframework.integration.jms.JmsOutboundGateway . setUseReplyContainer ( true ) ; org.springframework.integration.jms.JmsOutboundGateway . afterPropertiesSet ( ) ; org.springframework.integration.jms.JmsOutboundGateway . start ( ) ; final java.util.concurrent.atomic.AtomicReference<java.lang.Object> < java.lang.Object > java.util.concurrent.atomic.AtomicReference<java.lang.Object> = new java.util.concurrent.atomic.AtomicReference<java.lang.Object> < java.lang.Object > ( ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . void ( ( ) { java.util.concurrent.CountDownLatch . void ( ) ; try { java.util.concurrent.atomic.AtomicReference<java.lang.Object> . void ( org.springframework.integration.jms.JmsOutboundGateway . handleRequestMessage ( new GenericMessage < java.lang.String > ( STRING ) ) ) ; } finally { java.util.concurrent.CountDownLatch . void ( ) ; } } ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; JmsTemplate org.springframework.integration.jms.JmsTemplate = new JmsTemplate ( ) ; org.springframework.integration.jms.JmsTemplate . setConnectionFactory ( org.springframework.integration.jms.ConnectionFactory ( ) ) ; org.springframework.integration.jms.JmsTemplate . setReceiveTimeout ( NUMBER ) ; javax . javax.jms . javax.jms javax.jms.Message = org.springframework.integration.jms.JmsTemplate . receive ( org.springframework.integration.jms.Destination ) ; assertNotNull ( javax.jms.Message ) ; final javax . javax.jms . javax.jms javax.jms.Message = javax.jms.Message ; org.springframework.integration.jms.JmsTemplate . send ( javax.jms.Message . getJMSReplyTo ( ) , ( MessageCreator ) session -> jmsReply ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; assertNotNull ( java.util.concurrent.atomic.AtomicReference<java.lang.Object> . java.lang.Object ( ) ) ; org.springframework.integration.jms.JmsOutboundGateway . stop ( ) ; org.springframework.integration.jms.ThreadPoolTaskScheduler . destroy ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { BeanFactory org.springframework.integration.jms.BeanFactory = mock ( BeanFactory .class ) ; when ( org.springframework.integration.jms.BeanFactory . containsBean ( IntegrationContextUtils . TASK_SCHEDULER_BEAN_NAME ) ) . thenReturn ( true ) ; ThreadPoolTaskScheduler org.springframework.integration.jms.ThreadPoolTaskScheduler = new ThreadPoolTaskScheduler ( ) ; org.springframework.integration.jms.ThreadPoolTaskScheduler . initialize ( ) ; when ( org.springframework.integration.jms.BeanFactory . getBean ( IntegrationContextUtils . TASK_SCHEDULER_BEAN_NAME , TaskScheduler .class ) ) . thenReturn ( org.springframework.integration.jms.ThreadPoolTaskScheduler ) ; final JmsOutboundGateway org.springframework.integration.jms.JmsOutboundGateway = new JmsOutboundGateway ( ) ; org.springframework.integration.jms.JmsOutboundGateway . setBeanFactory ( org.springframework.integration.jms.BeanFactory ) ; org.springframework.integration.jms.JmsOutboundGateway . setConnectionFactory ( org.springframework.integration.jms.ConnectionFactory ( ) ) ; org.springframework.integration.jms.JmsOutboundGateway . setRequestDestination ( org.springframework.integration.jms.Destination ) ; org.springframework.integration.jms.JmsOutboundGateway . setReplyDestinationName ( STRING ) ; org.springframework.integration.jms.JmsOutboundGateway . setUseReplyContainer ( true ) ; org.springframework.integration.jms.JmsOutboundGateway . afterPropertiesSet ( ) ; org.springframework.integration.jms.JmsOutboundGateway . start ( ) ; final java.util.concurrent.atomic.AtomicReference<java.lang.Object> < java.lang.Object > java.util.concurrent.atomic.AtomicReference<java.lang.Object> = new java.util.concurrent.atomic.AtomicReference<java.lang.Object> < java.lang.Object > ( ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . void ( ( ) { java.util.concurrent.CountDownLatch . void ( ) ; try { java.util.concurrent.atomic.AtomicReference<java.lang.Object> . void ( org.springframework.integration.jms.JmsOutboundGateway . handleRequestMessage ( new GenericMessage < java.lang.String > ( STRING ) ) ) ; } finally { java.util.concurrent.CountDownLatch . void ( ) ; } } ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; JmsTemplate org.springframework.integration.jms.JmsTemplate = new JmsTemplate ( ) ; org.springframework.integration.jms.JmsTemplate . setConnectionFactory ( org.springframework.integration.jms.ConnectionFactory ( ) ) ; org.springframework.integration.jms.JmsTemplate . setReceiveTimeout ( NUMBER ) ; javax . javax.jms . javax.jms javax.jms.Message = org.springframework.integration.jms.JmsTemplate . receive ( org.springframework.integration.jms.Destination ) ; assertNotNull ( javax.jms.Message ) ; final javax . javax.jms . javax.jms javax.jms.Message = javax.jms.Message ; org.springframework.integration.jms.JmsTemplate . send ( javax.jms.Message . getJMSReplyTo ( ) , ( MessageCreator ) session -> { jmsReply . setJMSCorrelationID ( jmsReply . getJMSMessageID ( ) ) ; return jmsReply ; } ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; assertNotNull ( java.util.concurrent.atomic.AtomicReference<java.lang.Object> . java.lang.Object ( ) ) ; org.springframework.integration.jms.JmsOutboundGateway . stop ( ) ; org.springframework.integration.jms.ThreadPoolTaskScheduler . destroy ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { BeanFactory org.springframework.integration.jms.BeanFactory = mock ( BeanFactory .class ) ; when ( org.springframework.integration.jms.BeanFactory . containsBean ( IntegrationContextUtils . TASK_SCHEDULER_BEAN_NAME ) ) . thenReturn ( true ) ; ThreadPoolTaskScheduler org.springframework.integration.jms.ThreadPoolTaskScheduler = new ThreadPoolTaskScheduler ( ) ; org.springframework.integration.jms.ThreadPoolTaskScheduler . initialize ( ) ; when ( org.springframework.integration.jms.BeanFactory . getBean ( IntegrationContextUtils . TASK_SCHEDULER_BEAN_NAME , TaskScheduler .class ) ) . thenReturn ( org.springframework.integration.jms.ThreadPoolTaskScheduler ) ; final JmsOutboundGateway org.springframework.integration.jms.JmsOutboundGateway = new JmsOutboundGateway ( ) ; org.springframework.integration.jms.JmsOutboundGateway . setBeanFactory ( org.springframework.integration.jms.BeanFactory ) ; org.springframework.integration.jms.JmsOutboundGateway . setConnectionFactory ( org.springframework.integration.jms.ConnectionFactory ( ) ) ; org.springframework.integration.jms.JmsOutboundGateway . setRequestDestination ( org.springframework.integration.jms.Destination ) ; org.springframework.integration.jms.JmsOutboundGateway . setCorrelationKey ( STRING ) ; org.springframework.integration.jms.JmsOutboundGateway . setUseReplyContainer ( true ) ; org.springframework.integration.jms.JmsOutboundGateway . setComponentName ( STRING ) ; org.springframework.integration.jms.JmsOutboundGateway . afterPropertiesSet ( ) ; org.springframework.integration.jms.JmsOutboundGateway . start ( ) ; final java.util.concurrent.atomic.AtomicReference<java.lang.Object> < java.lang.Object > java.util.concurrent.atomic.AtomicReference<java.lang.Object> = new java.util.concurrent.atomic.AtomicReference<java.lang.Object> < java.lang.Object > ( ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . void ( ( ) { java.util.concurrent.CountDownLatch . void ( ) ; try { java.util.concurrent.atomic.AtomicReference<java.lang.Object> . void ( org.springframework.integration.jms.JmsOutboundGateway . handleRequestMessage ( new GenericMessage < java.lang.String > ( STRING ) ) ) ; } finally { java.util.concurrent.CountDownLatch . void ( ) ; } } ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; JmsTemplate org.springframework.integration.jms.JmsTemplate = new JmsTemplate ( ) ; org.springframework.integration.jms.JmsTemplate . setConnectionFactory ( org.springframework.integration.jms.ConnectionFactory ( ) ) ; org.springframework.integration.jms.JmsTemplate . setReceiveTimeout ( NUMBER ) ; javax . javax.jms . javax.jms javax.jms.Message = org.springframework.integration.jms.JmsTemplate . receive ( org.springframework.integration.jms.Destination ) ; assertNotNull ( javax.jms.Message ) ; final javax . javax.jms . javax.jms javax.jms.Message = javax.jms.Message ; org.springframework.integration.jms.JmsTemplate . send ( javax.jms.Message . getJMSReplyTo ( ) , ( MessageCreator ) session -> jmsReply ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; assertNotNull ( java.util.concurrent.atomic.AtomicReference<java.lang.Object> . java.lang.Object ( ) ) ; org.springframework.integration.jms.JmsOutboundGateway . stop ( ) ; org.springframework.integration.jms.ThreadPoolTaskScheduler . destroy ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { BeanFactory org.springframework.integration.jms.BeanFactory = mock ( BeanFactory .class ) ; when ( org.springframework.integration.jms.BeanFactory . containsBean ( IntegrationContextUtils . TASK_SCHEDULER_BEAN_NAME ) ) . thenReturn ( true ) ; ThreadPoolTaskScheduler org.springframework.integration.jms.ThreadPoolTaskScheduler = new ThreadPoolTaskScheduler ( ) ; org.springframework.integration.jms.ThreadPoolTaskScheduler . initialize ( ) ; when ( org.springframework.integration.jms.BeanFactory . getBean ( IntegrationContextUtils . TASK_SCHEDULER_BEAN_NAME , TaskScheduler .class ) ) . thenReturn ( org.springframework.integration.jms.ThreadPoolTaskScheduler ) ; final JmsOutboundGateway org.springframework.integration.jms.JmsOutboundGateway = new JmsOutboundGateway ( ) ; org.springframework.integration.jms.JmsOutboundGateway . setBeanFactory ( org.springframework.integration.jms.BeanFactory ) ; org.springframework.integration.jms.JmsOutboundGateway . setConnectionFactory ( org.springframework.integration.jms.ConnectionFactory ( ) ) ; org.springframework.integration.jms.JmsOutboundGateway . setRequestDestination ( org.springframework.integration.jms.Destination ) ; org.springframework.integration.jms.JmsOutboundGateway . setUseReplyContainer ( true ) ; org.springframework.integration.jms.JmsOutboundGateway . afterPropertiesSet ( ) ; org.springframework.integration.jms.JmsOutboundGateway . start ( ) ; final java.util.concurrent.atomic.AtomicReference<java.lang.Object> < java.lang.Object > java.util.concurrent.atomic.AtomicReference<java.lang.Object> = new java.util.concurrent.atomic.AtomicReference<java.lang.Object> < java.lang.Object > ( ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . void ( ( ) { java.util.concurrent.CountDownLatch . void ( ) ; try { java.util.concurrent.atomic.AtomicReference<java.lang.Object> . void ( org.springframework.integration.jms.JmsOutboundGateway . handleRequestMessage ( new GenericMessage < java.lang.String > ( STRING ) ) ) ; } finally { java.util.concurrent.CountDownLatch . void ( ) ; } } ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; JmsTemplate org.springframework.integration.jms.JmsTemplate = new JmsTemplate ( ) ; org.springframework.integration.jms.JmsTemplate . setConnectionFactory ( org.springframework.integration.jms.ConnectionFactory ( ) ) ; org.springframework.integration.jms.JmsTemplate . setReceiveTimeout ( NUMBER ) ; javax . javax.jms . javax.jms javax.jms.Message = org.springframework.integration.jms.JmsTemplate . receive ( org.springframework.integration.jms.Destination ) ; assertNotNull ( javax.jms.Message ) ; final javax . javax.jms . javax.jms javax.jms.Message = javax.jms.Message ; org.springframework.integration.jms.JmsTemplate . send ( javax.jms.Message . getJMSReplyTo ( ) , ( MessageCreator ) session -> { jmsReply . setJMSCorrelationID ( jmsReply . getJMSMessageID ( ) ) ; return jmsReply ; } ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; assertNotNull ( java.util.concurrent.atomic.AtomicReference<java.lang.Object> . java.lang.Object ( ) ) ; org.springframework.integration.jms.JmsOutboundGateway . stop ( ) ; org.springframework.integration.jms.ThreadPoolTaskScheduler . destroy ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { BeanFactory org.springframework.integration.jms.BeanFactory = mock ( BeanFactory .class ) ; when ( org.springframework.integration.jms.BeanFactory . containsBean ( IntegrationContextUtils . TASK_SCHEDULER_BEAN_NAME ) ) . thenReturn ( true ) ; ThreadPoolTaskScheduler org.springframework.integration.jms.ThreadPoolTaskScheduler = new ThreadPoolTaskScheduler ( ) ; org.springframework.integration.jms.ThreadPoolTaskScheduler . initialize ( ) ; when ( org.springframework.integration.jms.BeanFactory . getBean ( IntegrationContextUtils . TASK_SCHEDULER_BEAN_NAME , TaskScheduler .class ) ) . thenReturn ( org.springframework.integration.jms.ThreadPoolTaskScheduler ) ; final JmsOutboundGateway org.springframework.integration.jms.JmsOutboundGateway = new JmsOutboundGateway ( ) ; org.springframework.integration.jms.JmsOutboundGateway . setBeanFactory ( org.springframework.integration.jms.BeanFactory ) ; org.springframework.integration.jms.JmsOutboundGateway . setConnectionFactory ( org.springframework.integration.jms.ConnectionFactory ( ) ) ; org.springframework.integration.jms.JmsOutboundGateway . setRequestDestination ( org.springframework.integration.jms.Destination ) ; org.springframework.integration.jms.JmsOutboundGateway . setReplyDestination ( org.springframework.integration.jms.Destination ) ; org.springframework.integration.jms.JmsOutboundGateway . setCorrelationKey ( STRING ) ; org.springframework.integration.jms.JmsOutboundGateway . setUseReplyContainer ( true ) ; org.springframework.integration.jms.JmsOutboundGateway . setIdleReplyContainerTimeout ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ; org.springframework.integration.jms.JmsOutboundGateway . setRequiresReply ( true ) ; org.springframework.integration.jms.JmsOutboundGateway . setReceiveTimeout ( NUMBER ) ; org.springframework.integration.jms.JmsOutboundGateway . afterPropertiesSet ( ) ; org.springframework.integration.jms.JmsOutboundGateway . start ( ) ; java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . void ( ( ) { JmsTemplate org.springframework.integration.jms.JmsTemplate = new JmsTemplate ( ) ; org.springframework.integration.jms.JmsTemplate . setConnectionFactory ( org.springframework.integration.jms.ConnectionFactory ( ) ) ; org.springframework.integration.jms.JmsTemplate . setReceiveTimeout ( NUMBER ) ; void ( org.springframework.integration.jms.JmsTemplate ) ; void ( org.springframework.integration.jms.JmsTemplate ) ; } ) ; assertNotNull ( org.springframework.integration.jms.JmsOutboundGateway . handleRequestMessage ( new GenericMessage < java.lang.String > ( STRING ) ) ) ; DefaultMessageListenerContainer org.springframework.integration.jms.DefaultMessageListenerContainer = TestUtils . getPropertyValue ( org.springframework.integration.jms.JmsOutboundGateway , STRING , DefaultMessageListenerContainer .class ) ; int int = NUMBER ; while ( int ++ < NUMBER && org.springframework.integration.jms.DefaultMessageListenerContainer . isRunning ( ) ) { java.lang.Thread . void ( NUMBER ) ; } assertFalse ( org.springframework.integration.jms.DefaultMessageListenerContainer . isRunning ( ) ) ; assertNotNull ( org.springframework.integration.jms.JmsOutboundGateway . handleRequestMessage ( new GenericMessage < java.lang.String > ( STRING ) ) ) ; assertTrue ( org.springframework.integration.jms.DefaultMessageListenerContainer . isRunning ( ) ) ; org.springframework.integration.jms.JmsOutboundGateway . stop ( ) ; assertFalse ( org.springframework.integration.jms.DefaultMessageListenerContainer . isRunning ( ) ) ; org.springframework.integration.jms.ThreadPoolTaskScheduler . destroy ( ) ; }  <METHOD_END>
<METHOD_START> private void void ( JmsTemplate org.springframework.integration.jms.JmsTemplate ) { javax . javax.jms . javax.jms javax.jms.Message = org.springframework.integration.jms.JmsTemplate . receive ( org.springframework.integration.jms.Destination ) ; final javax . javax.jms . javax.jms javax.jms.Message = javax.jms.Message ; try { org.springframework.integration.jms.JmsTemplate . send ( javax.jms.Message . getJMSReplyTo ( ) , ( MessageCreator ) session -> jmsReply ) ; } catch ( JmsException | JMSException java.lang.Object ) {		} }  <METHOD_END>
<METHOD_START> private org.springframework.integration.jms.ConnectionFactory org.springframework.integration.jms.ConnectionFactory ( ) { ActiveMQConnectionFactory org.springframework.integration.jms.ActiveMQConnectionFactory = new ActiveMQConnectionFactory ( STRING ) ; CachingConnectionFactory org.springframework.integration.jms.CachingConnectionFactory = new CachingConnectionFactory ( org.springframework.integration.jms.ActiveMQConnectionFactory ) ; org.springframework.integration.jms.CachingConnectionFactory . setCacheConsumers ( false ) ; return org.springframework.integration.jms.CachingConnectionFactory ; }  <METHOD_END>
