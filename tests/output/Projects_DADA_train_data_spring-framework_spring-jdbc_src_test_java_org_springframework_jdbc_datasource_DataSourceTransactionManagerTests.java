<METHOD_START> @ Before public void void ( ) java.lang.Exception { javax.sql.DataSource = mock ( javax.sql.DataSource .class ) ; java.sql.Connection = mock ( java.sql.Connection .class ) ; given ( javax.sql.DataSource . java.sql.Connection ( ) ) . willReturn ( java.sql.Connection ) ; org.springframework.jdbc.datasource.DataSourceTransactionManager = new DataSourceTransactionManager ( javax.sql.DataSource ) ; }  <METHOD_END>
<METHOD_START> @ After public void void ( ) { assertTrue ( TransactionSynchronizationManager . getResourceMap ( ) . isEmpty ( ) ) ; assertFalse ( TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly ( ) ) ; assertFalse ( TransactionSynchronizationManager . isActualTransactionActive ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { void ( true , false , false ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { void ( false , false , false ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { void ( true , true , false ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { void ( false , true , false ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { void ( true , true , true ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { void ( false , true , true ) ; }  <METHOD_END>
<METHOD_START> private void void ( boolean boolean , boolean boolean , final boolean boolean ) throws java.lang.Exception { if ( boolean ) { given ( java.sql.Connection . boolean ( ) ) . willReturn ( boolean ) ; given ( java.sql.Connection . int ( ) ) . willReturn ( java.sql.Connection . int ) ; } if ( ! boolean || boolean ) { given ( java.sql.Connection . boolean ( ) ) . willReturn ( boolean ) ; } final javax.sql.DataSource javax.sql.DataSource = ( boolean ? new LazyConnectionDataSourceProxy ( javax.sql.DataSource ) : javax.sql.DataSource ) ; org.springframework.jdbc.datasource.DataSourceTransactionManager = new DataSourceTransactionManager ( javax.sql.DataSource ) ; TransactionTemplate org.springframework.jdbc.datasource.TransactionTemplate = new TransactionTemplate ( org.springframework.jdbc.datasource.DataSourceTransactionManager ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly ( ) ) ; assertTrue ( TransactionSynchronizationManager . isActualTransactionActive ( ) ) ; java.sql.Connection java.sql.Connection = DataSourceUtils . getConnection ( javax.sql.DataSource ) ; try { if ( boolean ) { java.sql.Connection . java.sql.Statement ( ) ; } } catch ( java.sql.SQLException java.sql.SQLException ) { throw new UncategorizedSQLException ( STRING , STRING , java.sql.SQLException ) ; } } } ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; if ( boolean && ( ! boolean || boolean ) ) { InOrder org.springframework.jdbc.datasource.InOrder = inOrder ( java.sql.Connection ) ; org.springframework.jdbc.datasource.InOrder . verify ( java.sql.Connection ) . setAutoCommit ( false ) ; org.springframework.jdbc.datasource.InOrder . verify ( java.sql.Connection ) . commit ( ) ; org.springframework.jdbc.datasource.InOrder . verify ( java.sql.Connection ) . setAutoCommit ( true ) ; } if ( boolean ) { verify ( java.sql.Connection , times ( NUMBER ) ) . close ( ) ; } else { verify ( java.sql.Connection ) . close ( ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly ( ) ) ; assertTrue ( TransactionSynchronizationManager . isActualTransactionActive ( ) ) ; java.sql.Connection java.sql.Connection = DataSourceUtils . getConnection ( javax.sql.DataSource ) ; try { if ( boolean ) { java.sql.Connection . java.sql.Statement ( ) ; } } catch ( java.sql.SQLException java.sql.SQLException ) { throw new UncategorizedSQLException ( STRING , STRING , java.sql.SQLException ) ; } }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { void ( true , false , false ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { void ( false , false , false ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { void ( true , true , false ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { void ( false , true , false ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { void ( true , true , true ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { void ( false , true , true ) ; }  <METHOD_END>
<METHOD_START> private void void ( boolean boolean , boolean boolean , final boolean boolean ) throws java.lang.Exception { if ( boolean ) { given ( java.sql.Connection . boolean ( ) ) . willReturn ( boolean ) ; given ( java.sql.Connection . int ( ) ) . willReturn ( java.sql.Connection . int ) ; } if ( ! boolean || boolean ) { given ( java.sql.Connection . boolean ( ) ) . willReturn ( boolean ) ; } final javax.sql.DataSource javax.sql.DataSource = ( boolean ? new LazyConnectionDataSourceProxy ( javax.sql.DataSource ) : javax.sql.DataSource ) ; org.springframework.jdbc.datasource.DataSourceTransactionManager = new DataSourceTransactionManager ( javax.sql.DataSource ) ; TransactionTemplate org.springframework.jdbc.datasource.TransactionTemplate = new TransactionTemplate ( org.springframework.jdbc.datasource.DataSourceTransactionManager ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; final java.lang.RuntimeException java.lang.RuntimeException = new java.lang.RuntimeException ( STRING ) ; try { org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; java.sql.Connection java.sql.Connection = DataSourceUtils . getConnection ( javax.sql.DataSource ) ; if ( boolean ) { try { java.sql.Connection . java.sql.Statement ( ) ; } catch ( java.sql.SQLException java.sql.SQLException ) { throw new UncategorizedSQLException ( STRING , STRING , java.sql.SQLException ) ; } } throw java.lang.RuntimeException ; } } ) ; fail ( STRING ) ; } catch ( java.lang.RuntimeException java.lang.RuntimeException ) { assertTrue ( STRING , java.lang.RuntimeException . boolean ( java.lang.RuntimeException ) ) ; } assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; if ( boolean && ( ! boolean || boolean ) ) { InOrder org.springframework.jdbc.datasource.InOrder = inOrder ( java.sql.Connection ) ; org.springframework.jdbc.datasource.InOrder . verify ( java.sql.Connection ) . setAutoCommit ( false ) ; org.springframework.jdbc.datasource.InOrder . verify ( java.sql.Connection ) . rollback ( ) ; org.springframework.jdbc.datasource.InOrder . verify ( java.sql.Connection ) . setAutoCommit ( true ) ; } if ( boolean ) { verify ( java.sql.Connection , times ( NUMBER ) ) . close ( ) ; } else { verify ( java.sql.Connection ) . close ( ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; java.sql.Connection java.sql.Connection = DataSourceUtils . getConnection ( javax.sql.DataSource ) ; if ( boolean ) { try { java.sql.Connection . java.sql.Statement ( ) ; } catch ( java.sql.SQLException java.sql.SQLException ) { throw new UncategorizedSQLException ( STRING , STRING , java.sql.SQLException ) ; } } throw java.lang.RuntimeException ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { org.springframework.jdbc.datasource.DataSourceTransactionManager . setTransactionSynchronization ( DataSourceTransactionManager . SYNCHRONIZATION_NEVER ) ; TransactionTemplate org.springframework.jdbc.datasource.TransactionTemplate = new TransactionTemplate ( org.springframework.jdbc.datasource.DataSourceTransactionManager ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; ConnectionHolder org.springframework.jdbc.datasource.ConnectionHolder = new ConnectionHolder ( java.sql.Connection ) ; org.springframework.jdbc.datasource.ConnectionHolder . setTransactionActive ( true ) ; TransactionSynchronizationManager . bindResource ( javax.sql.DataSource , org.springframework.jdbc.datasource.ConnectionHolder ) ; final java.lang.RuntimeException java.lang.RuntimeException = new java.lang.RuntimeException ( STRING ) ; try { org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; throw java.lang.RuntimeException ; } } ) ; fail ( STRING ) ; } catch ( java.lang.RuntimeException java.lang.RuntimeException ) { assertTrue ( STRING , ! TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertEquals ( STRING , java.lang.RuntimeException , java.lang.RuntimeException ) ; } finally { TransactionSynchronizationManager . unbindResource ( javax.sql.DataSource ) ; } assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; throw java.lang.RuntimeException ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { void ( false ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { void ( true ) ; }  <METHOD_END>
<METHOD_START> private void void ( boolean boolean ) throws java.lang.Exception { given ( java.sql.Connection . boolean ( ) ) . willReturn ( false ) ; if ( boolean ) { org.springframework.jdbc.datasource.DataSourceTransactionManager . setFailEarlyOnGlobalRollbackOnly ( true ) ; } assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; TransactionStatus org.springframework.jdbc.datasource.TransactionStatus = org.springframework.jdbc.datasource.DataSourceTransactionManager . getTransaction ( new DefaultTransactionDefinition ( ) ) ; org.springframework.jdbc.datasource.DataSourceTransactionManagerTests.TestTransactionSynchronization org.springframework.jdbc.datasource.DataSourceTransactionManagerTests.TestTransactionSynchronization = new org.springframework.jdbc.datasource.DataSourceTransactionManagerTests.TestTransactionSynchronization ( javax.sql.DataSource , TransactionSynchronization . STATUS_ROLLED_BACK ) ; TransactionSynchronizationManager . registerSynchronization ( org.springframework.jdbc.datasource.DataSourceTransactionManagerTests.TestTransactionSynchronization ) ; boolean boolean = false ; try { assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; final TransactionTemplate org.springframework.jdbc.datasource.TransactionTemplate = new TransactionTemplate ( org.springframework.jdbc.datasource.DataSourceTransactionManager ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertFalse ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isRollbackOnly ( ) ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; org.springframework.jdbc.datasource.TransactionStatus . setRollbackOnly ( ) ; } } ) ; assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isRollbackOnly ( ) ) ; } } ) ; boolean = true ; org.springframework.jdbc.datasource.DataSourceTransactionManager . commit ( org.springframework.jdbc.datasource.TransactionStatus ) ; fail ( STRING ) ; } catch ( UnexpectedRollbackException org.springframework.jdbc.datasource.UnexpectedRollbackException ) { if ( ! boolean ) { org.springframework.jdbc.datasource.DataSourceTransactionManager . rollback ( org.springframework.jdbc.datasource.TransactionStatus ) ; } if ( boolean ) { assertFalse ( boolean ) ; } else { assertTrue ( boolean ) ; } } assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertFalse ( org.springframework.jdbc.datasource.DataSourceTransactionManagerTests.TestTransactionSynchronization . boolean ) ; assertTrue ( org.springframework.jdbc.datasource.DataSourceTransactionManagerTests.TestTransactionSynchronization . boolean ) ; assertFalse ( org.springframework.jdbc.datasource.DataSourceTransactionManagerTests.TestTransactionSynchronization . boolean ) ; assertTrue ( org.springframework.jdbc.datasource.DataSourceTransactionManagerTests.TestTransactionSynchronization . boolean ) ; verify ( java.sql.Connection ) . rollback ( ) ; verify ( java.sql.Connection ) . close ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertFalse ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isRollbackOnly ( ) ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; org.springframework.jdbc.datasource.TransactionStatus . setRollbackOnly ( ) ; } } ) ; assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isRollbackOnly ( ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; org.springframework.jdbc.datasource.TransactionStatus . setRollbackOnly ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { org.springframework.jdbc.datasource.DataSourceTransactionManager . setValidateExistingTransaction ( true ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; try { final TransactionTemplate org.springframework.jdbc.datasource.TransactionTemplate = new TransactionTemplate ( org.springframework.jdbc.datasource.DataSourceTransactionManager ) ; final TransactionTemplate org.springframework.jdbc.datasource.TransactionTemplate = new TransactionTemplate ( org.springframework.jdbc.datasource.DataSourceTransactionManager ) ; org.springframework.jdbc.datasource.TransactionTemplate . setIsolationLevel ( TransactionDefinition . ISOLATION_SERIALIZABLE ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertFalse ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isRollbackOnly ( ) ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { org.springframework.jdbc.datasource.TransactionStatus . setRollbackOnly ( ) ; } } ) ; assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isRollbackOnly ( ) ) ; } } ) ; fail ( STRING ) ; } catch ( IllegalTransactionStateException org.springframework.jdbc.datasource.IllegalTransactionStateException ) { } assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; verify ( java.sql.Connection ) . rollback ( ) ; verify ( java.sql.Connection ) . close ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertFalse ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isRollbackOnly ( ) ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { org.springframework.jdbc.datasource.TransactionStatus . setRollbackOnly ( ) ; } } ) ; assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isRollbackOnly ( ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { org.springframework.jdbc.datasource.TransactionStatus . setRollbackOnly ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { willThrow ( new java.sql.SQLException ( STRING ) ) . given ( java.sql.Connection ) . setReadOnly ( true ) ; org.springframework.jdbc.datasource.DataSourceTransactionManager . setValidateExistingTransaction ( true ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; try { final TransactionTemplate org.springframework.jdbc.datasource.TransactionTemplate = new TransactionTemplate ( org.springframework.jdbc.datasource.DataSourceTransactionManager ) ; org.springframework.jdbc.datasource.TransactionTemplate . setReadOnly ( true ) ; final TransactionTemplate org.springframework.jdbc.datasource.TransactionTemplate = new TransactionTemplate ( org.springframework.jdbc.datasource.DataSourceTransactionManager ) ; org.springframework.jdbc.datasource.TransactionTemplate . setReadOnly ( false ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertFalse ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isRollbackOnly ( ) ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { org.springframework.jdbc.datasource.TransactionStatus . setRollbackOnly ( ) ; } } ) ; assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isRollbackOnly ( ) ) ; } } ) ; fail ( STRING ) ; } catch ( IllegalTransactionStateException org.springframework.jdbc.datasource.IllegalTransactionStateException ) { } assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; verify ( java.sql.Connection ) . rollback ( ) ; verify ( java.sql.Connection ) . close ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertFalse ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isRollbackOnly ( ) ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { org.springframework.jdbc.datasource.TransactionStatus . setRollbackOnly ( ) ; } } ) ; assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isRollbackOnly ( ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { org.springframework.jdbc.datasource.TransactionStatus . setRollbackOnly ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; final TransactionTemplate org.springframework.jdbc.datasource.TransactionTemplate = new TransactionTemplate ( org.springframework.jdbc.datasource.DataSourceTransactionManager ) ; org.springframework.jdbc.datasource.TransactionTemplate . setPropagationBehavior ( TransactionDefinition . PROPAGATION_REQUIRES_NEW ) ; final org.springframework.jdbc.datasource.DataSourceTransactionManagerTests.TestTransactionSynchronization org.springframework.jdbc.datasource.DataSourceTransactionManagerTests.TestTransactionSynchronization = new org.springframework.jdbc.datasource.DataSourceTransactionManagerTests.TestTransactionSynchronization ( javax.sql.DataSource , TransactionSynchronization . STATUS_COMMITTED ) { @ java.lang.Override protected void void ( int int ) { super. void ( int ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) {							} } ) ; TransactionSynchronizationManager . registerSynchronization ( new TransactionSynchronizationAdapter ( ) {								} ) ; } } ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { TransactionSynchronizationManager . registerSynchronization ( org.springframework.jdbc.datasource.DataSourceTransactionManagerTests.TestTransactionSynchronization ) ; } } ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( org.springframework.jdbc.datasource.DataSourceTransactionManagerTests.TestTransactionSynchronization . boolean ) ; assertTrue ( org.springframework.jdbc.datasource.DataSourceTransactionManagerTests.TestTransactionSynchronization . boolean ) ; assertTrue ( org.springframework.jdbc.datasource.DataSourceTransactionManagerTests.TestTransactionSynchronization . boolean ) ; assertTrue ( org.springframework.jdbc.datasource.DataSourceTransactionManagerTests.TestTransactionSynchronization . boolean ) ; assertTrue ( org.springframework.jdbc.datasource.DataSourceTransactionManagerTests.TestTransactionSynchronization . java.lang.Throwable instanceof java.lang.IllegalStateException ) ; verify ( java.sql.Connection , times ( NUMBER ) ) . commit ( ) ; verify ( java.sql.Connection , times ( NUMBER ) ) . close ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( int int ) { super. void ( int ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) {							} } ) ; TransactionSynchronizationManager . registerSynchronization ( new TransactionSynchronizationAdapter ( ) {								} ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) {							}  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { TransactionSynchronizationManager . registerSynchronization ( org.springframework.jdbc.datasource.DataSourceTransactionManagerTests.TestTransactionSynchronization ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { javax.sql.DataSource javax.sql.DataSource = mock ( javax.sql.DataSource .class ) ; final java.sql.Connection java.sql.Connection = mock ( java.sql.Connection .class ) ; given ( javax.sql.DataSource . java.sql.Connection ( ) ) . willReturn ( java.sql.Connection ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; final TransactionTemplate org.springframework.jdbc.datasource.TransactionTemplate = new TransactionTemplate ( org.springframework.jdbc.datasource.DataSourceTransactionManager ) ; final org.springframework.jdbc.datasource.DataSourceTransactionManagerTests.TestTransactionSynchronization org.springframework.jdbc.datasource.DataSourceTransactionManagerTests.TestTransactionSynchronization = new org.springframework.jdbc.datasource.DataSourceTransactionManagerTests.TestTransactionSynchronization ( javax.sql.DataSource , TransactionSynchronization . STATUS_COMMITTED ) { @ java.lang.Override protected void void ( int int ) { super. void ( int ) ; java.sql.Connection java.sql.Connection = DataSourceUtils . getConnection ( javax.sql.DataSource ) ; DataSourceUtils . releaseConnection ( java.sql.Connection , javax.sql.DataSource ) ; } } ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { TransactionSynchronizationManager . registerSynchronization ( org.springframework.jdbc.datasource.DataSourceTransactionManagerTests.TestTransactionSynchronization ) ; } } ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( org.springframework.jdbc.datasource.DataSourceTransactionManagerTests.TestTransactionSynchronization . boolean ) ; assertTrue ( org.springframework.jdbc.datasource.DataSourceTransactionManagerTests.TestTransactionSynchronization . boolean ) ; assertTrue ( org.springframework.jdbc.datasource.DataSourceTransactionManagerTests.TestTransactionSynchronization . boolean ) ; assertTrue ( org.springframework.jdbc.datasource.DataSourceTransactionManagerTests.TestTransactionSynchronization . boolean ) ; assertNull ( org.springframework.jdbc.datasource.DataSourceTransactionManagerTests.TestTransactionSynchronization . java.lang.Throwable ) ; verify ( java.sql.Connection ) . commit ( ) ; verify ( java.sql.Connection ) . close ( ) ; verify ( java.sql.Connection ) . close ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( int int ) { super. void ( int ) ; java.sql.Connection java.sql.Connection = DataSourceUtils . getConnection ( javax.sql.DataSource ) ; DataSourceUtils . releaseConnection ( java.sql.Connection , javax.sql.DataSource ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { TransactionSynchronizationManager . registerSynchronization ( org.springframework.jdbc.datasource.DataSourceTransactionManagerTests.TestTransactionSynchronization ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { org.springframework.jdbc.datasource.DataSourceTransactionManager . setTransactionSynchronization ( DataSourceTransactionManager . SYNCHRONIZATION_NEVER ) ; DataSourceTransactionManager org.springframework.jdbc.datasource.DataSourceTransactionManager = new DataSourceTransactionManager ( javax.sql.DataSource ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; TransactionStatus org.springframework.jdbc.datasource.TransactionStatus = org.springframework.jdbc.datasource.DataSourceTransactionManager . getTransaction ( new DefaultTransactionDefinition ( ) ) ; final org.springframework.jdbc.datasource.DataSourceTransactionManagerTests.TestTransactionSynchronization org.springframework.jdbc.datasource.DataSourceTransactionManagerTests.TestTransactionSynchronization = new org.springframework.jdbc.datasource.DataSourceTransactionManagerTests.TestTransactionSynchronization ( javax.sql.DataSource , TransactionSynchronization . STATUS_UNKNOWN ) ; try { assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; final TransactionTemplate org.springframework.jdbc.datasource.TransactionTemplate = new TransactionTemplate ( org.springframework.jdbc.datasource.DataSourceTransactionManager ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertFalse ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isRollbackOnly ( ) ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; org.springframework.jdbc.datasource.TransactionStatus . setRollbackOnly ( ) ; } } ) ; assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isRollbackOnly ( ) ) ; TransactionSynchronizationManager . registerSynchronization ( org.springframework.jdbc.datasource.DataSourceTransactionManagerTests.TestTransactionSynchronization ) ; } } ) ; org.springframework.jdbc.datasource.DataSourceTransactionManager . commit ( org.springframework.jdbc.datasource.TransactionStatus ) ; fail ( STRING ) ; } catch ( UnexpectedRollbackException org.springframework.jdbc.datasource.UnexpectedRollbackException ) { } assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertFalse ( org.springframework.jdbc.datasource.DataSourceTransactionManagerTests.TestTransactionSynchronization . boolean ) ; assertTrue ( org.springframework.jdbc.datasource.DataSourceTransactionManagerTests.TestTransactionSynchronization . boolean ) ; assertFalse ( org.springframework.jdbc.datasource.DataSourceTransactionManagerTests.TestTransactionSynchronization . boolean ) ; assertTrue ( org.springframework.jdbc.datasource.DataSourceTransactionManagerTests.TestTransactionSynchronization . boolean ) ; verify ( java.sql.Connection ) . rollback ( ) ; verify ( java.sql.Connection ) . close ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertFalse ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isRollbackOnly ( ) ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; org.springframework.jdbc.datasource.TransactionStatus . setRollbackOnly ( ) ; } } ) ; assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isRollbackOnly ( ) ) ; TransactionSynchronizationManager . registerSynchronization ( org.springframework.jdbc.datasource.DataSourceTransactionManagerTests.TestTransactionSynchronization ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; org.springframework.jdbc.datasource.TransactionStatus . setRollbackOnly ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final TransactionTemplate org.springframework.jdbc.datasource.TransactionTemplate = new TransactionTemplate ( org.springframework.jdbc.datasource.DataSourceTransactionManager ) ; org.springframework.jdbc.datasource.TransactionTemplate . setPropagationBehavior ( TransactionDefinition . PROPAGATION_REQUIRES_NEW ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly ( ) ) ; assertTrue ( TransactionSynchronizationManager . isActualTransactionActive ( ) ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly ( ) ) ; assertTrue ( TransactionSynchronizationManager . isActualTransactionActive ( ) ) ; org.springframework.jdbc.datasource.TransactionStatus . setRollbackOnly ( ) ; } } ) ; assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly ( ) ) ; assertTrue ( TransactionSynchronizationManager . isActualTransactionActive ( ) ) ; } } ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; verify ( java.sql.Connection ) . rollback ( ) ; verify ( java.sql.Connection ) . commit ( ) ; verify ( java.sql.Connection , times ( NUMBER ) ) . close ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly ( ) ) ; assertTrue ( TransactionSynchronizationManager . isActualTransactionActive ( ) ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly ( ) ) ; assertTrue ( TransactionSynchronizationManager . isActualTransactionActive ( ) ) ; org.springframework.jdbc.datasource.TransactionStatus . setRollbackOnly ( ) ; } } ) ; assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly ( ) ) ; assertTrue ( TransactionSynchronizationManager . isActualTransactionActive ( ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly ( ) ) ; assertTrue ( TransactionSynchronizationManager . isActualTransactionActive ( ) ) ; org.springframework.jdbc.datasource.TransactionStatus . setRollbackOnly ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.sql.Connection java.sql.Connection = mock ( java.sql.Connection .class ) ; final javax.sql.DataSource javax.sql.DataSource = mock ( javax.sql.DataSource .class ) ; given ( javax.sql.DataSource . java.sql.Connection ( ) ) . willReturn ( java.sql.Connection ) ; final TransactionTemplate org.springframework.jdbc.datasource.TransactionTemplate = new TransactionTemplate ( org.springframework.jdbc.datasource.DataSourceTransactionManager ) ; org.springframework.jdbc.datasource.TransactionTemplate . setPropagationBehavior ( TransactionDefinition . PROPAGATION_REQUIRES_NEW ) ; PlatformTransactionManager org.springframework.jdbc.datasource.PlatformTransactionManager = new DataSourceTransactionManager ( javax.sql.DataSource ) ; final TransactionTemplate org.springframework.jdbc.datasource.TransactionTemplate = new TransactionTemplate ( org.springframework.jdbc.datasource.PlatformTransactionManager ) ; org.springframework.jdbc.datasource.TransactionTemplate . setPropagationBehavior ( TransactionDefinition . PROPAGATION_REQUIRES_NEW ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly ( ) ) ; assertTrue ( TransactionSynchronizationManager . isActualTransactionActive ( ) ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly ( ) ) ; assertTrue ( TransactionSynchronizationManager . isActualTransactionActive ( ) ) ; org.springframework.jdbc.datasource.TransactionStatus . setRollbackOnly ( ) ; } } ) ; assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly ( ) ) ; assertTrue ( TransactionSynchronizationManager . isActualTransactionActive ( ) ) ; } } ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; verify ( java.sql.Connection ) . commit ( ) ; verify ( java.sql.Connection ) . close ( ) ; verify ( java.sql.Connection ) . rollback ( ) ; verify ( java.sql.Connection ) . close ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly ( ) ) ; assertTrue ( TransactionSynchronizationManager . isActualTransactionActive ( ) ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly ( ) ) ; assertTrue ( TransactionSynchronizationManager . isActualTransactionActive ( ) ) ; org.springframework.jdbc.datasource.TransactionStatus . setRollbackOnly ( ) ; } } ) ; assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly ( ) ) ; assertTrue ( TransactionSynchronizationManager . isActualTransactionActive ( ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly ( ) ) ; assertTrue ( TransactionSynchronizationManager . isActualTransactionActive ( ) ) ; org.springframework.jdbc.datasource.TransactionStatus . setRollbackOnly ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final javax.sql.DataSource javax.sql.DataSource = mock ( javax.sql.DataSource .class ) ; java.sql.SQLException java.sql.SQLException = new java.sql.SQLException ( ) ; given ( javax.sql.DataSource . java.sql.Connection ( ) ) . willThrow ( java.sql.SQLException ) ; final TransactionTemplate org.springframework.jdbc.datasource.TransactionTemplate = new TransactionTemplate ( org.springframework.jdbc.datasource.DataSourceTransactionManager ) ; org.springframework.jdbc.datasource.TransactionTemplate . setPropagationBehavior ( TransactionDefinition . PROPAGATION_REQUIRES_NEW ) ; DataSourceTransactionManager org.springframework.jdbc.datasource.DataSourceTransactionManager = new DataSourceTransactionManager ( javax.sql.DataSource ) ; org.springframework.jdbc.datasource.DataSourceTransactionManager . setTransactionSynchronization ( DataSourceTransactionManager . SYNCHRONIZATION_NEVER ) ; final TransactionTemplate org.springframework.jdbc.datasource.TransactionTemplate = new TransactionTemplate ( org.springframework.jdbc.datasource.DataSourceTransactionManager ) ; org.springframework.jdbc.datasource.TransactionTemplate . setPropagationBehavior ( TransactionDefinition . PROPAGATION_REQUIRES_NEW ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; try { org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly ( ) ) ; assertTrue ( TransactionSynchronizationManager . isActualTransactionActive ( ) ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { org.springframework.jdbc.datasource.TransactionStatus . setRollbackOnly ( ) ; } } ) ; } } ) ; fail ( STRING ) ; } catch ( CannotCreateTransactionException org.springframework.jdbc.datasource.CannotCreateTransactionException ) { assertSame ( java.sql.SQLException , org.springframework.jdbc.datasource.CannotCreateTransactionException . getCause ( ) ) ; } assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; verify ( java.sql.Connection ) . rollback ( ) ; verify ( java.sql.Connection ) . close ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly ( ) ) ; assertTrue ( TransactionSynchronizationManager . isActualTransactionActive ( ) ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { org.springframework.jdbc.datasource.TransactionStatus . setRollbackOnly ( ) ; } } ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { org.springframework.jdbc.datasource.TransactionStatus . setRollbackOnly ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final TransactionTemplate org.springframework.jdbc.datasource.TransactionTemplate = new TransactionTemplate ( org.springframework.jdbc.datasource.DataSourceTransactionManager ) ; org.springframework.jdbc.datasource.TransactionTemplate . setPropagationBehavior ( TransactionDefinition . PROPAGATION_REQUIRES_NEW ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly ( ) ) ; assertTrue ( TransactionSynchronizationManager . isActualTransactionActive ( ) ) ; org.springframework.jdbc.datasource.TransactionTemplate . setPropagationBehavior ( TransactionDefinition . PROPAGATION_NOT_SUPPORTED ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly ( ) ) ; assertFalse ( TransactionSynchronizationManager . isActualTransactionActive ( ) ) ; org.springframework.jdbc.datasource.TransactionStatus . setRollbackOnly ( ) ; } } ) ; assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly ( ) ) ; assertTrue ( TransactionSynchronizationManager . isActualTransactionActive ( ) ) ; } } ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; verify ( java.sql.Connection ) . commit ( ) ; verify ( java.sql.Connection ) . close ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly ( ) ) ; assertTrue ( TransactionSynchronizationManager . isActualTransactionActive ( ) ) ; org.springframework.jdbc.datasource.TransactionTemplate . setPropagationBehavior ( TransactionDefinition . PROPAGATION_NOT_SUPPORTED ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly ( ) ) ; assertFalse ( TransactionSynchronizationManager . isActualTransactionActive ( ) ) ; org.springframework.jdbc.datasource.TransactionStatus . setRollbackOnly ( ) ; } } ) ; assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly ( ) ) ; assertTrue ( TransactionSynchronizationManager . isActualTransactionActive ( ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly ( ) ) ; assertFalse ( TransactionSynchronizationManager . isActualTransactionActive ( ) ) ; org.springframework.jdbc.datasource.TransactionStatus . setRollbackOnly ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final TransactionTemplate org.springframework.jdbc.datasource.TransactionTemplate = new TransactionTemplate ( org.springframework.jdbc.datasource.DataSourceTransactionManager ) ; org.springframework.jdbc.datasource.TransactionTemplate . setPropagationBehavior ( TransactionDefinition . PROPAGATION_REQUIRES_NEW ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; try { org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; org.springframework.jdbc.datasource.TransactionTemplate . setPropagationBehavior ( TransactionDefinition . PROPAGATION_NEVER ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { fail ( STRING ) ; } } ) ; fail ( STRING ) ; } } ) ; } catch ( IllegalTransactionStateException org.springframework.jdbc.datasource.IllegalTransactionStateException ) { } assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; verify ( java.sql.Connection ) . rollback ( ) ; verify ( java.sql.Connection ) . close ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; org.springframework.jdbc.datasource.TransactionTemplate . setPropagationBehavior ( TransactionDefinition . PROPAGATION_NEVER ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { fail ( STRING ) ; } } ) ; fail ( STRING ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { fail ( STRING ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { TransactionTemplate org.springframework.jdbc.datasource.TransactionTemplate = new TransactionTemplate ( org.springframework.jdbc.datasource.DataSourceTransactionManager ) ; org.springframework.jdbc.datasource.TransactionTemplate . setPropagationBehavior ( TransactionDefinition . PROPAGATION_SUPPORTS ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; TransactionTemplate org.springframework.jdbc.datasource.TransactionTemplate = new TransactionTemplate ( org.springframework.jdbc.datasource.DataSourceTransactionManager ) ; org.springframework.jdbc.datasource.TransactionTemplate . setPropagationBehavior ( TransactionDefinition . PROPAGATION_REQUIRES_NEW ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertSame ( java.sql.Connection , DataSourceUtils . getConnection ( javax.sql.DataSource ) ) ; assertSame ( java.sql.Connection , DataSourceUtils . getConnection ( javax.sql.DataSource ) ) ; } } ) ; } } ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; verify ( java.sql.Connection ) . commit ( ) ; verify ( java.sql.Connection ) . close ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; TransactionTemplate org.springframework.jdbc.datasource.TransactionTemplate = new TransactionTemplate ( org.springframework.jdbc.datasource.DataSourceTransactionManager ) ; org.springframework.jdbc.datasource.TransactionTemplate . setPropagationBehavior ( TransactionDefinition . PROPAGATION_REQUIRES_NEW ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertSame ( java.sql.Connection , DataSourceUtils . getConnection ( javax.sql.DataSource ) ) ; assertSame ( java.sql.Connection , DataSourceUtils . getConnection ( javax.sql.DataSource ) ) ; } } ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertSame ( java.sql.Connection , DataSourceUtils . getConnection ( javax.sql.DataSource ) ) ; assertSame ( java.sql.Connection , DataSourceUtils . getConnection ( javax.sql.DataSource ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final java.sql.Connection java.sql.Connection = mock ( java.sql.Connection .class ) ; final java.sql.Connection java.sql.Connection = mock ( java.sql.Connection .class ) ; given ( javax.sql.DataSource . java.sql.Connection ( ) ) . willReturn ( java.sql.Connection , java.sql.Connection ) ; final TransactionTemplate org.springframework.jdbc.datasource.TransactionTemplate = new TransactionTemplate ( org.springframework.jdbc.datasource.DataSourceTransactionManager ) ; org.springframework.jdbc.datasource.TransactionTemplate . setPropagationBehavior ( TransactionDefinition . PROPAGATION_SUPPORTS ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertSame ( java.sql.Connection , DataSourceUtils . getConnection ( javax.sql.DataSource ) ) ; assertSame ( java.sql.Connection , DataSourceUtils . getConnection ( javax.sql.DataSource ) ) ; TransactionTemplate org.springframework.jdbc.datasource.TransactionTemplate = new TransactionTemplate ( org.springframework.jdbc.datasource.DataSourceTransactionManager ) ; org.springframework.jdbc.datasource.TransactionTemplate . setPropagationBehavior ( TransactionDefinition . PROPAGATION_REQUIRES_NEW ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertSame ( java.sql.Connection , DataSourceUtils . getConnection ( javax.sql.DataSource ) ) ; assertSame ( java.sql.Connection , DataSourceUtils . getConnection ( javax.sql.DataSource ) ) ; } } ) ; assertSame ( java.sql.Connection , DataSourceUtils . getConnection ( javax.sql.DataSource ) ) ; } } ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; verify ( java.sql.Connection ) . close ( ) ; verify ( java.sql.Connection ) . commit ( ) ; verify ( java.sql.Connection ) . close ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertSame ( java.sql.Connection , DataSourceUtils . getConnection ( javax.sql.DataSource ) ) ; assertSame ( java.sql.Connection , DataSourceUtils . getConnection ( javax.sql.DataSource ) ) ; TransactionTemplate org.springframework.jdbc.datasource.TransactionTemplate = new TransactionTemplate ( org.springframework.jdbc.datasource.DataSourceTransactionManager ) ; org.springframework.jdbc.datasource.TransactionTemplate . setPropagationBehavior ( TransactionDefinition . PROPAGATION_REQUIRES_NEW ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertSame ( java.sql.Connection , DataSourceUtils . getConnection ( javax.sql.DataSource ) ) ; assertSame ( java.sql.Connection , DataSourceUtils . getConnection ( javax.sql.DataSource ) ) ; } } ) ; assertSame ( java.sql.Connection , DataSourceUtils . getConnection ( javax.sql.DataSource ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertSame ( java.sql.Connection , DataSourceUtils . getConnection ( javax.sql.DataSource ) ) ; assertSame ( java.sql.Connection , DataSourceUtils . getConnection ( javax.sql.DataSource ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { given ( java.sql.Connection . int ( ) ) . willReturn ( java.sql.Connection . int ) ; given ( java.sql.Connection . boolean ( ) ) . willReturn ( true ) ; TransactionTemplate org.springframework.jdbc.datasource.TransactionTemplate = new TransactionTemplate ( org.springframework.jdbc.datasource.DataSourceTransactionManager ) ; org.springframework.jdbc.datasource.TransactionTemplate . setPropagationBehavior ( TransactionDefinition . PROPAGATION_REQUIRES_NEW ) ; org.springframework.jdbc.datasource.TransactionTemplate . setIsolationLevel ( TransactionDefinition . ISOLATION_SERIALIZABLE ) ; org.springframework.jdbc.datasource.TransactionTemplate . setReadOnly ( true ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) { assertTrue ( TransactionSynchronizationManager . isCurrentTransactionReadOnly ( ) ) ; assertTrue ( TransactionSynchronizationManager . isActualTransactionActive ( ) ) ; } } ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; InOrder org.springframework.jdbc.datasource.InOrder = inOrder ( java.sql.Connection ) ; org.springframework.jdbc.datasource.InOrder . verify ( java.sql.Connection ) . setTransactionIsolation ( java.sql.Connection . int ) ; org.springframework.jdbc.datasource.InOrder . verify ( java.sql.Connection ) . setAutoCommit ( false ) ; org.springframework.jdbc.datasource.InOrder . verify ( java.sql.Connection ) . commit ( ) ; org.springframework.jdbc.datasource.InOrder . verify ( java.sql.Connection ) . setAutoCommit ( true ) ; org.springframework.jdbc.datasource.InOrder . verify ( java.sql.Connection ) . setTransactionIsolation ( java.sql.Connection . int ) ; verify ( java.sql.Connection ) . close ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) { assertTrue ( TransactionSynchronizationManager . isCurrentTransactionReadOnly ( ) ) ; assertTrue ( TransactionSynchronizationManager . isActualTransactionActive ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { org.springframework.jdbc.datasource.DataSourceTransactionManager . setEnforceReadOnly ( true ) ; given ( java.sql.Connection . boolean ( ) ) . willReturn ( true ) ; java.sql.Statement java.sql.Statement = mock ( java.sql.Statement .class ) ; given ( java.sql.Connection . java.sql.Statement ( ) ) . willReturn ( java.sql.Statement ) ; TransactionTemplate org.springframework.jdbc.datasource.TransactionTemplate = new TransactionTemplate ( org.springframework.jdbc.datasource.DataSourceTransactionManager ) ; org.springframework.jdbc.datasource.TransactionTemplate . setPropagationBehavior ( TransactionDefinition . PROPAGATION_REQUIRES_NEW ) ; org.springframework.jdbc.datasource.TransactionTemplate . setReadOnly ( true ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) { assertTrue ( TransactionSynchronizationManager . isCurrentTransactionReadOnly ( ) ) ; assertTrue ( TransactionSynchronizationManager . isActualTransactionActive ( ) ) ; } } ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; InOrder org.springframework.jdbc.datasource.InOrder = inOrder ( java.sql.Connection , java.sql.Statement ) ; org.springframework.jdbc.datasource.InOrder . verify ( java.sql.Connection ) . setAutoCommit ( false ) ; org.springframework.jdbc.datasource.InOrder . verify ( java.sql.Statement ) . executeUpdate ( STRING ) ; org.springframework.jdbc.datasource.InOrder . verify ( java.sql.Statement ) . close ( ) ; org.springframework.jdbc.datasource.InOrder . verify ( java.sql.Connection ) . commit ( ) ; org.springframework.jdbc.datasource.InOrder . verify ( java.sql.Connection ) . setAutoCommit ( true ) ; org.springframework.jdbc.datasource.InOrder . verify ( java.sql.Connection ) . close ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) { assertTrue ( TransactionSynchronizationManager . isCurrentTransactionReadOnly ( ) ) ; assertTrue ( TransactionSynchronizationManager . isActualTransactionActive ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { void ( NUMBER ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { void ( NUMBER ) ; }  <METHOD_END>
<METHOD_START> private void void ( int int ) throws java.lang.Exception { Assume . group ( TestGroup . PERFORMANCE ) ; java.sql.PreparedStatement java.sql.PreparedStatement = mock ( java.sql.PreparedStatement .class ) ; given ( java.sql.Connection . boolean ( ) ) . willReturn ( true ) ; given ( java.sql.Connection . java.sql.PreparedStatement ( STRING ) ) . willReturn ( java.sql.PreparedStatement ) ; TransactionTemplate org.springframework.jdbc.datasource.TransactionTemplate = new TransactionTemplate ( org.springframework.jdbc.datasource.DataSourceTransactionManager ) ; org.springframework.jdbc.datasource.TransactionTemplate . setTimeout ( int ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; try { org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) { try { java.lang.Thread . void ( NUMBER ) ; } catch ( java.lang.InterruptedException java.lang.InterruptedException ) {					} try { java.sql.Connection java.sql.Connection = DataSourceUtils . getConnection ( javax.sql.DataSource ) ; java.sql.PreparedStatement java.sql.PreparedStatement = java.sql.Connection . java.sql.PreparedStatement ( STRING ) ; DataSourceUtils . applyTransactionTimeout ( java.sql.PreparedStatement , javax.sql.DataSource ) ; } catch ( java.sql.SQLException java.sql.SQLException ) { throw new DataAccessResourceFailureException ( STRING , java.sql.SQLException ) ; } } } ) ; if ( int <= NUMBER ) { fail ( STRING ) ; } } catch ( TransactionTimedOutException org.springframework.jdbc.datasource.TransactionTimedOutException ) { if ( int <= NUMBER ) { } else { throw org.springframework.jdbc.datasource.TransactionTimedOutException ; } } assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; if ( int > NUMBER ) { verify ( java.sql.PreparedStatement ) . setQueryTimeout ( int - NUMBER ) ; verify ( java.sql.Connection ) . commit ( ) ; } else { verify ( java.sql.Connection ) . rollback ( ) ; } InOrder org.springframework.jdbc.datasource.InOrder = inOrder ( java.sql.Connection ) ; org.springframework.jdbc.datasource.InOrder . verify ( java.sql.Connection ) . setAutoCommit ( false ) ; org.springframework.jdbc.datasource.InOrder . verify ( java.sql.Connection ) . setAutoCommit ( true ) ; verify ( java.sql.Connection ) . close ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) { try { java.lang.Thread . void ( NUMBER ) ; } catch ( java.lang.InterruptedException java.lang.InterruptedException ) {					} try { java.sql.Connection java.sql.Connection = DataSourceUtils . getConnection ( javax.sql.DataSource ) ; java.sql.PreparedStatement java.sql.PreparedStatement = java.sql.Connection . java.sql.PreparedStatement ( STRING ) ; DataSourceUtils . applyTransactionTimeout ( java.sql.PreparedStatement , javax.sql.DataSource ) ; } catch ( java.sql.SQLException java.sql.SQLException ) { throw new DataAccessResourceFailureException ( STRING , java.sql.SQLException ) ; } }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { given ( java.sql.Connection . boolean ( ) ) . willReturn ( true ) ; TransactionTemplate org.springframework.jdbc.datasource.TransactionTemplate = new TransactionTemplate ( org.springframework.jdbc.datasource.DataSourceTransactionManager ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) { assertEquals ( java.sql.Connection , DataSourceUtils . getConnection ( javax.sql.DataSource ) ) ; TransactionAwareDataSourceProxy org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy = new TransactionAwareDataSourceProxy ( javax.sql.DataSource ) ; try { assertEquals ( java.sql.Connection , ( ( ConnectionProxy ) org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy . getConnection ( ) ) . getTargetConnection ( ) ) ; org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy . getConnection ( ) . close ( ) ; } catch ( java.sql.SQLException java.sql.SQLException ) { throw new UncategorizedSQLException ( STRING , STRING , java.sql.SQLException ) ; } } } ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; InOrder org.springframework.jdbc.datasource.InOrder = inOrder ( java.sql.Connection ) ; org.springframework.jdbc.datasource.InOrder . verify ( java.sql.Connection ) . setAutoCommit ( false ) ; org.springframework.jdbc.datasource.InOrder . verify ( java.sql.Connection ) . commit ( ) ; org.springframework.jdbc.datasource.InOrder . verify ( java.sql.Connection ) . setAutoCommit ( true ) ; verify ( java.sql.Connection ) . close ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) { assertEquals ( java.sql.Connection , DataSourceUtils . getConnection ( javax.sql.DataSource ) ) ; TransactionAwareDataSourceProxy org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy = new TransactionAwareDataSourceProxy ( javax.sql.DataSource ) ; try { assertEquals ( java.sql.Connection , ( ( ConnectionProxy ) org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy . getConnection ( ) ) . getTargetConnection ( ) ) ; org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy . getConnection ( ) . close ( ) ; } catch ( java.sql.SQLException java.sql.SQLException ) { throw new UncategorizedSQLException ( STRING , STRING , java.sql.SQLException ) ; } }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { given ( java.sql.Connection . boolean ( ) ) . willReturn ( true ) ; final TransactionTemplate org.springframework.jdbc.datasource.TransactionTemplate = new TransactionTemplate ( org.springframework.jdbc.datasource.DataSourceTransactionManager ) ; org.springframework.jdbc.datasource.TransactionTemplate . setPropagationBehavior ( TransactionTemplate . PROPAGATION_REQUIRES_NEW ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) { assertEquals ( java.sql.Connection , DataSourceUtils . getConnection ( javax.sql.DataSource ) ) ; final TransactionAwareDataSourceProxy org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy = new TransactionAwareDataSourceProxy ( javax.sql.DataSource ) ; try { assertEquals ( java.sql.Connection , ( ( ConnectionProxy ) org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy . getConnection ( ) ) . getTargetConnection ( ) ) ; org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy . getConnection ( ) . close ( ) ; } catch ( java.sql.SQLException java.sql.SQLException ) { throw new UncategorizedSQLException ( STRING , STRING , java.sql.SQLException ) ; } org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) { assertEquals ( java.sql.Connection , DataSourceUtils . getConnection ( javax.sql.DataSource ) ) ; try { assertEquals ( java.sql.Connection , ( ( ConnectionProxy ) org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy . getConnection ( ) ) . getTargetConnection ( ) ) ; org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy . getConnection ( ) . close ( ) ; } catch ( java.sql.SQLException java.sql.SQLException ) { throw new UncategorizedSQLException ( STRING , STRING , java.sql.SQLException ) ; } } } ) ; try { assertEquals ( java.sql.Connection , ( ( ConnectionProxy ) org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy . getConnection ( ) ) . getTargetConnection ( ) ) ; org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy . getConnection ( ) . close ( ) ; } catch ( java.sql.SQLException java.sql.SQLException ) { throw new UncategorizedSQLException ( STRING , STRING , java.sql.SQLException ) ; } } } ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; InOrder org.springframework.jdbc.datasource.InOrder = inOrder ( java.sql.Connection ) ; org.springframework.jdbc.datasource.InOrder . verify ( java.sql.Connection ) . setAutoCommit ( false ) ; org.springframework.jdbc.datasource.InOrder . verify ( java.sql.Connection ) . commit ( ) ; org.springframework.jdbc.datasource.InOrder . verify ( java.sql.Connection ) . setAutoCommit ( true ) ; verify ( java.sql.Connection , times ( NUMBER ) ) . close ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) { assertEquals ( java.sql.Connection , DataSourceUtils . getConnection ( javax.sql.DataSource ) ) ; final TransactionAwareDataSourceProxy org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy = new TransactionAwareDataSourceProxy ( javax.sql.DataSource ) ; try { assertEquals ( java.sql.Connection , ( ( ConnectionProxy ) org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy . getConnection ( ) ) . getTargetConnection ( ) ) ; org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy . getConnection ( ) . close ( ) ; } catch ( java.sql.SQLException java.sql.SQLException ) { throw new UncategorizedSQLException ( STRING , STRING , java.sql.SQLException ) ; } org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) { assertEquals ( java.sql.Connection , DataSourceUtils . getConnection ( javax.sql.DataSource ) ) ; try { assertEquals ( java.sql.Connection , ( ( ConnectionProxy ) org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy . getConnection ( ) ) . getTargetConnection ( ) ) ; org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy . getConnection ( ) . close ( ) ; } catch ( java.sql.SQLException java.sql.SQLException ) { throw new UncategorizedSQLException ( STRING , STRING , java.sql.SQLException ) ; } } } ) ; try { assertEquals ( java.sql.Connection , ( ( ConnectionProxy ) org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy . getConnection ( ) ) . getTargetConnection ( ) ) ; org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy . getConnection ( ) . close ( ) ; } catch ( java.sql.SQLException java.sql.SQLException ) { throw new UncategorizedSQLException ( STRING , STRING , java.sql.SQLException ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) { assertEquals ( java.sql.Connection , DataSourceUtils . getConnection ( javax.sql.DataSource ) ) ; try { assertEquals ( java.sql.Connection , ( ( ConnectionProxy ) org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy . getConnection ( ) ) . getTargetConnection ( ) ) ; org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy . getConnection ( ) . close ( ) ; } catch ( java.sql.SQLException java.sql.SQLException ) { throw new UncategorizedSQLException ( STRING , STRING , java.sql.SQLException ) ; } }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { given ( java.sql.Connection . boolean ( ) ) . willReturn ( true ) ; final TransactionTemplate org.springframework.jdbc.datasource.TransactionTemplate = new TransactionTemplate ( org.springframework.jdbc.datasource.DataSourceTransactionManager ) ; org.springframework.jdbc.datasource.TransactionTemplate . setPropagationBehavior ( TransactionTemplate . PROPAGATION_REQUIRES_NEW ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) { assertEquals ( java.sql.Connection , DataSourceUtils . getConnection ( javax.sql.DataSource ) ) ; final TransactionAwareDataSourceProxy org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy = new TransactionAwareDataSourceProxy ( javax.sql.DataSource ) ; org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy . setReobtainTransactionalConnections ( true ) ; try { assertEquals ( java.sql.Connection , ( ( ConnectionProxy ) org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy . getConnection ( ) ) . getTargetConnection ( ) ) ; org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy . getConnection ( ) . close ( ) ; } catch ( java.sql.SQLException java.sql.SQLException ) { throw new UncategorizedSQLException ( STRING , STRING , java.sql.SQLException ) ; } org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) { assertEquals ( java.sql.Connection , DataSourceUtils . getConnection ( javax.sql.DataSource ) ) ; try { assertEquals ( java.sql.Connection , ( ( ConnectionProxy ) org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy . getConnection ( ) ) . getTargetConnection ( ) ) ; org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy . getConnection ( ) . close ( ) ; } catch ( java.sql.SQLException java.sql.SQLException ) { throw new UncategorizedSQLException ( STRING , STRING , java.sql.SQLException ) ; } } } ) ; try { assertEquals ( java.sql.Connection , ( ( ConnectionProxy ) org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy . getConnection ( ) ) . getTargetConnection ( ) ) ; org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy . getConnection ( ) . close ( ) ; } catch ( java.sql.SQLException java.sql.SQLException ) { throw new UncategorizedSQLException ( STRING , STRING , java.sql.SQLException ) ; } } } ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; InOrder org.springframework.jdbc.datasource.InOrder = inOrder ( java.sql.Connection ) ; org.springframework.jdbc.datasource.InOrder . verify ( java.sql.Connection ) . setAutoCommit ( false ) ; org.springframework.jdbc.datasource.InOrder . verify ( java.sql.Connection ) . commit ( ) ; org.springframework.jdbc.datasource.InOrder . verify ( java.sql.Connection ) . setAutoCommit ( true ) ; verify ( java.sql.Connection , times ( NUMBER ) ) . close ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) { assertEquals ( java.sql.Connection , DataSourceUtils . getConnection ( javax.sql.DataSource ) ) ; final TransactionAwareDataSourceProxy org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy = new TransactionAwareDataSourceProxy ( javax.sql.DataSource ) ; org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy . setReobtainTransactionalConnections ( true ) ; try { assertEquals ( java.sql.Connection , ( ( ConnectionProxy ) org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy . getConnection ( ) ) . getTargetConnection ( ) ) ; org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy . getConnection ( ) . close ( ) ; } catch ( java.sql.SQLException java.sql.SQLException ) { throw new UncategorizedSQLException ( STRING , STRING , java.sql.SQLException ) ; } org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) { assertEquals ( java.sql.Connection , DataSourceUtils . getConnection ( javax.sql.DataSource ) ) ; try { assertEquals ( java.sql.Connection , ( ( ConnectionProxy ) org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy . getConnection ( ) ) . getTargetConnection ( ) ) ; org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy . getConnection ( ) . close ( ) ; } catch ( java.sql.SQLException java.sql.SQLException ) { throw new UncategorizedSQLException ( STRING , STRING , java.sql.SQLException ) ; } } } ) ; try { assertEquals ( java.sql.Connection , ( ( ConnectionProxy ) org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy . getConnection ( ) ) . getTargetConnection ( ) ) ; org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy . getConnection ( ) . close ( ) ; } catch ( java.sql.SQLException java.sql.SQLException ) { throw new UncategorizedSQLException ( STRING , STRING , java.sql.SQLException ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) { assertEquals ( java.sql.Connection , DataSourceUtils . getConnection ( javax.sql.DataSource ) ) ; try { assertEquals ( java.sql.Connection , ( ( ConnectionProxy ) org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy . getConnection ( ) ) . getTargetConnection ( ) ) ; org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy . getConnection ( ) . close ( ) ; } catch ( java.sql.SQLException java.sql.SQLException ) { throw new UncategorizedSQLException ( STRING , STRING , java.sql.SQLException ) ; } }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { willThrow ( new java.sql.SQLException ( STRING ) ) . given ( java.sql.Connection ) . getAutoCommit ( ) ; TransactionTemplate org.springframework.jdbc.datasource.TransactionTemplate = new TransactionTemplate ( org.springframework.jdbc.datasource.DataSourceTransactionManager ) ; try { org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) { } } ) ; fail ( STRING ) ; } catch ( CannotCreateTransactionException org.springframework.jdbc.datasource.CannotCreateTransactionException ) { } assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; verify ( java.sql.Connection ) . close ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) { }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { willThrow ( new java.sql.SQLException ( STRING ) ) . given ( java.sql.Connection ) . commit ( ) ; TransactionTemplate org.springframework.jdbc.datasource.TransactionTemplate = new TransactionTemplate ( org.springframework.jdbc.datasource.DataSourceTransactionManager ) ; try { org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) { } } ) ; fail ( STRING ) ; } catch ( TransactionSystemException org.springframework.jdbc.datasource.TransactionSystemException ) { } assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; verify ( java.sql.Connection ) . close ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) { }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { willThrow ( new java.sql.SQLException ( STRING ) ) . given ( java.sql.Connection ) . commit ( ) ; org.springframework.jdbc.datasource.DataSourceTransactionManager . setRollbackOnCommitFailure ( true ) ; TransactionTemplate org.springframework.jdbc.datasource.TransactionTemplate = new TransactionTemplate ( org.springframework.jdbc.datasource.DataSourceTransactionManager ) ; try { org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) { } } ) ; fail ( STRING ) ; } catch ( TransactionSystemException org.springframework.jdbc.datasource.TransactionSystemException ) { } assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; verify ( java.sql.Connection ) . rollback ( ) ; verify ( java.sql.Connection ) . close ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) { }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { given ( java.sql.Connection . boolean ( ) ) . willReturn ( true ) ; willThrow ( new java.sql.SQLException ( STRING ) ) . given ( java.sql.Connection ) . rollback ( ) ; TransactionTemplate org.springframework.jdbc.datasource.TransactionTemplate = new TransactionTemplate ( org.springframework.jdbc.datasource.DataSourceTransactionManager ) ; try { org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { org.springframework.jdbc.datasource.TransactionStatus . setRollbackOnly ( ) ; } } ) ; fail ( STRING ) ; } catch ( TransactionSystemException org.springframework.jdbc.datasource.TransactionSystemException ) { } assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; InOrder org.springframework.jdbc.datasource.InOrder = inOrder ( java.sql.Connection ) ; org.springframework.jdbc.datasource.InOrder . verify ( java.sql.Connection ) . setAutoCommit ( false ) ; org.springframework.jdbc.datasource.InOrder . verify ( java.sql.Connection ) . rollback ( ) ; org.springframework.jdbc.datasource.InOrder . verify ( java.sql.Connection ) . setAutoCommit ( true ) ; verify ( java.sql.Connection ) . close ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { org.springframework.jdbc.datasource.TransactionStatus . setRollbackOnly ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { TransactionTemplate org.springframework.jdbc.datasource.TransactionTemplate = new TransactionTemplate ( org.springframework.jdbc.datasource.DataSourceTransactionManager ) ; org.springframework.jdbc.datasource.TransactionTemplate . setPropagationBehavior ( TransactionDefinition . PROPAGATION_SUPPORTS ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly ( ) ) ; assertFalse ( TransactionSynchronizationManager . isActualTransactionActive ( ) ) ; } } ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly ( ) ) ; assertFalse ( TransactionSynchronizationManager . isActualTransactionActive ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { TransactionTemplate org.springframework.jdbc.datasource.TransactionTemplate = new TransactionTemplate ( org.springframework.jdbc.datasource.DataSourceTransactionManager ) ; org.springframework.jdbc.datasource.TransactionTemplate . setPropagationBehavior ( TransactionDefinition . PROPAGATION_NOT_SUPPORTED ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; } } ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { TransactionTemplate org.springframework.jdbc.datasource.TransactionTemplate = new TransactionTemplate ( org.springframework.jdbc.datasource.DataSourceTransactionManager ) ; org.springframework.jdbc.datasource.TransactionTemplate . setPropagationBehavior ( TransactionDefinition . PROPAGATION_NEVER ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; } } ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { void ( NUMBER ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { void ( NUMBER ) ; }  <METHOD_END>
<METHOD_START> private void void ( final int int ) throws java.lang.Exception { java.sql.DatabaseMetaData java.sql.DatabaseMetaData = mock ( java.sql.DatabaseMetaData .class ) ; java.sql.Savepoint java.sql.Savepoint = mock ( java.sql.Savepoint .class ) ; given ( java.sql.DatabaseMetaData . boolean ( ) ) . willReturn ( true ) ; given ( java.sql.Connection . java.sql.DatabaseMetaData ( ) ) . willReturn ( java.sql.DatabaseMetaData ) ; for ( int int = NUMBER ; int <= int ; int ++ ) { given ( java.sql.Connection . java.sql.Savepoint ( ConnectionHolder . SAVEPOINT_NAME_PREFIX + int ) ) . willReturn ( java.sql.Savepoint ) ; } final TransactionTemplate org.springframework.jdbc.datasource.TransactionTemplate = new TransactionTemplate ( org.springframework.jdbc.datasource.DataSourceTransactionManager ) ; org.springframework.jdbc.datasource.TransactionTemplate . setPropagationBehavior ( TransactionDefinition . PROPAGATION_NESTED ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . hasSavepoint ( ) ) ; for ( int int = NUMBER ; int < int ; int ++ ) { org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . hasSavepoint ( ) ) ; } } ) ; } assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . hasSavepoint ( ) ) ; } } ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; verify ( java.sql.Connection , times ( int ) ) . releaseSavepoint ( java.sql.Savepoint ) ; verify ( java.sql.Connection ) . commit ( ) ; verify ( java.sql.Connection ) . close ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . hasSavepoint ( ) ) ; for ( int int = NUMBER ; int < int ; int ++ ) { org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . hasSavepoint ( ) ) ; } } ) ; } assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . hasSavepoint ( ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . hasSavepoint ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.sql.DatabaseMetaData java.sql.DatabaseMetaData = mock ( java.sql.DatabaseMetaData .class ) ; java.sql.Savepoint java.sql.Savepoint = mock ( java.sql.Savepoint .class ) ; given ( java.sql.DatabaseMetaData . boolean ( ) ) . willReturn ( true ) ; given ( java.sql.Connection . java.sql.DatabaseMetaData ( ) ) . willReturn ( java.sql.DatabaseMetaData ) ; given ( java.sql.Connection . java.sql.Savepoint ( STRING ) ) . willReturn ( java.sql.Savepoint ) ; final TransactionTemplate org.springframework.jdbc.datasource.TransactionTemplate = new TransactionTemplate ( org.springframework.jdbc.datasource.DataSourceTransactionManager ) ; org.springframework.jdbc.datasource.TransactionTemplate . setPropagationBehavior ( TransactionDefinition . PROPAGATION_NESTED ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . hasSavepoint ( ) ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . hasSavepoint ( ) ) ; org.springframework.jdbc.datasource.TransactionStatus . setRollbackOnly ( ) ; } } ) ; assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . hasSavepoint ( ) ) ; } } ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; verify ( java.sql.Connection ) . rollback ( java.sql.Savepoint ) ; verify ( java.sql.Connection ) . releaseSavepoint ( java.sql.Savepoint ) ; verify ( java.sql.Connection ) . commit ( ) ; verify ( java.sql.Connection ) . isReadOnly ( ) ; verify ( java.sql.Connection ) . close ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . hasSavepoint ( ) ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . hasSavepoint ( ) ) ; org.springframework.jdbc.datasource.TransactionStatus . setRollbackOnly ( ) ; } } ) ; assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . hasSavepoint ( ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . hasSavepoint ( ) ) ; org.springframework.jdbc.datasource.TransactionStatus . setRollbackOnly ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.sql.DatabaseMetaData java.sql.DatabaseMetaData = mock ( java.sql.DatabaseMetaData .class ) ; java.sql.Savepoint java.sql.Savepoint = mock ( java.sql.Savepoint .class ) ; given ( java.sql.DatabaseMetaData . boolean ( ) ) . willReturn ( true ) ; given ( java.sql.Connection . java.sql.DatabaseMetaData ( ) ) . willReturn ( java.sql.DatabaseMetaData ) ; given ( java.sql.Connection . java.sql.Savepoint ( STRING ) ) . willReturn ( java.sql.Savepoint ) ; final TransactionTemplate org.springframework.jdbc.datasource.TransactionTemplate = new TransactionTemplate ( org.springframework.jdbc.datasource.DataSourceTransactionManager ) ; org.springframework.jdbc.datasource.TransactionTemplate . setPropagationBehavior ( TransactionDefinition . PROPAGATION_NESTED ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . hasSavepoint ( ) ) ; try { org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . hasSavepoint ( ) ) ; TransactionTemplate org.springframework.jdbc.datasource.TransactionTemplate = new TransactionTemplate ( org.springframework.jdbc.datasource.DataSourceTransactionManager ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . hasSavepoint ( ) ) ; throw new java.lang.IllegalStateException ( ) ; } } ) ; } } ) ; fail ( STRING ) ; } catch ( java.lang.IllegalStateException java.lang.IllegalStateException ) { } assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . hasSavepoint ( ) ) ; } } ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; verify ( java.sql.Connection ) . rollback ( java.sql.Savepoint ) ; verify ( java.sql.Connection ) . releaseSavepoint ( java.sql.Savepoint ) ; verify ( java.sql.Connection ) . commit ( ) ; verify ( java.sql.Connection ) . isReadOnly ( ) ; verify ( java.sql.Connection ) . close ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . hasSavepoint ( ) ) ; try { org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . hasSavepoint ( ) ) ; TransactionTemplate org.springframework.jdbc.datasource.TransactionTemplate = new TransactionTemplate ( org.springframework.jdbc.datasource.DataSourceTransactionManager ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . hasSavepoint ( ) ) ; throw new java.lang.IllegalStateException ( ) ; } } ) ; } } ) ; fail ( STRING ) ; } catch ( java.lang.IllegalStateException java.lang.IllegalStateException ) { } assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . hasSavepoint ( ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . hasSavepoint ( ) ) ; TransactionTemplate org.springframework.jdbc.datasource.TransactionTemplate = new TransactionTemplate ( org.springframework.jdbc.datasource.DataSourceTransactionManager ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . hasSavepoint ( ) ) ; throw new java.lang.IllegalStateException ( ) ; } } ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . hasSavepoint ( ) ) ; throw new java.lang.IllegalStateException ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.sql.DatabaseMetaData java.sql.DatabaseMetaData = mock ( java.sql.DatabaseMetaData .class ) ; java.sql.Savepoint java.sql.Savepoint = mock ( java.sql.Savepoint .class ) ; given ( java.sql.DatabaseMetaData . boolean ( ) ) . willReturn ( true ) ; given ( java.sql.Connection . java.sql.DatabaseMetaData ( ) ) . willReturn ( java.sql.DatabaseMetaData ) ; given ( java.sql.Connection . java.sql.Savepoint ( STRING ) ) . willReturn ( java.sql.Savepoint ) ; final TransactionTemplate org.springframework.jdbc.datasource.TransactionTemplate = new TransactionTemplate ( org.springframework.jdbc.datasource.DataSourceTransactionManager ) ; org.springframework.jdbc.datasource.TransactionTemplate . setPropagationBehavior ( TransactionDefinition . PROPAGATION_NESTED ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . hasSavepoint ( ) ) ; try { org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . hasSavepoint ( ) ) ; TransactionTemplate org.springframework.jdbc.datasource.TransactionTemplate = new TransactionTemplate ( org.springframework.jdbc.datasource.DataSourceTransactionManager ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . hasSavepoint ( ) ) ; org.springframework.jdbc.datasource.TransactionStatus . setRollbackOnly ( ) ; } } ) ; } } ) ; fail ( STRING ) ; } catch ( UnexpectedRollbackException org.springframework.jdbc.datasource.UnexpectedRollbackException ) { } assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . hasSavepoint ( ) ) ; } } ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; verify ( java.sql.Connection ) . rollback ( java.sql.Savepoint ) ; verify ( java.sql.Connection ) . releaseSavepoint ( java.sql.Savepoint ) ; verify ( java.sql.Connection ) . commit ( ) ; verify ( java.sql.Connection ) . isReadOnly ( ) ; verify ( java.sql.Connection ) . close ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . hasSavepoint ( ) ) ; try { org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . hasSavepoint ( ) ) ; TransactionTemplate org.springframework.jdbc.datasource.TransactionTemplate = new TransactionTemplate ( org.springframework.jdbc.datasource.DataSourceTransactionManager ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . hasSavepoint ( ) ) ; org.springframework.jdbc.datasource.TransactionStatus . setRollbackOnly ( ) ; } } ) ; } } ) ; fail ( STRING ) ; } catch ( UnexpectedRollbackException org.springframework.jdbc.datasource.UnexpectedRollbackException ) { } assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . hasSavepoint ( ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . hasSavepoint ( ) ) ; TransactionTemplate org.springframework.jdbc.datasource.TransactionTemplate = new TransactionTemplate ( org.springframework.jdbc.datasource.DataSourceTransactionManager ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . hasSavepoint ( ) ) ; org.springframework.jdbc.datasource.TransactionStatus . setRollbackOnly ( ) ; } } ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; assertTrue ( STRING , ! org.springframework.jdbc.datasource.TransactionStatus . hasSavepoint ( ) ) ; org.springframework.jdbc.datasource.TransactionStatus . setRollbackOnly ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.sql.DatabaseMetaData java.sql.DatabaseMetaData = mock ( java.sql.DatabaseMetaData .class ) ; java.sql.Savepoint java.sql.Savepoint = mock ( java.sql.Savepoint .class ) ; given ( java.sql.DatabaseMetaData . boolean ( ) ) . willReturn ( true ) ; given ( java.sql.Connection . java.sql.DatabaseMetaData ( ) ) . willReturn ( java.sql.DatabaseMetaData ) ; given ( java.sql.Connection . java.sql.Savepoint ( STRING ) ) . willReturn ( java.sql.Savepoint ) ; final TransactionTemplate org.springframework.jdbc.datasource.TransactionTemplate = new TransactionTemplate ( org.springframework.jdbc.datasource.DataSourceTransactionManager ) ; org.springframework.jdbc.datasource.TransactionTemplate . setPropagationBehavior ( TransactionDefinition . PROPAGATION_NESTED ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; java.lang.Object java.lang.Object = org.springframework.jdbc.datasource.TransactionStatus . createSavepoint ( ) ; org.springframework.jdbc.datasource.TransactionStatus . releaseSavepoint ( java.lang.Object ) ; assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; } } ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; verify ( java.sql.Connection ) . releaseSavepoint ( java.sql.Savepoint ) ; verify ( java.sql.Connection ) . commit ( ) ; verify ( java.sql.Connection ) . close ( ) ; verify ( javax.sql.DataSource ) . getConnection ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; java.lang.Object java.lang.Object = org.springframework.jdbc.datasource.TransactionStatus . createSavepoint ( ) ; org.springframework.jdbc.datasource.TransactionStatus . releaseSavepoint ( java.lang.Object ) ; assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.sql.DatabaseMetaData java.sql.DatabaseMetaData = mock ( java.sql.DatabaseMetaData .class ) ; java.sql.Savepoint java.sql.Savepoint = mock ( java.sql.Savepoint .class ) ; given ( java.sql.DatabaseMetaData . boolean ( ) ) . willReturn ( true ) ; given ( java.sql.Connection . java.sql.DatabaseMetaData ( ) ) . willReturn ( java.sql.DatabaseMetaData ) ; given ( java.sql.Connection . java.sql.Savepoint ( STRING ) ) . willReturn ( java.sql.Savepoint ) ; final TransactionTemplate org.springframework.jdbc.datasource.TransactionTemplate = new TransactionTemplate ( org.springframework.jdbc.datasource.DataSourceTransactionManager ) ; org.springframework.jdbc.datasource.TransactionTemplate . setPropagationBehavior ( TransactionDefinition . PROPAGATION_NESTED ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; java.lang.Object java.lang.Object = org.springframework.jdbc.datasource.TransactionStatus . createSavepoint ( ) ; org.springframework.jdbc.datasource.TransactionStatus . rollbackToSavepoint ( java.lang.Object ) ; assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; } } ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; verify ( java.sql.Connection ) . rollback ( java.sql.Savepoint ) ; verify ( java.sql.Connection ) . commit ( ) ; verify ( java.sql.Connection ) . close ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; java.lang.Object java.lang.Object = org.springframework.jdbc.datasource.TransactionStatus . createSavepoint ( ) ; org.springframework.jdbc.datasource.TransactionStatus . rollbackToSavepoint ( java.lang.Object ) ; assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final TransactionTemplate org.springframework.jdbc.datasource.TransactionTemplate = new TransactionTemplate ( org.springframework.jdbc.datasource.DataSourceTransactionManager ) ; org.springframework.jdbc.datasource.TransactionTemplate . setPropagationBehavior ( TransactionDefinition . PROPAGATION_NESTED ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; } } ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; verify ( java.sql.Connection ) . commit ( ) ; verify ( java.sql.Connection ) . close ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { final TransactionTemplate org.springframework.jdbc.datasource.TransactionTemplate = new TransactionTemplate ( org.springframework.jdbc.datasource.DataSourceTransactionManager ) ; org.springframework.jdbc.datasource.TransactionTemplate . setPropagationBehavior ( TransactionDefinition . PROPAGATION_NESTED ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . isSynchronizationActive ( ) ) ; org.springframework.jdbc.datasource.TransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; org.springframework.jdbc.datasource.TransactionStatus . setRollbackOnly ( ) ; } } ) ; assertTrue ( STRING , ! TransactionSynchronizationManager . hasResource ( javax.sql.DataSource ) ) ; verify ( java.sql.Connection ) . rollback ( ) ; verify ( java.sql.Connection ) . close ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected void void ( TransactionStatus org.springframework.jdbc.datasource.TransactionStatus ) throws java.lang.RuntimeException { assertTrue ( STRING , org.springframework.jdbc.datasource.TransactionStatus . isNewTransaction ( ) ) ; org.springframework.jdbc.datasource.TransactionStatus . setRollbackOnly ( ) ; }  <METHOD_END>
<METHOD_START> public void ( javax.sql.DataSource javax.sql.DataSource , int int ) { this . javax.sql.DataSource = javax.sql.DataSource ; this . int = int ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ) {		}  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ) {		}  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ) {		}  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( boolean boolean ) { if ( this . int != TransactionSynchronization . STATUS_COMMITTED ) { fail ( STRING ) ; } assertFalse ( this . boolean ) ; this . boolean = true ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ) { assertFalse ( this . boolean ) ; this . boolean = true ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ) { if ( this . int != TransactionSynchronization . STATUS_COMMITTED ) { fail ( STRING ) ; } assertFalse ( this . boolean ) ; this . boolean = true ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( int int ) { try { void ( int ) ; } catch ( java.lang.Throwable java.lang.Throwable ) { this . java.lang.Throwable = java.lang.Throwable ; } }  <METHOD_END>
<METHOD_START> protected void void ( int int ) { assertFalse ( this . boolean ) ; this . boolean = true ; assertTrue ( int == this . int ) ; assertTrue ( TransactionSynchronizationManager . hasResource ( this . javax.sql.DataSource ) ) ; }  <METHOD_END>
