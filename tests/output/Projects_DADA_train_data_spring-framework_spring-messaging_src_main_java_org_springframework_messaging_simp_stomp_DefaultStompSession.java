<METHOD_START> public void ( StompSessionHandler org.springframework.messaging.simp.stomp.StompSessionHandler , StompHeaders org.springframework.messaging.simp.stomp.StompHeaders ) { Assert . notNull ( org.springframework.messaging.simp.stomp.StompSessionHandler , STRING ) ; Assert . notNull ( org.springframework.messaging.simp.stomp.StompHeaders , STRING ) ; this . java.lang.String = org.springframework.messaging.simp.stomp.IdGenerator . generateId ( ) . toString ( ) ; this . org.springframework.messaging.simp.stomp.StompSessionHandler = org.springframework.messaging.simp.stomp.StompSessionHandler ; this . org.springframework.messaging.simp.stomp.StompHeaders = org.springframework.messaging.simp.stomp.StompHeaders ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.String java.lang.String ( ) { return this . java.lang.String ; }  <METHOD_END>
<METHOD_START> public org.springframework.messaging.simp.stomp.StompSessionHandler org.springframework.messaging.simp.stomp.StompSessionHandler ( ) { return this . org.springframework.messaging.simp.stomp.StompSessionHandler ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.messaging.simp.stomp.ListenableFuture<org.springframework.messaging.simp.stomp.StompSession> < StompSession > org.springframework.messaging.simp.stomp.ListenableFuture<org.springframework.messaging.simp.stomp.StompSession> ( ) { return this . org.springframework.messaging.simp.stomp.SettableListenableFuture<org.springframework.messaging.simp.stomp.StompSession> ; }  <METHOD_END>
<METHOD_START> public void void ( MessageConverter org.springframework.messaging.simp.stomp.MessageConverter ) { Assert . notNull ( org.springframework.messaging.simp.stomp.MessageConverter , STRING ) ; this . org.springframework.messaging.simp.stomp.MessageConverter = org.springframework.messaging.simp.stomp.MessageConverter ; }  <METHOD_END>
<METHOD_START> public org.springframework.messaging.simp.stomp.MessageConverter org.springframework.messaging.simp.stomp.MessageConverter ( ) { return this . org.springframework.messaging.simp.stomp.MessageConverter ; }  <METHOD_END>
<METHOD_START> public void void ( TaskScheduler org.springframework.messaging.simp.stomp.TaskScheduler ) { this . org.springframework.messaging.simp.stomp.TaskScheduler = org.springframework.messaging.simp.stomp.TaskScheduler ; }  <METHOD_END>
<METHOD_START> public org.springframework.messaging.simp.stomp.TaskScheduler org.springframework.messaging.simp.stomp.TaskScheduler ( ) { return this . org.springframework.messaging.simp.stomp.TaskScheduler ; }  <METHOD_END>
<METHOD_START> public void void ( long long ) { Assert . isTrue ( long > NUMBER , STRING ) ; this . long = long ; }  <METHOD_END>
<METHOD_START> public long long ( ) { return this . long ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( boolean boolean ) { this . boolean = boolean ; }  <METHOD_END>
<METHOD_START> public boolean boolean ( ) { return this . boolean ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( ) { return ( this . org.springframework.messaging.simp.stomp.TcpConnection<byte[]> != null ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.messaging.simp.stomp.Receiptable org.springframework.messaging.simp.stomp.Receiptable ( java.lang.String java.lang.String , java.lang.Object java.lang.Object ) { StompHeaders org.springframework.messaging.simp.stomp.StompHeaders = new StompHeaders ( ) ; org.springframework.messaging.simp.stomp.StompHeaders . setDestination ( java.lang.String ) ; return org.springframework.messaging.simp.stomp.Receiptable ( org.springframework.messaging.simp.stomp.StompHeaders , java.lang.Object ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.messaging.simp.stomp.Receiptable org.springframework.messaging.simp.stomp.Receiptable ( StompHeaders org.springframework.messaging.simp.stomp.StompHeaders , java.lang.Object java.lang.Object ) { Assert . hasText ( org.springframework.messaging.simp.stomp.StompHeaders . getDestination ( ) , STRING ) ; java.lang.String java.lang.String = java.lang.String ( org.springframework.messaging.simp.stomp.StompHeaders ) ; Receiptable org.springframework.messaging.simp.stomp.Receiptable = new org.springframework.messaging.simp.stomp.DefaultStompSession.ReceiptHandler ( java.lang.String ) ; StompHeaderAccessor org.springframework.messaging.simp.stomp.StompHeaderAccessor = org.springframework.messaging.simp.stomp.StompHeaderAccessor ( StompCommand . SEND ) ; org.springframework.messaging.simp.stomp.StompHeaderAccessor . addNativeHeaders ( org.springframework.messaging.simp.stomp.StompHeaders ) ; Message < byte [] > org.springframework.messaging.simp.stomp.Message<byte[]> = org.springframework.messaging.simp.stomp.Message<byte[]> ( org.springframework.messaging.simp.stomp.StompHeaderAccessor , java.lang.Object ) ; void ( org.springframework.messaging.simp.stomp.Message<byte[]> ) ; return org.springframework.messaging.simp.stomp.Receiptable ; }  <METHOD_END>
<METHOD_START> private java.lang.String java.lang.String ( StompHeaders org.springframework.messaging.simp.stomp.StompHeaders ) { java.lang.String java.lang.String = org.springframework.messaging.simp.stomp.StompHeaders . getReceipt ( ) ; if ( boolean ( ) && java.lang.String == null ) { java.lang.String = java.lang.String . java.lang.String ( org.springframework.messaging.simp.stomp.DefaultStompSession .this . java.util.concurrent.atomic.AtomicInteger . int ( ) ) ; org.springframework.messaging.simp.stomp.StompHeaders . setReceipt ( java.lang.String ) ; } return java.lang.String ; }  <METHOD_END>
<METHOD_START> private org.springframework.messaging.simp.stomp.StompHeaderAccessor org.springframework.messaging.simp.stomp.StompHeaderAccessor ( StompCommand org.springframework.messaging.simp.stomp.StompCommand ) { StompHeaderAccessor org.springframework.messaging.simp.stomp.StompHeaderAccessor = StompHeaderAccessor . create ( org.springframework.messaging.simp.stomp.StompCommand ) ; org.springframework.messaging.simp.stomp.StompHeaderAccessor . setSessionId ( this . java.lang.String ) ; org.springframework.messaging.simp.stomp.StompHeaderAccessor . setLeaveMutable ( true ) ; return org.springframework.messaging.simp.stomp.StompHeaderAccessor ; }  <METHOD_END>
<METHOD_START> @ java.lang.SuppressWarnings ( STRING ) private org.springframework.messaging.simp.stomp.Message<byte[]> < byte [] > org.springframework.messaging.simp.stomp.Message<byte[]> ( StompHeaderAccessor org.springframework.messaging.simp.stomp.StompHeaderAccessor , java.lang.Object java.lang.Object ) { org.springframework.messaging.simp.stomp.StompHeaderAccessor . updateSimpMessageHeadersFromStompHeaders ( ) ; Message < byte [] > org.springframework.messaging.simp.stomp.Message<byte[]> ; if ( java.lang.Object == null ) { org.springframework.messaging.simp.stomp.Message<byte[]> = MessageBuilder . createMessage ( byte[] , org.springframework.messaging.simp.stomp.StompHeaderAccessor . getMessageHeaders ( ) ) ; } else if ( java.lang.Object instanceof byte [] ) { org.springframework.messaging.simp.stomp.Message<byte[]> = MessageBuilder . createMessage ( ( byte [] ) java.lang.Object , org.springframework.messaging.simp.stomp.StompHeaderAccessor . getMessageHeaders ( ) ) ; } else { org.springframework.messaging.simp.stomp.Message<byte[]> = ( Message < byte [] > ) org.springframework.messaging.simp.stomp.MessageConverter ( ) . toMessage ( java.lang.Object , org.springframework.messaging.simp.stomp.StompHeaderAccessor . getMessageHeaders ( ) ) ; org.springframework.messaging.simp.stomp.StompHeaderAccessor . updateStompHeadersFromSimpMessageHeaders ( ) ; if ( org.springframework.messaging.simp.stomp.Message<byte[]> == null ) { throw new MessageConversionException ( STRING + java.lang.Object . java.lang.Class<? extends java.lang.Object> ( ) . java.lang.String ( ) + STRING + org.springframework.messaging.simp.stomp.StompHeaderAccessor . getContentType ( ) + STRING + org.springframework.messaging.simp.stomp.MessageConverter ( ) + STRING ) ; } } return org.springframework.messaging.simp.stomp.Message<byte[]> ; }  <METHOD_END>
<METHOD_START> private void void ( Message < byte [] > org.springframework.messaging.simp.stomp.Message<byte[]> ) { StompHeaderAccessor org.springframework.messaging.simp.stomp.StompHeaderAccessor = MessageHeaderAccessor . getAccessor ( org.springframework.messaging.simp.stomp.Message<byte[]> , StompHeaderAccessor .class ) ; if ( org.springframework.messaging.simp.stomp.Log . isTraceEnabled ( ) ) { org.springframework.messaging.simp.stomp.Log . trace ( STRING + org.springframework.messaging.simp.stomp.StompHeaderAccessor . getDetailedLogMessage ( org.springframework.messaging.simp.stomp.Message<byte[]> . getPayload ( ) ) ) ; } TcpConnection < byte [] > org.springframework.messaging.simp.stomp.TcpConnection<byte[]> = this . org.springframework.messaging.simp.stomp.TcpConnection<byte[]> ; Assert . state ( org.springframework.messaging.simp.stomp.TcpConnection<byte[]> != null , STRING ) ; try { org.springframework.messaging.simp.stomp.TcpConnection<byte[]> . send ( org.springframework.messaging.simp.stomp.Message<byte[]> ) . get ( ) ; } catch ( java.util.concurrent.ExecutionException java.util.concurrent.ExecutionException ) { throw new MessageDeliveryException ( org.springframework.messaging.simp.stomp.Message<byte[]> , java.util.concurrent.ExecutionException . java.lang.Throwable ( ) ) ; } catch ( java.lang.Throwable java.lang.Throwable ) { throw new MessageDeliveryException ( org.springframework.messaging.simp.stomp.Message<byte[]> , java.lang.Throwable ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.messaging.simp.stomp.Subscription org.springframework.messaging.simp.stomp.Subscription ( java.lang.String java.lang.String , StompFrameHandler org.springframework.messaging.simp.stomp.StompFrameHandler ) { StompHeaders org.springframework.messaging.simp.stomp.StompHeaders = new StompHeaders ( ) ; org.springframework.messaging.simp.stomp.StompHeaders . setDestination ( java.lang.String ) ; return org.springframework.messaging.simp.stomp.Subscription ( org.springframework.messaging.simp.stomp.StompHeaders , org.springframework.messaging.simp.stomp.StompFrameHandler ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.messaging.simp.stomp.Subscription org.springframework.messaging.simp.stomp.Subscription ( StompHeaders org.springframework.messaging.simp.stomp.StompHeaders , StompFrameHandler org.springframework.messaging.simp.stomp.StompFrameHandler ) { Assert . hasText ( org.springframework.messaging.simp.stomp.StompHeaders . getDestination ( ) , STRING ) ; Assert . notNull ( org.springframework.messaging.simp.stomp.StompFrameHandler , STRING ) ; java.lang.String java.lang.String = org.springframework.messaging.simp.stomp.StompHeaders . getId ( ) ; if ( ! StringUtils . hasText ( java.lang.String ) ) { java.lang.String = java.lang.String . java.lang.String ( org.springframework.messaging.simp.stomp.DefaultStompSession .this . java.util.concurrent.atomic.AtomicInteger . int ( ) ) ; org.springframework.messaging.simp.stomp.StompHeaders . setId ( java.lang.String ) ; } java.lang.String ( org.springframework.messaging.simp.stomp.StompHeaders ) ; Subscription org.springframework.messaging.simp.stomp.Subscription = new org.springframework.messaging.simp.stomp.DefaultStompSession.DefaultSubscription ( org.springframework.messaging.simp.stomp.StompHeaders , org.springframework.messaging.simp.stomp.StompFrameHandler ) ; StompHeaderAccessor org.springframework.messaging.simp.stomp.StompHeaderAccessor = org.springframework.messaging.simp.stomp.StompHeaderAccessor ( StompCommand . SUBSCRIBE ) ; org.springframework.messaging.simp.stomp.StompHeaderAccessor . addNativeHeaders ( org.springframework.messaging.simp.stomp.StompHeaders ) ; Message < byte [] > org.springframework.messaging.simp.stomp.Message<byte[]> = org.springframework.messaging.simp.stomp.Message<byte[]> ( org.springframework.messaging.simp.stomp.StompHeaderAccessor , byte[] ) ; void ( org.springframework.messaging.simp.stomp.Message<byte[]> ) ; return org.springframework.messaging.simp.stomp.Subscription ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.messaging.simp.stomp.Receiptable org.springframework.messaging.simp.stomp.Receiptable ( java.lang.String java.lang.String , boolean boolean ) { StompHeaders org.springframework.messaging.simp.stomp.StompHeaders = new StompHeaders ( ) ; if ( STRING . boolean ( this . java.lang.String ) ) { org.springframework.messaging.simp.stomp.StompHeaders . setMessageId ( java.lang.String ) ; } else { org.springframework.messaging.simp.stomp.StompHeaders . setId ( java.lang.String ) ; } java.lang.String java.lang.String = java.lang.String ( org.springframework.messaging.simp.stomp.StompHeaders ) ; Receiptable org.springframework.messaging.simp.stomp.Receiptable = new org.springframework.messaging.simp.stomp.DefaultStompSession.ReceiptHandler ( java.lang.String ) ; StompCommand org.springframework.messaging.simp.stomp.StompCommand = ( boolean ? StompCommand . ACK : StompCommand . NACK ) ; StompHeaderAccessor org.springframework.messaging.simp.stomp.StompHeaderAccessor = org.springframework.messaging.simp.stomp.StompHeaderAccessor ( org.springframework.messaging.simp.stomp.StompCommand ) ; org.springframework.messaging.simp.stomp.StompHeaderAccessor . addNativeHeaders ( org.springframework.messaging.simp.stomp.StompHeaders ) ; Message < byte [] > org.springframework.messaging.simp.stomp.Message<byte[]> = org.springframework.messaging.simp.stomp.Message<byte[]> ( org.springframework.messaging.simp.stomp.StompHeaderAccessor , null ) ; void ( org.springframework.messaging.simp.stomp.Message<byte[]> ) ; return org.springframework.messaging.simp.stomp.Receiptable ; }  <METHOD_END>
<METHOD_START> private void void ( java.lang.String java.lang.String , StompHeaders org.springframework.messaging.simp.stomp.StompHeaders ) { StompHeaderAccessor org.springframework.messaging.simp.stomp.StompHeaderAccessor = org.springframework.messaging.simp.stomp.StompHeaderAccessor ( StompCommand . UNSUBSCRIBE ) ; if ( org.springframework.messaging.simp.stomp.StompHeaders != null ) { org.springframework.messaging.simp.stomp.StompHeaderAccessor . addNativeHeaders ( org.springframework.messaging.simp.stomp.StompHeaders ) ; } org.springframework.messaging.simp.stomp.StompHeaderAccessor . setSubscriptionId ( java.lang.String ) ; Message < byte [] > org.springframework.messaging.simp.stomp.Message<byte[]> = org.springframework.messaging.simp.stomp.Message<byte[]> ( org.springframework.messaging.simp.stomp.StompHeaderAccessor , byte[] ) ; void ( org.springframework.messaging.simp.stomp.Message<byte[]> ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ) { this . boolean = true ; try { StompHeaderAccessor org.springframework.messaging.simp.stomp.StompHeaderAccessor = org.springframework.messaging.simp.stomp.StompHeaderAccessor ( StompCommand . DISCONNECT ) ; Message < byte [] > org.springframework.messaging.simp.stomp.Message<byte[]> = org.springframework.messaging.simp.stomp.Message<byte[]> ( org.springframework.messaging.simp.stomp.StompHeaderAccessor , byte[] ) ; void ( org.springframework.messaging.simp.stomp.Message<byte[]> ) ; } finally { void ( ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( TcpConnection < byte [] > org.springframework.messaging.simp.stomp.TcpConnection<byte[]> ) { this . org.springframework.messaging.simp.stomp.TcpConnection<byte[]> = org.springframework.messaging.simp.stomp.TcpConnection<byte[]> ; if ( org.springframework.messaging.simp.stomp.Log . isDebugEnabled ( ) ) { org.springframework.messaging.simp.stomp.Log . debug ( STRING + this . java.lang.String ) ; } StompHeaderAccessor org.springframework.messaging.simp.stomp.StompHeaderAccessor = org.springframework.messaging.simp.stomp.StompHeaderAccessor ( StompCommand . CONNECT ) ; org.springframework.messaging.simp.stomp.StompHeaderAccessor . addNativeHeaders ( this . org.springframework.messaging.simp.stomp.StompHeaders ) ; org.springframework.messaging.simp.stomp.StompHeaderAccessor . setAcceptVersion ( STRING ) ; Message < byte [] > org.springframework.messaging.simp.stomp.Message<byte[]> = org.springframework.messaging.simp.stomp.Message<byte[]> ( org.springframework.messaging.simp.stomp.StompHeaderAccessor , byte[] ) ; void ( org.springframework.messaging.simp.stomp.Message<byte[]> ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( java.lang.Throwable java.lang.Throwable ) { if ( org.springframework.messaging.simp.stomp.Log . isDebugEnabled ( ) ) { org.springframework.messaging.simp.stomp.Log . debug ( STRING + this . java.lang.String , java.lang.Throwable ) ; } this . org.springframework.messaging.simp.stomp.SettableListenableFuture<org.springframework.messaging.simp.stomp.StompSession> . setException ( java.lang.Throwable ) ; this . org.springframework.messaging.simp.stomp.StompSessionHandler . handleTransportError ( this , java.lang.Throwable ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( Message < byte [] > org.springframework.messaging.simp.stomp.Message<byte[]> ) { StompHeaderAccessor org.springframework.messaging.simp.stomp.StompHeaderAccessor = MessageHeaderAccessor . getAccessor ( org.springframework.messaging.simp.stomp.Message<byte[]> , StompHeaderAccessor .class ) ; org.springframework.messaging.simp.stomp.StompHeaderAccessor . setSessionId ( this . java.lang.String ) ; StompCommand org.springframework.messaging.simp.stomp.StompCommand = org.springframework.messaging.simp.stomp.StompHeaderAccessor . getCommand ( ) ; java.util.Map<java.lang.String,java.util.List<java.lang.String>> < java.lang.String , java.util.List<java.lang.String> < java.lang.String > > java.util.Map<java.lang.String,java.util.List<java.lang.String>> = org.springframework.messaging.simp.stomp.StompHeaderAccessor . getNativeHeaders ( ) ; StompHeaders org.springframework.messaging.simp.stomp.StompHeaders = StompHeaders . readOnlyStompHeaders ( java.util.Map<java.lang.String,java.util.List<java.lang.String>> ) ; boolean boolean = org.springframework.messaging.simp.stomp.StompHeaderAccessor . isHeartbeat ( ) ; if ( org.springframework.messaging.simp.stomp.Log . isTraceEnabled ( ) ) { org.springframework.messaging.simp.stomp.Log . trace ( STRING + org.springframework.messaging.simp.stomp.StompHeaderAccessor . getDetailedLogMessage ( org.springframework.messaging.simp.stomp.Message<byte[]> . getPayload ( ) ) ) ; } try { if ( StompCommand . MESSAGE . equals ( org.springframework.messaging.simp.stomp.StompCommand ) ) { org.springframework.messaging.simp.stomp.DefaultStompSession.DefaultSubscription org.springframework.messaging.simp.stomp.DefaultStompSession.DefaultSubscription = this . java.util.Map<java.lang.String,org.springframework.messaging.simp.stomp.DefaultStompSession.DefaultSubscription> . org.springframework.messaging.simp.stomp.DefaultStompSession.DefaultSubscription ( org.springframework.messaging.simp.stomp.StompHeaders . getSubscription ( ) ) ; if ( org.springframework.messaging.simp.stomp.DefaultStompSession.DefaultSubscription != null ) { void ( org.springframework.messaging.simp.stomp.DefaultStompSession.DefaultSubscription . org.springframework.messaging.simp.stomp.StompFrameHandler ( ) , org.springframework.messaging.simp.stomp.Message<byte[]> , org.springframework.messaging.simp.stomp.StompHeaders ) ; } else if ( org.springframework.messaging.simp.stomp.Log . isDebugEnabled ( ) ) { org.springframework.messaging.simp.stomp.Log . debug ( STRING + org.springframework.messaging.simp.stomp.StompHeaderAccessor . getDetailedLogMessage ( org.springframework.messaging.simp.stomp.Message<byte[]> . getPayload ( ) ) + STRING ) ; } } else { if ( StompCommand . RECEIPT . equals ( org.springframework.messaging.simp.stomp.StompCommand ) ) { java.lang.String java.lang.String = org.springframework.messaging.simp.stomp.StompHeaders . getReceiptId ( ) ; org.springframework.messaging.simp.stomp.DefaultStompSession.ReceiptHandler org.springframework.messaging.simp.stomp.DefaultStompSession.ReceiptHandler = this . java.util.Map<java.lang.String,org.springframework.messaging.simp.stomp.DefaultStompSession.ReceiptHandler> . org.springframework.messaging.simp.stomp.DefaultStompSession.ReceiptHandler ( java.lang.String ) ; if ( org.springframework.messaging.simp.stomp.DefaultStompSession.ReceiptHandler != null ) { org.springframework.messaging.simp.stomp.DefaultStompSession.ReceiptHandler . void ( ) ; } else if ( org.springframework.messaging.simp.stomp.Log . isDebugEnabled ( ) ) { org.springframework.messaging.simp.stomp.Log . debug ( STRING + org.springframework.messaging.simp.stomp.StompHeaderAccessor . getDetailedLogMessage ( org.springframework.messaging.simp.stomp.Message<byte[]> . getPayload ( ) ) ) ; } } else if ( StompCommand . CONNECTED . equals ( org.springframework.messaging.simp.stomp.StompCommand ) ) { void ( org.springframework.messaging.simp.stomp.StompHeaders ) ; this . java.lang.String = org.springframework.messaging.simp.stomp.StompHeaders . getFirst ( STRING ) ; this . org.springframework.messaging.simp.stomp.SettableListenableFuture<org.springframework.messaging.simp.stomp.StompSession> . set ( this ) ; this . org.springframework.messaging.simp.stomp.StompSessionHandler . afterConnected ( this , org.springframework.messaging.simp.stomp.StompHeaders ) ; } else if ( StompCommand . ERROR . equals ( org.springframework.messaging.simp.stomp.StompCommand ) ) { void ( this . org.springframework.messaging.simp.stomp.StompSessionHandler , org.springframework.messaging.simp.stomp.Message<byte[]> , org.springframework.messaging.simp.stomp.StompHeaders ) ; } else if ( ! boolean && org.springframework.messaging.simp.stomp.Log . isTraceEnabled ( ) ) { org.springframework.messaging.simp.stomp.Log . trace ( STRING ) ; } } } catch ( java.lang.Throwable java.lang.Throwable ) { this . org.springframework.messaging.simp.stomp.StompSessionHandler . handleException ( this , org.springframework.messaging.simp.stomp.StompCommand , org.springframework.messaging.simp.stomp.StompHeaders , org.springframework.messaging.simp.stomp.Message<byte[]> . getPayload ( ) , java.lang.Throwable ) ; } }  <METHOD_END>
<METHOD_START> private void void ( StompFrameHandler org.springframework.messaging.simp.stomp.StompFrameHandler , Message < byte [] > org.springframework.messaging.simp.stomp.Message<byte[]> , StompHeaders org.springframework.messaging.simp.stomp.StompHeaders ) { if ( org.springframework.messaging.simp.stomp.Message<byte[]> . getPayload ( ) . length == NUMBER ) { org.springframework.messaging.simp.stomp.StompFrameHandler . handleFrame ( org.springframework.messaging.simp.stomp.StompHeaders , null ) ; return; } java.lang.reflect.Type java.lang.reflect.Type = org.springframework.messaging.simp.stomp.StompFrameHandler . getPayloadType ( org.springframework.messaging.simp.stomp.StompHeaders ) ; java.lang.Class<?> < ? > java.lang.Class<?> = ResolvableType . forType ( java.lang.reflect.Type ) . resolve ( ) ; java.lang.Object java.lang.Object = org.springframework.messaging.simp.stomp.MessageConverter ( ) . fromMessage ( org.springframework.messaging.simp.stomp.Message<byte[]> , java.lang.Class<> ) ; if ( java.lang.Object == null ) { throw new MessageConversionException ( STRING + java.lang.Class<> + STRING + org.springframework.messaging.simp.stomp.StompFrameHandler . getClass ( ) ) ; } org.springframework.messaging.simp.stomp.StompFrameHandler . handleFrame ( org.springframework.messaging.simp.stomp.StompHeaders , java.lang.Object ) ; }  <METHOD_END>
<METHOD_START> private void void ( StompHeaders org.springframework.messaging.simp.stomp.StompHeaders ) { long [] long[] = this . org.springframework.messaging.simp.stomp.StompHeaders . getHeartbeat ( ) ; long [] long[] = org.springframework.messaging.simp.stomp.StompHeaders . getHeartbeat ( ) ; if ( long[] == null || long[] == null ) { return; } if ( long[] [ NUMBER ] > NUMBER && long[] [ NUMBER ] > NUMBER ) { long long = java.lang.Math . long ( long[] [ NUMBER ] , long[] [ NUMBER ] ) ; this . org.springframework.messaging.simp.stomp.TcpConnection<byte[]> . onWriteInactivity ( new org.springframework.messaging.simp.stomp.DefaultStompSession.WriteInactivityTask ( ) , long ) ; } if ( long[] [ NUMBER ] > NUMBER && long[] [ NUMBER ] > NUMBER ) { final long long = java.lang.Math . long ( long[] [ NUMBER ] , long[] [ NUMBER ] ) * long ; this . org.springframework.messaging.simp.stomp.TcpConnection<byte[]> . onReadInactivity ( new org.springframework.messaging.simp.stomp.DefaultStompSession.ReadInactivityTask ( ) , long ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( java.lang.Throwable java.lang.Throwable ) { try { this . org.springframework.messaging.simp.stomp.SettableListenableFuture<org.springframework.messaging.simp.stomp.StompSession> . setException ( java.lang.Throwable ) ; this . org.springframework.messaging.simp.stomp.StompSessionHandler . handleTransportError ( this , java.lang.Throwable ) ; } catch ( java.lang.Throwable java.lang.Throwable ) { if ( org.springframework.messaging.simp.stomp.Log . isDebugEnabled ( ) ) { org.springframework.messaging.simp.stomp.Log . debug ( STRING , java.lang.Throwable ) ; } } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ) { if ( org.springframework.messaging.simp.stomp.Log . isDebugEnabled ( ) ) { org.springframework.messaging.simp.stomp.Log . debug ( STRING + this . java.lang.String ) ; } if ( ! this . boolean ) { void ( ) ; void ( new ConnectionLostException ( STRING ) ) ; } }  <METHOD_END>
<METHOD_START> private void void ( ) { TcpConnection < ? > org.springframework.messaging.simp.stomp.TcpConnection<?> = this . org.springframework.messaging.simp.stomp.TcpConnection<byte[]> ; this . org.springframework.messaging.simp.stomp.TcpConnection<byte[]> = null ; if ( org.springframework.messaging.simp.stomp.TcpConnection<> != null ) { try { org.springframework.messaging.simp.stomp.TcpConnection<> . close ( ) ; } catch ( java.lang.Throwable java.lang.Throwable ) { } } }  <METHOD_END>
<METHOD_START> public void ( java.lang.String java.lang.String ) { this . java.lang.String = java.lang.String ; if ( this . java.lang.String != null ) { void ( ) ; } }  <METHOD_END>
<METHOD_START> private void void ( ) { Assert . notNull ( org.springframework.messaging.simp.stomp.TaskScheduler ( ) , STRING ) ; org.springframework.messaging.simp.stomp.DefaultStompSession .this . java.util.Map<java.lang.String,org.springframework.messaging.simp.stomp.DefaultStompSession.ReceiptHandler> . org.springframework.messaging.simp.stomp.DefaultStompSession.ReceiptHandler ( this . java.lang.String , this ) ; java.util.Date java.util.Date = new java.util.Date ( java.lang.System . long ( ) + long ( ) ) ; this . java.util.concurrent.ScheduledFuture<?> = org.springframework.messaging.simp.stomp.TaskScheduler ( ) . schedule ( new java.lang.Runnable ( ) { @ java.lang.Override public void void ( ) { void ( ) ; } } , java.util.Date ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ) { void ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.String java.lang.String ( ) { return this . java.lang.String ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( java.lang.Runnable java.lang.Runnable ) { void ( java.lang.Runnable , true ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( java.lang.Runnable java.lang.Runnable ) { void ( java.lang.Runnable , false ) ; }  <METHOD_END>
<METHOD_START> private void void ( java.lang.Runnable java.lang.Runnable , boolean boolean ) { Assert . notNull ( this . java.lang.String , STRING ) ; synchronized ( this ) { if ( this . java.lang.Boolean != null && this . java.lang.Boolean == boolean ) { void ( java.util.Collections . java.util.List<java.lang.Runnable> ( java.lang.Runnable ) ) ; } else { if ( boolean ) { this . java.util.List<java.lang.Runnable> . boolean ( java.lang.Runnable ) ; } else { this . java.util.List<java.lang.Runnable> . boolean ( java.lang.Runnable ) ; } } } }  <METHOD_END>
<METHOD_START> private void void ( java.util.List<java.lang.Runnable> < java.lang.Runnable > java.util.List<java.lang.Runnable> ) { for ( java.lang.Runnable java.lang.Runnable : java.util.List<java.lang.Runnable> ) { try { java.lang.Runnable . void ( ) ; } catch ( java.lang.Throwable java.lang.Throwable ) { } } }  <METHOD_END>
<METHOD_START> public void void ( ) { void ( true ) ; }  <METHOD_END>
<METHOD_START> public void void ( ) { void ( false ) ; }  <METHOD_END>
<METHOD_START> private void void ( boolean boolean ) { synchronized ( this ) { if ( this . java.lang.Boolean != null ) { return; } this . java.lang.Boolean = boolean ; void ( boolean ? this . java.util.List<java.lang.Runnable> : this . java.util.List<java.lang.Runnable> ) ; org.springframework.messaging.simp.stomp.DefaultStompSession .this . java.util.Map<java.lang.String,org.springframework.messaging.simp.stomp.DefaultStompSession.ReceiptHandler> . org.springframework.messaging.simp.stomp.DefaultStompSession.ReceiptHandler ( this . java.lang.String ) ; if ( this . java.util.concurrent.ScheduledFuture<> != null ) { this . java.util.concurrent.ScheduledFuture<> . boolean ( true ) ; } } }  <METHOD_END>
<METHOD_START> public void ( StompHeaders org.springframework.messaging.simp.stomp.StompHeaders , StompFrameHandler org.springframework.messaging.simp.stomp.StompFrameHandler ) { super( org.springframework.messaging.simp.stomp.StompHeaders . getReceipt ( ) ); Assert . notNull ( org.springframework.messaging.simp.stomp.StompHeaders . getDestination ( ) , STRING ) ; Assert . notNull ( org.springframework.messaging.simp.stomp.StompFrameHandler , STRING ) ; this . org.springframework.messaging.simp.stomp.StompHeaders = org.springframework.messaging.simp.stomp.StompHeaders ; this . org.springframework.messaging.simp.stomp.StompFrameHandler = org.springframework.messaging.simp.stomp.StompFrameHandler ; org.springframework.messaging.simp.stomp.DefaultStompSession .this . java.util.Map<java.lang.String,org.springframework.messaging.simp.stomp.DefaultStompSession.DefaultSubscription> . org.springframework.messaging.simp.stomp.DefaultStompSession.DefaultSubscription ( org.springframework.messaging.simp.stomp.StompHeaders . getId ( ) , this ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.String java.lang.String ( ) { return this . org.springframework.messaging.simp.stomp.StompHeaders . getId ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.messaging.simp.stomp.StompHeaders org.springframework.messaging.simp.stomp.StompHeaders ( ) { return this . org.springframework.messaging.simp.stomp.StompHeaders ; }  <METHOD_END>
<METHOD_START> public org.springframework.messaging.simp.stomp.StompFrameHandler org.springframework.messaging.simp.stomp.StompFrameHandler ( ) { return this . org.springframework.messaging.simp.stomp.StompFrameHandler ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ) { void ( null ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( StompHeaders org.springframework.messaging.simp.stomp.StompHeaders ) { java.lang.String java.lang.String = this . org.springframework.messaging.simp.stomp.StompHeaders . getId ( ) ; org.springframework.messaging.simp.stomp.DefaultStompSession .this . java.util.Map<java.lang.String,org.springframework.messaging.simp.stomp.DefaultStompSession.DefaultSubscription> . org.springframework.messaging.simp.stomp.DefaultStompSession.DefaultSubscription ( java.lang.String ) ; org.springframework.messaging.simp.stomp.DefaultStompSession .this . void ( java.lang.String , org.springframework.messaging.simp.stomp.StompHeaders ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.String java.lang.String ( ) { return STRING + java.lang.String ( ) + STRING + this . org.springframework.messaging.simp.stomp.StompHeaders . getDestination ( ) + STRING + java.lang.String ( ) + STRING + org.springframework.messaging.simp.stomp.StompFrameHandler ( ) + STRING ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ) { TcpConnection < byte [] > org.springframework.messaging.simp.stomp.TcpConnection<byte[]> = org.springframework.messaging.simp.stomp.TcpConnection<byte[]> ; if ( org.springframework.messaging.simp.stomp.TcpConnection<byte[]> != null ) { org.springframework.messaging.simp.stomp.TcpConnection<byte[]> . send ( org.springframework.messaging.simp.stomp.Message<byte[]> ) . addCallback ( new ListenableFutureCallback < java.lang.Void > ( ) { public void void ( java.lang.Void java.lang.Void ) {							} public void void ( java.lang.Throwable java.lang.Throwable ) { void ( java.lang.Throwable ) ; } } ) ; } }  <METHOD_END>
<METHOD_START> public void void ( java.lang.Void java.lang.Void ) {							}  <METHOD_END>
<METHOD_START> public void void ( java.lang.Throwable java.lang.Throwable ) { void ( java.lang.Throwable ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ) { boolean = true ; java.lang.String java.lang.String = STRING + java.lang.String + STRING ; if ( org.springframework.messaging.simp.stomp.Log . isDebugEnabled ( ) ) { org.springframework.messaging.simp.stomp.Log . debug ( java.lang.String ) ; } void ( ) ; void ( new java.lang.IllegalStateException ( java.lang.String ) ) ; }  <METHOD_END>
