<METHOD_START> @ Before @ After public void void ( ) { this . org.springframework.integration.redis.util.RedisTemplate<java.lang.String,?> = this . org.springframework.integration.redis.util.RedisTemplate<java.lang.String,?> ( ) ; java.util.Set<java.lang.String> < java.lang.String > java.util.Set<java.lang.String> = org.springframework.integration.redis.util.RedisTemplate<java.lang.String,> . keys ( STRING ) ; for ( java.lang.String java.lang.String : java.util.Set<java.lang.String> ) { org.springframework.integration.redis.util.RedisTemplate<java.lang.String,> . delete ( java.lang.String ) ; } }  <METHOD_END>
<METHOD_START> @ Test @ RedisAvailable public void void ( ) java.lang.Exception { this . org.springframework.integration.redis.util.AggregatorWithRedisLocksTests.LatchingReleaseStrategy . void ( NUMBER ) ; java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . void ( java.lang.Runnable ( STRING , NUMBER , NUMBER ) ) ; java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . void ( java.lang.Runnable ( STRING , NUMBER , NUMBER ) ) ; assertTrue ( this . org.springframework.integration.redis.util.AggregatorWithRedisLocksTests.LatchingReleaseStrategy . java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; assertEquals ( NUMBER , this . org.springframework.integration.redis.util.RedisTemplate<java.lang.String,> . keys ( STRING ) . size ( ) ) ; this . org.springframework.integration.redis.util.AggregatorWithRedisLocksTests.LatchingReleaseStrategy . java.util.concurrent.CountDownLatch . void ( ) ; assertNotNull ( this . org.springframework.integration.redis.util.PollableChannel . receive ( NUMBER ) ) ; assertEquals ( NUMBER , this . org.springframework.integration.redis.util.AggregatorWithRedisLocksTests.LatchingReleaseStrategy . java.util.concurrent.atomic.AtomicInteger . int ( ) ) ; this . void ( ) ; assertNull ( STRING + ( this . java.lang.Exception != null ? this . java.lang.Exception . java.lang.String ( ) : STRING ) , this . java.lang.Exception ) ; }  <METHOD_END>
<METHOD_START> @ Test @ RedisAvailable public void void ( ) java.lang.Exception { this . org.springframework.integration.redis.util.AggregatorWithRedisLocksTests.LatchingReleaseStrategy . void ( NUMBER ) ; java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . void ( java.lang.Runnable ( STRING , NUMBER , NUMBER ) ) ; java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . void ( java.lang.Runnable ( STRING , NUMBER , NUMBER ) ) ; java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . void ( java.lang.Runnable ( STRING , NUMBER , NUMBER ) ) ; java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . void ( java.lang.Runnable ( STRING , NUMBER , NUMBER ) ) ; java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . void ( java.lang.Runnable ( STRING , NUMBER , NUMBER ) ) ; java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . void ( java.lang.Runnable ( STRING , NUMBER , NUMBER ) ) ; assertTrue ( this . org.springframework.integration.redis.util.AggregatorWithRedisLocksTests.LatchingReleaseStrategy . java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; assertEquals ( NUMBER , this . org.springframework.integration.redis.util.RedisTemplate<java.lang.String,> . keys ( STRING ) . size ( ) ) ; this . org.springframework.integration.redis.util.AggregatorWithRedisLocksTests.LatchingReleaseStrategy . java.util.concurrent.CountDownLatch . void ( ) ; this . org.springframework.integration.redis.util.AggregatorWithRedisLocksTests.LatchingReleaseStrategy . java.util.concurrent.CountDownLatch . void ( ) ; this . org.springframework.integration.redis.util.AggregatorWithRedisLocksTests.LatchingReleaseStrategy . java.util.concurrent.CountDownLatch . void ( ) ; assertNotNull ( this . org.springframework.integration.redis.util.PollableChannel . receive ( NUMBER ) ) ; assertNotNull ( this . org.springframework.integration.redis.util.PollableChannel . receive ( NUMBER ) ) ; assertNotNull ( this . org.springframework.integration.redis.util.PollableChannel . receive ( NUMBER ) ) ; assertEquals ( NUMBER , this . org.springframework.integration.redis.util.AggregatorWithRedisLocksTests.LatchingReleaseStrategy . java.util.concurrent.atomic.AtomicInteger . int ( ) ) ; this . void ( ) ; assertNull ( STRING + ( this . java.lang.Exception != null ? this . java.lang.Exception . java.lang.String ( ) : STRING ) , this . java.lang.Exception ) ; }  <METHOD_END>
<METHOD_START> @ Test @ RedisAvailable @ Repeat ( NUMBER ) public void void ( ) java.lang.Exception { this . org.springframework.integration.redis.util.AggregatorWithRedisLocksTests.LatchingReleaseStrategy . void ( NUMBER ) ; java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . void ( java.lang.Runnable ( STRING , NUMBER , NUMBER ) ) ; java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . void ( ( ) { try { org.springframework.integration.redis.util.MessageChannel . send ( new GenericMessage < java.lang.String > ( STRING , java.util.Map<java.lang.String,java.lang.Object> ( NUMBER , NUMBER , NUMBER ) ) ) ; } catch ( java.lang.Exception java.lang.Exception ) { java.lang.Exception = java.lang.Exception ; } } ) ; assertTrue ( this . org.springframework.integration.redis.util.AggregatorWithRedisLocksTests.LatchingReleaseStrategy . java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; assertEquals ( NUMBER , this . org.springframework.integration.redis.util.RedisTemplate<java.lang.String,> . keys ( STRING ) . size ( ) ) ; this . org.springframework.integration.redis.util.AggregatorWithRedisLocksTests.LatchingReleaseStrategy . java.util.concurrent.CountDownLatch . void ( ) ; assertNotNull ( this . org.springframework.integration.redis.util.PollableChannel . receive ( NUMBER ) ) ; assertEquals ( NUMBER , this . org.springframework.integration.redis.util.AggregatorWithRedisLocksTests.LatchingReleaseStrategy . java.util.concurrent.atomic.AtomicInteger . int ( ) ) ; this . void ( ) ; assertNull ( STRING + ( this . java.lang.Exception != null ? this . java.lang.Exception . java.lang.String ( ) : STRING ) , this . java.lang.Exception ) ; }  <METHOD_END>
<METHOD_START> private void void ( ) java.lang.Exception { int int = NUMBER ; while ( int ++ < NUMBER && this . org.springframework.integration.redis.util.RedisTemplate<java.lang.String,> . keys ( STRING ) . size ( ) > NUMBER ) { java.lang.Thread . void ( NUMBER ) ; } assertEquals ( NUMBER , this . org.springframework.integration.redis.util.RedisTemplate<java.lang.String,> . keys ( STRING ) . size ( ) ) ; }  <METHOD_END>
<METHOD_START> private java.lang.Runnable java.lang.Runnable ( final java.lang.String java.lang.String , final int int , final int int ) { return ( ) { try { org.springframework.integration.redis.util.MessageChannel . send ( new GenericMessage < java.lang.String > ( java.lang.String , java.util.Map<java.lang.String,java.lang.Object> ( int , NUMBER , int ) ) ) ; } catch ( java.lang.Exception java.lang.Exception ) { java.lang.Exception = java.lang.Exception ; } } ; }  <METHOD_END>
<METHOD_START> private java.util.Map<java.lang.String,java.lang.Object> < java.lang.String , java.lang.Object > java.util.Map<java.lang.String,java.lang.Object> ( int int , int int , int int ) { java.util.Map<java.lang.String,java.lang.Object> < java.lang.String , java.lang.Object > java.util.Map<java.lang.String,java.lang.Object> = new java.util.HashMap<java.lang.String,java.lang.Object> < java.lang.String , java.lang.Object > ( ) ; java.util.Map<java.lang.String,java.lang.Object> . java.lang.Object ( IntegrationMessageHeaderAccessor . SEQUENCE_NUMBER , int ) ; java.util.Map<java.lang.String,java.lang.Object> . java.lang.Object ( IntegrationMessageHeaderAccessor . SEQUENCE_SIZE , int ) ; java.util.Map<java.lang.String,java.lang.Object> . java.lang.Object ( IntegrationMessageHeaderAccessor . CORRELATION_ID , int ) ; return java.util.Map<java.lang.String,java.lang.Object> ; }  <METHOD_END>
<METHOD_START> private org.springframework.integration.redis.util.RedisTemplate<java.lang.String,?> < java.lang.String , ? > org.springframework.integration.redis.util.RedisTemplate<java.lang.String,?> ( ) { RedisTemplate < java.lang.String , ? > org.springframework.integration.redis.util.RedisTemplate<java.lang.String,?> = new RedisTemplate < java.lang.String , java.lang.Object > ( ) ; org.springframework.integration.redis.util.RedisTemplate<java.lang.String,> . setConnectionFactory ( this . getConnectionFactoryForTest ( ) ) ; org.springframework.integration.redis.util.RedisTemplate<java.lang.String,> . setKeySerializer ( new StringRedisSerializer ( ) ) ; org.springframework.integration.redis.util.RedisTemplate<java.lang.String,> . afterPropertiesSet ( ) ; return org.springframework.integration.redis.util.RedisTemplate<java.lang.String,> ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( MessageGroup org.springframework.integration.redis.util.MessageGroup ) { synchronized ( this ) { this . java.util.concurrent.atomic.AtomicInteger . int ( ) ; this . java.util.concurrent.atomic.AtomicInteger . void ( java.lang.Math . int ( this . java.util.concurrent.atomic.AtomicInteger . int ( ) , this . java.util.concurrent.atomic.AtomicInteger . int ( ) ) ) ; } this . java.util.concurrent.CountDownLatch . void ( ) ; try { this . java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ; } catch ( java.lang.InterruptedException java.lang.InterruptedException ) { java.lang.Thread . java.lang.Thread ( ) . void ( ) ; } this . java.util.concurrent.atomic.AtomicInteger . int ( ) ; return org.springframework.integration.redis.util.MessageGroup . size ( ) > NUMBER ; }  <METHOD_END>
<METHOD_START> public void void ( int int ) { this . java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( int ) ; this . java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( int ) ; this . java.util.concurrent.atomic.AtomicInteger = new java.util.concurrent.atomic.AtomicInteger ( ) ; this . java.util.concurrent.atomic.AtomicInteger = new java.util.concurrent.atomic.AtomicInteger ( ) ; }  <METHOD_END>
