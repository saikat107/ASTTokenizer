<METHOD_START> public void ( ) { this( NUMBER * NUMBER ); }  <METHOD_END>
<METHOD_START> public void ( int int ) { this( int , true ); }  <METHOD_END>
<METHOD_START> public void ( boolean boolean ) { this( NUMBER * NUMBER , boolean ); }  <METHOD_END>
<METHOD_START> public void ( int int , boolean boolean ) { super( new MimeType ( STRING , STRING , java.nio.charset.StandardCharsets . java.nio.charset.Charset ) , new MimeType ( STRING , STRING , java.nio.charset.StandardCharsets . java.nio.charset.Charset ) ); if ( int < NUMBER ) { throw new java.lang.IllegalArgumentException ( STRING ) ; } this . int = int ; this . boolean = boolean ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.http.codec.json.Flux<org.springframework.http.codec.json.DataBuffer> < DataBuffer > org.springframework.http.codec.json.Flux<org.springframework.http.codec.json.DataBuffer> ( Publisher < DataBuffer > org.springframework.http.codec.json.Publisher<org.springframework.http.codec.json.DataBuffer> , ResolvableType org.springframework.http.codec.json.ResolvableType , MimeType org.springframework.http.codec.json.MimeType , java.util.Map<java.lang.String,java.lang.Object> < java.lang.String , java.lang.Object > java.util.Map<java.lang.String,java.lang.Object> ) { return Flux . from ( org.springframework.http.codec.json.Publisher<org.springframework.http.codec.json.DataBuffer> ) . flatMap ( new java.util.function.Function<org.springframework.http.codec.json.DataBuffer,org.springframework.http.codec.json.Publisher<? extends org.springframework.http.codec.json.DataBuffer>> < DataBuffer , Publisher < ? extends DataBuffer > > ( ) { int int ; int int ; int int ; boolean boolean ; org.springframework.http.codec.json.ByteBuf org.springframework.http.codec.json.ByteBuf ; java.lang.Integer java.lang.Integer ; @ java.lang.Override public org.springframework.http.codec.json.Publisher<? extends org.springframework.http.codec.json.DataBuffer> < ? extends DataBuffer > org.springframework.http.codec.json.Publisher<? extends org.springframework.http.codec.json.DataBuffer> ( DataBuffer org.springframework.http.codec.json.DataBuffer ) { java.util.List<org.springframework.http.codec.json.DataBuffer> < DataBuffer > java.util.List<org.springframework.http.codec.json.DataBuffer> = new java.util.ArrayList<org.springframework.http.codec.json.DataBuffer> <> ( ) ; if ( this . org.springframework.http.codec.json.ByteBuf == null ) { this . org.springframework.http.codec.json.ByteBuf = Unpooled . copiedBuffer ( org.springframework.http.codec.json.DataBuffer . asByteBuffer ( ) ) ; DataBufferUtils . release ( org.springframework.http.codec.json.DataBuffer ) ; this . java.lang.Integer = this . org.springframework.http.codec.json.ByteBuf . writerIndex ( ) ; } else { this . int = this . int - this . org.springframework.http.codec.json.ByteBuf . readerIndex ( ) ; this . org.springframework.http.codec.json.ByteBuf = Unpooled . copiedBuffer ( this . org.springframework.http.codec.json.ByteBuf , Unpooled . copiedBuffer ( org.springframework.http.codec.json.DataBuffer . asByteBuffer ( ) ) ) ; DataBufferUtils . release ( org.springframework.http.codec.json.DataBuffer ) ; this . java.lang.Integer = this . org.springframework.http.codec.json.ByteBuf . writerIndex ( ) ; } if ( this . int == int ) { this . org.springframework.http.codec.json.ByteBuf . skipBytes ( this . org.springframework.http.codec.json.ByteBuf . readableBytes ( ) ) ; return Flux . error ( new java.lang.IllegalStateException ( STRING ) ) ; } if ( this . java.lang.Integer > int ) { this . org.springframework.http.codec.json.ByteBuf . skipBytes ( this . org.springframework.http.codec.json.ByteBuf . readableBytes ( ) ) ; void ( ) ; return Flux . error ( new java.lang.IllegalStateException ( STRING + int + STRING + this . java.lang.Integer + STRING ) ) ; } DataBufferFactory org.springframework.http.codec.json.DataBufferFactory = org.springframework.http.codec.json.DataBuffer . factory ( ) ; for ( ; this . int < this . java.lang.Integer ; this . int ++ ) { byte byte = this . org.springframework.http.codec.json.ByteBuf . getByte ( this . int ) ; if ( this . int == int ) { void ( byte , this . org.springframework.http.codec.json.ByteBuf , this . int ) ; if ( this . int == NUMBER ) { ByteBuf org.springframework.http.codec.json.ByteBuf = org.springframework.http.codec.json.ByteBuf ( this . org.springframework.http.codec.json.ByteBuf , this . org.springframework.http.codec.json.ByteBuf . readerIndex ( ) , this . int + NUMBER - this . org.springframework.http.codec.json.ByteBuf . readerIndex ( ) ) ; if ( org.springframework.http.codec.json.ByteBuf != null ) { java.util.List<org.springframework.http.codec.json.DataBuffer> . add ( org.springframework.http.codec.json.DataBufferFactory . wrap ( org.springframework.http.codec.json.ByteBuf . nioBuffer ( ) ) ) ; } this . org.springframework.http.codec.json.ByteBuf . readerIndex ( this . int + NUMBER ) ; void ( ) ; } } else if ( this . int == int ) { void ( byte , this . org.springframework.http.codec.json.ByteBuf , this . int ) ; if ( ! this . boolean && ( this . int == NUMBER && byte == ',' || this . int == NUMBER && byte == ']' ) ) { for ( int int = this . org.springframework.http.codec.json.ByteBuf . readerIndex ( ) ; java.lang.Character . boolean ( this . org.springframework.http.codec.json.ByteBuf . getByte ( int ) ) ; int ++ ) { this . org.springframework.http.codec.json.ByteBuf . skipBytes ( NUMBER ) ; } int int = this . int - NUMBER ; while ( int >= this . org.springframework.http.codec.json.ByteBuf . readerIndex ( ) && java.lang.Character . boolean ( this . org.springframework.http.codec.json.ByteBuf . getByte ( int ) ) ) { int -- ; } ByteBuf org.springframework.http.codec.json.ByteBuf = org.springframework.http.codec.json.ByteBuf ( this . org.springframework.http.codec.json.ByteBuf , this . org.springframework.http.codec.json.ByteBuf . readerIndex ( ) , int + NUMBER - this . org.springframework.http.codec.json.ByteBuf . readerIndex ( ) ) ; if ( org.springframework.http.codec.json.ByteBuf != null ) { java.util.List<org.springframework.http.codec.json.DataBuffer> . add ( org.springframework.http.codec.json.DataBufferFactory . wrap ( org.springframework.http.codec.json.ByteBuf . nioBuffer ( ) ) ) ; } this . org.springframework.http.codec.json.ByteBuf . readerIndex ( this . int + NUMBER ) ; if ( byte == ']' ) { void ( ) ; } } } else if ( byte == '{' || byte == '[' ) { void ( byte , boolean ) ; if ( this . int == int ) { this . org.springframework.http.codec.json.ByteBuf . skipBytes ( NUMBER ) ; } } else if ( java.lang.Character . boolean ( byte ) ) { this . org.springframework.http.codec.json.ByteBuf . skipBytes ( NUMBER ) ; } else { this . int = int ; return Flux . error ( new java.lang.IllegalStateException ( STRING + this . int + STRING + ByteBufUtil . hexDump ( this . org.springframework.http.codec.json.ByteBuf ) ) ) ; } } return Flux . fromIterable ( java.util.List<org.springframework.http.codec.json.DataBuffer> ) ; } protected org.springframework.http.codec.json.ByteBuf org.springframework.http.codec.json.ByteBuf ( ByteBuf org.springframework.http.codec.json.ByteBuf , int int , int int ) { return org.springframework.http.codec.json.ByteBuf . slice ( int , int ) . retain ( ) ; } private void void ( byte byte , ByteBuf org.springframework.http.codec.json.ByteBuf , int int ) { if ( ( byte == '{' || byte == '[' ) && ! this . boolean ) { this . int ++ ; } else if ( ( byte == '}' || byte == ']' ) && ! this . boolean ) { this . int -- ; } else if ( byte == '"' ) { if ( ! this . boolean ) { this . boolean = true ; } else if ( org.springframework.http.codec.json.ByteBuf . getByte ( int - NUMBER ) != '\\' ) { this . boolean = false ; } } } private void void ( byte byte , boolean boolean ) { this . int = NUMBER ; if ( byte == '[' && boolean ) { this . int = int ; } else { this . int = int ; } } private void void ( ) { this . boolean = false ; this . int = int ; this . int = NUMBER ; } } ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.http.codec.json.Publisher<? extends org.springframework.http.codec.json.DataBuffer> < ? extends DataBuffer > org.springframework.http.codec.json.Publisher<? extends org.springframework.http.codec.json.DataBuffer> ( DataBuffer org.springframework.http.codec.json.DataBuffer ) { java.util.List<org.springframework.http.codec.json.DataBuffer> < DataBuffer > java.util.List<org.springframework.http.codec.json.DataBuffer> = new java.util.ArrayList<org.springframework.http.codec.json.DataBuffer> <> ( ) ; if ( this . org.springframework.http.codec.json.ByteBuf == null ) { this . org.springframework.http.codec.json.ByteBuf = Unpooled . copiedBuffer ( org.springframework.http.codec.json.DataBuffer . asByteBuffer ( ) ) ; DataBufferUtils . release ( org.springframework.http.codec.json.DataBuffer ) ; this . java.lang.Integer = this . org.springframework.http.codec.json.ByteBuf . writerIndex ( ) ; } else { this . int = this . int - this . org.springframework.http.codec.json.ByteBuf . readerIndex ( ) ; this . org.springframework.http.codec.json.ByteBuf = Unpooled . copiedBuffer ( this . org.springframework.http.codec.json.ByteBuf , Unpooled . copiedBuffer ( org.springframework.http.codec.json.DataBuffer . asByteBuffer ( ) ) ) ; DataBufferUtils . release ( org.springframework.http.codec.json.DataBuffer ) ; this . java.lang.Integer = this . org.springframework.http.codec.json.ByteBuf . writerIndex ( ) ; } if ( this . int == int ) { this . org.springframework.http.codec.json.ByteBuf . skipBytes ( this . org.springframework.http.codec.json.ByteBuf . readableBytes ( ) ) ; return Flux . error ( new java.lang.IllegalStateException ( STRING ) ) ; } if ( this . java.lang.Integer > int ) { this . org.springframework.http.codec.json.ByteBuf . skipBytes ( this . org.springframework.http.codec.json.ByteBuf . readableBytes ( ) ) ; void ( ) ; return Flux . error ( new java.lang.IllegalStateException ( STRING + int + STRING + this . java.lang.Integer + STRING ) ) ; } DataBufferFactory org.springframework.http.codec.json.DataBufferFactory = org.springframework.http.codec.json.DataBuffer . factory ( ) ; for ( ; this . int < this . java.lang.Integer ; this . int ++ ) { byte byte = this . org.springframework.http.codec.json.ByteBuf . getByte ( this . int ) ; if ( this . int == int ) { void ( byte , this . org.springframework.http.codec.json.ByteBuf , this . int ) ; if ( this . int == NUMBER ) { ByteBuf org.springframework.http.codec.json.ByteBuf = org.springframework.http.codec.json.ByteBuf ( this . org.springframework.http.codec.json.ByteBuf , this . org.springframework.http.codec.json.ByteBuf . readerIndex ( ) , this . int + NUMBER - this . org.springframework.http.codec.json.ByteBuf . readerIndex ( ) ) ; if ( org.springframework.http.codec.json.ByteBuf != null ) { java.util.List<org.springframework.http.codec.json.DataBuffer> . add ( org.springframework.http.codec.json.DataBufferFactory . wrap ( org.springframework.http.codec.json.ByteBuf . nioBuffer ( ) ) ) ; } this . org.springframework.http.codec.json.ByteBuf . readerIndex ( this . int + NUMBER ) ; void ( ) ; } } else if ( this . int == int ) { void ( byte , this . org.springframework.http.codec.json.ByteBuf , this . int ) ; if ( ! this . boolean && ( this . int == NUMBER && byte == ',' || this . int == NUMBER && byte == ']' ) ) { for ( int int = this . org.springframework.http.codec.json.ByteBuf . readerIndex ( ) ; java.lang.Character . boolean ( this . org.springframework.http.codec.json.ByteBuf . getByte ( int ) ) ; int ++ ) { this . org.springframework.http.codec.json.ByteBuf . skipBytes ( NUMBER ) ; } int int = this . int - NUMBER ; while ( int >= this . org.springframework.http.codec.json.ByteBuf . readerIndex ( ) && java.lang.Character . boolean ( this . org.springframework.http.codec.json.ByteBuf . getByte ( int ) ) ) { int -- ; } ByteBuf org.springframework.http.codec.json.ByteBuf = org.springframework.http.codec.json.ByteBuf ( this . org.springframework.http.codec.json.ByteBuf , this . org.springframework.http.codec.json.ByteBuf . readerIndex ( ) , int + NUMBER - this . org.springframework.http.codec.json.ByteBuf . readerIndex ( ) ) ; if ( org.springframework.http.codec.json.ByteBuf != null ) { java.util.List<org.springframework.http.codec.json.DataBuffer> . add ( org.springframework.http.codec.json.DataBufferFactory . wrap ( org.springframework.http.codec.json.ByteBuf . nioBuffer ( ) ) ) ; } this . org.springframework.http.codec.json.ByteBuf . readerIndex ( this . int + NUMBER ) ; if ( byte == ']' ) { void ( ) ; } } } else if ( byte == '{' || byte == '[' ) { void ( byte , boolean ) ; if ( this . int == int ) { this . org.springframework.http.codec.json.ByteBuf . skipBytes ( NUMBER ) ; } } else if ( java.lang.Character . boolean ( byte ) ) { this . org.springframework.http.codec.json.ByteBuf . skipBytes ( NUMBER ) ; } else { this . int = int ; return Flux . error ( new java.lang.IllegalStateException ( STRING + this . int + STRING + ByteBufUtil . hexDump ( this . org.springframework.http.codec.json.ByteBuf ) ) ) ; } } return Flux . fromIterable ( java.util.List<org.springframework.http.codec.json.DataBuffer> ) ; }  <METHOD_END>
<METHOD_START> protected org.springframework.http.codec.json.ByteBuf org.springframework.http.codec.json.ByteBuf ( ByteBuf org.springframework.http.codec.json.ByteBuf , int int , int int ) { return org.springframework.http.codec.json.ByteBuf . slice ( int , int ) . retain ( ) ; }  <METHOD_END>
<METHOD_START> private void void ( byte byte , ByteBuf org.springframework.http.codec.json.ByteBuf , int int ) { if ( ( byte == '{' || byte == '[' ) && ! this . boolean ) { this . int ++ ; } else if ( ( byte == '}' || byte == ']' ) && ! this . boolean ) { this . int -- ; } else if ( byte == '"' ) { if ( ! this . boolean ) { this . boolean = true ; } else if ( org.springframework.http.codec.json.ByteBuf . getByte ( int - NUMBER ) != '\\' ) { this . boolean = false ; } } }  <METHOD_END>
<METHOD_START> private void void ( byte byte , boolean boolean ) { this . int = NUMBER ; if ( byte == '[' && boolean ) { this . int = int ; } else { this . int = int ; } }  <METHOD_END>
<METHOD_START> private void void ( ) { this . boolean = false ; this . int = int ; this . int = NUMBER ; }  <METHOD_END>
