<METHOD_START> @ Before public void void ( ) { this . org.springframework.data.repository.util.DefaultConversionService = new DefaultConversionService ( ) ; QueryExecutionConverters . registerConvertersIn ( org.springframework.data.repository.util.DefaultConversionService ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { assertThat ( QueryExecutionConverters . supports ( Optional .class ) ) . isTrue ( ) ; assertThat ( QueryExecutionConverters . supports ( java . util . java.util.Optional .class ) ) . isTrue ( ) ; assertThat ( QueryExecutionConverters . supports ( java.util.concurrent.Future .class ) ) . isTrue ( ) ; assertThat ( QueryExecutionConverters . supports ( ListenableFuture .class ) ) . isTrue ( ) ; assertThat ( QueryExecutionConverters . supports ( Option .class ) ) . isTrue ( ) ; assertThat ( QueryExecutionConverters . supports ( javaslang . javaslang . javaslang .class ) ) . isTrue ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { assertThat ( QueryExecutionConverters . supports ( Publisher .class ) ) . isTrue ( ) ; assertThat ( QueryExecutionConverters . supports ( Mono .class ) ) . isTrue ( ) ; assertThat ( QueryExecutionConverters . supports ( Flux .class ) ) . isTrue ( ) ; assertThat ( QueryExecutionConverters . supports ( Single .class ) ) . isTrue ( ) ; assertThat ( QueryExecutionConverters . supports ( Completable .class ) ) . isTrue ( ) ; assertThat ( QueryExecutionConverters . supports ( Observable .class ) ) . isTrue ( ) ; assertThat ( QueryExecutionConverters . supports ( io . io . io .class ) ) . isTrue ( ) ; assertThat ( QueryExecutionConverters . supports ( io . io . io .class ) ) . isTrue ( ) ; assertThat ( QueryExecutionConverters . supports ( io . io . io .class ) ) . isTrue ( ) ; assertThat ( QueryExecutionConverters . supports ( io . io . io .class ) ) . isTrue ( ) ; assertThat ( QueryExecutionConverters . supports ( io . io . io .class ) ) . isTrue ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { assertThat ( QueryExecutionConverters . supportsUnwrapping ( Optional .class ) ) . isTrue ( ) ; assertThat ( QueryExecutionConverters . supportsUnwrapping ( java . util . java.util.Optional .class ) ) . isTrue ( ) ; assertThat ( QueryExecutionConverters . supportsUnwrapping ( java.util.concurrent.Future .class ) ) . isTrue ( ) ; assertThat ( QueryExecutionConverters . supportsUnwrapping ( ListenableFuture .class ) ) . isTrue ( ) ; assertThat ( QueryExecutionConverters . supportsUnwrapping ( Option .class ) ) . isTrue ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { assertThat ( QueryExecutionConverters . supportsUnwrapping ( Publisher .class ) ) . isFalse ( ) ; assertThat ( QueryExecutionConverters . supportsUnwrapping ( Mono .class ) ) . isFalse ( ) ; assertThat ( QueryExecutionConverters . supportsUnwrapping ( Flux .class ) ) . isFalse ( ) ; assertThat ( QueryExecutionConverters . supportsUnwrapping ( Single .class ) ) . isFalse ( ) ; assertThat ( QueryExecutionConverters . supportsUnwrapping ( Completable .class ) ) . isFalse ( ) ; assertThat ( QueryExecutionConverters . supportsUnwrapping ( Observable .class ) ) . isFalse ( ) ; assertThat ( QueryExecutionConverters . supportsUnwrapping ( io . io . io .class ) ) . isFalse ( ) ; assertThat ( QueryExecutionConverters . supportsUnwrapping ( io . io . io .class ) ) . isFalse ( ) ; assertThat ( QueryExecutionConverters . supportsUnwrapping ( io . io . io .class ) ) . isFalse ( ) ; assertThat ( QueryExecutionConverters . supportsUnwrapping ( io . io . io .class ) ) . isFalse ( ) ; assertThat ( QueryExecutionConverters . supportsUnwrapping ( io . io . io .class ) ) . isFalse ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { assertThat ( QueryExecutionConverters . supports ( java.util.concurrent.CompletableFuture .class ) ) . isTrue ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { assertThat ( org.springframework.data.repository.util.DefaultConversionService . convert ( new NullableWrapper ( null ) , Optional .class ) ) . isEqualTo ( Optional . absent ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test @ java.lang.SuppressWarnings ( STRING ) public void void ( ) { assertThat ( org.springframework.data.repository.util.DefaultConversionService . convert ( new NullableWrapper ( null ) , java . util . java.util.Optional .class ) ) . isEmpty ( ) ; }  <METHOD_END>
<METHOD_START> @ Test @ java.lang.SuppressWarnings ( STRING ) public void void ( ) java.lang.Exception { java.util.concurrent.CompletableFuture<java.lang.Object> < java.lang.Object > java.util.concurrent.CompletableFuture<java.lang.Object> = org.springframework.data.repository.util.DefaultConversionService . convert ( new NullableWrapper ( null ) , java.util.concurrent.CompletableFuture .class ) ; assertThat ( java.util.concurrent.CompletableFuture<java.lang.Object> ) . isNotNull ( ) ; assertThat ( java.util.concurrent.CompletableFuture<java.lang.Object> . boolean ( ) ) . isTrue ( ) ; assertThat ( java.util.concurrent.CompletableFuture<java.lang.Object> . java.lang.Object ( ) ) . isNull ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { assertThat ( QueryExecutionConverters . unwrap ( java . util . java.util.Optional . java.util.Optional<java.lang.String> ( STRING ) ) ) . isEqualTo ( STRING ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { assertThat ( QueryExecutionConverters . unwrap ( Optional . of ( STRING ) ) ) . isEqualTo ( STRING ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { assertThat ( QueryExecutionConverters . unwrap ( null ) ) . isNull ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { assertThat ( QueryExecutionConverters . unwrap ( STRING ) ) . isEqualTo ( STRING ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { assertThat ( org.springframework.data.repository.util.DefaultConversionService . convert ( new NullableWrapper ( null ) , Option .class ) ) . isEqualTo ( Option . empty ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { assertThat ( QueryExecutionConverters . unwrap ( Option . apply ( STRING ) ) ) . isEqualTo ( STRING ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { assertThat ( QueryExecutionConverters . unwrap ( Option . empty ( ) ) ) . isNull ( ) ; }  <METHOD_END>
<METHOD_START> @ Test @ java.lang.SuppressWarnings ( STRING ) public void void ( ) { assertThat ( org.springframework.data.repository.util.DefaultConversionService . convert ( new NullableWrapper ( null ) , javaslang . javaslang . javaslang .class ) ) . isEqualTo ( javaslang . control . Option . none ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { javaslang . javaslang . javaslang < ? > result = org.springframework.data.repository.util.DefaultConversionService . convert ( new NullableWrapper ( STRING ) , javaslang . javaslang . javaslang .class ) ; assertThat ( result . isEmpty ( ) ) . isFalse ( ) ; assertThat ( result . get ( ) ) . isEqualTo ( STRING ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { assertThat ( QueryExecutionConverters . unwrap ( javaslang . control . Option . none ( ) ) ) . isNull ( ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { assertThat ( QueryExecutionConverters . unwrap ( javaslang . control . Option . of ( STRING ) ) ) . isEqualTo ( STRING ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { assertThat ( org.springframework.data.repository.util.DefaultConversionService . canConvert ( java.util.List .class , javaslang . javaslang . javaslang .class ) ) . isTrue ( ) ; assertThat ( org.springframework.data.repository.util.DefaultConversionService . canConvert ( java.util.List .class , javaslang . javaslang . javaslang .class ) ) . isTrue ( ) ; assertThat ( org.springframework.data.repository.util.DefaultConversionService . canConvert ( java.util.List .class , javaslang . javaslang . javaslang .class ) ) . isTrue ( ) ; assertThat ( org.springframework.data.repository.util.DefaultConversionService . canConvert ( java.util.List .class , javaslang . javaslang . javaslang .class ) ) . isFalse ( ) ; java.util.List<java.lang.Integer> < java.lang.Integer > java.util.List<java.lang.Integer> = java.util.Arrays . java.util.List<java.lang.Integer> ( NUMBER , NUMBER , NUMBER ) ; Traversable < ? > org.springframework.data.repository.util.Traversable<?> = org.springframework.data.repository.util.DefaultConversionService . convert ( java.util.List<java.lang.Integer> , Traversable .class ) ; assertThat ( org.springframework.data.repository.util.Traversable<> ) . isInstanceOf ( javaslang . javaslang . javaslang .class ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { assertThat ( org.springframework.data.repository.util.DefaultConversionService . canConvert ( java.util.Set .class , javaslang . javaslang . javaslang .class ) ) . isTrue ( ) ; assertThat ( org.springframework.data.repository.util.DefaultConversionService . canConvert ( java.util.Set .class , javaslang . javaslang . javaslang .class ) ) . isTrue ( ) ; assertThat ( org.springframework.data.repository.util.DefaultConversionService . canConvert ( java.util.Set .class , javaslang . javaslang . javaslang .class ) ) . isTrue ( ) ; assertThat ( org.springframework.data.repository.util.DefaultConversionService . canConvert ( java.util.Set .class , javaslang . javaslang . javaslang .class ) ) . isFalse ( ) ; java.util.Set<java.lang.Integer> < java.lang.Integer > java.util.Set<java.lang.Integer> = java.util.Collections . java.util.Set<java.lang.Integer> ( NUMBER ) ; Traversable < ? > org.springframework.data.repository.util.Traversable<?> = org.springframework.data.repository.util.DefaultConversionService . convert ( java.util.Set<java.lang.Integer> , Traversable .class ) ; assertThat ( org.springframework.data.repository.util.Traversable<> ) . isInstanceOf ( javaslang . javaslang . javaslang .class ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { assertThat ( org.springframework.data.repository.util.DefaultConversionService . canConvert ( java.util.Map .class , javaslang . javaslang . javaslang .class ) ) . isTrue ( ) ; assertThat ( org.springframework.data.repository.util.DefaultConversionService . canConvert ( java.util.Map .class , javaslang . javaslang . javaslang .class ) ) . isTrue ( ) ; assertThat ( org.springframework.data.repository.util.DefaultConversionService . canConvert ( java.util.Map .class , javaslang . javaslang . javaslang .class ) ) . isFalse ( ) ; assertThat ( org.springframework.data.repository.util.DefaultConversionService . canConvert ( java.util.Map .class , javaslang . javaslang . javaslang .class ) ) . isFalse ( ) ; java.util.Map<java.lang.String,java.lang.String> < java.lang.String , java.lang.String > java.util.Map<java.lang.String,java.lang.String> = java.util.Collections . java.util.Map<java.lang.String,java.lang.String> ( STRING , STRING ) ; Traversable < ? > org.springframework.data.repository.util.Traversable<?> = org.springframework.data.repository.util.DefaultConversionService . convert ( java.util.Map<java.lang.String,java.lang.String> , Traversable .class ) ; assertThat ( org.springframework.data.repository.util.Traversable<> ) . isInstanceOf ( javaslang . javaslang . javaslang .class ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { assertThat ( unwrap ( javaslang . collection . List . of ( NUMBER , NUMBER , NUMBER ) ) ) . isInstanceOf ( java.util.List .class ) ; assertThat ( unwrap ( LinkedHashSet . of ( NUMBER , NUMBER , NUMBER ) ) ) . isInstanceOf ( java.util.Set .class ) ; assertThat ( unwrap ( LinkedHashMap . of ( STRING , STRING ) ) ) . isInstanceOf ( java.util.Map .class ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { java.util.Set<java.lang.Class<?>> < java.lang.Class<?> < ? > > java.util.Set<java.lang.Class<?>> = QueryExecutionConverters . getAllowedPageableTypes ( ) ; assertThat ( java.util.Set<java.lang.Class<?>> ) . contains ( Page .class , Slice .class , java.util.List .class , Seq .class ) ; }  <METHOD_END>
