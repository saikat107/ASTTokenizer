<METHOD_START> public void ( Environment org.springframework.context.annotation.Environment , ResourceLoader org.springframework.context.annotation.ResourceLoader , BeanNameGenerator org.springframework.context.annotation.BeanNameGenerator , BeanDefinitionRegistry org.springframework.context.annotation.BeanDefinitionRegistry ) { this . org.springframework.context.annotation.ResourceLoader = org.springframework.context.annotation.ResourceLoader ; this . org.springframework.context.annotation.Environment = org.springframework.context.annotation.Environment ; this . org.springframework.context.annotation.BeanNameGenerator = org.springframework.context.annotation.BeanNameGenerator ; this . org.springframework.context.annotation.BeanDefinitionRegistry = org.springframework.context.annotation.BeanDefinitionRegistry ; }  <METHOD_END>
<METHOD_START> public java.util.Set<org.springframework.context.annotation.BeanDefinitionHolder> < BeanDefinitionHolder > java.util.Set<org.springframework.context.annotation.BeanDefinitionHolder> ( AnnotationAttributes org.springframework.context.annotation.AnnotationAttributes , final java.lang.String java.lang.String ) { Assert . state ( this . org.springframework.context.annotation.Environment != null , STRING ) ; Assert . state ( this . org.springframework.context.annotation.ResourceLoader != null , STRING ) ; ClassPathBeanDefinitionScanner org.springframework.context.annotation.ClassPathBeanDefinitionScanner = new ClassPathBeanDefinitionScanner ( this . org.springframework.context.annotation.BeanDefinitionRegistry , org.springframework.context.annotation.AnnotationAttributes . getBoolean ( STRING ) , this . org.springframework.context.annotation.Environment , this . org.springframework.context.annotation.ResourceLoader ) ; java.lang.Class<? extends org.springframework.context.annotation.BeanNameGenerator> < ? extends BeanNameGenerator > java.lang.Class<? extends org.springframework.context.annotation.BeanNameGenerator> = org.springframework.context.annotation.AnnotationAttributes . getClass ( STRING ) ; boolean boolean = ( BeanNameGenerator .class == java.lang.Class<> ) ; org.springframework.context.annotation.ClassPathBeanDefinitionScanner . setBeanNameGenerator ( boolean ? this . org.springframework.context.annotation.BeanNameGenerator : BeanUtils . instantiateClass ( java.lang.Class<> ) ) ; ScopedProxyMode org.springframework.context.annotation.ScopedProxyMode = org.springframework.context.annotation.AnnotationAttributes . getEnum ( STRING ) ; if ( org.springframework.context.annotation.ScopedProxyMode != ScopedProxyMode . DEFAULT ) { org.springframework.context.annotation.ClassPathBeanDefinitionScanner . setScopedProxyMode ( org.springframework.context.annotation.ScopedProxyMode ) ; } else { java.lang.Class<? extends org.springframework.context.annotation.ScopeMetadataResolver> < ? extends ScopeMetadataResolver > java.lang.Class<? extends org.springframework.context.annotation.ScopeMetadataResolver> = org.springframework.context.annotation.AnnotationAttributes . getClass ( STRING ) ; org.springframework.context.annotation.ClassPathBeanDefinitionScanner . setScopeMetadataResolver ( BeanUtils . instantiateClass ( java.lang.Class<> ) ) ; } org.springframework.context.annotation.ClassPathBeanDefinitionScanner . setResourcePattern ( org.springframework.context.annotation.AnnotationAttributes . getString ( STRING ) ) ; for ( AnnotationAttributes org.springframework.context.annotation.AnnotationAttributes : org.springframework.context.annotation.AnnotationAttributes . getAnnotationArray ( STRING ) ) { for ( TypeFilter org.springframework.context.annotation.TypeFilter : java.util.List<org.springframework.context.annotation.TypeFilter> ( org.springframework.context.annotation.AnnotationAttributes ) ) { org.springframework.context.annotation.ClassPathBeanDefinitionScanner . addIncludeFilter ( org.springframework.context.annotation.TypeFilter ) ; } } for ( AnnotationAttributes org.springframework.context.annotation.AnnotationAttributes : org.springframework.context.annotation.AnnotationAttributes . getAnnotationArray ( STRING ) ) { for ( TypeFilter org.springframework.context.annotation.TypeFilter : java.util.List<org.springframework.context.annotation.TypeFilter> ( org.springframework.context.annotation.AnnotationAttributes ) ) { org.springframework.context.annotation.ClassPathBeanDefinitionScanner . addExcludeFilter ( org.springframework.context.annotation.TypeFilter ) ; } } boolean boolean = org.springframework.context.annotation.AnnotationAttributes . getBoolean ( STRING ) ; if ( boolean ) { org.springframework.context.annotation.ClassPathBeanDefinitionScanner . getBeanDefinitionDefaults ( ) . setLazyInit ( true ) ; } java.util.Set<java.lang.String> < java.lang.String > java.util.Set<java.lang.String> = new java.util.LinkedHashSet<java.lang.String> <> ( ) ; java.lang.String [] java.lang.String[] = org.springframework.context.annotation.AnnotationAttributes . getStringArray ( STRING ) ; for ( java.lang.String java.lang.String : java.lang.String[] ) { java.lang.String [] java.lang.String[] = StringUtils . tokenizeToStringArray ( this . org.springframework.context.annotation.Environment . resolvePlaceholders ( java.lang.String ) , ConfigurableApplicationContext . CONFIG_LOCATION_DELIMITERS ) ; java.util.Set<java.lang.String> . boolean ( java.util.Arrays . java.util.List<java.lang.String> ( java.lang.String[] ) ) ; } for ( java.lang.Class<?> < ? > java.lang.Class<?> : org.springframework.context.annotation.AnnotationAttributes . getClassArray ( STRING ) ) { java.util.Set<java.lang.String> . boolean ( ClassUtils . getPackageName ( java.lang.Class<> ) ) ; } if ( java.util.Set<java.lang.String> . boolean ( ) ) { java.util.Set<java.lang.String> . boolean ( ClassUtils . getPackageName ( java.lang.String ) ) ; } org.springframework.context.annotation.ClassPathBeanDefinitionScanner . addExcludeFilter ( new AbstractTypeHierarchyTraversingFilter ( false , false ) { @ java.lang.Override protected boolean boolean ( java.lang.String java.lang.String ) { return java.lang.String . boolean ( java.lang.String ) ; } } ) ; return org.springframework.context.annotation.ClassPathBeanDefinitionScanner . doScan ( StringUtils . toStringArray ( java.util.Set<java.lang.String> ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected boolean boolean ( java.lang.String java.lang.String ) { return java.lang.String . boolean ( java.lang.String ) ; }  <METHOD_END>
<METHOD_START> private java.util.List<org.springframework.context.annotation.TypeFilter> < TypeFilter > java.util.List<org.springframework.context.annotation.TypeFilter> ( AnnotationAttributes org.springframework.context.annotation.AnnotationAttributes ) { java.util.List<org.springframework.context.annotation.TypeFilter> < TypeFilter > java.util.List<org.springframework.context.annotation.TypeFilter> = new java.util.ArrayList<org.springframework.context.annotation.TypeFilter> <> ( ) ; FilterType org.springframework.context.annotation.FilterType = org.springframework.context.annotation.AnnotationAttributes . getEnum ( STRING ) ; for ( java.lang.Class<?> < ? > java.lang.Class<?> : org.springframework.context.annotation.AnnotationAttributes . getClassArray ( STRING ) ) { switch ( org.springframework.context.annotation.FilterType ) { case ANNOTATION : Assert . isAssignable ( java.lang.annotation.Annotation .class , java.lang.Class<> , STRING ) ; @ java.lang.SuppressWarnings ( STRING ) java.lang.Class<java.lang.annotation.Annotation> < java.lang.annotation.Annotation > java.lang.Class<java.lang.annotation.Annotation> = ( java.lang.Class<java.lang.annotation.Annotation> < java.lang.annotation.Annotation > ) java.lang.Class<> ; java.util.List<org.springframework.context.annotation.TypeFilter> . add ( new AnnotationTypeFilter ( java.lang.Class<java.lang.annotation.Annotation> ) ) ; break; case ASSIGNABLE_TYPE : java.util.List<org.springframework.context.annotation.TypeFilter> . add ( new AssignableTypeFilter ( java.lang.Class<> ) ) ; break; case CUSTOM : Assert . isAssignable ( TypeFilter .class , java.lang.Class<> , STRING ) ; TypeFilter org.springframework.context.annotation.TypeFilter = BeanUtils . instantiateClass ( java.lang.Class<> , TypeFilter .class ) ; ParserStrategyUtils . invokeAwareMethods ( org.springframework.context.annotation.TypeFilter , this . org.springframework.context.annotation.Environment , this . org.springframework.context.annotation.ResourceLoader , this . org.springframework.context.annotation.BeanDefinitionRegistry ) ; java.util.List<org.springframework.context.annotation.TypeFilter> . add ( org.springframework.context.annotation.TypeFilter ) ; break; default: throw new java.lang.IllegalArgumentException ( STRING + org.springframework.context.annotation.FilterType ) ; } } for ( java.lang.String java.lang.String : org.springframework.context.annotation.AnnotationAttributes . getStringArray ( STRING ) ) { switch ( org.springframework.context.annotation.FilterType ) { case ASPECTJ : java.util.List<org.springframework.context.annotation.TypeFilter> . add ( new AspectJTypeFilter ( java.lang.String , this . org.springframework.context.annotation.ResourceLoader . getClassLoader ( ) ) ) ; break; case REGEX : java.util.List<org.springframework.context.annotation.TypeFilter> . add ( new RegexPatternTypeFilter ( java.util.regex.Pattern . java.util.regex.Pattern ( java.lang.String ) ) ) ; break; default: throw new java.lang.IllegalArgumentException ( STRING + org.springframework.context.annotation.FilterType ) ; } } return java.util.List<org.springframework.context.annotation.TypeFilter> ; }  <METHOD_END>
