<METHOD_START> public void void ( int int ) { Assert . isTrue ( int > NUMBER , STRING ) ; this . int = int ; if ( this . java.util.concurrent.ScheduledExecutorService instanceof java.util.concurrent.ScheduledThreadPoolExecutor ) { ( ( java.util.concurrent.ScheduledThreadPoolExecutor ) this . java.util.concurrent.ScheduledExecutorService ) . void ( int ) ; } }  <METHOD_END>
<METHOD_START> public void void ( boolean boolean ) { this . boolean = boolean ; if ( this . java.util.concurrent.ScheduledExecutorService instanceof java.util.concurrent.ScheduledThreadPoolExecutor ) { ( ( java.util.concurrent.ScheduledThreadPoolExecutor ) this . java.util.concurrent.ScheduledExecutorService ) . void ( boolean ) ; } else if ( boolean && this . java.util.concurrent.ScheduledExecutorService != null ) { logger . info ( STRING ) ; } }  <METHOD_END>
<METHOD_START> public void void ( ErrorHandler org.springframework.scheduling.concurrent.ErrorHandler ) { this . org.springframework.scheduling.concurrent.ErrorHandler = org.springframework.scheduling.concurrent.ErrorHandler ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected java.util.concurrent.ExecutorService java.util.concurrent.ExecutorService ( java.util.concurrent.ThreadFactory java.util.concurrent.ThreadFactory , java.util.concurrent.RejectedExecutionHandler java.util.concurrent.RejectedExecutionHandler ) { this . java.util.concurrent.ScheduledExecutorService = java.util.concurrent.ScheduledExecutorService ( this . int , java.util.concurrent.ThreadFactory , java.util.concurrent.RejectedExecutionHandler ) ; if ( this . boolean ) { if ( this . java.util.concurrent.ScheduledExecutorService instanceof java.util.concurrent.ScheduledThreadPoolExecutor ) { ( ( java.util.concurrent.ScheduledThreadPoolExecutor ) this . java.util.concurrent.ScheduledExecutorService ) . void ( true ) ; } else { logger . info ( STRING ) ; } } return this . java.util.concurrent.ScheduledExecutorService ; }  <METHOD_END>
<METHOD_START> protected java.util.concurrent.ScheduledExecutorService java.util.concurrent.ScheduledExecutorService ( int int , java.util.concurrent.ThreadFactory java.util.concurrent.ThreadFactory , java.util.concurrent.RejectedExecutionHandler java.util.concurrent.RejectedExecutionHandler ) { return new java.util.concurrent.ScheduledThreadPoolExecutor ( int , java.util.concurrent.ThreadFactory , java.util.concurrent.RejectedExecutionHandler ) ; }  <METHOD_END>
<METHOD_START> public java.util.concurrent.ScheduledExecutorService java.util.concurrent.ScheduledExecutorService ( ) java.lang.IllegalStateException { Assert . state ( this . java.util.concurrent.ScheduledExecutorService != null , STRING ) ; return this . java.util.concurrent.ScheduledExecutorService ; }  <METHOD_END>
<METHOD_START> public java.util.concurrent.ScheduledThreadPoolExecutor java.util.concurrent.ScheduledThreadPoolExecutor ( ) java.lang.IllegalStateException { Assert . state ( this . java.util.concurrent.ScheduledExecutorService instanceof java.util.concurrent.ScheduledThreadPoolExecutor , STRING ) ; return ( java.util.concurrent.ScheduledThreadPoolExecutor ) this . java.util.concurrent.ScheduledExecutorService ; }  <METHOD_END>
<METHOD_START> public int int ( ) { if ( this . java.util.concurrent.ScheduledExecutorService == null ) { return this . int ; } return java.util.concurrent.ScheduledThreadPoolExecutor ( ) . int ( ) ; }  <METHOD_END>
<METHOD_START> public boolean boolean ( ) { if ( this . java.util.concurrent.ScheduledExecutorService == null ) { return this . boolean ; } return java.util.concurrent.ScheduledThreadPoolExecutor ( ) . boolean ( ) ; }  <METHOD_END>
<METHOD_START> public int int ( ) { if ( this . java.util.concurrent.ScheduledExecutorService == null ) { return NUMBER ; } return java.util.concurrent.ScheduledThreadPoolExecutor ( ) . int ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( java.lang.Runnable java.lang.Runnable ) { java.util.concurrent.Executor java.util.concurrent.Executor = java.util.concurrent.ScheduledExecutorService ( ) ; try { java.util.concurrent.Executor . void ( java.lang.Runnable ( java.lang.Runnable , false ) ) ; } catch ( java.util.concurrent.RejectedExecutionException java.util.concurrent.RejectedExecutionException ) { throw new TaskRejectedException ( STRING + java.util.concurrent.Executor + STRING + java.lang.Runnable , java.util.concurrent.RejectedExecutionException ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( java.lang.Runnable java.lang.Runnable , long long ) { void ( java.lang.Runnable ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.util.concurrent.Future<?> < ? > java.util.concurrent.Future<?> ( java.lang.Runnable java.lang.Runnable ) { java.util.concurrent.ExecutorService java.util.concurrent.ExecutorService = java.util.concurrent.ScheduledExecutorService ( ) ; try { return java.util.concurrent.ExecutorService . java.util.concurrent.Future<?> ( java.lang.Runnable ( java.lang.Runnable , false ) ) ; } catch ( java.util.concurrent.RejectedExecutionException java.util.concurrent.RejectedExecutionException ) { throw new TaskRejectedException ( STRING + java.util.concurrent.ExecutorService + STRING + java.lang.Runnable , java.util.concurrent.RejectedExecutionException ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public < T > java.util.concurrent.Future<T> < T > java.util.concurrent.Future<T> ( java.util.concurrent.Callable<T> < T > java.util.concurrent.Callable<T> ) { java.util.concurrent.ExecutorService java.util.concurrent.ExecutorService = java.util.concurrent.ScheduledExecutorService ( ) ; try { java.util.concurrent.Callable<T> < T > java.util.concurrent.Callable<T> = java.util.concurrent.Callable<T> ; if ( this . org.springframework.scheduling.concurrent.ErrorHandler != null ) { java.util.concurrent.Callable<T> = new org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler.DelegatingErrorHandlingCallable <> ( java.util.concurrent.Callable<T> , this . org.springframework.scheduling.concurrent.ErrorHandler ) ; } return java.util.concurrent.ExecutorService . java.util.concurrent.Future<T> ( java.util.concurrent.Callable<T> ) ; } catch ( java.util.concurrent.RejectedExecutionException java.util.concurrent.RejectedExecutionException ) { throw new TaskRejectedException ( STRING + java.util.concurrent.ExecutorService + STRING + java.util.concurrent.Callable<T> , java.util.concurrent.RejectedExecutionException ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.scheduling.concurrent.ListenableFuture<?> < ? > org.springframework.scheduling.concurrent.ListenableFuture<?> ( java.lang.Runnable java.lang.Runnable ) { java.util.concurrent.ExecutorService java.util.concurrent.ExecutorService = java.util.concurrent.ScheduledExecutorService ( ) ; try { ListenableFutureTask < java.lang.Object > org.springframework.scheduling.concurrent.ListenableFutureTask<java.lang.Object> = new ListenableFutureTask <> ( java.lang.Runnable , null ) ; java.util.concurrent.ExecutorService . void ( java.lang.Runnable ( org.springframework.scheduling.concurrent.ListenableFutureTask<java.lang.Object> , false ) ) ; return org.springframework.scheduling.concurrent.ListenableFutureTask<java.lang.Object> ; } catch ( java.util.concurrent.RejectedExecutionException java.util.concurrent.RejectedExecutionException ) { throw new TaskRejectedException ( STRING + java.util.concurrent.ExecutorService + STRING + java.lang.Runnable , java.util.concurrent.RejectedExecutionException ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public < T > org.springframework.scheduling.concurrent.ListenableFuture<T> < T > org.springframework.scheduling.concurrent.ListenableFuture<T> ( java.util.concurrent.Callable<T> < T > java.util.concurrent.Callable<T> ) { java.util.concurrent.ExecutorService java.util.concurrent.ExecutorService = java.util.concurrent.ScheduledExecutorService ( ) ; try { ListenableFutureTask < T > org.springframework.scheduling.concurrent.ListenableFutureTask<T> = new ListenableFutureTask <> ( java.util.concurrent.Callable<T> ) ; java.util.concurrent.ExecutorService . void ( java.lang.Runnable ( org.springframework.scheduling.concurrent.ListenableFutureTask<T> , false ) ) ; return org.springframework.scheduling.concurrent.ListenableFutureTask<T> ; } catch ( java.util.concurrent.RejectedExecutionException java.util.concurrent.RejectedExecutionException ) { throw new TaskRejectedException ( STRING + java.util.concurrent.ExecutorService + STRING + java.util.concurrent.Callable<T> , java.util.concurrent.RejectedExecutionException ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( ) { return true ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.util.concurrent.ScheduledFuture<?> < ? > java.util.concurrent.ScheduledFuture<?> ( java.lang.Runnable java.lang.Runnable , Trigger org.springframework.scheduling.concurrent.Trigger ) { java.util.concurrent.ScheduledExecutorService java.util.concurrent.ScheduledExecutorService = java.util.concurrent.ScheduledExecutorService ( ) ; try { ErrorHandler org.springframework.scheduling.concurrent.ErrorHandler = ( this . org.springframework.scheduling.concurrent.ErrorHandler != null ? this . org.springframework.scheduling.concurrent.ErrorHandler : TaskUtils . getDefaultErrorHandler ( true ) ) ; return new ReschedulingRunnable ( java.lang.Runnable , org.springframework.scheduling.concurrent.Trigger , java.util.concurrent.ScheduledExecutorService , org.springframework.scheduling.concurrent.ErrorHandler ) . schedule ( ) ; } catch ( java.util.concurrent.RejectedExecutionException java.util.concurrent.RejectedExecutionException ) { throw new TaskRejectedException ( STRING + java.util.concurrent.ScheduledExecutorService + STRING + java.lang.Runnable , java.util.concurrent.RejectedExecutionException ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.util.concurrent.ScheduledFuture<?> < ? > java.util.concurrent.ScheduledFuture<?> ( java.lang.Runnable java.lang.Runnable , java.util.Date java.util.Date ) { java.util.concurrent.ScheduledExecutorService java.util.concurrent.ScheduledExecutorService = java.util.concurrent.ScheduledExecutorService ( ) ; long long = java.util.Date . long ( ) - java.lang.System . long ( ) ; try { return java.util.concurrent.ScheduledExecutorService . java.util.concurrent.ScheduledFuture<?> ( java.lang.Runnable ( java.lang.Runnable , false ) , long , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ; } catch ( java.util.concurrent.RejectedExecutionException java.util.concurrent.RejectedExecutionException ) { throw new TaskRejectedException ( STRING + java.util.concurrent.ScheduledExecutorService + STRING + java.lang.Runnable , java.util.concurrent.RejectedExecutionException ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.util.concurrent.ScheduledFuture<?> < ? > java.util.concurrent.ScheduledFuture<?> ( java.lang.Runnable java.lang.Runnable , java.util.Date java.util.Date , long long ) { java.util.concurrent.ScheduledExecutorService java.util.concurrent.ScheduledExecutorService = java.util.concurrent.ScheduledExecutorService ( ) ; long long = java.util.Date . long ( ) - java.lang.System . long ( ) ; try { return java.util.concurrent.ScheduledExecutorService . java.util.concurrent.ScheduledFuture<?> ( java.lang.Runnable ( java.lang.Runnable , true ) , long , long , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ; } catch ( java.util.concurrent.RejectedExecutionException java.util.concurrent.RejectedExecutionException ) { throw new TaskRejectedException ( STRING + java.util.concurrent.ScheduledExecutorService + STRING + java.lang.Runnable , java.util.concurrent.RejectedExecutionException ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.util.concurrent.ScheduledFuture<?> < ? > java.util.concurrent.ScheduledFuture<?> ( java.lang.Runnable java.lang.Runnable , long long ) { java.util.concurrent.ScheduledExecutorService java.util.concurrent.ScheduledExecutorService = java.util.concurrent.ScheduledExecutorService ( ) ; try { return java.util.concurrent.ScheduledExecutorService . java.util.concurrent.ScheduledFuture<?> ( java.lang.Runnable ( java.lang.Runnable , true ) , NUMBER , long , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ; } catch ( java.util.concurrent.RejectedExecutionException java.util.concurrent.RejectedExecutionException ) { throw new TaskRejectedException ( STRING + java.util.concurrent.ScheduledExecutorService + STRING + java.lang.Runnable , java.util.concurrent.RejectedExecutionException ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.util.concurrent.ScheduledFuture<?> < ? > java.util.concurrent.ScheduledFuture<?> ( java.lang.Runnable java.lang.Runnable , java.util.Date java.util.Date , long long ) { java.util.concurrent.ScheduledExecutorService java.util.concurrent.ScheduledExecutorService = java.util.concurrent.ScheduledExecutorService ( ) ; long long = java.util.Date . long ( ) - java.lang.System . long ( ) ; try { return java.util.concurrent.ScheduledExecutorService . java.util.concurrent.ScheduledFuture<?> ( java.lang.Runnable ( java.lang.Runnable , true ) , long , long , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ; } catch ( java.util.concurrent.RejectedExecutionException java.util.concurrent.RejectedExecutionException ) { throw new TaskRejectedException ( STRING + java.util.concurrent.ScheduledExecutorService + STRING + java.lang.Runnable , java.util.concurrent.RejectedExecutionException ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.util.concurrent.ScheduledFuture<?> < ? > java.util.concurrent.ScheduledFuture<?> ( java.lang.Runnable java.lang.Runnable , long long ) { java.util.concurrent.ScheduledExecutorService java.util.concurrent.ScheduledExecutorService = java.util.concurrent.ScheduledExecutorService ( ) ; try { return java.util.concurrent.ScheduledExecutorService . java.util.concurrent.ScheduledFuture<?> ( java.lang.Runnable ( java.lang.Runnable , true ) , NUMBER , long , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ; } catch ( java.util.concurrent.RejectedExecutionException java.util.concurrent.RejectedExecutionException ) { throw new TaskRejectedException ( STRING + java.util.concurrent.ScheduledExecutorService + STRING + java.lang.Runnable , java.util.concurrent.RejectedExecutionException ) ; } }  <METHOD_END>
<METHOD_START> private java.lang.Runnable java.lang.Runnable ( java.lang.Runnable java.lang.Runnable , boolean boolean ) { return TaskUtils . decorateTaskWithErrorHandler ( java.lang.Runnable , this . org.springframework.scheduling.concurrent.ErrorHandler , boolean ) ; }  <METHOD_END>
<METHOD_START> public void ( java.util.concurrent.Callable<V> < V > java.util.concurrent.Callable<V> , ErrorHandler org.springframework.scheduling.concurrent.ErrorHandler ) { this . java.util.concurrent.Callable<V> = java.util.concurrent.Callable<V> ; this . org.springframework.scheduling.concurrent.ErrorHandler = org.springframework.scheduling.concurrent.ErrorHandler ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public V V ( ) java.lang.Exception { try { return this . java.util.concurrent.Callable<V> . V ( ) ; } catch ( java.lang.Throwable java.lang.Throwable ) { this . org.springframework.scheduling.concurrent.ErrorHandler . handleError ( java.lang.Throwable ) ; return null ; } }  <METHOD_END>
