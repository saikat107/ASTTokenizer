<METHOD_START> public void ( java.lang.Class<?> < ? > java.lang.Class<?> ) { super( java.util.Map<java.lang.Class<? extends java.lang.Throwable>,java.lang.reflect.Method> ( java.lang.Class<> ) ); }  <METHOD_END>
<METHOD_START> private static java.util.Map<java.lang.Class<? extends java.lang.Throwable>,java.lang.reflect.Method> < java.lang.Class<? extends java.lang.Throwable> < ? extends java.lang.Throwable > , java.lang.reflect.Method > java.util.Map<java.lang.Class<? extends java.lang.Throwable>,java.lang.reflect.Method> ( java.lang.Class<?> < ? > java.lang.Class<?> ) { java.util.Map<java.lang.reflect.Method,org.springframework.messaging.handler.annotation.support.MessageExceptionHandler> < java.lang.reflect.Method , MessageExceptionHandler > java.util.Map<java.lang.reflect.Method,org.springframework.messaging.handler.annotation.support.MessageExceptionHandler> = MethodIntrospector . selectMethods ( java.lang.Class<> , new MethodIntrospector . MethodIntrospector < MessageExceptionHandler > ( ) { @ Override public MessageExceptionHandler inspect ( Method method ) { return AnnotationUtils . findAnnotation ( method , MessageExceptionHandler .class ) ; } } ) ; java.util.Map<java.lang.Class<? extends java.lang.Throwable>,java.lang.reflect.Method> < java.lang.Class<? extends java.lang.Throwable> < ? extends java.lang.Throwable > , java.lang.reflect.Method > java.util.Map<java.lang.Class<? extends java.lang.Throwable>,java.lang.reflect.Method> = new java.util.HashMap<java.lang.Class<? extends java.lang.Throwable>,java.lang.reflect.Method> <> ( ) ; for ( java.util.Map . java.util.Map.Entry<java.lang.reflect.Method,org.springframework.messaging.handler.annotation.support.MessageExceptionHandler> < java.lang.reflect.Method , MessageExceptionHandler > java.util.Map.Entry<java.lang.reflect.Method,org.springframework.messaging.handler.annotation.support.MessageExceptionHandler> : java.util.Map<java.lang.reflect.Method,org.springframework.messaging.handler.annotation.support.MessageExceptionHandler> . entrySet ( ) ) { java.lang.reflect.Method java.lang.reflect.Method = java.util.Map.Entry<java.lang.reflect.Method,org.springframework.messaging.handler.annotation.support.MessageExceptionHandler> . getKey ( ) ; java.util.List<java.lang.Class<? extends java.lang.Throwable>> < java.lang.Class<? extends java.lang.Throwable> < ? extends java.lang.Throwable > > java.util.List<java.lang.Class<? extends java.lang.Throwable>> = new java.util.ArrayList<java.lang.Class<? extends java.lang.Throwable>> <> ( ) ; java.util.List<java.lang.Class<? extends java.lang.Throwable>> . boolean ( java.util.Arrays . java.util.List ( java.util.Map.Entry<java.lang.reflect.Method,org.springframework.messaging.handler.annotation.support.MessageExceptionHandler> . getValue ( ) . value ( ) ) ) ; if ( java.util.List<java.lang.Class<? extends java.lang.Throwable>> . boolean ( ) ) { java.util.List<java.lang.Class<? extends java.lang.Throwable>> . boolean ( getExceptionsFromMethodSignature ( java.lang.reflect.Method ) ) ; } for ( java.lang.Class<? extends java.lang.Throwable> < ? extends java.lang.Throwable > java.lang.Class<? extends java.lang.Throwable> : java.util.List<java.lang.Class<? extends java.lang.Throwable>> ) { java.lang.reflect.Method java.lang.reflect.Method = java.util.Map<java.lang.Class<? extends java.lang.Throwable>,java.lang.reflect.Method> . java.lang.reflect.Method ( java.lang.Class<> , java.lang.reflect.Method ) ; if ( java.lang.reflect.Method != null && ! java.lang.reflect.Method . boolean ( java.lang.reflect.Method ) ) { throw new java.lang.IllegalStateException ( STRING + java.lang.Class<> + STRING + java.lang.reflect.Method + STRING + java.lang.reflect.Method + STRING ) ; } } } return java.util.Map<java.lang.Class<? extends java.lang.Throwable>,java.lang.reflect.Method> ; }  <METHOD_END>
<METHOD_START> @ Override public MessageExceptionHandler inspect ( Method method ) { return AnnotationUtils . findAnnotation ( method , MessageExceptionHandler .class ) ; }  <METHOD_END>
