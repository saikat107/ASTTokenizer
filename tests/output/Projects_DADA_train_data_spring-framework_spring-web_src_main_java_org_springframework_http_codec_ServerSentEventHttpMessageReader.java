<METHOD_START> public void ( ) { this( null ); }  <METHOD_END>
<METHOD_START> public void ( Decoder < ? > org.springframework.http.codec.Decoder<?> ) { this . org.springframework.http.codec.Decoder<?> = org.springframework.http.codec.Decoder<> ; }  <METHOD_END>
<METHOD_START> public org.springframework.http.codec.Decoder<?> < ? > org.springframework.http.codec.Decoder<?> ( ) { return this . org.springframework.http.codec.Decoder<> ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.util.List<org.springframework.http.codec.MediaType> < MediaType > java.util.List<org.springframework.http.codec.MediaType> ( ) { return java.util.Collections . java.util.List ( MediaType . TEXT_EVENT_STREAM ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( ResolvableType org.springframework.http.codec.ResolvableType , MediaType org.springframework.http.codec.MediaType ) { return MediaType . TEXT_EVENT_STREAM . includes ( org.springframework.http.codec.MediaType ) || ServerSentEvent .class . boolean ( org.springframework.http.codec.ResolvableType . getRawClass ( ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.http.codec.Flux<java.lang.Object> < java.lang.Object > org.springframework.http.codec.Flux<java.lang.Object> ( ResolvableType org.springframework.http.codec.ResolvableType , ReactiveHttpInputMessage org.springframework.http.codec.ReactiveHttpInputMessage , java.util.Map<java.lang.String,java.lang.Object> < java.lang.String , java.lang.Object > java.util.Map<java.lang.String,java.lang.Object> ) { boolean boolean = ServerSentEvent .class . boolean ( org.springframework.http.codec.ResolvableType . getRawClass ( ) ) ; ResolvableType org.springframework.http.codec.ResolvableType = boolean ? org.springframework.http.codec.ResolvableType . getGeneric ( NUMBER ) : org.springframework.http.codec.ResolvableType ; return Flux . from ( org.springframework.http.codec.ReactiveHttpInputMessage . getBody ( ) ) . concatMap ( org.springframework.http.codec.ServerSentEventHttpMessageReader :: org.springframework.http.codec.Flux<org.springframework.http.codec.DataBuffer> ) . map ( buffer -> { CharBuffer charBuffer = StandardCharsets . UTF_8 . decode ( buffer . asByteBuffer ( ) ) ; DataBufferUtils . release ( buffer ) ; return charBuffer . toString ( ) ; } ) . bufferUntil ( line -> line . equals ( STRING ) ) . concatMap ( rawLines -> { String [] lines = rawLines . stream ( ) . collect ( joining ( ) ) . split ( STRING ) ; ServerSentEvent < Object > event = buildEvent ( lines , valueType , hints ) ; return ( shouldWrap ? Mono . just ( event ) : Mono . justOrEmpty ( event . data ( ) ) ) ; } ) . cast ( java.lang.Object .class ) ; }  <METHOD_END>
<METHOD_START> private static org.springframework.http.codec.Flux<org.springframework.http.codec.DataBuffer> < DataBuffer > org.springframework.http.codec.Flux<org.springframework.http.codec.DataBuffer> ( DataBuffer org.springframework.http.codec.DataBuffer ) { java.util.List<org.springframework.http.codec.DataBuffer> < DataBuffer > java.util.List<org.springframework.http.codec.DataBuffer> = new java.util.ArrayList<org.springframework.http.codec.DataBuffer> <> ( ) ; int int = NUMBER ; int int ; final int int = org.springframework.http.codec.DataBuffer . readableByteCount ( ) ; do { int = org.springframework.http.codec.DataBuffer . indexOf ( java.util.function.IntPredicate , int ) ; int int = int != - NUMBER ? int - int + NUMBER : int - int ; DataBuffer org.springframework.http.codec.DataBuffer = org.springframework.http.codec.DataBuffer . slice ( int , int ) ; java.util.List<org.springframework.http.codec.DataBuffer> . add ( DataBufferUtils . retain ( org.springframework.http.codec.DataBuffer ) ) ; int = int + NUMBER ; } while ( int < int && int != - NUMBER ); DataBufferUtils . release ( org.springframework.http.codec.DataBuffer ) ; return Flux . fromIterable ( java.util.List<org.springframework.http.codec.DataBuffer> ) ; }  <METHOD_END>
<METHOD_START> private org.springframework.http.codec.ServerSentEvent<java.lang.Object> < java.lang.Object > org.springframework.http.codec.ServerSentEvent<java.lang.Object> ( java.lang.String [] java.lang.String[] , ResolvableType org.springframework.http.codec.ResolvableType , java.util.Map<java.lang.String,java.lang.Object> < java.lang.String , java.lang.Object > java.util.Map<java.lang.String,java.lang.Object> ) { ServerSentEvent . ServerSentEvent < java.lang.Object > sseBuilder = ServerSentEvent . builder ( ) ; java.lang.StringBuilder java.lang.StringBuilder = new java.lang.StringBuilder ( ) ; java.lang.StringBuilder java.lang.StringBuilder = new java.lang.StringBuilder ( ) ; for ( java.lang.String java.lang.String : java.lang.String[] ) { if ( java.lang.String . boolean ( STRING ) ) { sseBuilder . id ( java.lang.String . java.lang.String ( NUMBER ) ) ; } else if ( java.lang.String . boolean ( STRING ) ) { sseBuilder . event ( java.lang.String . java.lang.String ( NUMBER ) ) ; } else if ( java.lang.String . boolean ( STRING ) ) { java.lang.StringBuilder . java.lang.StringBuilder ( java.lang.String . java.lang.String ( NUMBER ) ) . java.lang.StringBuilder ( STRING ) ; } else if ( java.lang.String . boolean ( STRING ) ) { sseBuilder . retry ( java.time.Duration . java.time.Duration ( java.lang.Long . java.lang.Long ( java.lang.String . java.lang.String ( NUMBER ) ) ) ) ; } else if ( java.lang.String . boolean ( STRING ) ) { java.lang.StringBuilder . java.lang.StringBuilder ( java.lang.String . java.lang.String ( NUMBER ) ) . java.lang.StringBuilder ( STRING ) ; } } if ( java.lang.StringBuilder . int ( ) > NUMBER ) { java.lang.String java.lang.String = java.lang.StringBuilder . java.lang.String ( ) ; sseBuilder . data ( java.lang.Object ( java.lang.String , org.springframework.http.codec.ResolvableType , java.util.Map<java.lang.String,java.lang.Object> ) ) ; } if ( java.lang.StringBuilder . int ( ) > NUMBER ) { java.lang.String java.lang.String = java.lang.StringBuilder . java.lang.String ( ) ; sseBuilder . comment ( java.lang.String . java.lang.String ( NUMBER , java.lang.String . int ( ) - NUMBER ) ) ; } return sseBuilder . build ( ) ; }  <METHOD_END>
<METHOD_START> private java.lang.Object java.lang.Object ( java.lang.String java.lang.String , ResolvableType org.springframework.http.codec.ResolvableType , java.util.Map<java.lang.String,java.lang.Object> < java.lang.String , java.lang.Object > java.util.Map<java.lang.String,java.lang.Object> ) { if ( java.lang.String .class . boolean ( org.springframework.http.codec.ResolvableType . getRawClass ( ) ) ) { return java.lang.String . java.lang.String ( NUMBER , java.lang.String . int ( ) - NUMBER ) ; } byte [] byte[] = java.lang.String . byte[] ( java.nio.charset.StandardCharsets . java.nio.charset.Charset ) ; Mono < DataBuffer > org.springframework.http.codec.Mono<org.springframework.http.codec.DataBuffer> = Mono . just ( org.springframework.http.codec.DataBufferFactory . wrap ( byte[] ) ) ; return this . org.springframework.http.codec.Decoder<> . decodeToMono ( org.springframework.http.codec.Mono<org.springframework.http.codec.DataBuffer> , org.springframework.http.codec.ResolvableType , MediaType . TEXT_EVENT_STREAM , java.util.Map<java.lang.String,java.lang.Object> ) . block ( java.time.Duration . java.time.Duration ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.http.codec.Mono<java.lang.Object> < java.lang.Object > org.springframework.http.codec.Mono<java.lang.Object> ( ResolvableType org.springframework.http.codec.ResolvableType , ReactiveHttpInputMessage org.springframework.http.codec.ReactiveHttpInputMessage , java.util.Map<java.lang.String,java.lang.Object> < java.lang.String , java.lang.Object > java.util.Map<java.lang.String,java.lang.Object> ) { if ( java.lang.String .class . boolean ( org.springframework.http.codec.ResolvableType . getRawClass ( ) ) ) { Flux < DataBuffer > org.springframework.http.codec.Flux<org.springframework.http.codec.DataBuffer> = org.springframework.http.codec.ReactiveHttpInputMessage . getBody ( ) ; return org.springframework.http.codec.StringDecoder . decodeToMono ( org.springframework.http.codec.Flux<org.springframework.http.codec.DataBuffer> , org.springframework.http.codec.ResolvableType , null , null ) . cast ( java.lang.Object .class ) ; } return Mono . error ( new java.lang.UnsupportedOperationException ( STRING ) ) ; }  <METHOD_END>
