<METHOD_START> public void ( java.lang.Object java.lang.Object , java.lang.Class<?> < ? > java.lang.Class<?> ) { Assert . notNull ( java.lang.Object , STRING ) ; this . java.lang.Object = java.lang.Object ; final java.util.concurrent.atomic.AtomicReference<java.lang.reflect.Method> < java.lang.reflect.Method > java.util.concurrent.atomic.AtomicReference<java.lang.reflect.Method> = new java.util.concurrent.atomic.AtomicReference<java.lang.reflect.Method> <> ( ) ; ReflectionUtils . doWithMethods ( java.lang.Object . java.lang.Class<? extends java.lang.Object> ( ) , java.util.concurrent.atomic.AtomicReference<java.lang.reflect.Method> :: void , methodCandidate -> { boolean isCandidate = ! methodCandidate . isBridge ( ) && ! methodCandidate . isDefault ( ) && methodCandidate . getDeclaringClass ( ) != Object .class && Modifier . isPublic ( methodCandidate . getModifiers ( ) ) && ! Modifier . isStatic ( methodCandidate . getModifiers ( ) ) ; if ( isCandidate ) { Assert . isNull ( methodValue . get ( ) , STRING + STRING ) ; } return isCandidate ; } ) ; Assert . notNull ( java.util.concurrent.atomic.AtomicReference<java.lang.reflect.Method> . java.lang.reflect.Method ( ) , STRING + STRING ) ; this . java.lang.reflect.Method = java.util.concurrent.atomic.AtomicReference<java.lang.reflect.Method> . java.lang.reflect.Method ( ) ; this . java.lang.reflect.Method . void ( true ) ; this . java.lang.Class<?>[] = this . java.lang.reflect.Method . java.lang.Class<?>[] ( ) ; this . org.springframework.integration.handler.TypeDescriptor = java.lang.Class<> != null ? TypeDescriptor . valueOf ( java.lang.Class<> ) : null ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( BeanFactory org.springframework.integration.handler.BeanFactory ) throws org.springframework.integration.handler.BeansException { ConversionService org.springframework.integration.handler.ConversionService = IntegrationUtils . getConversionService ( org.springframework.integration.handler.BeanFactory ) ; if ( org.springframework.integration.handler.ConversionService == null ) { org.springframework.integration.handler.ConversionService = DefaultConversionService . getSharedInstance ( ) ; } this . org.springframework.integration.handler.ConversionService = org.springframework.integration.handler.ConversionService ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.Object java.lang.Object ( Message < ? > org.springframework.integration.handler.Message<?> ) { java.lang.Object [] java.lang.Object[] = new java.lang.Object [ this . java.lang.Class<?>[] . int ] ; for ( int int = NUMBER ; int < this . java.lang.Class<?>[] . int ; int ++ ) { java.lang.Class<?> < ? > java.lang.Class<?> = this . java.lang.Class<?>[] [ int ] ; if ( Message .class . boolean ( java.lang.Class<> ) ) { java.lang.Object[] [ int ] = org.springframework.integration.handler.Message<> ; } else if ( java.util.Map .class . boolean ( java.lang.Class<> ) ) { if ( org.springframework.integration.handler.Message<> . getPayload ( ) instanceof java.util.Map ) { java.lang.Object[] [ int ] = org.springframework.integration.handler.Message<> . getPayload ( ) ; } else { java.lang.Object[] [ int ] = org.springframework.integration.handler.Message<> . getHeaders ( ) ; } } else { if ( this . org.springframework.integration.handler.TypeDescriptor != null ) { if ( Message .class . boolean ( this . org.springframework.integration.handler.TypeDescriptor . getType ( ) ) ) { java.lang.Object[] [ int ] = org.springframework.integration.handler.Message<> ; } else { java.lang.Object[] [ int ] = this . org.springframework.integration.handler.ConversionService . convert ( org.springframework.integration.handler.Message<> . getPayload ( ) , TypeDescriptor . forObject ( org.springframework.integration.handler.Message<> . getPayload ( ) ) , this . org.springframework.integration.handler.TypeDescriptor ) ; } } else { java.lang.Object[] [ int ] = org.springframework.integration.handler.Message<> . getPayload ( ) ; } } } try { return this . java.lang.reflect.Method . java.lang.Object ( this . java.lang.Object , java.lang.Object[] ) ; } catch ( java.lang.reflect.InvocationTargetException java.lang.reflect.InvocationTargetException ) { throw new MessageHandlingException ( org.springframework.integration.handler.Message<> , java.lang.reflect.InvocationTargetException . java.lang.Throwable ( ) ) ; } catch ( java.lang.Exception java.lang.Exception ) { throw new MessageHandlingException ( org.springframework.integration.handler.Message<> , java.lang.Exception ) ; } }  <METHOD_END>
