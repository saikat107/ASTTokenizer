<METHOD_START> public abstract boolean boolean ( T T );  <METHOD_END>
<METHOD_START> protected void ( ) { java.lang.Class<?> = java.lang.Class<?> ( java.lang.Class<? extends org.springframework.integration.test.matcher.TypeSafeMatcher> ( ) ) ; }  <METHOD_END>
<METHOD_START> private static java.lang.Class<?> < ? > java.lang.Class<?> ( java.lang.Class<?> < ? > java.lang.Class<?> ) { for ( java.lang.Class<?> < ? > java.lang.Class<?> = java.lang.Class<> ; java.lang.Class<> != java.lang.Object .class ; java.lang.Class<?> = java.lang.Class<> . java.lang.Class<? super > ( ) ) { for ( java.lang.reflect.Method java.lang.reflect.Method : java.lang.Class<> . java.lang.reflect.Method[] ( ) ) { if ( boolean ( java.lang.reflect.Method ) ) { return java.lang.reflect.Method . java.lang.Class<?>[] ( ) [ NUMBER ] ; } } } throw new java.lang.Error ( STRING ) ; }  <METHOD_END>
<METHOD_START> private static boolean boolean ( java.lang.reflect.Method java.lang.reflect.Method ) { return java.lang.reflect.Method . java.lang.String ( ) . boolean ( STRING ) && java.lang.reflect.Method . java.lang.Class<?>[] ( ) . int == NUMBER && ! java.lang.reflect.Method . boolean ( ) ; }  <METHOD_END>
<METHOD_START> protected void ( java.lang.Class<T> < T > java.lang.Class<T> ) { this . java.lang.Class<?> = java.lang.Class<T> ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override @ java.lang.SuppressWarnings ( { STRING } ) public final boolean boolean ( java.lang.Object java.lang.Object ) { return java.lang.Object != null && java.lang.Class<> . boolean ( java.lang.Object ) && boolean ( ( T ) java.lang.Object ) ; }  <METHOD_END>
