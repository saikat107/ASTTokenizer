<METHOD_START> private void ( boolean boolean , MimeType ... org.springframework.core.codec.MimeType[] ) { super( org.springframework.core.codec.MimeType[] ); this . boolean = boolean ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( ResolvableType org.springframework.core.codec.ResolvableType , MimeType org.springframework.core.codec.MimeType ) { return ( super. canDecode ( org.springframework.core.codec.ResolvableType , org.springframework.core.codec.MimeType ) && java.lang.String .class . boolean ( org.springframework.core.codec.ResolvableType . getRawClass ( ) ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.core.codec.Flux<java.lang.String> < java.lang.String > org.springframework.core.codec.Flux<java.lang.String> ( Publisher < DataBuffer > org.springframework.core.codec.Publisher<org.springframework.core.codec.DataBuffer> , ResolvableType org.springframework.core.codec.ResolvableType , MimeType org.springframework.core.codec.MimeType , java.util.Map<java.lang.String,java.lang.Object> < java.lang.String , java.lang.Object > java.util.Map<java.lang.String,java.lang.Object> ) { Flux < DataBuffer > org.springframework.core.codec.Flux<org.springframework.core.codec.DataBuffer> = Flux . from ( org.springframework.core.codec.Publisher<org.springframework.core.codec.DataBuffer> ) ; if ( this . boolean ) { org.springframework.core.codec.Flux<org.springframework.core.codec.DataBuffer> = Flux . from ( org.springframework.core.codec.Publisher<org.springframework.core.codec.DataBuffer> ) . flatMap ( org.springframework.core.codec.StringDecoder :: org.springframework.core.codec.Flux<org.springframework.core.codec.DataBuffer> ) ; } return org.springframework.core.codec.Flux<org.springframework.core.codec.DataBuffer> . map ( buffer -> decodeDataBuffer ( buffer , mimeType ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.core.codec.Mono<java.lang.String> < java.lang.String > org.springframework.core.codec.Mono<java.lang.String> ( Publisher < DataBuffer > org.springframework.core.codec.Publisher<org.springframework.core.codec.DataBuffer> , ResolvableType org.springframework.core.codec.ResolvableType , MimeType org.springframework.core.codec.MimeType , java.util.Map<java.lang.String,java.lang.Object> < java.lang.String , java.lang.Object > java.util.Map<java.lang.String,java.lang.Object> ) { return Flux . from ( org.springframework.core.codec.Publisher<org.springframework.core.codec.DataBuffer> ) . reduce ( DataBuffer :: write ) . map ( buffer -> decodeDataBuffer ( buffer , mimeType ) ) ; }  <METHOD_END>
<METHOD_START> private static org.springframework.core.codec.Flux<org.springframework.core.codec.DataBuffer> < DataBuffer > org.springframework.core.codec.Flux<org.springframework.core.codec.DataBuffer> ( DataBuffer org.springframework.core.codec.DataBuffer ) { java.util.List<org.springframework.core.codec.DataBuffer> < DataBuffer > java.util.List<org.springframework.core.codec.DataBuffer> = new java.util.ArrayList<org.springframework.core.codec.DataBuffer> <> ( ) ; int int = NUMBER ; int int ; final int int = org.springframework.core.codec.DataBuffer . readableByteCount ( ) ; do { int = org.springframework.core.codec.DataBuffer . indexOf ( java.util.function.IntPredicate , int ) ; int int = int != - NUMBER ? int - int + NUMBER : int - int ; DataBuffer org.springframework.core.codec.DataBuffer = org.springframework.core.codec.DataBuffer . slice ( int , int ) ; java.util.List<org.springframework.core.codec.DataBuffer> . add ( DataBufferUtils . retain ( org.springframework.core.codec.DataBuffer ) ) ; int = int + NUMBER ; } while ( int < int && int != - NUMBER ); DataBufferUtils . release ( org.springframework.core.codec.DataBuffer ) ; return Flux . fromIterable ( java.util.List<org.springframework.core.codec.DataBuffer> ) ; }  <METHOD_END>
<METHOD_START> private java.lang.String java.lang.String ( DataBuffer org.springframework.core.codec.DataBuffer , MimeType org.springframework.core.codec.MimeType ) { java.nio.charset.Charset java.nio.charset.Charset = java.nio.charset.Charset ( org.springframework.core.codec.MimeType ) ; java.nio.CharBuffer java.nio.CharBuffer = java.nio.charset.Charset . java.nio.CharBuffer ( org.springframework.core.codec.DataBuffer . asByteBuffer ( ) ) ; DataBufferUtils . release ( org.springframework.core.codec.DataBuffer ) ; return java.nio.CharBuffer . java.lang.String ( ) ; }  <METHOD_END>
<METHOD_START> private java.nio.charset.Charset java.nio.charset.Charset ( MimeType org.springframework.core.codec.MimeType ) { if ( org.springframework.core.codec.MimeType != null && org.springframework.core.codec.MimeType . getCharset ( ) != null ) { return org.springframework.core.codec.MimeType . getCharset ( ) ; } else { return java.nio.charset.Charset ; } }  <METHOD_END>
<METHOD_START> public static org.springframework.core.codec.StringDecoder org.springframework.core.codec.StringDecoder ( boolean boolean ) { return new org.springframework.core.codec.StringDecoder ( boolean , new MimeType ( STRING , STRING , java.nio.charset.Charset ) ) ; }  <METHOD_END>
<METHOD_START> public static org.springframework.core.codec.StringDecoder org.springframework.core.codec.StringDecoder ( boolean boolean ) { return new org.springframework.core.codec.StringDecoder ( boolean , new MimeType ( STRING , STRING , java.nio.charset.Charset ) , MimeTypeUtils . ALL ) ; }  <METHOD_END>
