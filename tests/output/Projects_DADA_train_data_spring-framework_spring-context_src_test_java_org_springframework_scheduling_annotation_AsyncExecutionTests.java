<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.lang.String = java.lang.Thread . java.lang.Thread ( ) . java.lang.String ( ) ; GenericApplicationContext org.springframework.scheduling.annotation.GenericApplicationContext = new GenericApplicationContext ( ) ; org.springframework.scheduling.annotation.GenericApplicationContext . registerBeanDefinition ( STRING , new RootBeanDefinition ( org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncMethodBean .class ) ) ; org.springframework.scheduling.annotation.GenericApplicationContext . registerBeanDefinition ( STRING , new RootBeanDefinition ( DefaultAdvisorAutoProxyCreator .class ) ) ; org.springframework.scheduling.annotation.GenericApplicationContext . registerBeanDefinition ( STRING , new RootBeanDefinition ( AsyncAnnotationAdvisor .class ) ) ; org.springframework.scheduling.annotation.GenericApplicationContext . refresh ( ) ; org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncMethodBean org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncMethodBean = org.springframework.scheduling.annotation.GenericApplicationContext . getBean ( STRING , org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncMethodBean .class ) ; org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncMethodBean . void ( NUMBER ) ; org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncMethodBean . void ( NUMBER ) ; java.util.concurrent.Future<java.lang.String> < java.lang.String > java.util.concurrent.Future<java.lang.String> = org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncMethodBean . java.util.concurrent.Future<java.lang.String> ( NUMBER ) ; assertEquals ( STRING , java.util.concurrent.Future<java.lang.String> . java.lang.String ( ) ) ; ListenableFuture < java.lang.String > org.springframework.scheduling.annotation.ListenableFuture<java.lang.String> = org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncMethodBean . org.springframework.scheduling.annotation.ListenableFuture<java.lang.String> ( NUMBER ) ; assertEquals ( STRING , org.springframework.scheduling.annotation.ListenableFuture<java.lang.String> . get ( ) ) ; java.util.concurrent.CompletableFuture<java.lang.String> < java.lang.String > java.util.concurrent.CompletableFuture<java.lang.String> = org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncMethodBean . java.util.concurrent.CompletableFuture<java.lang.String> ( NUMBER ) ; assertEquals ( STRING , java.util.concurrent.CompletableFuture<java.lang.String> . java.lang.String ( ) ) ; try { org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncMethodBean . java.util.concurrent.Future<java.lang.String> ( NUMBER ) . java.lang.String ( ) ; fail ( STRING ) ; } catch ( java.util.concurrent.ExecutionException java.util.concurrent.ExecutionException ) { assertTrue ( java.util.concurrent.ExecutionException . java.lang.Throwable ( ) instanceof java.lang.IllegalArgumentException ) ; } try { org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncMethodBean . java.util.concurrent.Future<java.lang.String> ( - NUMBER ) . java.lang.String ( ) ; fail ( STRING ) ; } catch ( java.util.concurrent.ExecutionException java.util.concurrent.ExecutionException ) { assertTrue ( java.util.concurrent.ExecutionException . java.lang.Throwable ( ) instanceof java.io.IOException ) ; } try { org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncMethodBean . org.springframework.scheduling.annotation.ListenableFuture<java.lang.String> ( NUMBER ) . get ( ) ; fail ( STRING ) ; } catch ( java.util.concurrent.ExecutionException java.util.concurrent.ExecutionException ) { assertTrue ( java.util.concurrent.ExecutionException . java.lang.Throwable ( ) instanceof java.lang.IllegalArgumentException ) ; } try { org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncMethodBean . org.springframework.scheduling.annotation.ListenableFuture<java.lang.String> ( - NUMBER ) . get ( ) ; fail ( STRING ) ; } catch ( java.util.concurrent.ExecutionException java.util.concurrent.ExecutionException ) { assertTrue ( java.util.concurrent.ExecutionException . java.lang.Throwable ( ) instanceof java.io.IOException ) ; } try { org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncMethodBean . java.util.concurrent.CompletableFuture<java.lang.String> ( NUMBER ) . java.lang.String ( ) ; fail ( STRING ) ; } catch ( java.util.concurrent.ExecutionException java.util.concurrent.ExecutionException ) { assertTrue ( java.util.concurrent.ExecutionException . java.lang.Throwable ( ) instanceof java.lang.IllegalArgumentException ) ; } }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.lang.String = java.lang.Thread . java.lang.Thread ( ) . java.lang.String ( ) ; GenericApplicationContext org.springframework.scheduling.annotation.GenericApplicationContext = new GenericApplicationContext ( ) ; org.springframework.scheduling.annotation.GenericApplicationContext . registerBeanDefinition ( STRING , new RootBeanDefinition ( org.springframework.scheduling.annotation.AsyncExecutionTests.SimpleAsyncMethodBean .class ) ) ; org.springframework.scheduling.annotation.GenericApplicationContext . registerBeanDefinition ( STRING , new RootBeanDefinition ( DefaultAdvisorAutoProxyCreator .class ) ) ; org.springframework.scheduling.annotation.GenericApplicationContext . registerBeanDefinition ( STRING , new RootBeanDefinition ( AsyncAnnotationAdvisor .class ) ) ; org.springframework.scheduling.annotation.GenericApplicationContext . refresh ( ) ; org.springframework.scheduling.annotation.AsyncExecutionTests.SimpleInterface org.springframework.scheduling.annotation.AsyncExecutionTests.SimpleInterface = org.springframework.scheduling.annotation.GenericApplicationContext . getBean ( STRING , org.springframework.scheduling.annotation.AsyncExecutionTests.SimpleInterface .class ) ; org.springframework.scheduling.annotation.AsyncExecutionTests.SimpleInterface . void ( NUMBER ) ; org.springframework.scheduling.annotation.AsyncExecutionTests.SimpleInterface . void ( NUMBER ) ; java.util.concurrent.Future<java.lang.String> < java.lang.String > java.util.concurrent.Future<java.lang.String> = org.springframework.scheduling.annotation.AsyncExecutionTests.SimpleInterface . java.util.concurrent.Future<java.lang.String> ( NUMBER ) ; assertEquals ( STRING , java.util.concurrent.Future<java.lang.String> . java.lang.String ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.lang.String = java.lang.Thread . java.lang.Thread ( ) . java.lang.String ( ) ; GenericApplicationContext org.springframework.scheduling.annotation.GenericApplicationContext = new GenericApplicationContext ( ) ; org.springframework.scheduling.annotation.GenericApplicationContext . registerBeanDefinition ( STRING , new RootBeanDefinition ( org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncMethodWithQualifierBean .class ) ) ; org.springframework.scheduling.annotation.GenericApplicationContext . registerBeanDefinition ( STRING , new RootBeanDefinition ( DefaultAdvisorAutoProxyCreator .class ) ) ; org.springframework.scheduling.annotation.GenericApplicationContext . registerBeanDefinition ( STRING , new RootBeanDefinition ( AsyncAnnotationAdvisor .class ) ) ; org.springframework.scheduling.annotation.GenericApplicationContext . registerBeanDefinition ( STRING , new RootBeanDefinition ( ThreadPoolTaskExecutor .class ) ) ; org.springframework.scheduling.annotation.GenericApplicationContext . registerBeanDefinition ( STRING , new RootBeanDefinition ( ThreadPoolTaskExecutor .class ) ) ; org.springframework.scheduling.annotation.GenericApplicationContext . registerBeanDefinition ( STRING , new RootBeanDefinition ( ThreadPoolTaskExecutor .class ) ) ; org.springframework.scheduling.annotation.GenericApplicationContext . refresh ( ) ; org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncMethodWithQualifierBean org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncMethodWithQualifierBean = org.springframework.scheduling.annotation.GenericApplicationContext . getBean ( STRING , org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncMethodWithQualifierBean .class ) ; org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncMethodWithQualifierBean . void ( NUMBER ) ; org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncMethodWithQualifierBean . void ( NUMBER ) ; java.util.concurrent.Future<java.lang.String> < java.lang.String > java.util.concurrent.Future<java.lang.String> = org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncMethodWithQualifierBean . java.util.concurrent.Future<java.lang.String> ( NUMBER ) ; assertEquals ( STRING , java.util.concurrent.Future<java.lang.String> . java.lang.String ( ) ) ; java.util.concurrent.Future<java.lang.String> < java.lang.String > java.util.concurrent.Future<java.lang.String> = org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncMethodWithQualifierBean . java.util.concurrent.Future<java.lang.String> ( NUMBER ) ; assertEquals ( STRING , java.util.concurrent.Future<java.lang.String> . java.lang.String ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.lang.String = java.lang.Thread . java.lang.Thread ( ) . java.lang.String ( ) ; GenericApplicationContext org.springframework.scheduling.annotation.GenericApplicationContext = new GenericApplicationContext ( ) ; org.springframework.scheduling.annotation.GenericApplicationContext . registerBeanDefinition ( STRING , new RootBeanDefinition ( org.springframework.scheduling.annotation.AsyncExecutionTests.SimpleAsyncMethodWithQualifierBean .class ) ) ; org.springframework.scheduling.annotation.GenericApplicationContext . registerBeanDefinition ( STRING , new RootBeanDefinition ( DefaultAdvisorAutoProxyCreator .class ) ) ; org.springframework.scheduling.annotation.GenericApplicationContext . registerBeanDefinition ( STRING , new RootBeanDefinition ( AsyncAnnotationAdvisor .class ) ) ; org.springframework.scheduling.annotation.GenericApplicationContext . registerBeanDefinition ( STRING , new RootBeanDefinition ( ThreadPoolTaskExecutor .class ) ) ; org.springframework.scheduling.annotation.GenericApplicationContext . registerBeanDefinition ( STRING , new RootBeanDefinition ( ThreadPoolTaskExecutor .class ) ) ; org.springframework.scheduling.annotation.GenericApplicationContext . registerBeanDefinition ( STRING , new RootBeanDefinition ( ThreadPoolTaskExecutor .class ) ) ; org.springframework.scheduling.annotation.GenericApplicationContext . refresh ( ) ; org.springframework.scheduling.annotation.AsyncExecutionTests.SimpleInterface org.springframework.scheduling.annotation.AsyncExecutionTests.SimpleInterface = org.springframework.scheduling.annotation.GenericApplicationContext . getBean ( STRING , org.springframework.scheduling.annotation.AsyncExecutionTests.SimpleInterface .class ) ; org.springframework.scheduling.annotation.AsyncExecutionTests.SimpleInterface . void ( NUMBER ) ; org.springframework.scheduling.annotation.AsyncExecutionTests.SimpleInterface . void ( NUMBER ) ; java.util.concurrent.Future<java.lang.String> < java.lang.String > java.util.concurrent.Future<java.lang.String> = org.springframework.scheduling.annotation.AsyncExecutionTests.SimpleInterface . java.util.concurrent.Future<java.lang.String> ( NUMBER ) ; assertEquals ( STRING , java.util.concurrent.Future<java.lang.String> . java.lang.String ( ) ) ; java.util.concurrent.Future<java.lang.String> < java.lang.String > java.util.concurrent.Future<java.lang.String> = org.springframework.scheduling.annotation.AsyncExecutionTests.SimpleInterface . java.util.concurrent.Future<java.lang.String> ( NUMBER ) ; assertEquals ( STRING , java.util.concurrent.Future<java.lang.String> . java.lang.String ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.lang.String = java.lang.Thread . java.lang.Thread ( ) . java.lang.String ( ) ; GenericApplicationContext org.springframework.scheduling.annotation.GenericApplicationContext = new GenericApplicationContext ( ) ; org.springframework.scheduling.annotation.GenericApplicationContext . registerBeanDefinition ( STRING , new RootBeanDefinition ( org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncClassBean .class ) ) ; org.springframework.scheduling.annotation.GenericApplicationContext . registerBeanDefinition ( STRING , new RootBeanDefinition ( DefaultAdvisorAutoProxyCreator .class ) ) ; org.springframework.scheduling.annotation.GenericApplicationContext . registerBeanDefinition ( STRING , new RootBeanDefinition ( AsyncAnnotationAdvisor .class ) ) ; org.springframework.scheduling.annotation.GenericApplicationContext . refresh ( ) ; org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncClassBean org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncClassBean = org.springframework.scheduling.annotation.GenericApplicationContext . getBean ( STRING , org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncClassBean .class ) ; org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncClassBean . void ( NUMBER ) ; java.util.concurrent.Future<java.lang.String> < java.lang.String > java.util.concurrent.Future<java.lang.String> = org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncClassBean . java.util.concurrent.Future<java.lang.String> ( NUMBER ) ; assertEquals ( STRING , java.util.concurrent.Future<java.lang.String> . java.lang.String ( ) ) ; ListenableFuture < java.lang.String > org.springframework.scheduling.annotation.ListenableFuture<java.lang.String> = org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncClassBean . org.springframework.scheduling.annotation.ListenableFuture<java.lang.String> ( NUMBER ) ; assertEquals ( STRING , org.springframework.scheduling.annotation.ListenableFuture<java.lang.String> . get ( ) ) ; java.util.concurrent.CompletableFuture<java.lang.String> < java.lang.String > java.util.concurrent.CompletableFuture<java.lang.String> = org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncClassBean . java.util.concurrent.CompletableFuture<java.lang.String> ( NUMBER ) ; assertEquals ( STRING , java.util.concurrent.CompletableFuture<java.lang.String> . java.lang.String ( ) ) ; try { org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncClassBean . java.util.concurrent.Future<java.lang.String> ( NUMBER ) . java.lang.String ( ) ; fail ( STRING ) ; } catch ( java.util.concurrent.ExecutionException java.util.concurrent.ExecutionException ) { assertTrue ( java.util.concurrent.ExecutionException . java.lang.Throwable ( ) instanceof java.lang.IllegalArgumentException ) ; } try { org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncClassBean . org.springframework.scheduling.annotation.ListenableFuture<java.lang.String> ( NUMBER ) . get ( ) ; fail ( STRING ) ; } catch ( java.util.concurrent.ExecutionException java.util.concurrent.ExecutionException ) { assertTrue ( java.util.concurrent.ExecutionException . java.lang.Throwable ( ) instanceof java.lang.IllegalArgumentException ) ; } try { org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncClassBean . java.util.concurrent.CompletableFuture<java.lang.String> ( NUMBER ) . java.lang.String ( ) ; fail ( STRING ) ; } catch ( java.util.concurrent.ExecutionException java.util.concurrent.ExecutionException ) { assertTrue ( java.util.concurrent.ExecutionException . java.lang.Throwable ( ) instanceof java.lang.IllegalArgumentException ) ; } }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.lang.String = java.lang.Thread . java.lang.Thread ( ) . java.lang.String ( ) ; GenericApplicationContext org.springframework.scheduling.annotation.GenericApplicationContext = new GenericApplicationContext ( ) ; org.springframework.scheduling.annotation.GenericApplicationContext . registerBeanDefinition ( STRING , new RootBeanDefinition ( org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncClassBean .class ) ) ; org.springframework.scheduling.annotation.GenericApplicationContext . registerBeanDefinition ( STRING , new RootBeanDefinition ( AsyncAnnotationBeanPostProcessor .class ) ) ; org.springframework.scheduling.annotation.GenericApplicationContext . refresh ( ) ; org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncClassBean org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncClassBean = org.springframework.scheduling.annotation.GenericApplicationContext . getBean ( STRING , org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncClassBean .class ) ; org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncClassBean . void ( NUMBER ) ; java.util.concurrent.Future<java.lang.String> < java.lang.String > java.util.concurrent.Future<java.lang.String> = org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncClassBean . java.util.concurrent.Future<java.lang.String> ( NUMBER ) ; assertEquals ( STRING , java.util.concurrent.Future<java.lang.String> . java.lang.String ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.lang.String = java.lang.Thread . java.lang.Thread ( ) . java.lang.String ( ) ; GenericApplicationContext org.springframework.scheduling.annotation.GenericApplicationContext = new GenericApplicationContext ( ) ; org.springframework.scheduling.annotation.GenericApplicationContext . registerBeanDefinition ( STRING , new RootBeanDefinition ( org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncClassBeanWithInterface .class ) ) ; org.springframework.scheduling.annotation.GenericApplicationContext . registerBeanDefinition ( STRING , new RootBeanDefinition ( DefaultAdvisorAutoProxyCreator .class ) ) ; org.springframework.scheduling.annotation.GenericApplicationContext . registerBeanDefinition ( STRING , new RootBeanDefinition ( AsyncAnnotationAdvisor .class ) ) ; org.springframework.scheduling.annotation.GenericApplicationContext . refresh ( ) ; org.springframework.scheduling.annotation.AsyncExecutionTests.RegularInterface org.springframework.scheduling.annotation.AsyncExecutionTests.RegularInterface = org.springframework.scheduling.annotation.GenericApplicationContext . getBean ( STRING , org.springframework.scheduling.annotation.AsyncExecutionTests.RegularInterface .class ) ; org.springframework.scheduling.annotation.AsyncExecutionTests.RegularInterface . void ( NUMBER ) ; java.util.concurrent.Future<java.lang.String> < java.lang.String > java.util.concurrent.Future<java.lang.String> = org.springframework.scheduling.annotation.AsyncExecutionTests.RegularInterface . java.util.concurrent.Future<java.lang.String> ( NUMBER ) ; assertEquals ( STRING , java.util.concurrent.Future<java.lang.String> . java.lang.String ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.lang.String = java.lang.Thread . java.lang.Thread ( ) . java.lang.String ( ) ; GenericApplicationContext org.springframework.scheduling.annotation.GenericApplicationContext = new GenericApplicationContext ( ) ; org.springframework.scheduling.annotation.GenericApplicationContext . registerBeanDefinition ( STRING , new RootBeanDefinition ( org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncClassBeanWithInterface .class ) ) ; org.springframework.scheduling.annotation.GenericApplicationContext . registerBeanDefinition ( STRING , new RootBeanDefinition ( AsyncAnnotationBeanPostProcessor .class ) ) ; org.springframework.scheduling.annotation.GenericApplicationContext . refresh ( ) ; org.springframework.scheduling.annotation.AsyncExecutionTests.RegularInterface org.springframework.scheduling.annotation.AsyncExecutionTests.RegularInterface = org.springframework.scheduling.annotation.GenericApplicationContext . getBean ( STRING , org.springframework.scheduling.annotation.AsyncExecutionTests.RegularInterface .class ) ; org.springframework.scheduling.annotation.AsyncExecutionTests.RegularInterface . void ( NUMBER ) ; java.util.concurrent.Future<java.lang.String> < java.lang.String > java.util.concurrent.Future<java.lang.String> = org.springframework.scheduling.annotation.AsyncExecutionTests.RegularInterface . java.util.concurrent.Future<java.lang.String> ( NUMBER ) ; assertEquals ( STRING , java.util.concurrent.Future<java.lang.String> . java.lang.String ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.lang.String = java.lang.Thread . java.lang.Thread ( ) . java.lang.String ( ) ; GenericApplicationContext org.springframework.scheduling.annotation.GenericApplicationContext = new GenericApplicationContext ( ) ; org.springframework.scheduling.annotation.GenericApplicationContext . registerBeanDefinition ( STRING , new RootBeanDefinition ( org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncInterfaceBean .class ) ) ; org.springframework.scheduling.annotation.GenericApplicationContext . registerBeanDefinition ( STRING , new RootBeanDefinition ( DefaultAdvisorAutoProxyCreator .class ) ) ; org.springframework.scheduling.annotation.GenericApplicationContext . registerBeanDefinition ( STRING , new RootBeanDefinition ( AsyncAnnotationAdvisor .class ) ) ; org.springframework.scheduling.annotation.GenericApplicationContext . refresh ( ) ; org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncInterface org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncInterface = org.springframework.scheduling.annotation.GenericApplicationContext . getBean ( STRING , org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncInterface .class ) ; org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncInterface . void ( NUMBER ) ; java.util.concurrent.Future<java.lang.String> < java.lang.String > java.util.concurrent.Future<java.lang.String> = org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncInterface . java.util.concurrent.Future<java.lang.String> ( NUMBER ) ; assertEquals ( STRING , java.util.concurrent.Future<java.lang.String> . java.lang.String ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.lang.String = java.lang.Thread . java.lang.Thread ( ) . java.lang.String ( ) ; GenericApplicationContext org.springframework.scheduling.annotation.GenericApplicationContext = new GenericApplicationContext ( ) ; org.springframework.scheduling.annotation.GenericApplicationContext . registerBeanDefinition ( STRING , new RootBeanDefinition ( org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncInterfaceBean .class ) ) ; org.springframework.scheduling.annotation.GenericApplicationContext . registerBeanDefinition ( STRING , new RootBeanDefinition ( AsyncAnnotationBeanPostProcessor .class ) ) ; org.springframework.scheduling.annotation.GenericApplicationContext . refresh ( ) ; org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncInterface org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncInterface = org.springframework.scheduling.annotation.GenericApplicationContext . getBean ( STRING , org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncInterface .class ) ; org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncInterface . void ( NUMBER ) ; java.util.concurrent.Future<java.lang.String> < java.lang.String > java.util.concurrent.Future<java.lang.String> = org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncInterface . java.util.concurrent.Future<java.lang.String> ( NUMBER ) ; assertEquals ( STRING , java.util.concurrent.Future<java.lang.String> . java.lang.String ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.lang.String = java.lang.Thread . java.lang.Thread ( ) . java.lang.String ( ) ; GenericApplicationContext org.springframework.scheduling.annotation.GenericApplicationContext = new GenericApplicationContext ( ) ; org.springframework.scheduling.annotation.GenericApplicationContext . registerBeanDefinition ( STRING , new RootBeanDefinition ( org.springframework.scheduling.annotation.AsyncExecutionTests.DynamicAsyncInterfaceBean .class ) ) ; org.springframework.scheduling.annotation.GenericApplicationContext . registerBeanDefinition ( STRING , new RootBeanDefinition ( DefaultAdvisorAutoProxyCreator .class ) ) ; org.springframework.scheduling.annotation.GenericApplicationContext . registerBeanDefinition ( STRING , new RootBeanDefinition ( AsyncAnnotationAdvisor .class ) ) ; org.springframework.scheduling.annotation.GenericApplicationContext . refresh ( ) ; org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncInterface org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncInterface = org.springframework.scheduling.annotation.GenericApplicationContext . getBean ( STRING , org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncInterface .class ) ; org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncInterface . void ( NUMBER ) ; java.util.concurrent.Future<java.lang.String> < java.lang.String > java.util.concurrent.Future<java.lang.String> = org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncInterface . java.util.concurrent.Future<java.lang.String> ( NUMBER ) ; assertEquals ( STRING , java.util.concurrent.Future<java.lang.String> . java.lang.String ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.lang.String = java.lang.Thread . java.lang.Thread ( ) . java.lang.String ( ) ; GenericApplicationContext org.springframework.scheduling.annotation.GenericApplicationContext = new GenericApplicationContext ( ) ; org.springframework.scheduling.annotation.GenericApplicationContext . registerBeanDefinition ( STRING , new RootBeanDefinition ( org.springframework.scheduling.annotation.AsyncExecutionTests.DynamicAsyncInterfaceBean .class ) ) ; org.springframework.scheduling.annotation.GenericApplicationContext . registerBeanDefinition ( STRING , new RootBeanDefinition ( AsyncAnnotationBeanPostProcessor .class ) ) ; org.springframework.scheduling.annotation.GenericApplicationContext . refresh ( ) ; org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncInterface org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncInterface = org.springframework.scheduling.annotation.GenericApplicationContext . getBean ( STRING , org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncInterface .class ) ; org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncInterface . void ( NUMBER ) ; java.util.concurrent.Future<java.lang.String> < java.lang.String > java.util.concurrent.Future<java.lang.String> = org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncInterface . java.util.concurrent.Future<java.lang.String> ( NUMBER ) ; assertEquals ( STRING , java.util.concurrent.Future<java.lang.String> . java.lang.String ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.lang.String = java.lang.Thread . java.lang.Thread ( ) . java.lang.String ( ) ; GenericApplicationContext org.springframework.scheduling.annotation.GenericApplicationContext = new GenericApplicationContext ( ) ; org.springframework.scheduling.annotation.GenericApplicationContext . registerBeanDefinition ( STRING , new RootBeanDefinition ( org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncMethodsInterfaceBean .class ) ) ; org.springframework.scheduling.annotation.GenericApplicationContext . registerBeanDefinition ( STRING , new RootBeanDefinition ( DefaultAdvisorAutoProxyCreator .class ) ) ; org.springframework.scheduling.annotation.GenericApplicationContext . registerBeanDefinition ( STRING , new RootBeanDefinition ( AsyncAnnotationAdvisor .class ) ) ; org.springframework.scheduling.annotation.GenericApplicationContext . refresh ( ) ; org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncMethodsInterface org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncMethodsInterface = org.springframework.scheduling.annotation.GenericApplicationContext . getBean ( STRING , org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncMethodsInterface .class ) ; org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncMethodsInterface . void ( NUMBER ) ; org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncMethodsInterface . void ( NUMBER ) ; java.util.concurrent.Future<java.lang.String> < java.lang.String > java.util.concurrent.Future<java.lang.String> = org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncMethodsInterface . java.util.concurrent.Future<java.lang.String> ( NUMBER ) ; assertEquals ( STRING , java.util.concurrent.Future<java.lang.String> . java.lang.String ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.lang.String = java.lang.Thread . java.lang.Thread ( ) . java.lang.String ( ) ; GenericApplicationContext org.springframework.scheduling.annotation.GenericApplicationContext = new GenericApplicationContext ( ) ; org.springframework.scheduling.annotation.GenericApplicationContext . registerBeanDefinition ( STRING , new RootBeanDefinition ( org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncMethodsInterfaceBean .class ) ) ; org.springframework.scheduling.annotation.GenericApplicationContext . registerBeanDefinition ( STRING , new RootBeanDefinition ( AsyncAnnotationBeanPostProcessor .class ) ) ; org.springframework.scheduling.annotation.GenericApplicationContext . refresh ( ) ; org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncMethodsInterface org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncMethodsInterface = org.springframework.scheduling.annotation.GenericApplicationContext . getBean ( STRING , org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncMethodsInterface .class ) ; org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncMethodsInterface . void ( NUMBER ) ; org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncMethodsInterface . void ( NUMBER ) ; java.util.concurrent.Future<java.lang.String> < java.lang.String > java.util.concurrent.Future<java.lang.String> = org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncMethodsInterface . java.util.concurrent.Future<java.lang.String> ( NUMBER ) ; assertEquals ( STRING , java.util.concurrent.Future<java.lang.String> . java.lang.String ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.lang.String = java.lang.Thread . java.lang.Thread ( ) . java.lang.String ( ) ; GenericApplicationContext org.springframework.scheduling.annotation.GenericApplicationContext = new GenericApplicationContext ( ) ; org.springframework.scheduling.annotation.GenericApplicationContext . registerBeanDefinition ( STRING , new RootBeanDefinition ( org.springframework.scheduling.annotation.AsyncExecutionTests.DynamicAsyncMethodsInterfaceBean .class ) ) ; org.springframework.scheduling.annotation.GenericApplicationContext . registerBeanDefinition ( STRING , new RootBeanDefinition ( AsyncAnnotationBeanPostProcessor .class ) ) ; org.springframework.scheduling.annotation.GenericApplicationContext . refresh ( ) ; org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncMethodsInterface org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncMethodsInterface = org.springframework.scheduling.annotation.GenericApplicationContext . getBean ( STRING , org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncMethodsInterface .class ) ; org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncMethodsInterface . void ( NUMBER ) ; java.util.concurrent.Future<java.lang.String> < java.lang.String > java.util.concurrent.Future<java.lang.String> = org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncMethodsInterface . java.util.concurrent.Future<java.lang.String> ( NUMBER ) ; assertEquals ( STRING , java.util.concurrent.Future<java.lang.String> . java.lang.String ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.lang.String = java.lang.Thread . java.lang.Thread ( ) . java.lang.String ( ) ; int = NUMBER ; GenericApplicationContext org.springframework.scheduling.annotation.GenericApplicationContext = new GenericApplicationContext ( ) ; org.springframework.scheduling.annotation.GenericApplicationContext . registerBeanDefinition ( STRING , new RootBeanDefinition ( org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncMethodListener .class ) ) ; org.springframework.scheduling.annotation.GenericApplicationContext . registerBeanDefinition ( STRING , new RootBeanDefinition ( DefaultAdvisorAutoProxyCreator .class ) ) ; org.springframework.scheduling.annotation.GenericApplicationContext . registerBeanDefinition ( STRING , new RootBeanDefinition ( AsyncAnnotationAdvisor .class ) ) ; org.springframework.scheduling.annotation.GenericApplicationContext . refresh ( ) ; java.lang.Thread . void ( NUMBER ) ; assertEquals ( NUMBER , int ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.lang.String = java.lang.Thread . java.lang.Thread ( ) . java.lang.String ( ) ; int = NUMBER ; int = NUMBER ; GenericApplicationContext org.springframework.scheduling.annotation.GenericApplicationContext = new GenericApplicationContext ( ) ; org.springframework.scheduling.annotation.GenericApplicationContext . registerBeanDefinition ( STRING , new RootBeanDefinition ( org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncClassListener .class ) ) ; org.springframework.scheduling.annotation.GenericApplicationContext . registerBeanDefinition ( STRING , new RootBeanDefinition ( DefaultAdvisorAutoProxyCreator .class ) ) ; org.springframework.scheduling.annotation.GenericApplicationContext . registerBeanDefinition ( STRING , new RootBeanDefinition ( AsyncAnnotationAdvisor .class ) ) ; org.springframework.scheduling.annotation.GenericApplicationContext . refresh ( ) ; org.springframework.scheduling.annotation.GenericApplicationContext . close ( ) ; java.lang.Thread . void ( NUMBER ) ; assertEquals ( NUMBER , int ) ; assertEquals ( NUMBER , int ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.lang.String = java.lang.Thread . java.lang.Thread ( ) . java.lang.String ( ) ; int = NUMBER ; int = NUMBER ; GenericApplicationContext org.springframework.scheduling.annotation.GenericApplicationContext = new GenericApplicationContext ( ) ; RootBeanDefinition org.springframework.scheduling.annotation.RootBeanDefinition = new RootBeanDefinition ( org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncClassListener .class ) ; org.springframework.scheduling.annotation.RootBeanDefinition . setScope ( RootBeanDefinition . SCOPE_PROTOTYPE ) ; org.springframework.scheduling.annotation.GenericApplicationContext . registerBeanDefinition ( STRING , org.springframework.scheduling.annotation.RootBeanDefinition ) ; org.springframework.scheduling.annotation.GenericApplicationContext . registerBeanDefinition ( STRING , new RootBeanDefinition ( DefaultAdvisorAutoProxyCreator .class ) ) ; org.springframework.scheduling.annotation.GenericApplicationContext . registerBeanDefinition ( STRING , new RootBeanDefinition ( AsyncAnnotationAdvisor .class ) ) ; org.springframework.scheduling.annotation.GenericApplicationContext . refresh ( ) ; org.springframework.scheduling.annotation.GenericApplicationContext . close ( ) ; java.lang.Thread . void ( NUMBER ) ; assertEquals ( NUMBER , int ) ; assertEquals ( NUMBER , int ) ; }  <METHOD_END>
<METHOD_START> void void ( int int );  <METHOD_END>
<METHOD_START> void void ( int int );  <METHOD_END>
<METHOD_START> java.util.concurrent.Future<java.lang.String> < java.lang.String > java.util.concurrent.Future<java.lang.String> ( int int );  <METHOD_END>
<METHOD_START> java.util.concurrent.Future<java.lang.String> < java.lang.String > java.util.concurrent.Future<java.lang.String> ( int int );  <METHOD_END>
<METHOD_START> public void void ( int int ) { assertTrue ( java.lang.Thread . java.lang.Thread ( ) . java.lang.String ( ) . boolean ( java.lang.String ) ) ; }  <METHOD_END>
<METHOD_START> @ Async public void void ( int int ) { assertTrue ( ! java.lang.Thread . java.lang.Thread ( ) . java.lang.String ( ) . boolean ( java.lang.String ) ) ; }  <METHOD_END>
<METHOD_START> @ Async public java.util.concurrent.Future<java.lang.String> < java.lang.String > java.util.concurrent.Future<java.lang.String> ( int int ) { assertTrue ( ! java.lang.Thread . java.lang.Thread ( ) . java.lang.String ( ) . boolean ( java.lang.String ) ) ; if ( int == NUMBER ) { throw new java.lang.IllegalArgumentException ( ) ; } else if ( int < NUMBER ) { return AsyncResult . forExecutionException ( new java.io.IOException ( ) ) ; } return AsyncResult . forValue ( java.lang.Integer . java.lang.String ( int ) ) ; }  <METHOD_END>
<METHOD_START> @ Async public org.springframework.scheduling.annotation.ListenableFuture<java.lang.String> < java.lang.String > org.springframework.scheduling.annotation.ListenableFuture<java.lang.String> ( int int ) { assertTrue ( ! java.lang.Thread . java.lang.Thread ( ) . java.lang.String ( ) . boolean ( java.lang.String ) ) ; if ( int == NUMBER ) { throw new java.lang.IllegalArgumentException ( ) ; } else if ( int < NUMBER ) { return AsyncResult . forExecutionException ( new java.io.IOException ( ) ) ; } return new AsyncResult <> ( java.lang.Integer . java.lang.String ( int ) ) ; }  <METHOD_END>
<METHOD_START> @ Async public java.util.concurrent.CompletableFuture<java.lang.String> < java.lang.String > java.util.concurrent.CompletableFuture<java.lang.String> ( int int ) { assertTrue ( ! java.lang.Thread . java.lang.Thread ( ) . java.lang.String ( ) . boolean ( java.lang.String ) ) ; if ( int == NUMBER ) { throw new java.lang.IllegalArgumentException ( ) ; } return java.util.concurrent.CompletableFuture . java.util.concurrent.CompletableFuture<java.lang.String> ( java.lang.Integer . java.lang.String ( int ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.util.concurrent.Future<java.lang.String> < java.lang.String > java.util.concurrent.Future<java.lang.String> ( int int ) { throw new java.lang.UnsupportedOperationException ( ) ; }  <METHOD_END>
<METHOD_START> public void void ( int int ) { assertTrue ( java.lang.Thread . java.lang.Thread ( ) . java.lang.String ( ) . boolean ( java.lang.String ) ) ; }  <METHOD_END>
<METHOD_START> @ Async ( STRING ) public void void ( int int ) { assertTrue ( ! java.lang.Thread . java.lang.Thread ( ) . java.lang.String ( ) . boolean ( java.lang.String ) ) ; assertTrue ( java.lang.Thread . java.lang.Thread ( ) . java.lang.String ( ) . boolean ( STRING ) ) ; }  <METHOD_END>
<METHOD_START> @ org.springframework.scheduling.annotation.AsyncExecutionTests.MyAsync public java.util.concurrent.Future<java.lang.String> < java.lang.String > java.util.concurrent.Future<java.lang.String> ( int int ) { assertTrue ( ! java.lang.Thread . java.lang.Thread ( ) . java.lang.String ( ) . boolean ( java.lang.String ) ) ; assertTrue ( java.lang.Thread . java.lang.Thread ( ) . java.lang.String ( ) . boolean ( STRING ) ) ; return new AsyncResult <> ( java.lang.Integer . java.lang.String ( int ) ) ; }  <METHOD_END>
<METHOD_START> public java.util.concurrent.Future<java.lang.String> < java.lang.String > java.util.concurrent.Future<java.lang.String> ( int int ) { assertTrue ( ! java.lang.Thread . java.lang.Thread ( ) . java.lang.String ( ) . boolean ( java.lang.String ) ) ; assertTrue ( java.lang.Thread . java.lang.Thread ( ) . java.lang.String ( ) . boolean ( STRING ) ) ; return new AsyncResult <> ( java.lang.Integer . java.lang.String ( int ) ) ; }  <METHOD_END>
<METHOD_START> public void void ( int int ) { assertTrue ( ! java.lang.Thread . java.lang.Thread ( ) . java.lang.String ( ) . boolean ( java.lang.String ) ) ; }  <METHOD_END>
<METHOD_START> public java.util.concurrent.Future<java.lang.String> < java.lang.String > java.util.concurrent.Future<java.lang.String> ( int int ) { assertTrue ( ! java.lang.Thread . java.lang.Thread ( ) . java.lang.String ( ) . boolean ( java.lang.String ) ) ; if ( int == NUMBER ) { throw new java.lang.IllegalArgumentException ( ) ; } return new AsyncResult <> ( java.lang.Integer . java.lang.String ( int ) ) ; }  <METHOD_END>
<METHOD_START> public org.springframework.scheduling.annotation.ListenableFuture<java.lang.String> < java.lang.String > org.springframework.scheduling.annotation.ListenableFuture<java.lang.String> ( int int ) { assertTrue ( ! java.lang.Thread . java.lang.Thread ( ) . java.lang.String ( ) . boolean ( java.lang.String ) ) ; if ( int == NUMBER ) { throw new java.lang.IllegalArgumentException ( ) ; } return new AsyncResult <> ( java.lang.Integer . java.lang.String ( int ) ) ; }  <METHOD_END>
<METHOD_START> @ Async public java.util.concurrent.CompletableFuture<java.lang.String> < java.lang.String > java.util.concurrent.CompletableFuture<java.lang.String> ( int int ) { assertTrue ( ! java.lang.Thread . java.lang.Thread ( ) . java.lang.String ( ) . boolean ( java.lang.String ) ) ; if ( int == NUMBER ) { throw new java.lang.IllegalArgumentException ( ) ; } return java.util.concurrent.CompletableFuture . java.util.concurrent.CompletableFuture<java.lang.String> ( java.lang.Integer . java.lang.String ( int ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ) {		}  <METHOD_END>
<METHOD_START> void void ( int int );  <METHOD_END>
<METHOD_START> java.util.concurrent.Future<java.lang.String> < java.lang.String > java.util.concurrent.Future<java.lang.String> ( int int );  <METHOD_END>
<METHOD_START> public void void ( int int ) { assertTrue ( ! java.lang.Thread . java.lang.Thread ( ) . java.lang.String ( ) . boolean ( java.lang.String ) ) ; }  <METHOD_END>
<METHOD_START> public java.util.concurrent.Future<java.lang.String> < java.lang.String > java.util.concurrent.Future<java.lang.String> ( int int ) { assertTrue ( ! java.lang.Thread . java.lang.Thread ( ) . java.lang.String ( ) . boolean ( java.lang.String ) ) ; return new AsyncResult <> ( java.lang.Integer . java.lang.String ( int ) ) ; }  <METHOD_END>
<METHOD_START> void void ( int int );  <METHOD_END>
<METHOD_START> java.util.concurrent.Future<java.lang.String> < java.lang.String > java.util.concurrent.Future<java.lang.String> ( int int );  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( int int ) { assertTrue ( ! java.lang.Thread . java.lang.Thread ( ) . java.lang.String ( ) . boolean ( java.lang.String ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.util.concurrent.Future<java.lang.String> < java.lang.String > java.util.concurrent.Future<java.lang.String> ( int int ) { assertTrue ( ! java.lang.Thread . java.lang.Thread ( ) . java.lang.String ( ) . boolean ( java.lang.String ) ) ; return new AsyncResult <> ( java.lang.Integer . java.lang.String ( int ) ) ; }  <METHOD_END>
<METHOD_START> public void ( ) { ProxyFactory org.springframework.scheduling.annotation.ProxyFactory = new ProxyFactory ( new java.util.HashMap <> ( ) ) ; DefaultIntroductionAdvisor org.springframework.scheduling.annotation.DefaultIntroductionAdvisor = new DefaultIntroductionAdvisor ( new MethodInterceptor ( ) { @ java.lang.Override public java.lang.Object java.lang.Object ( MethodInvocation org.springframework.scheduling.annotation.MethodInvocation ) throws java.lang.Throwable { assertTrue ( ! java.lang.Thread . java.lang.Thread ( ) . java.lang.String ( ) . boolean ( java.lang.String ) ) ; if ( java.util.concurrent.Future .class . boolean ( org.springframework.scheduling.annotation.MethodInvocation . getMethod ( ) . getReturnType ( ) ) ) { return new AsyncResult <> ( org.springframework.scheduling.annotation.MethodInvocation . getArguments ( ) [ NUMBER ] . toString ( ) ) ; } return null ; } } ) ; org.springframework.scheduling.annotation.DefaultIntroductionAdvisor . addInterface ( org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncInterface .class ) ; org.springframework.scheduling.annotation.ProxyFactory . addAdvisor ( org.springframework.scheduling.annotation.DefaultIntroductionAdvisor ) ; this . org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncInterface = ( org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncInterface ) org.springframework.scheduling.annotation.ProxyFactory . getProxy ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.Object java.lang.Object ( MethodInvocation org.springframework.scheduling.annotation.MethodInvocation ) throws java.lang.Throwable { assertTrue ( ! java.lang.Thread . java.lang.Thread ( ) . java.lang.String ( ) . boolean ( java.lang.String ) ) ; if ( java.util.concurrent.Future .class . boolean ( org.springframework.scheduling.annotation.MethodInvocation . getMethod ( ) . getReturnType ( ) ) ) { return new AsyncResult <> ( org.springframework.scheduling.annotation.MethodInvocation . getArguments ( ) [ NUMBER ] . toString ( ) ) ; } return null ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncInterface org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncInterface ( ) { return this . org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncInterface ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.Class<?> < ? > java.lang.Class<?> ( ) { return this . org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncInterface . java.lang.Class<? extends org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncInterface> ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( ) { return true ; }  <METHOD_END>
<METHOD_START> void void ( int int );  <METHOD_END>
<METHOD_START> @ Async void void ( int int );  <METHOD_END>
<METHOD_START> @ Async java.util.concurrent.Future<java.lang.String> < java.lang.String > java.util.concurrent.Future<java.lang.String> ( int int );  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( int int ) { assertTrue ( java.lang.Thread . java.lang.Thread ( ) . java.lang.String ( ) . boolean ( java.lang.String ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( int int ) { assertTrue ( ! java.lang.Thread . java.lang.Thread ( ) . java.lang.String ( ) . boolean ( java.lang.String ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.util.concurrent.Future<java.lang.String> < java.lang.String > java.util.concurrent.Future<java.lang.String> ( int int ) { assertTrue ( ! java.lang.Thread . java.lang.Thread ( ) . java.lang.String ( ) . boolean ( java.lang.String ) ) ; return new AsyncResult <> ( java.lang.Integer . java.lang.String ( int ) ) ; }  <METHOD_END>
<METHOD_START> public void ( ) { ProxyFactory org.springframework.scheduling.annotation.ProxyFactory = new ProxyFactory ( new java.util.HashMap <> ( ) ) ; DefaultIntroductionAdvisor org.springframework.scheduling.annotation.DefaultIntroductionAdvisor = new DefaultIntroductionAdvisor ( new MethodInterceptor ( ) { @ java.lang.Override public java.lang.Object java.lang.Object ( MethodInvocation org.springframework.scheduling.annotation.MethodInvocation ) throws java.lang.Throwable { assertTrue ( ! java.lang.Thread . java.lang.Thread ( ) . java.lang.String ( ) . boolean ( java.lang.String ) ) ; if ( java.util.concurrent.Future .class . boolean ( org.springframework.scheduling.annotation.MethodInvocation . getMethod ( ) . getReturnType ( ) ) ) { return new AsyncResult <> ( org.springframework.scheduling.annotation.MethodInvocation . getArguments ( ) [ NUMBER ] . toString ( ) ) ; } return null ; } } ) ; org.springframework.scheduling.annotation.DefaultIntroductionAdvisor . addInterface ( org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncMethodsInterface .class ) ; org.springframework.scheduling.annotation.ProxyFactory . addAdvisor ( org.springframework.scheduling.annotation.DefaultIntroductionAdvisor ) ; this . org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncMethodsInterface = ( org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncMethodsInterface ) org.springframework.scheduling.annotation.ProxyFactory . getProxy ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.Object java.lang.Object ( MethodInvocation org.springframework.scheduling.annotation.MethodInvocation ) throws java.lang.Throwable { assertTrue ( ! java.lang.Thread . java.lang.Thread ( ) . java.lang.String ( ) . boolean ( java.lang.String ) ) ; if ( java.util.concurrent.Future .class . boolean ( org.springframework.scheduling.annotation.MethodInvocation . getMethod ( ) . getReturnType ( ) ) ) { return new AsyncResult <> ( org.springframework.scheduling.annotation.MethodInvocation . getArguments ( ) [ NUMBER ] . toString ( ) ) ; } return null ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncMethodsInterface org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncMethodsInterface ( ) { return this . org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncMethodsInterface ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.Class<?> < ? > java.lang.Class<?> ( ) { return this . org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncMethodsInterface . java.lang.Class<? extends org.springframework.scheduling.annotation.AsyncExecutionTests.AsyncMethodsInterface> ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( ) { return true ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override @ Async public void void ( ApplicationEvent org.springframework.scheduling.annotation.ApplicationEvent ) { int ++ ; assertTrue ( ! java.lang.Thread . java.lang.Thread ( ) . java.lang.String ( ) . boolean ( java.lang.String ) ) ; }  <METHOD_END>
<METHOD_START> public void ( ) { int ++ ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ApplicationEvent org.springframework.scheduling.annotation.ApplicationEvent ) { int ++ ; assertTrue ( ! java.lang.Thread . java.lang.Thread ( ) . java.lang.String ( ) . boolean ( java.lang.String ) ) ; }  <METHOD_END>
