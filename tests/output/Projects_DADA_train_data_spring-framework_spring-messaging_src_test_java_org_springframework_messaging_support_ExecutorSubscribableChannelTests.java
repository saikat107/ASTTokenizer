<METHOD_START> @ Before public void void ( ) { MockitoAnnotations . initMocks ( this ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { org.springframework.messaging.support.ExpectedException . expect ( java.lang.IllegalArgumentException .class ) ; org.springframework.messaging.support.ExpectedException . expectMessage ( STRING ) ; this . org.springframework.messaging.support.ExecutorSubscribableChannel . send ( null ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { org.springframework.messaging.support.ExecutorSubscribableChannelTests.BeforeHandleInterceptor org.springframework.messaging.support.ExecutorSubscribableChannelTests.BeforeHandleInterceptor = new org.springframework.messaging.support.ExecutorSubscribableChannelTests.BeforeHandleInterceptor ( ) ; this . org.springframework.messaging.support.ExecutorSubscribableChannel . addInterceptor ( org.springframework.messaging.support.ExecutorSubscribableChannelTests.BeforeHandleInterceptor ) ; this . org.springframework.messaging.support.ExecutorSubscribableChannel . subscribe ( this . org.springframework.messaging.support.MessageHandler ) ; this . org.springframework.messaging.support.ExecutorSubscribableChannel . send ( this . org.springframework.messaging.support.Message<java.lang.Object> ) ; verify ( this . org.springframework.messaging.support.MessageHandler ) . handleMessage ( this . org.springframework.messaging.support.Message<java.lang.Object> ) ; assertEquals ( NUMBER , org.springframework.messaging.support.ExecutorSubscribableChannelTests.BeforeHandleInterceptor . java.util.concurrent.atomic.AtomicInteger ( ) . int ( ) ) ; assertTrue ( org.springframework.messaging.support.ExecutorSubscribableChannelTests.BeforeHandleInterceptor . boolean ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { org.springframework.messaging.support.ExecutorSubscribableChannelTests.BeforeHandleInterceptor org.springframework.messaging.support.ExecutorSubscribableChannelTests.BeforeHandleInterceptor = new org.springframework.messaging.support.ExecutorSubscribableChannelTests.BeforeHandleInterceptor ( ) ; TaskExecutor org.springframework.messaging.support.TaskExecutor = mock ( TaskExecutor .class ) ; ExecutorSubscribableChannel org.springframework.messaging.support.ExecutorSubscribableChannel = new ExecutorSubscribableChannel ( org.springframework.messaging.support.TaskExecutor ) ; org.springframework.messaging.support.ExecutorSubscribableChannel . addInterceptor ( org.springframework.messaging.support.ExecutorSubscribableChannelTests.BeforeHandleInterceptor ) ; org.springframework.messaging.support.ExecutorSubscribableChannel . subscribe ( this . org.springframework.messaging.support.MessageHandler ) ; org.springframework.messaging.support.ExecutorSubscribableChannel . send ( this . org.springframework.messaging.support.Message<java.lang.Object> ) ; verify ( org.springframework.messaging.support.TaskExecutor ) . execute ( this . org.springframework.messaging.support.ArgumentCaptor<java.lang.Runnable> . capture ( ) ) ; verify ( this . org.springframework.messaging.support.MessageHandler , never ( ) ) . handleMessage ( this . org.springframework.messaging.support.Message<java.lang.Object> ) ; this . org.springframework.messaging.support.ArgumentCaptor<java.lang.Runnable> . getValue ( ) . run ( ) ; verify ( this . org.springframework.messaging.support.MessageHandler ) . handleMessage ( this . org.springframework.messaging.support.Message<java.lang.Object> ) ; assertEquals ( NUMBER , org.springframework.messaging.support.ExecutorSubscribableChannelTests.BeforeHandleInterceptor . java.util.concurrent.atomic.AtomicInteger ( ) . int ( ) ) ; assertTrue ( org.springframework.messaging.support.ExecutorSubscribableChannelTests.BeforeHandleInterceptor . boolean ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { assertThat ( this . org.springframework.messaging.support.ExecutorSubscribableChannel . subscribe ( this . org.springframework.messaging.support.MessageHandler ) , equalTo ( true ) ) ; assertThat ( this . org.springframework.messaging.support.ExecutorSubscribableChannel . subscribe ( this . org.springframework.messaging.support.MessageHandler ) , equalTo ( false ) ) ; this . org.springframework.messaging.support.ExecutorSubscribableChannel . send ( this . org.springframework.messaging.support.Message<java.lang.Object> ) ; verify ( this . org.springframework.messaging.support.MessageHandler , times ( NUMBER ) ) . handleMessage ( this . org.springframework.messaging.support.Message<java.lang.Object> ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { this . org.springframework.messaging.support.ExecutorSubscribableChannel . subscribe ( this . org.springframework.messaging.support.MessageHandler ) ; assertThat ( this . org.springframework.messaging.support.ExecutorSubscribableChannel . unsubscribe ( this . org.springframework.messaging.support.MessageHandler ) , equalTo ( true ) ) ; assertThat ( this . org.springframework.messaging.support.ExecutorSubscribableChannel . unsubscribe ( this . org.springframework.messaging.support.MessageHandler ) , equalTo ( false ) ) ; this . org.springframework.messaging.support.ExecutorSubscribableChannel . send ( this . org.springframework.messaging.support.Message<java.lang.Object> ) ; verify ( this . org.springframework.messaging.support.MessageHandler , never ( ) ) . handleMessage ( this . org.springframework.messaging.support.Message<java.lang.Object> ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.lang.RuntimeException java.lang.RuntimeException = new java.lang.RuntimeException ( ) ; willThrow ( java.lang.RuntimeException ) . given ( this . org.springframework.messaging.support.MessageHandler ) . handleMessage ( this . org.springframework.messaging.support.Message<java.lang.Object> ) ; MessageHandler org.springframework.messaging.support.MessageHandler = mock ( MessageHandler .class ) ; this . org.springframework.messaging.support.ExecutorSubscribableChannel . subscribe ( this . org.springframework.messaging.support.MessageHandler ) ; this . org.springframework.messaging.support.ExecutorSubscribableChannel . subscribe ( org.springframework.messaging.support.MessageHandler ) ; try { this . org.springframework.messaging.support.ExecutorSubscribableChannel . send ( org.springframework.messaging.support.Message<java.lang.Object> ) ; } catch ( MessageDeliveryException org.springframework.messaging.support.MessageDeliveryException ) { assertThat ( org.springframework.messaging.support.MessageDeliveryException . getCause ( ) , equalTo ( java.lang.RuntimeException ) ) ; } verifyZeroInteractions ( org.springframework.messaging.support.MessageHandler ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { this . org.springframework.messaging.support.ExecutorSubscribableChannel . subscribe ( message1 -> channel . unsubscribe ( handler ) ) ; this . org.springframework.messaging.support.ExecutorSubscribableChannel . subscribe ( this . org.springframework.messaging.support.MessageHandler ) ; this . org.springframework.messaging.support.ExecutorSubscribableChannel . send ( this . org.springframework.messaging.support.Message<java.lang.Object> ) ; verify ( this . org.springframework.messaging.support.MessageHandler ) . handleMessage ( this . org.springframework.messaging.support.Message<java.lang.Object> ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { Message < ? > org.springframework.messaging.support.Message<?> = mock ( Message .class ) ; org.springframework.messaging.support.ExecutorSubscribableChannelTests.BeforeHandleInterceptor org.springframework.messaging.support.ExecutorSubscribableChannelTests.BeforeHandleInterceptor = new org.springframework.messaging.support.ExecutorSubscribableChannelTests.BeforeHandleInterceptor ( ) ; org.springframework.messaging.support.ExecutorSubscribableChannelTests.BeforeHandleInterceptor . void ( org.springframework.messaging.support.Message<> ) ; this . org.springframework.messaging.support.ExecutorSubscribableChannel . addInterceptor ( org.springframework.messaging.support.ExecutorSubscribableChannelTests.BeforeHandleInterceptor ) ; this . org.springframework.messaging.support.ExecutorSubscribableChannel . subscribe ( this . org.springframework.messaging.support.MessageHandler ) ; this . org.springframework.messaging.support.ExecutorSubscribableChannel . send ( this . org.springframework.messaging.support.Message<java.lang.Object> ) ; verify ( this . org.springframework.messaging.support.MessageHandler ) . handleMessage ( org.springframework.messaging.support.Message<> ) ; assertEquals ( NUMBER , org.springframework.messaging.support.ExecutorSubscribableChannelTests.BeforeHandleInterceptor . java.util.concurrent.atomic.AtomicInteger ( ) . int ( ) ) ; assertTrue ( org.springframework.messaging.support.ExecutorSubscribableChannelTests.BeforeHandleInterceptor . boolean ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { org.springframework.messaging.support.ExecutorSubscribableChannelTests.BeforeHandleInterceptor org.springframework.messaging.support.ExecutorSubscribableChannelTests.BeforeHandleInterceptor = new org.springframework.messaging.support.ExecutorSubscribableChannelTests.BeforeHandleInterceptor ( ) ; org.springframework.messaging.support.ExecutorSubscribableChannelTests.NullReturningBeforeHandleInterceptor org.springframework.messaging.support.ExecutorSubscribableChannelTests.NullReturningBeforeHandleInterceptor = new org.springframework.messaging.support.ExecutorSubscribableChannelTests.NullReturningBeforeHandleInterceptor ( ) ; this . org.springframework.messaging.support.ExecutorSubscribableChannel . addInterceptor ( org.springframework.messaging.support.ExecutorSubscribableChannelTests.BeforeHandleInterceptor ) ; this . org.springframework.messaging.support.ExecutorSubscribableChannel . addInterceptor ( org.springframework.messaging.support.ExecutorSubscribableChannelTests.NullReturningBeforeHandleInterceptor ) ; this . org.springframework.messaging.support.ExecutorSubscribableChannel . subscribe ( this . org.springframework.messaging.support.MessageHandler ) ; this . org.springframework.messaging.support.ExecutorSubscribableChannel . send ( this . org.springframework.messaging.support.Message<java.lang.Object> ) ; verifyNoMoreInteractions ( this . org.springframework.messaging.support.MessageHandler ) ; assertEquals ( NUMBER , org.springframework.messaging.support.ExecutorSubscribableChannelTests.BeforeHandleInterceptor . java.util.concurrent.atomic.AtomicInteger ( ) . int ( ) ) ; assertEquals ( NUMBER , org.springframework.messaging.support.ExecutorSubscribableChannelTests.NullReturningBeforeHandleInterceptor . java.util.concurrent.atomic.AtomicInteger ( ) . int ( ) ) ; assertTrue ( org.springframework.messaging.support.ExecutorSubscribableChannelTests.BeforeHandleInterceptor . boolean ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { java.lang.IllegalStateException java.lang.IllegalStateException = new java.lang.IllegalStateException ( STRING ) ; willThrow ( java.lang.IllegalStateException ) . given ( this . org.springframework.messaging.support.MessageHandler ) . handleMessage ( this . org.springframework.messaging.support.Message<java.lang.Object> ) ; org.springframework.messaging.support.ExecutorSubscribableChannelTests.BeforeHandleInterceptor org.springframework.messaging.support.ExecutorSubscribableChannelTests.BeforeHandleInterceptor = new org.springframework.messaging.support.ExecutorSubscribableChannelTests.BeforeHandleInterceptor ( ) ; this . org.springframework.messaging.support.ExecutorSubscribableChannel . addInterceptor ( org.springframework.messaging.support.ExecutorSubscribableChannelTests.BeforeHandleInterceptor ) ; this . org.springframework.messaging.support.ExecutorSubscribableChannel . subscribe ( this . org.springframework.messaging.support.MessageHandler ) ; try { this . org.springframework.messaging.support.ExecutorSubscribableChannel . send ( this . org.springframework.messaging.support.Message<java.lang.Object> ) ; } catch ( MessageDeliveryException org.springframework.messaging.support.MessageDeliveryException ) { assertSame ( java.lang.IllegalStateException , org.springframework.messaging.support.MessageDeliveryException . getCause ( ) ) ; } verify ( this . org.springframework.messaging.support.MessageHandler ) . handleMessage ( this . org.springframework.messaging.support.Message<java.lang.Object> ) ; assertEquals ( NUMBER , org.springframework.messaging.support.ExecutorSubscribableChannelTests.BeforeHandleInterceptor . java.util.concurrent.atomic.AtomicInteger ( ) . int ( ) ) ; assertTrue ( org.springframework.messaging.support.ExecutorSubscribableChannelTests.BeforeHandleInterceptor . boolean ( ) ) ; }  <METHOD_END>
<METHOD_START> public java.util.concurrent.atomic.AtomicInteger java.util.concurrent.atomic.AtomicInteger ( ) { return this . java.util.concurrent.atomic.AtomicInteger ; }  <METHOD_END>
<METHOD_START> public boolean boolean ( ) { return this . boolean ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.messaging.support.Message<?> < ? > org.springframework.messaging.support.Message<?> ( Message < ? > org.springframework.messaging.support.Message<?> , MessageChannel org.springframework.messaging.support.MessageChannel , MessageHandler org.springframework.messaging.support.MessageHandler ) { assertNotNull ( org.springframework.messaging.support.Message<> ) ; java.util.concurrent.atomic.AtomicInteger . int ( ) ; return org.springframework.messaging.support.Message<> ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( Message < ? > org.springframework.messaging.support.Message<?> , MessageChannel org.springframework.messaging.support.MessageChannel , MessageHandler org.springframework.messaging.support.MessageHandler , java.lang.Exception java.lang.Exception ) { this . boolean = true ; }  <METHOD_END>
<METHOD_START> public void void ( Message < ? > org.springframework.messaging.support.Message<?> ) { this . org.springframework.messaging.support.Message<?> = org.springframework.messaging.support.Message<> ; }  <METHOD_END>
<METHOD_START> @ java.lang.SuppressWarnings ( STRING ) public void void ( java.lang.RuntimeException java.lang.RuntimeException ) { this . java.lang.RuntimeException = java.lang.RuntimeException ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.messaging.support.Message<?> < ? > org.springframework.messaging.support.Message<?> ( Message < ? > org.springframework.messaging.support.Message<?> , MessageChannel org.springframework.messaging.support.MessageChannel , MessageHandler org.springframework.messaging.support.MessageHandler ) { super. org.springframework.messaging.support.Message<?> ( org.springframework.messaging.support.Message<> , org.springframework.messaging.support.MessageChannel , org.springframework.messaging.support.MessageHandler ) ; if ( this . java.lang.RuntimeException != null ) { throw this . java.lang.RuntimeException ; } return ( this . org.springframework.messaging.support.Message<> != null ? this . org.springframework.messaging.support.Message<> : org.springframework.messaging.support.Message<> ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.messaging.support.Message<?> < ? > org.springframework.messaging.support.Message<?> ( Message < ? > org.springframework.messaging.support.Message<?> , MessageChannel org.springframework.messaging.support.MessageChannel , MessageHandler org.springframework.messaging.support.MessageHandler ) { super. org.springframework.messaging.support.Message<?> ( org.springframework.messaging.support.Message<> , org.springframework.messaging.support.MessageChannel , org.springframework.messaging.support.MessageHandler ) ; return null ; }  <METHOD_END>
