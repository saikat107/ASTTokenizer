<METHOD_START> public void ( int int , SpelNodeImpl org.springframework.expression.spel.ast.SpelNodeImpl ) { this( int , org.springframework.expression.spel.ast.SpelNodeImpl , NUMBER ); }  <METHOD_END>
<METHOD_START> public void ( int int , SpelNodeImpl org.springframework.expression.spel.ast.SpelNodeImpl , int int ) { super( int , org.springframework.expression.spel.ast.SpelNodeImpl ); this . int = int ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.expression.spel.ast.TypedValue org.springframework.expression.spel.ast.TypedValue ( ExpressionState org.springframework.expression.spel.ast.ExpressionState ) throws org.springframework.expression.spel.ast.EvaluationException { java.lang.String java.lang.String = ( java.lang.String ) this . children [ NUMBER ] . getValueInternal ( org.springframework.expression.spel.ast.ExpressionState ) . getValue ( ) ; if ( ! java.lang.String . boolean ( STRING ) && java.lang.Character . boolean ( java.lang.String . char ( NUMBER ) ) ) { TypeCode org.springframework.expression.spel.ast.TypeCode = TypeCode . valueOf ( java.lang.String . java.lang.String ( ) ) ; if ( org.springframework.expression.spel.ast.TypeCode != TypeCode . OBJECT ) { java.lang.Class<?> < ? > java.lang.Class<?> = java.lang.Class<?> ( org.springframework.expression.spel.ast.TypeCode . getType ( ) ) ; this . exitTypeDescriptor = STRING ; this . java.lang.Class<?> = java.lang.Class<> ; return new TypedValue ( java.lang.Class<> ) ; } } java.lang.Class<?> < ? > java.lang.Class<?> = org.springframework.expression.spel.ast.ExpressionState . findType ( java.lang.String ) ; java.lang.Class<?> = java.lang.Class<?> ( java.lang.Class<> ) ; this . exitTypeDescriptor = STRING ; this . java.lang.Class<?> = java.lang.Class<> ; return new TypedValue ( java.lang.Class<> ) ; }  <METHOD_END>
<METHOD_START> private java.lang.Class<?> < ? > java.lang.Class<?> ( java.lang.Class<?> < ? > java.lang.Class<?> ) { if ( this . int != NUMBER ) { for ( int int = NUMBER ; int < this . int ; int ++ ) { java.lang.Object java.lang.Object = java.lang.reflect.Array . java.lang.Object ( java.lang.Class<> , NUMBER ) ; java.lang.Class<?> = java.lang.Object . java.lang.Class<? extends java.lang.Object> ( ) ; } } return java.lang.Class<> ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.String java.lang.String ( ) { java.lang.StringBuilder java.lang.StringBuilder = new java.lang.StringBuilder ( STRING ) ; java.lang.StringBuilder . java.lang.StringBuilder ( getChild ( NUMBER ) . toStringAST ( ) ) ; for ( int int = NUMBER ; int < this . int ; int ++ ) { java.lang.StringBuilder . java.lang.StringBuilder ( STRING ) ; } java.lang.StringBuilder . java.lang.StringBuilder ( STRING ) ; return java.lang.StringBuilder . java.lang.String ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( ) { return ( this . exitTypeDescriptor != null ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( MethodVisitor org.springframework.expression.spel.ast.MethodVisitor , CodeFlow org.springframework.expression.spel.ast.CodeFlow ) { if ( this . java.lang.Class<> . boolean ( ) ) { if ( this . java.lang.Class<> == java.lang.Integer . java.lang.Class<java.lang.Integer> ) { org.springframework.expression.spel.ast.MethodVisitor . visitFieldInsn ( GETSTATIC , STRING , STRING , STRING ) ; } else if ( this . java.lang.Class<> == java.lang.Boolean . java.lang.Class<java.lang.Boolean> ) { org.springframework.expression.spel.ast.MethodVisitor . visitFieldInsn ( GETSTATIC , STRING , STRING , STRING ) ; } else if ( this . java.lang.Class<> == java.lang.Byte . java.lang.Class<java.lang.Byte> ) { org.springframework.expression.spel.ast.MethodVisitor . visitFieldInsn ( GETSTATIC , STRING , STRING , STRING ) ; } else if ( this . java.lang.Class<> == java.lang.Short . java.lang.Class<java.lang.Short> ) { org.springframework.expression.spel.ast.MethodVisitor . visitFieldInsn ( GETSTATIC , STRING , STRING , STRING ) ; } else if ( this . java.lang.Class<> == java.lang.Double . java.lang.Class<java.lang.Double> ) { org.springframework.expression.spel.ast.MethodVisitor . visitFieldInsn ( GETSTATIC , STRING , STRING , STRING ) ; } else if ( this . java.lang.Class<> == java.lang.Character . java.lang.Class<java.lang.Character> ) { org.springframework.expression.spel.ast.MethodVisitor . visitFieldInsn ( GETSTATIC , STRING , STRING , STRING ) ; } else if ( this . java.lang.Class<> == java.lang.Float . java.lang.Class<java.lang.Float> ) { org.springframework.expression.spel.ast.MethodVisitor . visitFieldInsn ( GETSTATIC , STRING , STRING , STRING ) ; } else if ( this . java.lang.Class<> == java.lang.Long . java.lang.Class<java.lang.Long> ) { org.springframework.expression.spel.ast.MethodVisitor . visitFieldInsn ( GETSTATIC , STRING , STRING , STRING ) ; } else if ( this . java.lang.Class<> == java.lang.Boolean . java.lang.Class<java.lang.Boolean> ) { org.springframework.expression.spel.ast.MethodVisitor . visitFieldInsn ( GETSTATIC , STRING , STRING , STRING ) ; } } else { org.springframework.expression.spel.ast.MethodVisitor . visitLdcInsn ( Type . getType ( this . java.lang.Class<> ) ) ; } org.springframework.expression.spel.ast.CodeFlow . pushDescriptor ( this . exitTypeDescriptor ) ; }  <METHOD_END>
