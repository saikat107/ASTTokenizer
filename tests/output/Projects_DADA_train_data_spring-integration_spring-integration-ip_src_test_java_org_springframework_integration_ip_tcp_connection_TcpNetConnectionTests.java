<METHOD_START> @ java.lang.Override public void void ( ApplicationEvent org.springframework.integration.ip.tcp.connection.ApplicationEvent ) {		}  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( java.lang.Object java.lang.Object ) {		}  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.net.Socket java.net.Socket = mock ( java.net.Socket .class ) ; java.io.InputStream java.io.InputStream = mock ( java.io.InputStream .class ) ; when ( java.net.Socket . java.io.InputStream ( ) ) . thenReturn ( java.io.InputStream ) ; when ( java.io.InputStream . int ( ) ) . thenReturn ( ( int ) 'x' ) ; TcpNetConnection org.springframework.integration.ip.tcp.connection.TcpNetConnection = new TcpNetConnection ( java.net.Socket , true , false , org.springframework.integration.ip.tcp.connection.ApplicationEventPublisher , null ) ; org.springframework.integration.ip.tcp.connection.TcpNetConnection . setDeserializer ( new ByteArrayStxEtxSerializer ( ) ) ; final java.util.concurrent.atomic.AtomicReference<java.lang.Object> < java.lang.Object > java.util.concurrent.atomic.AtomicReference<java.lang.Object> = new java.util.concurrent.atomic.AtomicReference<java.lang.Object> < java.lang.Object > ( ) ; Log org.springframework.integration.ip.tcp.connection.Log = mock ( Log .class ) ; doAnswer ( invocation -> { log . set ( invocation . getArguments ( ) [ NUMBER ] ) ; return null ; } ) . when ( org.springframework.integration.ip.tcp.connection.Log ) . error ( Mockito . anyString ( ) ) ; DirectFieldAccessor org.springframework.integration.ip.tcp.connection.DirectFieldAccessor = new DirectFieldAccessor ( org.springframework.integration.ip.tcp.connection.TcpNetConnection ) ; org.springframework.integration.ip.tcp.connection.DirectFieldAccessor . setPropertyValue ( STRING , org.springframework.integration.ip.tcp.connection.Log ) ; org.springframework.integration.ip.tcp.connection.TcpNetConnection . registerListener ( mock ( TcpListener .class ) ) ; org.springframework.integration.ip.tcp.connection.TcpNetConnection . setMapper ( new TcpMessageMapper ( ) ) ; org.springframework.integration.ip.tcp.connection.TcpNetConnection . run ( ) ; assertNotNull ( java.util.concurrent.atomic.AtomicReference<java.lang.Object> . java.lang.Object ( ) ) ; assertEquals ( STRING + org.springframework.integration.ip.tcp.connection.TcpNetConnection . getConnectionId ( ) + STRING , java.util.concurrent.atomic.AtomicReference<java.lang.Object> . java.lang.Object ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.nio.channels.SocketChannel java.nio.channels.SocketChannel = mock ( java.nio.channels.SocketChannel .class ) ; java.net.Socket java.net.Socket = mock ( java.net.Socket .class ) ; when ( java.nio.channels.SocketChannel . java.net.Socket ( ) ) . thenReturn ( java.net.Socket ) ; TcpNioConnection org.springframework.integration.ip.tcp.connection.TcpNioConnection = new TcpNioConnection ( java.nio.channels.SocketChannel , true , false , org.springframework.integration.ip.tcp.connection.ApplicationEventPublisher , null ) ; ChannelInputStream org.springframework.integration.ip.tcp.connection.ChannelInputStream = TestUtils . getPropertyValue ( org.springframework.integration.ip.tcp.connection.TcpNioConnection , STRING , ChannelInputStream .class ) ; org.springframework.integration.ip.tcp.connection.ChannelInputStream . write ( java.nio.ByteBuffer . java.nio.ByteBuffer ( new byte [] { ( byte ) NUMBER } ) ) ; assertEquals ( NUMBER , org.springframework.integration.ip.tcp.connection.ChannelInputStream . read ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.net.Socket java.net.Socket = mock ( java.net.Socket .class ) ; java.io.PipedInputStream java.io.PipedInputStream = new java.io.PipedInputStream ( ) ; when ( java.net.Socket . java.io.InputStream ( ) ) . thenReturn ( java.io.PipedInputStream ) ; TcpConnectionSupport org.springframework.integration.ip.tcp.connection.TcpConnectionSupport = new TcpNetConnection ( java.net.Socket , true , false , org.springframework.integration.ip.tcp.connection.ApplicationEventPublisher , null ) ; org.springframework.integration.ip.tcp.connection.TcpConnectionSupport . setDeserializer ( new MapJsonSerializer ( ) ) ; MapMessageConverter org.springframework.integration.ip.tcp.connection.MapMessageConverter = new MapMessageConverter ( ) ; MessageConvertingTcpMessageMapper org.springframework.integration.ip.tcp.connection.MessageConvertingTcpMessageMapper = new MessageConvertingTcpMessageMapper ( org.springframework.integration.ip.tcp.connection.MapMessageConverter ) ; org.springframework.integration.ip.tcp.connection.TcpConnectionSupport . setMapper ( org.springframework.integration.ip.tcp.connection.MessageConvertingTcpMessageMapper ) ; java.io.ByteArrayOutputStream java.io.ByteArrayOutputStream = new java.io.ByteArrayOutputStream ( ) ; java.net.Socket java.net.Socket = mock ( java.net.Socket .class ) ; TcpNetConnection org.springframework.integration.ip.tcp.connection.TcpNetConnection = new TcpNetConnection ( java.net.Socket , true , false , org.springframework.integration.ip.tcp.connection.ApplicationEventPublisher , null ) ; when ( java.net.Socket . java.io.OutputStream ( ) ) . thenReturn ( java.io.ByteArrayOutputStream ) ; MapMessageConverter org.springframework.integration.ip.tcp.connection.MapMessageConverter = new MapMessageConverter ( ) ; org.springframework.integration.ip.tcp.connection.MapMessageConverter . setHeaderNames ( STRING ) ; MessageConvertingTcpMessageMapper org.springframework.integration.ip.tcp.connection.MessageConvertingTcpMessageMapper = new MessageConvertingTcpMessageMapper ( org.springframework.integration.ip.tcp.connection.MapMessageConverter ) ; org.springframework.integration.ip.tcp.connection.TcpNetConnection . setMapper ( org.springframework.integration.ip.tcp.connection.MessageConvertingTcpMessageMapper ) ; org.springframework.integration.ip.tcp.connection.TcpNetConnection . setSerializer ( new MapJsonSerializer ( ) ) ; Message < java.lang.String > org.springframework.integration.ip.tcp.connection.Message<java.lang.String> = MessageBuilder . withPayload ( STRING ) . setHeader ( STRING , STRING ) . build ( ) ; org.springframework.integration.ip.tcp.connection.TcpNetConnection . send ( org.springframework.integration.ip.tcp.connection.Message<java.lang.String> ) ; java.io.PipedOutputStream java.io.PipedOutputStream = new java.io.PipedOutputStream ( java.io.PipedInputStream ) ; java.io.PipedOutputStream . void ( java.io.ByteArrayOutputStream . byte[] ( ) ) ; java.io.PipedOutputStream . void ( ) ; final java.util.concurrent.atomic.AtomicReference<org.springframework.integration.ip.tcp.connection.Message<?>> < Message < ? > > java.util.concurrent.atomic.AtomicReference<org.springframework.integration.ip.tcp.connection.Message<?>> = new java.util.concurrent.atomic.AtomicReference<org.springframework.integration.ip.tcp.connection.Message<?>> < Message < ? > > ( ) ; TcpListener org.springframework.integration.ip.tcp.connection.TcpListener = message1 -> { if ( ! ( message1 instanceof ErrorMessage ) ) { inboundMessage . set ( message1 ) ; } return false ; } ; org.springframework.integration.ip.tcp.connection.TcpConnectionSupport . registerListener ( org.springframework.integration.ip.tcp.connection.TcpListener ) ; org.springframework.integration.ip.tcp.connection.TcpConnectionSupport . run ( ) ; assertNotNull ( java.util.concurrent.atomic.AtomicReference<org.springframework.integration.ip.tcp.connection.Message<?>> . get ( ) ) ; assertEquals ( STRING , java.util.concurrent.atomic.AtomicReference<org.springframework.integration.ip.tcp.connection.Message<?>> . get ( ) . getPayload ( ) ) ; assertEquals ( STRING , java.util.concurrent.atomic.AtomicReference<org.springframework.integration.ip.tcp.connection.Message<?>> . get ( ) . getHeaders ( ) . get ( STRING ) ) ; }  <METHOD_END>
