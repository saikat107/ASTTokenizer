<METHOD_START> @ java.lang.Override protected boolean boolean ( java.util.Map . java.util.Map.Entry<java.lang.String,byte[]> < java.lang.String , byte [] > java.util.Map.Entry<java.lang.String,byte[]> ) { if ( int ( ) > int ) { java.util.Map<java.lang.String,byte[]> . byte[] ( java.util.Map.Entry<java.lang.String,byte[]> . java.lang.String ( ) ) ; return true ; } else { return false ; } }  <METHOD_END>
<METHOD_START> public byte [] byte[] ( Message < byte [] > org.springframework.messaging.simp.stomp.Message<byte[]> ) { return byte[] ( org.springframework.messaging.simp.stomp.Message<byte[]> . getHeaders ( ) , org.springframework.messaging.simp.stomp.Message<byte[]> . getPayload ( ) ) ; }  <METHOD_END>
<METHOD_START> public byte [] byte[] ( java.util.Map<java.lang.String,java.lang.Object> < java.lang.String , java.lang.Object > java.util.Map<java.lang.String,java.lang.Object> , byte [] byte[] ) { Assert . notNull ( java.util.Map<java.lang.String,java.lang.Object> , STRING ) ; Assert . notNull ( byte[] , STRING ) ; try { java.io.ByteArrayOutputStream java.io.ByteArrayOutputStream = new java.io.ByteArrayOutputStream ( NUMBER + byte[] . int ) ; java.io.DataOutputStream java.io.DataOutputStream = new java.io.DataOutputStream ( java.io.ByteArrayOutputStream ) ; if ( SimpMessageType . HEARTBEAT . equals ( SimpMessageHeaderAccessor . getMessageType ( java.util.Map<java.lang.String,java.lang.Object> ) ) ) { if ( org.springframework.messaging.simp.stomp.Log . isTraceEnabled ( ) ) { org.springframework.messaging.simp.stomp.Log . trace ( STRING ) ; } java.io.DataOutputStream . void ( StompDecoder . HEARTBEAT_PAYLOAD ) ; } else { StompCommand org.springframework.messaging.simp.stomp.StompCommand = StompHeaderAccessor . getCommand ( java.util.Map<java.lang.String,java.lang.Object> ) ; if ( org.springframework.messaging.simp.stomp.StompCommand == null ) { throw new java.lang.IllegalStateException ( STRING + java.util.Map<java.lang.String,java.lang.Object> ) ; } java.io.DataOutputStream . void ( org.springframework.messaging.simp.stomp.StompCommand . toString ( ) . getBytes ( java.nio.charset.StandardCharsets . java.nio.charset.Charset ) ) ; java.io.DataOutputStream . void ( byte ) ; void ( org.springframework.messaging.simp.stomp.StompCommand , java.util.Map<java.lang.String,java.lang.Object> , byte[] , java.io.DataOutputStream ) ; java.io.DataOutputStream . void ( byte ) ; void ( byte[] , java.io.DataOutputStream ) ; java.io.DataOutputStream . void ( ( byte ) NUMBER ) ; } return java.io.ByteArrayOutputStream . byte[] ( ) ; } catch ( java.io.IOException java.io.IOException ) { throw new StompConversionException ( STRING + java.util.Map<java.lang.String,java.lang.Object> , java.io.IOException ) ; } }  <METHOD_END>
<METHOD_START> private void void ( StompCommand org.springframework.messaging.simp.stomp.StompCommand , java.util.Map<java.lang.String,java.lang.Object> < java.lang.String , java.lang.Object > java.util.Map<java.lang.String,java.lang.Object> , byte [] byte[] , java.io.DataOutputStream java.io.DataOutputStream ) throws java.io.IOException { @ java.lang.SuppressWarnings ( STRING ) java.util.Map<java.lang.String,java.util.List<java.lang.String>> < java.lang.String , java.util.List<java.lang.String> < java.lang.String > > java.util.Map<java.lang.String,java.util.List<java.lang.String>> = ( java.util.Map<java.lang.String,java.util.List<java.lang.String>> < java.lang.String , java.util.List<java.lang.String> < java.lang.String > > ) java.util.Map<java.lang.String,java.lang.Object> . java.lang.Object ( NativeMessageHeaderAccessor . NATIVE_HEADERS ) ; if ( org.springframework.messaging.simp.stomp.Log . isTraceEnabled ( ) ) { org.springframework.messaging.simp.stomp.Log . trace ( STRING + org.springframework.messaging.simp.stomp.StompCommand + STRING + java.util.Map<java.lang.String,java.util.List<java.lang.String>> ) ; } if ( java.util.Map<java.lang.String,java.util.List<java.lang.String>> == null ) { return; } boolean boolean = ( org.springframework.messaging.simp.stomp.StompCommand != StompCommand . CONNECT && org.springframework.messaging.simp.stomp.StompCommand != StompCommand . CONNECTED ) ; for ( java.util.Map.Entry<java.lang.String,java.util.List<java.lang.String>> < java.lang.String , java.util.List<java.lang.String> < java.lang.String > > java.util.Map.Entry<java.lang.String,java.util.List<java.lang.String>> : java.util.Map<java.lang.String,java.util.List<java.lang.String>> . java.util.Set<java.util.Map.Entry<java.lang.String,java.util.List<java.lang.String>>> ( ) ) { if ( org.springframework.messaging.simp.stomp.StompCommand . requiresContentLength ( ) && STRING . boolean ( java.util.Map.Entry<java.lang.String,java.util.List<java.lang.String>> . java.lang.String ( ) ) ) { continue; } java.util.List<java.lang.String> < java.lang.String > java.util.List<java.lang.String> = java.util.Map.Entry<java.lang.String,java.util.List<java.lang.String>> . java.util.List<java.lang.String> ( ) ; if ( StompCommand . CONNECT . equals ( org.springframework.messaging.simp.stomp.StompCommand ) && StompHeaderAccessor . STOMP_PASSCODE_HEADER . equals ( java.util.Map.Entry<java.lang.String,java.util.List<java.lang.String>> . java.lang.String ( ) ) ) { java.util.List<java.lang.String> = java.util.Collections . java.util.List ( StompHeaderAccessor . getPasscode ( java.util.Map<java.lang.String,java.lang.Object> ) ) ; } byte [] byte[] = byte[] ( java.util.Map.Entry<java.lang.String,java.util.List<java.lang.String>> . java.lang.String ( ) , boolean ) ; for ( java.lang.String java.lang.String : java.util.List<java.lang.String> ) { java.io.DataOutputStream . void ( byte[] ) ; java.io.DataOutputStream . void ( byte ) ; java.io.DataOutputStream . void ( byte[] ( java.lang.String , boolean ) ) ; java.io.DataOutputStream . void ( byte ) ; } } if ( org.springframework.messaging.simp.stomp.StompCommand . requiresContentLength ( ) ) { int int = byte[] . int ; java.io.DataOutputStream . void ( STRING . byte[] ( java.nio.charset.StandardCharsets . java.nio.charset.Charset ) ) ; java.io.DataOutputStream . void ( java.lang.Integer . java.lang.String ( int ) . byte[] ( java.nio.charset.StandardCharsets . java.nio.charset.Charset ) ) ; java.io.DataOutputStream . void ( byte ) ; } }  <METHOD_END>
<METHOD_START> private byte [] byte[] ( java.lang.String java.lang.String , boolean boolean ) { java.lang.String java.lang.String = ( boolean ? java.lang.String ( java.lang.String ) : java.lang.String ) ; if ( this . java.util.Map<java.lang.String,byte[]> . boolean ( java.lang.String ) ) { return this . java.util.Map<java.lang.String,byte[]> . byte[] ( java.lang.String ) ; } synchronized ( this . java.util.Map<java.lang.String,byte[]> ) { byte [] byte[] = this . java.util.Map<java.lang.String,byte[]> . byte[] ( java.lang.String ) ; if ( byte[] == null ) { byte[] = java.lang.String . byte[] ( java.nio.charset.StandardCharsets . java.nio.charset.Charset ) ; this . java.util.Map<java.lang.String,byte[]> . byte[] ( java.lang.String , byte[] ) ; this . java.util.Map<java.lang.String,byte[]> . byte[] ( java.lang.String , byte[] ) ; } return byte[] ; } }  <METHOD_END>
<METHOD_START> private byte [] byte[] ( java.lang.String java.lang.String , boolean boolean ) { java.lang.String java.lang.String = ( boolean ? java.lang.String ( java.lang.String ) : java.lang.String ) ; return java.lang.String . byte[] ( java.nio.charset.StandardCharsets . java.nio.charset.Charset ) ; }  <METHOD_END>
<METHOD_START> private java.lang.String java.lang.String ( java.lang.String java.lang.String ) { java.lang.StringBuilder java.lang.StringBuilder = null ; for ( int int = NUMBER ; int < java.lang.String . int ( ) ; int ++ ) { char char = java.lang.String . char ( int ) ; if ( char == '\\' ) { java.lang.StringBuilder = java.lang.StringBuilder ( java.lang.StringBuilder , java.lang.String , int ) ; java.lang.StringBuilder . java.lang.StringBuilder ( STRING ) ; } else if ( char == ':' ) { java.lang.StringBuilder = java.lang.StringBuilder ( java.lang.StringBuilder , java.lang.String , int ) ; java.lang.StringBuilder . java.lang.StringBuilder ( STRING ) ; } else if ( char == '\n' ) { java.lang.StringBuilder = java.lang.StringBuilder ( java.lang.StringBuilder , java.lang.String , int ) ; java.lang.StringBuilder . java.lang.StringBuilder ( STRING ) ; } else if ( char == '\r' ) { java.lang.StringBuilder = java.lang.StringBuilder ( java.lang.StringBuilder , java.lang.String , int ) ; java.lang.StringBuilder . java.lang.StringBuilder ( STRING ) ; } else if ( java.lang.StringBuilder != null ) { java.lang.StringBuilder . java.lang.StringBuilder ( char ) ; } } return ( java.lang.StringBuilder != null ? java.lang.StringBuilder . java.lang.String ( ) : java.lang.String ) ; }  <METHOD_END>
<METHOD_START> private java.lang.StringBuilder java.lang.StringBuilder ( java.lang.StringBuilder java.lang.StringBuilder , java.lang.String java.lang.String , int int ) { if ( java.lang.StringBuilder == null ) { java.lang.StringBuilder = new java.lang.StringBuilder ( java.lang.String . int ( ) ) ; java.lang.StringBuilder . java.lang.StringBuilder ( java.lang.String . java.lang.String ( NUMBER , int ) ) ; } return java.lang.StringBuilder ; }  <METHOD_END>
<METHOD_START> private void void ( byte [] byte[] , java.io.DataOutputStream java.io.DataOutputStream ) throws java.io.IOException { java.io.DataOutputStream . void ( byte[] ) ; }  <METHOD_END>
