<METHOD_START> public void ( ) { super( STRING , STRING , STRING ); }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { StompHeaderAccessor org.springframework.integration.websocket.client.StompHeaderAccessor = StompHeaderAccessor . create ( StompCommand . CONNECT ) ; this . org.springframework.integration.websocket.client.MessageChannel . send ( MessageBuilder . withPayload ( new byte [ NUMBER ] ) . setHeaders ( org.springframework.integration.websocket.client.StompHeaderAccessor ) . build ( ) ) ; Message < ? > org.springframework.integration.websocket.client.Message<?> = this . org.springframework.integration.websocket.client.QueueChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.websocket.client.Message<> ) ; java.lang.Object java.lang.Object = org.springframework.integration.websocket.client.Message<> . getPayload ( ) ; assertThat ( java.lang.Object , instanceOf ( SessionConnectedEvent .class ) ) ; Message < ? > org.springframework.integration.websocket.client.Message<?> = ( ( SessionConnectedEvent ) java.lang.Object ) . getMessage ( ) ; org.springframework.integration.websocket.client.StompHeaderAccessor = StompHeaderAccessor . wrap ( org.springframework.integration.websocket.client.Message<> ) ; assertEquals ( StompCommand . CONNECTED , org.springframework.integration.websocket.client.StompHeaderAccessor . getCommand ( ) ) ; org.springframework.integration.websocket.client.StompHeaderAccessor = StompHeaderAccessor . create ( StompCommand . SEND ) ; org.springframework.integration.websocket.client.StompHeaderAccessor . setSubscriptionId ( STRING ) ; org.springframework.integration.websocket.client.StompHeaderAccessor . setDestination ( STRING ) ; Message < java.lang.String > org.springframework.integration.websocket.client.Message<java.lang.String> = MessageBuilder . withPayload ( STRING ) . setHeaders ( org.springframework.integration.websocket.client.StompHeaderAccessor ) . build ( ) ; this . org.springframework.integration.websocket.client.MessageChannel . send ( org.springframework.integration.websocket.client.Message<java.lang.String> ) ; org.springframework.integration.websocket.client.StompIntegrationTests.SimpleController org.springframework.integration.websocket.client.StompIntegrationTests.SimpleController = this . org.springframework.integration.websocket.client.ApplicationContext . getBean ( org.springframework.integration.websocket.client.StompIntegrationTests.SimpleController .class ) ; assertTrue ( org.springframework.integration.websocket.client.StompIntegrationTests.SimpleController . java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { StompHeaderAccessor org.springframework.integration.websocket.client.StompHeaderAccessor = StompHeaderAccessor . create ( StompCommand . SUBSCRIBE ) ; org.springframework.integration.websocket.client.StompHeaderAccessor . setSubscriptionId ( STRING ) ; org.springframework.integration.websocket.client.StompHeaderAccessor . setDestination ( STRING ) ; org.springframework.integration.websocket.client.StompHeaderAccessor . setReceipt ( STRING ) ; Message < byte [] > org.springframework.integration.websocket.client.Message<byte[]> = MessageBuilder . withPayload ( java.nio.ByteBuffer . java.nio.ByteBuffer ( NUMBER ) . byte[] ( ) ) . setHeaders ( org.springframework.integration.websocket.client.StompHeaderAccessor ) . build ( ) ; this . org.springframework.integration.websocket.client.MessageChannel . send ( org.springframework.integration.websocket.client.Message<byte[]> ) ; Message < ? > org.springframework.integration.websocket.client.Message<?> = this . org.springframework.integration.websocket.client.QueueChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.websocket.client.Message<> ) ; java.lang.Object java.lang.Object = org.springframework.integration.websocket.client.Message<> . getPayload ( ) ; assertThat ( java.lang.Object , instanceOf ( ReceiptEvent .class ) ) ; Message < ? > org.springframework.integration.websocket.client.Message<?> = ( ( ReceiptEvent ) java.lang.Object ) . getMessage ( ) ; org.springframework.integration.websocket.client.StompHeaderAccessor = StompHeaderAccessor . wrap ( org.springframework.integration.websocket.client.Message<> ) ; assertEquals ( StompCommand . RECEIPT , org.springframework.integration.websocket.client.StompHeaderAccessor . getCommand ( ) ) ; assertEquals ( STRING , org.springframework.integration.websocket.client.StompHeaderAccessor . getReceiptId ( ) ) ; void ( STRING ) ; org.springframework.integration.websocket.client.StompHeaderAccessor = StompHeaderAccessor . create ( StompCommand . SEND ) ; org.springframework.integration.websocket.client.StompHeaderAccessor . setSubscriptionId ( STRING ) ; org.springframework.integration.websocket.client.StompHeaderAccessor . setDestination ( STRING ) ; Message < java.lang.Integer > org.springframework.integration.websocket.client.Message<java.lang.Integer> = MessageBuilder . withPayload ( NUMBER ) . setHeaders ( org.springframework.integration.websocket.client.StompHeaderAccessor ) . build ( ) ; this . org.springframework.integration.websocket.client.MessageChannel . send ( org.springframework.integration.websocket.client.Message<java.lang.Integer> ) ; org.springframework.integration.websocket.client.Message<?> = org.springframework.integration.websocket.client.QueueChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.websocket.client.Message<> ) ; assertEquals ( STRING , org.springframework.integration.websocket.client.Message<> . getPayload ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { StompHeaderAccessor org.springframework.integration.websocket.client.StompHeaderAccessor = StompHeaderAccessor . create ( StompCommand . SUBSCRIBE ) ; org.springframework.integration.websocket.client.StompHeaderAccessor . setSubscriptionId ( STRING ) ; org.springframework.integration.websocket.client.StompHeaderAccessor . setDestination ( STRING ) ; Message < byte [] > org.springframework.integration.websocket.client.Message<byte[]> = MessageBuilder . withPayload ( java.nio.ByteBuffer . java.nio.ByteBuffer ( NUMBER ) . byte[] ( ) ) . setHeaders ( org.springframework.integration.websocket.client.StompHeaderAccessor ) . build ( ) ; org.springframework.integration.websocket.client.StompHeaderAccessor = StompHeaderAccessor . create ( StompCommand . SEND ) ; org.springframework.integration.websocket.client.StompHeaderAccessor . setSubscriptionId ( STRING ) ; org.springframework.integration.websocket.client.StompHeaderAccessor . setDestination ( STRING ) ; Message < java.lang.Integer > org.springframework.integration.websocket.client.Message<java.lang.Integer> = MessageBuilder . withPayload ( NUMBER ) . setHeaders ( org.springframework.integration.websocket.client.StompHeaderAccessor ) . build ( ) ; this . org.springframework.integration.websocket.client.MessageChannel . send ( org.springframework.integration.websocket.client.Message<byte[]> ) ; void ( STRING ) ; this . org.springframework.integration.websocket.client.MessageChannel . send ( org.springframework.integration.websocket.client.Message<java.lang.Integer> ) ; Message < ? > org.springframework.integration.websocket.client.Message<?> = org.springframework.integration.websocket.client.QueueChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.websocket.client.Message<> ) ; assertEquals ( STRING , org.springframework.integration.websocket.client.Message<> . getPayload ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.lang.String java.lang.String = STRING ; StompHeaderAccessor org.springframework.integration.websocket.client.StompHeaderAccessor = StompHeaderAccessor . create ( StompCommand . SUBSCRIBE ) ; org.springframework.integration.websocket.client.StompHeaderAccessor . setSubscriptionId ( STRING ) ; org.springframework.integration.websocket.client.StompHeaderAccessor . setDestination ( java.lang.String ) ; Message < byte [] > org.springframework.integration.websocket.client.Message<byte[]> = MessageBuilder . withPayload ( java.nio.ByteBuffer . java.nio.ByteBuffer ( NUMBER ) . byte[] ( ) ) . setHeaders ( org.springframework.integration.websocket.client.StompHeaderAccessor ) . build ( ) ; this . org.springframework.integration.websocket.client.MessageChannel . send ( org.springframework.integration.websocket.client.Message<byte[]> ) ; Message < ? > org.springframework.integration.websocket.client.Message<?> = org.springframework.integration.websocket.client.QueueChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.websocket.client.Message<> ) ; StompHeaderAccessor org.springframework.integration.websocket.client.StompHeaderAccessor = StompHeaderAccessor . wrap ( org.springframework.integration.websocket.client.Message<> ) ; assertEquals ( STRING + org.springframework.integration.websocket.client.StompHeaderAccessor , java.lang.String , org.springframework.integration.websocket.client.StompHeaderAccessor . getDestination ( ) ) ; java.lang.Object java.lang.Object = org.springframework.integration.websocket.client.Message<> . getPayload ( ) ; assertEquals ( STRING + java.lang.Object , STRING , java.lang.Object ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { java.lang.String java.lang.String = STRING ; StompHeaderAccessor org.springframework.integration.websocket.client.StompHeaderAccessor = StompHeaderAccessor . create ( StompCommand . SUBSCRIBE ) ; org.springframework.integration.websocket.client.StompHeaderAccessor . setSubscriptionId ( STRING ) ; org.springframework.integration.websocket.client.StompHeaderAccessor . setDestination ( java.lang.String ) ; Message < byte [] > org.springframework.integration.websocket.client.Message<byte[]> = MessageBuilder . withPayload ( java.nio.ByteBuffer . java.nio.ByteBuffer ( NUMBER ) . byte[] ( ) ) . setHeaders ( org.springframework.integration.websocket.client.StompHeaderAccessor ) . build ( ) ; org.springframework.integration.websocket.client.StompHeaderAccessor = StompHeaderAccessor . create ( StompCommand . SEND ) ; org.springframework.integration.websocket.client.StompHeaderAccessor . setSubscriptionId ( STRING ) ; org.springframework.integration.websocket.client.StompHeaderAccessor . setDestination ( STRING ) ; Message < java.lang.String > org.springframework.integration.websocket.client.Message<java.lang.String> = MessageBuilder . withPayload ( STRING ) . setHeaders ( org.springframework.integration.websocket.client.StompHeaderAccessor ) . build ( ) ; this . org.springframework.integration.websocket.client.MessageChannel . send ( org.springframework.integration.websocket.client.Message<byte[]> ) ; void ( STRING + this . org.springframework.integration.websocket.client.IntegrationWebSocketContainer . getSession ( null ) . getId ( ) ) ; this . org.springframework.integration.websocket.client.MessageChannel . send ( org.springframework.integration.websocket.client.Message<java.lang.String> ) ; Message < ? > org.springframework.integration.websocket.client.Message<?> = org.springframework.integration.websocket.client.QueueChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.websocket.client.Message<> ) ; StompHeaderAccessor org.springframework.integration.websocket.client.StompHeaderAccessor = StompHeaderAccessor . wrap ( org.springframework.integration.websocket.client.Message<> ) ; assertEquals ( STRING + org.springframework.integration.websocket.client.StompHeaderAccessor , java.lang.String , org.springframework.integration.websocket.client.StompHeaderAccessor . getDestination ( ) ) ; assertEquals ( STRING , org.springframework.integration.websocket.client.Message<> . getPayload ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) java.lang.Exception { StompHeaderAccessor org.springframework.integration.websocket.client.StompHeaderAccessor = StompHeaderAccessor . create ( StompCommand . SUBSCRIBE ) ; org.springframework.integration.websocket.client.StompHeaderAccessor . setSubscriptionId ( STRING ) ; org.springframework.integration.websocket.client.StompHeaderAccessor . setDestination ( STRING ) ; Message < byte [] > org.springframework.integration.websocket.client.Message<byte[]> = MessageBuilder . withPayload ( java.nio.ByteBuffer . java.nio.ByteBuffer ( NUMBER ) . byte[] ( ) ) . setHeaders ( org.springframework.integration.websocket.client.StompHeaderAccessor ) . build ( ) ; org.springframework.integration.websocket.client.StompHeaderAccessor = StompHeaderAccessor . create ( StompCommand . SEND ) ; org.springframework.integration.websocket.client.StompHeaderAccessor . setSubscriptionId ( STRING ) ; org.springframework.integration.websocket.client.StompHeaderAccessor . setDestination ( STRING ) ; Message < java.lang.String > org.springframework.integration.websocket.client.Message<java.lang.String> = MessageBuilder . withPayload ( STRING ) . setHeaders ( org.springframework.integration.websocket.client.StompHeaderAccessor ) . build ( ) ; this . org.springframework.integration.websocket.client.MessageChannel . send ( org.springframework.integration.websocket.client.Message<byte[]> ) ; void ( STRING + this . org.springframework.integration.websocket.client.IntegrationWebSocketContainer . getSession ( null ) . getId ( ) ) ; this . org.springframework.integration.websocket.client.MessageChannel . send ( org.springframework.integration.websocket.client.Message<java.lang.String> ) ; Message < ? > org.springframework.integration.websocket.client.Message<?> = org.springframework.integration.websocket.client.QueueChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.websocket.client.Message<> ) ; assertEquals ( STRING , org.springframework.integration.websocket.client.Message<> . getPayload ( ) ) ; }  <METHOD_END>
<METHOD_START> private void void ( java.lang.String java.lang.String ) throws java.lang.InterruptedException { SimpleBrokerMessageHandler org.springframework.integration.websocket.client.SimpleBrokerMessageHandler = this . org.springframework.integration.websocket.client.ApplicationContext . getBean ( STRING , SimpleBrokerMessageHandler .class ) ; SubscriptionRegistry org.springframework.integration.websocket.client.SubscriptionRegistry = org.springframework.integration.websocket.client.SimpleBrokerMessageHandler . getSubscriptionRegistry ( ) ; int int = NUMBER ; while ( ! boolean ( java.lang.String , org.springframework.integration.websocket.client.SubscriptionRegistry ) && int ++ < NUMBER ) { java.lang.Thread . void ( NUMBER ) ; } assertTrue ( STRING + java.lang.String + STRING , int < NUMBER ) ; }  <METHOD_END>
<METHOD_START> private boolean boolean ( java.lang.String java.lang.String , SubscriptionRegistry org.springframework.integration.websocket.client.SubscriptionRegistry ) { StompHeaderAccessor org.springframework.integration.websocket.client.StompHeaderAccessor = StompHeaderAccessor . create ( StompCommand . MESSAGE ) ; org.springframework.integration.websocket.client.StompHeaderAccessor . setDestination ( java.lang.String ) ; Message < byte [] > org.springframework.integration.websocket.client.Message<byte[]> = MessageBuilder . createMessage ( new byte [ NUMBER ] , org.springframework.integration.websocket.client.StompHeaderAccessor . toMessageHeaders ( ) ) ; MultiValueMap < java.lang.String , java.lang.String > org.springframework.integration.websocket.client.MultiValueMap<java.lang.String,java.lang.String> = org.springframework.integration.websocket.client.SubscriptionRegistry . findSubscriptions ( org.springframework.integration.websocket.client.Message<byte[]> ) ; return ! org.springframework.integration.websocket.client.MultiValueMap<java.lang.String,java.lang.String> . isEmpty ( ) ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.integration.websocket.client.TomcatWebSocketTestServer org.springframework.integration.websocket.client.TomcatWebSocketTestServer ( ) { return new TomcatWebSocketTestServer ( org.springframework.integration.websocket.client.StompIntegrationTests.ServerConfig .class ) ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.integration.websocket.client.WebSocketClient org.springframework.integration.websocket.client.WebSocketClient ( ) { return new SockJsClient ( java.util.Collections .< Transport > java.util.List<org.springframework.integration.websocket.client.Transport> ( new WebSocketTransport ( new StandardWebSocketClient ( ) ) ) ) ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.integration.websocket.client.IntegrationWebSocketContainer org.springframework.integration.websocket.client.IntegrationWebSocketContainer ( ) { return new ClientWebSocketContainer ( org.springframework.integration.websocket.client.WebSocketClient ( ) , org.springframework.integration.websocket.client.TomcatWebSocketTestServer ( ) . getWsBaseUrl ( ) + STRING ) ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.integration.websocket.client.SubProtocolHandler org.springframework.integration.websocket.client.SubProtocolHandler ( ) { return new StompSubProtocolHandler ( ) ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.integration.websocket.client.MessageChannel org.springframework.integration.websocket.client.MessageChannel ( ) { return new QueueChannel ( ) ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.integration.websocket.client.MessageChannel org.springframework.integration.websocket.client.MessageChannel ( ) { return new DirectChannel ( ) ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.integration.websocket.client.MessageProducer org.springframework.integration.websocket.client.MessageProducer ( ) { WebSocketInboundChannelAdapter org.springframework.integration.websocket.client.WebSocketInboundChannelAdapter = new WebSocketInboundChannelAdapter ( org.springframework.integration.websocket.client.IntegrationWebSocketContainer ( ) , new SubProtocolHandlerRegistry ( org.springframework.integration.websocket.client.SubProtocolHandler ( ) ) ) ; org.springframework.integration.websocket.client.WebSocketInboundChannelAdapter . setOutputChannel ( org.springframework.integration.websocket.client.MessageChannel ( ) ) ; return org.springframework.integration.websocket.client.WebSocketInboundChannelAdapter ; }  <METHOD_END>
<METHOD_START> @ Bean @ ServiceActivator ( inputChannel = STRING ) public org.springframework.integration.websocket.client.MessageHandler org.springframework.integration.websocket.client.MessageHandler ( ) { return new WebSocketOutboundMessageHandler ( org.springframework.integration.websocket.client.IntegrationWebSocketContainer ( ) , new SubProtocolHandlerRegistry ( org.springframework.integration.websocket.client.SubProtocolHandler ( ) ) ) ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.integration.websocket.client.PollableChannel org.springframework.integration.websocket.client.PollableChannel ( ) { return new QueueChannel ( ) ; }  <METHOD_END>
<METHOD_START> @ Bean @ java.lang.SuppressWarnings ( STRING ) public org.springframework.integration.websocket.client.ApplicationListener<org.springframework.integration.websocket.client.ApplicationEvent> < ApplicationEvent > org.springframework.integration.websocket.client.ApplicationListener<org.springframework.integration.websocket.client.ApplicationEvent> ( ) { ApplicationEventListeningMessageProducer org.springframework.integration.websocket.client.ApplicationEventListeningMessageProducer = new ApplicationEventListeningMessageProducer ( ) ; org.springframework.integration.websocket.client.ApplicationEventListeningMessageProducer . setEventTypes ( AbstractSubProtocolEvent .class ) ; org.springframework.integration.websocket.client.ApplicationEventListeningMessageProducer . setOutputChannel ( org.springframework.integration.websocket.client.PollableChannel ( ) ) ; return org.springframework.integration.websocket.client.ApplicationEventListeningMessageProducer ; }  <METHOD_END>
<METHOD_START> @ MessageMapping ( STRING ) public void void ( ) { this . java.util.concurrent.CountDownLatch . void ( ) ; }  <METHOD_END>
<METHOD_START> @ MessageMapping ( STRING ) public void void ( ) { throw new java.lang.IllegalArgumentException ( STRING ) ; }  <METHOD_END>
<METHOD_START> @ MessageExceptionHandler @ SendToUser ( STRING ) public java.lang.String java.lang.String ( java.lang.IllegalArgumentException java.lang.IllegalArgumentException ) { return STRING + java.lang.IllegalArgumentException . java.lang.String ( ) ; }  <METHOD_END>
<METHOD_START> @ MessageMapping ( STRING ) public int int ( int int ) { return int + NUMBER ; }  <METHOD_END>
<METHOD_START> @ SubscribeMapping ( STRING ) public int int ( ) { return NUMBER ; }  <METHOD_END>
<METHOD_START> @ MessageMapping ( STRING ) @ SendToUser ( STRING ) @ Gateway ( requestChannel = STRING ) java.lang.String java.lang.String ( java.lang.String java.lang.String );  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.integration.websocket.client.MessageChannel org.springframework.integration.websocket.client.MessageChannel ( ) { return new DirectChannel ( ) ; }  <METHOD_END>
<METHOD_START> @ Bean @ Transformer ( inputChannel = STRING ) public org.springframework.integration.websocket.client.ExpressionEvaluatingTransformer org.springframework.integration.websocket.client.ExpressionEvaluatingTransformer ( ) { return new ExpressionEvaluatingTransformer ( org.springframework.integration.websocket.client.ExpressionParser . parseExpression ( STRING ) ) ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.integration.websocket.client.DefaultHandshakeHandler org.springframework.integration.websocket.client.DefaultHandshakeHandler ( ) { return new DefaultHandshakeHandler ( new TomcatRequestUpgradeStrategy ( ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( StompEndpointRegistry org.springframework.integration.websocket.client.StompEndpointRegistry ) { org.springframework.integration.websocket.client.StompEndpointRegistry . addEndpoint ( STRING ) . setHandshakeHandler ( org.springframework.integration.websocket.client.DefaultHandshakeHandler ( ) ) . withSockJS ( ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( MessageBrokerRegistry org.springframework.integration.websocket.client.MessageBrokerRegistry ) { org.springframework.integration.websocket.client.MessageBrokerRegistry . setApplicationDestinationPrefixes ( STRING ) ; org.springframework.integration.websocket.client.MessageBrokerRegistry . enableSimpleBroker ( STRING , STRING ) ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.integration.websocket.client.ApplicationListener<org.springframework.integration.websocket.client.SessionSubscribeEvent> < SessionSubscribeEvent > org.springframework.integration.websocket.client.ApplicationListener<org.springframework.integration.websocket.client.SessionSubscribeEvent> ( final AbstractSubscribableChannel org.springframework.integration.websocket.client.AbstractSubscribableChannel ) { return event -> { Message < byte [] > message = event . getMessage ( ) ; StompHeaderAccessor stompHeaderAccessor = StompHeaderAccessor . wrap ( message ) ; if ( stompHeaderAccessor . getReceipt ( ) != null ) { stompHeaderAccessor . setHeader ( STRING , StompCommand . RECEIPT ) ; stompHeaderAccessor . setReceiptId ( stompHeaderAccessor . getReceipt ( ) ) ; clientOutboundChannel . send ( MessageBuilder . createMessage ( new byte [ NUMBER ] , stompHeaderAccessor . getMessageHeaders ( ) ) ) ; } } ; }  <METHOD_END>
