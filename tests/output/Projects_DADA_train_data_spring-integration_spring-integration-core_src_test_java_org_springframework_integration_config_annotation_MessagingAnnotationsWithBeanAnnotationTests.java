<METHOD_START> @ Test public void void ( ) { this . org.springframework.integration.config.annotation.SourcePollingChannelAdapter . start ( ) ; for ( int int = NUMBER ; int < NUMBER ; int ++ ) { Message < ? > org.springframework.integration.config.annotation.Message<?> = this . org.springframework.integration.config.annotation.PollableChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.config.annotation.Message<> ) ; assertTrue ( ( ( java.lang.Integer ) org.springframework.integration.config.annotation.Message<> . getPayload ( ) ) % NUMBER == NUMBER ) ; org.springframework.integration.config.annotation.Message<?> = this . org.springframework.integration.config.annotation.PollableChannel . receive ( NUMBER ) ; assertNotNull ( org.springframework.integration.config.annotation.Message<> ) ; assertThat ( org.springframework.integration.config.annotation.Message<> , instanceOf ( ErrorMessage .class ) ) ; assertThat ( org.springframework.integration.config.annotation.Message<> . getPayload ( ) , instanceOf ( MessageRejectedException .class ) ) ; MessageRejectedException org.springframework.integration.config.annotation.MessageRejectedException = ( MessageRejectedException ) org.springframework.integration.config.annotation.Message<> . getPayload ( ) ; assertThat ( org.springframework.integration.config.annotation.MessageRejectedException . getMessage ( ) , containsString ( STRING + STRING + STRING ) ) ; } for ( Message < ? > org.springframework.integration.config.annotation.Message<?> : java.util.List<org.springframework.integration.config.annotation.Message<?>> ) { assertFalse ( ( ( java.lang.Integer ) org.springframework.integration.config.annotation.Message<> . getPayload ( ) ) % NUMBER == NUMBER ) ; MessageHistory org.springframework.integration.config.annotation.MessageHistory = MessageHistory . read ( org.springframework.integration.config.annotation.Message<> ) ; assertNotNull ( org.springframework.integration.config.annotation.MessageHistory ) ; java.lang.String java.lang.String = org.springframework.integration.config.annotation.MessageHistory . toString ( ) ; assertThat ( java.lang.String , Matchers . containsString ( STRING ) ) ; assertThat ( java.lang.String , Matchers . containsString ( STRING ) ) ; assertThat ( java.lang.String , Matchers . containsString ( STRING ) ) ; assertThat ( java.lang.String , Matchers . containsString ( STRING ) ) ; assertThat ( java.lang.String , Matchers . containsString ( STRING ) ) ; assertThat ( java.lang.String , Matchers . not ( Matchers . containsString ( STRING ) ) ) ; } assertNull ( this . org.springframework.integration.config.annotation.EventDrivenConsumer ) ; assertNull ( this . org.springframework.integration.config.annotation.MessageHandler ) ; assertNull ( this . org.springframework.integration.config.annotation.MessageChannel ) ; assertNull ( this . org.springframework.integration.config.annotation.MessageChannel ) ; assertNull ( this . org.springframework.integration.config.annotation.MessageSource<> ) ; }  <METHOD_END>
<METHOD_START> @ Test public void void ( ) { try { new AnnotationConfigApplicationContext ( org.springframework.integration.config.annotation.MessagingAnnotationsWithBeanAnnotationTests.InvalidContextConfiguration .class ) . close ( ) ; fail ( STRING ) ; } catch ( java.lang.Exception java.lang.Exception ) { assertThat ( java.lang.Exception , instanceOf ( BeanCreationException .class ) ) ; assertThat ( java.lang.Exception . java.lang.Throwable ( ) , instanceOf ( BeanDefinitionValidationException .class ) ) ; assertThat ( java.lang.Exception . java.lang.String ( ) , containsString ( STRING ) ) ; } }  <METHOD_END>
<METHOD_START> @ Bean public java.util.concurrent.atomic.AtomicInteger java.util.concurrent.atomic.AtomicInteger ( ) { return new java.util.concurrent.atomic.AtomicInteger ( ) ; }  <METHOD_END>
<METHOD_START> @ Bean @ InboundChannelAdapter ( value = STRING , autoStartup = STRING , poller = @ Poller ( fixedRate = STRING , maxMessagesPerPoll = STRING , errorChannel = STRING ) ) public org.springframework.integration.config.annotation.MessageSource<java.lang.Integer> < java.lang.Integer > org.springframework.integration.config.annotation.MessageSource<java.lang.Integer> ( final java.util.concurrent.atomic.AtomicInteger java.util.concurrent.atomic.AtomicInteger ) { return ( ) new GenericMessage <> ( counter . incrementAndGet ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.integration.config.annotation.PollableChannel org.springframework.integration.config.annotation.PollableChannel ( ) { return new QueueChannel ( ) ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.integration.config.annotation.MessageChannel org.springframework.integration.config.annotation.MessageChannel ( ) { return new DirectChannel ( ) ; }  <METHOD_END>
<METHOD_START> @ Bean @ Router ( inputChannel = STRING , channelMappings = { STRING , STRING } , suffix = STRING ) public org.springframework.integration.config.annotation.MessageSelector org.springframework.integration.config.annotation.MessageSelector ( ) { return new ExpressionEvaluatingSelector ( STRING ) ; }  <METHOD_END>
<METHOD_START> @ Bean @ Transformer ( inputChannel = STRING , outputChannel = STRING ) public org.springframework.integration.config.annotation.ExpressionEvaluatingTransformer org.springframework.integration.config.annotation.ExpressionEvaluatingTransformer ( ) { return new ExpressionEvaluatingTransformer ( org.springframework.integration.config.annotation.ExpressionParser . parseExpression ( STRING ) ) ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.integration.config.annotation.MessageChannel org.springframework.integration.config.annotation.MessageChannel ( ) { return new DirectChannel ( ) ; }  <METHOD_END>
<METHOD_START> @ Bean @ Filter ( inputChannel = STRING , outputChannel = STRING , discardChannel = STRING , throwExceptionOnRejection = STRING ) public org.springframework.integration.config.annotation.MessageSelector org.springframework.integration.config.annotation.MessageSelector ( ) { return new ExpressionEvaluatingSelector ( STRING ) ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.integration.config.annotation.MessageChannel org.springframework.integration.config.annotation.MessageChannel ( ) { return new DirectChannel ( ) ; }  <METHOD_END>
<METHOD_START> @ Bean @ ServiceActivator ( inputChannel = STRING ) public org.springframework.integration.config.annotation.MessageHandler org.springframework.integration.config.annotation.MessageHandler ( ) { AggregatingMessageHandler org.springframework.integration.config.annotation.AggregatingMessageHandler = new AggregatingMessageHandler ( new SimpleMessageGroupProcessor ( ) ) ; org.springframework.integration.config.annotation.AggregatingMessageHandler . setCorrelationStrategy ( new ExpressionEvaluatingCorrelationStrategy ( STRING ) ) ; org.springframework.integration.config.annotation.AggregatingMessageHandler . setReleaseStrategy ( new ExpressionEvaluatingReleaseStrategy ( STRING ) ) ; org.springframework.integration.config.annotation.AggregatingMessageHandler . setOutputChannelName ( STRING ) ; return org.springframework.integration.config.annotation.AggregatingMessageHandler ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.integration.config.annotation.MessageChannel org.springframework.integration.config.annotation.MessageChannel ( ) { return new DirectChannel ( ) ; }  <METHOD_END>
<METHOD_START> @ Bean @ Splitter ( inputChannel = STRING ) public org.springframework.integration.config.annotation.MessageHandler org.springframework.integration.config.annotation.MessageHandler ( ) { DefaultMessageSplitter org.springframework.integration.config.annotation.DefaultMessageSplitter = new DefaultMessageSplitter ( ) ; org.springframework.integration.config.annotation.DefaultMessageSplitter . setOutputChannelName ( STRING ) ; return org.springframework.integration.config.annotation.DefaultMessageSplitter ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.integration.config.annotation.PollableChannel org.springframework.integration.config.annotation.PollableChannel ( ) { return new QueueChannel ( ) ; }  <METHOD_END>
<METHOD_START> @ Bean public java.util.List<org.springframework.integration.config.annotation.Message<?>> < Message < ? > > java.util.List<org.springframework.integration.config.annotation.Message<?>> ( ) { return new java.util.ArrayList<org.springframework.integration.config.annotation.Message<?>> < Message < ? > > ( ) ; }  <METHOD_END>
<METHOD_START> @ Bean public org.springframework.integration.config.annotation.MessageChannel org.springframework.integration.config.annotation.MessageChannel ( ) { return new DirectChannel ( ) ; }  <METHOD_END>
<METHOD_START> @ Bean @ ServiceActivator ( inputChannel = STRING ) public org.springframework.integration.config.annotation.MessageHandler org.springframework.integration.config.annotation.MessageHandler ( ) { final java.util.List<org.springframework.integration.config.annotation.Message<?>> < Message < ? > > java.util.List<org.springframework.integration.config.annotation.Message<?>> = this . java.util.List<org.springframework.integration.config.annotation.Message<?>> ( ) ; return message -> collector . add ( message ) ; }  <METHOD_END>
<METHOD_START> @ Bean @ ServiceActivator ( inputChannel = STRING ) @ Splitter ( inputChannel = STRING ) @ Router ( inputChannel = STRING ) @ Transformer ( inputChannel = STRING ) @ Filter ( inputChannel = STRING ) @ Profile ( STRING ) public org.springframework.integration.config.annotation.MessageHandler org.springframework.integration.config.annotation.MessageHandler ( ) { return m -> {			} ; }  <METHOD_END>
<METHOD_START> @ Bean @ BridgeFrom ( STRING ) @ Profile ( STRING ) public org.springframework.integration.config.annotation.MessageChannel org.springframework.integration.config.annotation.MessageChannel ( ) { return new DirectChannel ( ) ; }  <METHOD_END>
<METHOD_START> @ Bean @ BridgeTo @ Profile ( STRING ) public org.springframework.integration.config.annotation.MessageChannel org.springframework.integration.config.annotation.MessageChannel ( ) { return new DirectChannel ( ) ; }  <METHOD_END>
<METHOD_START> @ Bean @ InboundChannelAdapter ( STRING ) @ Profile ( STRING ) public org.springframework.integration.config.annotation.MessageSource<?> < ? > org.springframework.integration.config.annotation.MessageSource<?> ( ) { return ( ) new GenericMessage <> ( STRING ) ; }  <METHOD_END>
<METHOD_START> @ Bean @ Splitter ( inputChannel = STRING , applySequence = STRING ) public org.springframework.integration.config.annotation.MessageHandler org.springframework.integration.config.annotation.MessageHandler ( ) { return new DefaultMessageSplitter ( ) ; }  <METHOD_END>
