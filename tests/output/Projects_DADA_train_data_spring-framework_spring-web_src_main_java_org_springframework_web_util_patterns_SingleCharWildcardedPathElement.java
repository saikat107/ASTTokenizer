<METHOD_START> public void ( int int , char [] char[] , int int , boolean boolean , char char ) { super( int , char ); this . int = char[] . int ; this . int = int ; this . boolean = boolean ; if ( boolean ) { this . char[] = char[] ; } else { this . char[] = new char [ char[] . int ] ; for ( int int = NUMBER ; int < int ; int ++ ) { this . char[] [ int ] = java.lang.Character . char ( char[] [ int ] ) ; } } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public boolean boolean ( int int , MatchingContext org.springframework.web.util.patterns.MatchingContext ) { if ( matchingContext . candidateLength < ( int + int ) ) { return false ; } char [] char[] = matchingContext . candidate ; if ( boolean ) { for ( int int = NUMBER ; int < int ; int ++ ) { char char = char[] [ int ] ; if ( char != '?' && char[] [ int ] != char ) { return false ; } int ++ ; } } else { for ( int int = NUMBER ; int < int ; int ++ ) { char char = char[] [ int ] ; if ( char != '?' && java.lang.Character . char ( char[] [ int ] ) != char ) { return false ; } int ++ ; } } if ( next == null ) { if ( matchingContext . determineRemaining && nextIfExistsIsSeparator ( int , org.springframework.web.util.patterns.MatchingContext ) ) { matchingContext . remainingPathIndex = int ; return true ; } else { return int == matchingContext . candidateLength ; } } else { if ( matchingContext . isMatchStartMatching && int == matchingContext . candidateLength ) { return true ; } return next . matches ( int , org.springframework.web.util.patterns.MatchingContext ) ; } }  <METHOD_END>
<METHOD_START> @ java.lang.Override public int int ( ) { return int ; }  <METHOD_END>
<METHOD_START> public java.lang.String java.lang.String ( ) { return STRING + new java.lang.String ( char[] ) + STRING ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public int int ( ) { return int ; }  <METHOD_END>
