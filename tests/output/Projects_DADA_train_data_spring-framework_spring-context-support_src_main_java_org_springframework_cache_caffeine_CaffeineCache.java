<METHOD_START> public CaffeineCache ( java.lang.String java.lang.String , com . com.github . com.github . com.github . com.github . com.github < java.lang.Object , java.lang.Object > cache ) { this( java.lang.String , cache , true ); }  <METHOD_END>
<METHOD_START> public CaffeineCache ( java.lang.String java.lang.String , com . com.github . com.github . com.github . com.github . com.github < java.lang.Object , java.lang.Object > cache , boolean boolean ) { super( boolean ); Assert . notNull ( java.lang.String , STRING ) ; Assert . notNull ( cache , STRING ) ; this . java.lang.String = java.lang.String ; this . cache = cache ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public final java.lang.String java.lang.String ( ) { return this . java.lang.String ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public final com . com.github . com.github . com.github . com.github . com.github < java.lang.Object , java.lang.Object > getNativeCache ( ) { return this . cache ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.cache.caffeine.ValueWrapper org.springframework.cache.caffeine.ValueWrapper ( java.lang.Object java.lang.Object ) { if ( this . cache instanceof LoadingCache ) { java.lang.Object java.lang.Object = ( ( LoadingCache < java.lang.Object , java.lang.Object > ) this . cache ) . get ( java.lang.Object ) ; return toValueWrapper ( java.lang.Object ) ; } return super. get ( java.lang.Object ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.SuppressWarnings ( STRING ) @ java.lang.Override public < T > T T ( java.lang.Object java.lang.Object , final java.util.concurrent.Callable<T> < T > java.util.concurrent.Callable<T> ) { return ( T ) fromStoreValue ( this . cache . get ( java.lang.Object , new org.springframework.cache.caffeine.CaffeineCache.LoadFunction ( java.util.concurrent.Callable<T> ) ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override protected java.lang.Object java.lang.Object ( java.lang.Object java.lang.Object ) { return this . cache . getIfPresent ( java.lang.Object ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( java.lang.Object java.lang.Object , java.lang.Object java.lang.Object ) { this . cache . put ( java.lang.Object , toStoreValue ( java.lang.Object ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public org.springframework.cache.caffeine.ValueWrapper org.springframework.cache.caffeine.ValueWrapper ( java.lang.Object java.lang.Object , final java.lang.Object java.lang.Object ) { org.springframework.cache.caffeine.CaffeineCache.PutIfAbsentFunction org.springframework.cache.caffeine.CaffeineCache.PutIfAbsentFunction = new org.springframework.cache.caffeine.CaffeineCache.PutIfAbsentFunction ( java.lang.Object ) ; java.lang.Object java.lang.Object = this . cache . get ( java.lang.Object , org.springframework.cache.caffeine.CaffeineCache.PutIfAbsentFunction ) ; return ( org.springframework.cache.caffeine.CaffeineCache.PutIfAbsentFunction . boolean ? null : toValueWrapper ( java.lang.Object ) ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( java.lang.Object java.lang.Object ) { this . cache . invalidate ( java.lang.Object ) ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public void void ( ) { this . cache . invalidateAll ( ) ; }  <METHOD_END>
<METHOD_START> public void ( java.lang.Object java.lang.Object ) { this . java.lang.Object = java.lang.Object ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.Object java.lang.Object ( java.lang.Object java.lang.Object ) { this . boolean = true ; return toStoreValue ( this . java.lang.Object ) ; }  <METHOD_END>
<METHOD_START> public void ( java.util.concurrent.Callable<?> < ? > java.util.concurrent.Callable<?> ) { this . java.util.concurrent.Callable<?> = java.util.concurrent.Callable<> ; }  <METHOD_END>
<METHOD_START> @ java.lang.Override public java.lang.Object java.lang.Object ( java.lang.Object java.lang.Object ) { try { return toStoreValue ( java.util.concurrent.Callable<> . call ( ) ) ; } catch ( java.lang.Exception java.lang.Exception ) { throw new ValueRetrievalException ( java.lang.Object , java.util.concurrent.Callable<> , java.lang.Exception ) ; } }  <METHOD_END>
