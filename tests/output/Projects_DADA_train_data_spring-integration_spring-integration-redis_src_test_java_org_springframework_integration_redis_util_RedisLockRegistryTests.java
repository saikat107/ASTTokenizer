<METHOD_START> @ Before @ After public void void ( ) { RedisTemplate < java.lang.String , ? > org.springframework.integration.redis.util.RedisTemplate<java.lang.String,?> = this . org.springframework.integration.redis.util.RedisTemplate<java.lang.String,?> ( ) ; org.springframework.integration.redis.util.RedisTemplate<java.lang.String,> . delete ( this . java.lang.String + STRING ) ; org.springframework.integration.redis.util.RedisTemplate<java.lang.String,> . delete ( this . java.lang.String + STRING ) ; }  <METHOD_END>
<METHOD_START> private org.springframework.integration.redis.util.RedisTemplate<java.lang.String,?> < java.lang.String , ? > org.springframework.integration.redis.util.RedisTemplate<java.lang.String,?> ( ) { RedisTemplate < java.lang.String , ? > org.springframework.integration.redis.util.RedisTemplate<java.lang.String,?> = new RedisTemplate <> ( ) ; org.springframework.integration.redis.util.RedisTemplate<java.lang.String,> . setConnectionFactory ( this . getConnectionFactoryForTest ( ) ) ; org.springframework.integration.redis.util.RedisTemplate<java.lang.String,> . setKeySerializer ( new StringRedisSerializer ( ) ) ; org.springframework.integration.redis.util.RedisTemplate<java.lang.String,> . afterPropertiesSet ( ) ; return org.springframework.integration.redis.util.RedisTemplate<java.lang.String,> ; }  <METHOD_END>
<METHOD_START> @ Test @ RedisAvailable public void void ( ) java.lang.Exception { RedisLockRegistry org.springframework.integration.redis.util.RedisLockRegistry = new RedisLockRegistry ( this . getConnectionFactoryForTest ( ) , this . java.lang.String ) ; for ( int int = NUMBER ; int < NUMBER ; int ++ ) { java.util.concurrent.locks.Lock java.util.concurrent.locks.Lock = org.springframework.integration.redis.util.RedisLockRegistry . obtain ( STRING ) ; java.util.concurrent.locks.Lock . void ( ) ; try { assertNotNull ( TestUtils . getPropertyValue ( org.springframework.integration.redis.util.RedisLockRegistry , STRING , java.lang.ThreadLocal .class ) . get ( ) ) ; } finally { java.util.concurrent.locks.Lock . void ( ) ; } } assertNull ( TestUtils . getPropertyValue ( org.springframework.integration.redis.util.RedisLockRegistry , STRING , java.lang.ThreadLocal .class ) . get ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test @ RedisAvailable public void void ( ) java.lang.Exception { RedisLockRegistry org.springframework.integration.redis.util.RedisLockRegistry = new RedisLockRegistry ( this . getConnectionFactoryForTest ( ) , this . java.lang.String ) ; for ( int int = NUMBER ; int < NUMBER ; int ++ ) { java.util.concurrent.locks.Lock java.util.concurrent.locks.Lock = org.springframework.integration.redis.util.RedisLockRegistry . obtain ( STRING ) ; java.util.concurrent.locks.Lock . void ( ) ; try { assertNotNull ( TestUtils . getPropertyValue ( org.springframework.integration.redis.util.RedisLockRegistry , STRING , java.lang.ThreadLocal .class ) . get ( ) ) ; } finally { java.util.concurrent.locks.Lock . void ( ) ; } } assertNull ( TestUtils . getPropertyValue ( org.springframework.integration.redis.util.RedisLockRegistry , STRING , java.lang.ThreadLocal .class ) . get ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test @ RedisAvailable public void void ( ) java.lang.Exception { RedisLockRegistry org.springframework.integration.redis.util.RedisLockRegistry = new RedisLockRegistry ( this . getConnectionFactoryForTest ( ) , this . java.lang.String ) ; for ( int int = NUMBER ; int < NUMBER ; int ++ ) { java.util.concurrent.locks.Lock java.util.concurrent.locks.Lock = org.springframework.integration.redis.util.RedisLockRegistry . obtain ( STRING ) ; java.util.concurrent.locks.Lock . void ( ) ; try { java.util.concurrent.locks.Lock java.util.concurrent.locks.Lock = org.springframework.integration.redis.util.RedisLockRegistry . obtain ( STRING ) ; assertSame ( java.util.concurrent.locks.Lock , java.util.concurrent.locks.Lock ) ; java.util.concurrent.locks.Lock . void ( ) ; try { } finally { java.util.concurrent.locks.Lock . void ( ) ; } } finally { java.util.concurrent.locks.Lock . void ( ) ; } } assertNull ( TestUtils . getPropertyValue ( org.springframework.integration.redis.util.RedisLockRegistry , STRING , java.lang.ThreadLocal .class ) . get ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test @ RedisAvailable public void void ( ) java.lang.Exception { RedisLockRegistry org.springframework.integration.redis.util.RedisLockRegistry = new RedisLockRegistry ( this . getConnectionFactoryForTest ( ) , this . java.lang.String ) ; for ( int int = NUMBER ; int < NUMBER ; int ++ ) { java.util.concurrent.locks.Lock java.util.concurrent.locks.Lock = org.springframework.integration.redis.util.RedisLockRegistry . obtain ( STRING ) ; java.util.concurrent.locks.Lock . void ( ) ; try { java.util.concurrent.locks.Lock java.util.concurrent.locks.Lock = org.springframework.integration.redis.util.RedisLockRegistry . obtain ( STRING ) ; assertSame ( java.util.concurrent.locks.Lock , java.util.concurrent.locks.Lock ) ; java.util.concurrent.locks.Lock . void ( ) ; try { } finally { java.util.concurrent.locks.Lock . void ( ) ; } } finally { java.util.concurrent.locks.Lock . void ( ) ; } } assertNull ( TestUtils . getPropertyValue ( org.springframework.integration.redis.util.RedisLockRegistry , STRING , java.lang.ThreadLocal .class ) . get ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test @ RedisAvailable public void void ( ) java.lang.Exception { RedisLockRegistry org.springframework.integration.redis.util.RedisLockRegistry = new RedisLockRegistry ( this . getConnectionFactoryForTest ( ) , this . java.lang.String ) ; for ( int int = NUMBER ; int < NUMBER ; int ++ ) { java.util.concurrent.locks.Lock java.util.concurrent.locks.Lock = org.springframework.integration.redis.util.RedisLockRegistry . obtain ( STRING ) ; java.util.concurrent.locks.Lock . void ( ) ; try { java.util.concurrent.locks.Lock java.util.concurrent.locks.Lock = org.springframework.integration.redis.util.RedisLockRegistry . obtain ( STRING ) ; assertNotSame ( java.util.concurrent.locks.Lock , java.util.concurrent.locks.Lock ) ; java.util.concurrent.locks.Lock . void ( ) ; try { } finally { java.util.concurrent.locks.Lock . void ( ) ; } } finally { java.util.concurrent.locks.Lock . void ( ) ; } } assertNull ( TestUtils . getPropertyValue ( org.springframework.integration.redis.util.RedisLockRegistry , STRING , java.lang.ThreadLocal .class ) . get ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test @ RedisAvailable public void void ( ) java.lang.Exception { final RedisLockRegistry org.springframework.integration.redis.util.RedisLockRegistry = new RedisLockRegistry ( this . getConnectionFactoryForTest ( ) , this . java.lang.String ) ; final java.util.concurrent.locks.Lock java.util.concurrent.locks.Lock = org.springframework.integration.redis.util.RedisLockRegistry . obtain ( STRING ) ; java.util.concurrent.locks.Lock . void ( ) ; final java.util.concurrent.atomic.AtomicBoolean java.util.concurrent.atomic.AtomicBoolean = new java.util.concurrent.atomic.AtomicBoolean ( ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; java.util.concurrent.Future<java.lang.Object> < java.lang.Object > java.util.concurrent.Future<java.lang.Object> = java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . java.util.concurrent.Future<java.lang.Object> ( ( ) { java.util.concurrent.locks.Lock java.util.concurrent.locks.Lock = org.springframework.integration.redis.util.RedisLockRegistry . obtain ( STRING ) ; java.util.concurrent.atomic.AtomicBoolean . void ( java.util.concurrent.locks.Lock . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; java.util.concurrent.CountDownLatch . void ( ) ; try { java.util.concurrent.locks.Lock . void ( ) ; } catch ( java.lang.IllegalStateException java.lang.IllegalStateException ) { return java.lang.IllegalStateException ; } return null ; } ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; assertFalse ( java.util.concurrent.atomic.AtomicBoolean . boolean ( ) ) ; java.util.concurrent.locks.Lock . void ( ) ; java.lang.Object java.lang.Object = java.util.concurrent.Future<java.lang.Object> . java.lang.Object ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ; assertThat ( java.lang.Object , instanceOf ( java.lang.IllegalStateException .class ) ) ; assertThat ( ( ( java.lang.Exception ) java.lang.Object ) . java.lang.String ( ) , containsString ( STRING ) ) ; assertNull ( TestUtils . getPropertyValue ( org.springframework.integration.redis.util.RedisLockRegistry , STRING , java.lang.ThreadLocal .class ) . get ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test @ RedisAvailable public void void ( ) java.lang.Exception { final RedisLockRegistry org.springframework.integration.redis.util.RedisLockRegistry = new RedisLockRegistry ( this . getConnectionFactoryForTest ( ) , this . java.lang.String ) ; final java.util.concurrent.locks.Lock java.util.concurrent.locks.Lock = org.springframework.integration.redis.util.RedisLockRegistry . obtain ( STRING ) ; final java.util.concurrent.atomic.AtomicBoolean java.util.concurrent.atomic.AtomicBoolean = new java.util.concurrent.atomic.AtomicBoolean ( ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; java.util.concurrent.locks.Lock . void ( ) ; assertNotNull ( TestUtils . getPropertyValue ( org.springframework.integration.redis.util.RedisLockRegistry , STRING , java.lang.ThreadLocal .class ) . get ( ) ) ; java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . void ( ( ) { java.util.concurrent.locks.Lock java.util.concurrent.locks.Lock = org.springframework.integration.redis.util.RedisLockRegistry . obtain ( STRING ) ; try { java.util.concurrent.CountDownLatch . void ( ) ; java.util.concurrent.locks.Lock . void ( ) ; assertNotNull ( TestUtils . getPropertyValue ( org.springframework.integration.redis.util.RedisLockRegistry , STRING , java.lang.ThreadLocal .class ) . get ( ) ) ; java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ; java.util.concurrent.atomic.AtomicBoolean . void ( true ) ; } catch ( java.lang.InterruptedException java.lang.InterruptedException ) { java.lang.Thread . java.lang.Thread ( ) . void ( ) ; } finally { java.util.concurrent.locks.Lock . void ( ) ; java.util.concurrent.CountDownLatch . void ( ) ; } } ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; assertFalse ( java.util.concurrent.atomic.AtomicBoolean . boolean ( ) ) ; java.util.concurrent.locks.Lock . void ( ) ; java.util.concurrent.CountDownLatch . void ( ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; assertTrue ( java.util.concurrent.atomic.AtomicBoolean . boolean ( ) ) ; assertNull ( TestUtils . getPropertyValue ( org.springframework.integration.redis.util.RedisLockRegistry , STRING , java.lang.ThreadLocal .class ) . get ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test @ RedisAvailable public void void ( ) java.lang.Exception { final RedisLockRegistry org.springframework.integration.redis.util.RedisLockRegistry = new RedisLockRegistry ( this . getConnectionFactoryForTest ( ) , this . java.lang.String ) ; final RedisLockRegistry org.springframework.integration.redis.util.RedisLockRegistry = new RedisLockRegistry ( this . getConnectionFactoryForTest ( ) , this . java.lang.String ) ; final java.util.concurrent.locks.Lock java.util.concurrent.locks.Lock = org.springframework.integration.redis.util.RedisLockRegistry . obtain ( STRING ) ; final java.util.concurrent.atomic.AtomicBoolean java.util.concurrent.atomic.AtomicBoolean = new java.util.concurrent.atomic.AtomicBoolean ( ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; java.util.concurrent.locks.Lock . void ( ) ; assertNotNull ( TestUtils . getPropertyValue ( org.springframework.integration.redis.util.RedisLockRegistry , STRING , java.lang.ThreadLocal .class ) . get ( ) ) ; java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . void ( ( ) { java.util.concurrent.locks.Lock java.util.concurrent.locks.Lock = org.springframework.integration.redis.util.RedisLockRegistry . obtain ( STRING ) ; try { java.util.concurrent.CountDownLatch . void ( ) ; java.util.concurrent.locks.Lock . void ( ) ; assertNotNull ( TestUtils . getPropertyValue ( org.springframework.integration.redis.util.RedisLockRegistry , STRING , java.lang.ThreadLocal .class ) . get ( ) ) ; java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ; java.util.concurrent.atomic.AtomicBoolean . void ( true ) ; } catch ( java.lang.InterruptedException java.lang.InterruptedException ) { java.lang.Thread . java.lang.Thread ( ) . void ( ) ; org.springframework.integration.redis.util.Log . error ( STRING + java.util.concurrent.locks.Lock , java.lang.InterruptedException ) ; } finally { try { java.util.concurrent.locks.Lock . void ( ) ; java.util.concurrent.CountDownLatch . void ( ) ; } catch ( java.lang.IllegalStateException java.lang.IllegalStateException ) { org.springframework.integration.redis.util.Log . error ( STRING + java.util.concurrent.locks.Lock , java.lang.IllegalStateException ) ; } } } ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; assertFalse ( java.util.concurrent.atomic.AtomicBoolean . boolean ( ) ) ; java.util.concurrent.locks.Lock . void ( ) ; java.util.concurrent.CountDownLatch . void ( ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; assertTrue ( java.util.concurrent.atomic.AtomicBoolean . boolean ( ) ) ; assertNull ( TestUtils . getPropertyValue ( org.springframework.integration.redis.util.RedisLockRegistry , STRING , java.lang.ThreadLocal .class ) . get ( ) ) ; assertNull ( TestUtils . getPropertyValue ( org.springframework.integration.redis.util.RedisLockRegistry , STRING , java.lang.ThreadLocal .class ) . get ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test @ RedisAvailable public void void ( ) java.lang.Exception { final RedisLockRegistry org.springframework.integration.redis.util.RedisLockRegistry = new RedisLockRegistry ( this . getConnectionFactoryForTest ( ) , this . java.lang.String ) ; final java.util.concurrent.locks.Lock java.util.concurrent.locks.Lock = org.springframework.integration.redis.util.RedisLockRegistry . obtain ( STRING ) ; java.util.concurrent.locks.Lock . void ( ) ; final java.util.concurrent.atomic.AtomicBoolean java.util.concurrent.atomic.AtomicBoolean = new java.util.concurrent.atomic.AtomicBoolean ( ) ; final java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch = new java.util.concurrent.CountDownLatch ( NUMBER ) ; java.util.concurrent.Future<java.lang.Object> < java.lang.Object > java.util.concurrent.Future<java.lang.Object> = java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . java.util.concurrent.Future<java.lang.Object> ( ( ) { try { java.util.concurrent.locks.Lock . void ( ) ; } catch ( java.lang.IllegalStateException java.lang.IllegalStateException ) { java.util.concurrent.CountDownLatch . void ( ) ; return java.lang.IllegalStateException ; } return null ; } ) ; assertTrue ( java.util.concurrent.CountDownLatch . boolean ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ) ; assertFalse ( java.util.concurrent.atomic.AtomicBoolean . boolean ( ) ) ; java.util.concurrent.locks.Lock . void ( ) ; java.lang.Object java.lang.Object = java.util.concurrent.Future<java.lang.Object> . java.lang.Object ( NUMBER , java.util.concurrent.TimeUnit . java.util.concurrent.TimeUnit ) ; assertThat ( java.lang.Object , instanceOf ( java.lang.IllegalStateException .class ) ) ; assertThat ( ( ( java.lang.Exception ) java.lang.Object ) . java.lang.String ( ) , containsString ( STRING ) ) ; assertNull ( TestUtils . getPropertyValue ( org.springframework.integration.redis.util.RedisLockRegistry , STRING , java.lang.ThreadLocal .class ) . get ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test @ RedisAvailable public void void ( ) java.lang.Exception { RedisLockRegistry org.springframework.integration.redis.util.RedisLockRegistry = new RedisLockRegistry ( this . getConnectionFactoryForTest ( ) , this . java.lang.String ) ; java.util.concurrent.locks.Lock java.util.concurrent.locks.Lock = org.springframework.integration.redis.util.RedisLockRegistry . obtain ( STRING ) ; java.util.concurrent.locks.Lock . void ( ) ; java.util.concurrent.locks.Lock java.util.concurrent.locks.Lock = org.springframework.integration.redis.util.RedisLockRegistry . obtain ( STRING ) ; java.util.concurrent.locks.Lock . void ( ) ; java.util.concurrent.locks.Lock java.util.concurrent.locks.Lock = org.springframework.integration.redis.util.RedisLockRegistry . obtain ( STRING ) ; java.util.concurrent.locks.Lock . void ( ) ; java.util.Collection<java.util.concurrent.locks.Lock> < java.util.concurrent.locks.Lock > java.util.Collection<java.util.concurrent.locks.Lock> = org.springframework.integration.redis.util.RedisLockRegistry . listLocks ( ) ; assertEquals ( NUMBER , java.util.Collection<java.util.concurrent.locks.Lock> . int ( ) ) ; java.util.concurrent.locks.Lock . void ( ) ; java.util.concurrent.locks.Lock . void ( ) ; java.util.concurrent.locks.Lock . void ( ) ; assertNull ( TestUtils . getPropertyValue ( org.springframework.integration.redis.util.RedisLockRegistry , STRING , java.lang.ThreadLocal .class ) . get ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test @ RedisAvailable public void void ( ) java.lang.Exception { RedisLockRegistry org.springframework.integration.redis.util.RedisLockRegistry = new RedisLockRegistry ( this . getConnectionFactoryForTest ( ) , this . java.lang.String , NUMBER ) ; java.util.concurrent.locks.Lock java.util.concurrent.locks.Lock = org.springframework.integration.redis.util.RedisLockRegistry . obtain ( STRING ) ; java.util.concurrent.locks.Lock . void ( ) ; void ( STRING ) ; try { java.util.concurrent.locks.Lock . void ( ) ; fail ( STRING ) ; } catch ( java.lang.IllegalStateException java.lang.IllegalStateException ) { assertThat ( java.lang.IllegalStateException . java.lang.String ( ) , containsString ( STRING ) ) ; } assertNull ( TestUtils . getPropertyValue ( org.springframework.integration.redis.util.RedisLockRegistry , STRING , java.lang.ThreadLocal .class ) . get ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test @ RedisAvailable public void void ( ) java.lang.Exception { RedisLockRegistry org.springframework.integration.redis.util.RedisLockRegistry = new RedisLockRegistry ( this . getConnectionFactoryForTest ( ) , this . java.lang.String , NUMBER ) ; org.springframework.integration.redis.util.RedisLockRegistry . setUseWeakReferences ( true ) ; java.util.concurrent.locks.Lock java.util.concurrent.locks.Lock = org.springframework.integration.redis.util.RedisLockRegistry . obtain ( STRING ) ; java.util.concurrent.locks.Lock . void ( ) ; void ( STRING ) ; java.util.concurrent.locks.Lock java.util.concurrent.locks.Lock = org.springframework.integration.redis.util.RedisLockRegistry . obtain ( STRING ) ; assertNotSame ( java.util.concurrent.locks.Lock , java.util.concurrent.locks.Lock ) ; try { java.util.concurrent.locks.Lock . void ( ) ; fail ( STRING ) ; } catch ( java.lang.IllegalStateException java.lang.IllegalStateException ) { assertThat ( java.lang.IllegalStateException . java.lang.String ( ) , containsString ( STRING ) ) ; } }  <METHOD_END>
<METHOD_START> @ Test @ RedisAvailable public void void ( ) java.lang.Exception { RedisLockRegistry org.springframework.integration.redis.util.RedisLockRegistry = new RedisLockRegistry ( this . getConnectionFactoryForTest ( ) , this . java.lang.String , NUMBER ) ; java.util.concurrent.locks.Lock java.util.concurrent.locks.Lock = org.springframework.integration.redis.util.RedisLockRegistry . obtain ( STRING ) ; java.util.concurrent.locks.Lock . void ( ) ; void ( STRING ) ; java.util.concurrent.locks.Lock java.util.concurrent.locks.Lock = org.springframework.integration.redis.util.RedisLockRegistry . obtain ( STRING ) ; assertNotSame ( java.util.concurrent.locks.Lock , java.util.concurrent.locks.Lock ) ; java.util.concurrent.locks.Lock . void ( ) ; try { java.util.concurrent.locks.Lock . void ( ) ; fail ( STRING ) ; } catch ( java.lang.IllegalStateException java.lang.IllegalStateException ) { assertThat ( java.lang.IllegalStateException . java.lang.String ( ) , containsString ( STRING ) ) ; } java.util.concurrent.locks.Lock . void ( ) ; assertNull ( TestUtils . getPropertyValue ( org.springframework.integration.redis.util.RedisLockRegistry , STRING , java.lang.ThreadLocal .class ) . get ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test @ RedisAvailable public void void ( ) java.lang.Exception { RedisConnectionFactory org.springframework.integration.redis.util.RedisConnectionFactory = this . getConnectionFactoryForTest ( ) ; RedisLockRegistry org.springframework.integration.redis.util.RedisLockRegistry = new RedisLockRegistry ( org.springframework.integration.redis.util.RedisConnectionFactory , this . java.lang.String ) ; org.springframework.integration.redis.util.RedisLockRegistry . setUseWeakReferences ( true ) ; RedisLockRegistry org.springframework.integration.redis.util.RedisLockRegistry = new RedisLockRegistry ( org.springframework.integration.redis.util.RedisConnectionFactory , this . java.lang.String ) ; RedisLockRegistry org.springframework.integration.redis.util.RedisLockRegistry = new RedisLockRegistry ( org.springframework.integration.redis.util.RedisConnectionFactory , this . java.lang.String ) ; java.util.concurrent.locks.Lock java.util.concurrent.locks.Lock = org.springframework.integration.redis.util.RedisLockRegistry . obtain ( STRING ) ; java.util.concurrent.locks.Lock java.util.concurrent.locks.Lock = org.springframework.integration.redis.util.RedisLockRegistry . obtain ( STRING ) ; assertEquals ( java.util.concurrent.locks.Lock , java.util.concurrent.locks.Lock ) ; java.util.concurrent.locks.Lock . void ( ) ; java.util.concurrent.locks.Lock . void ( ) ; assertEquals ( java.util.concurrent.locks.Lock , java.util.concurrent.locks.Lock ) ; java.util.concurrent.locks.Lock . void ( ) ; java.util.concurrent.locks.Lock . void ( ) ; assertEquals ( java.util.concurrent.locks.Lock , java.util.concurrent.locks.Lock ) ; java.util.concurrent.locks.Lock = org.springframework.integration.redis.util.RedisLockRegistry . obtain ( STRING ) ; java.util.concurrent.locks.Lock = org.springframework.integration.redis.util.RedisLockRegistry . obtain ( STRING ) ; assertNotEquals ( java.util.concurrent.locks.Lock , java.util.concurrent.locks.Lock ) ; java.util.concurrent.locks.Lock . void ( ) ; assertFalse ( java.util.concurrent.locks.Lock . boolean ( ) ) ; java.util.concurrent.locks.Lock . void ( ) ; java.util.concurrent.locks.Lock = org.springframework.integration.redis.util.RedisLockRegistry . obtain ( STRING ) ; java.util.concurrent.locks.Lock = org.springframework.integration.redis.util.RedisLockRegistry . obtain ( STRING ) ; assertNotEquals ( java.util.concurrent.locks.Lock , java.util.concurrent.locks.Lock ) ; java.util.concurrent.locks.Lock . void ( ) ; java.util.concurrent.locks.Lock . void ( ) ; java.util.concurrent.locks.Lock . void ( ) ; java.util.concurrent.locks.Lock . void ( ) ; }  <METHOD_END>
<METHOD_START> @ Test @ RedisAvailable public void void ( ) { RedisLockRegistry org.springframework.integration.redis.util.RedisLockRegistry = new RedisLockRegistry ( this . getConnectionFactoryForTest ( ) , this . java.lang.String , NUMBER ) ; org.springframework.integration.redis.util.RedisLockRegistry . setUseWeakReferences ( true ) ; for ( int int = NUMBER ; int < NUMBER ; int ++ ) { org.springframework.integration.redis.util.RedisLockRegistry . obtain ( STRING + int ) ; } assertNull ( TestUtils . getPropertyValue ( org.springframework.integration.redis.util.RedisLockRegistry , STRING , java.lang.ThreadLocal .class ) . get ( ) ) ; for ( int int = NUMBER ; int < NUMBER ; int ++ ) { java.util.concurrent.locks.Lock java.util.concurrent.locks.Lock = org.springframework.integration.redis.util.RedisLockRegistry . obtain ( STRING + int ) ; java.util.concurrent.locks.Lock . void ( ) ; } assertEquals ( NUMBER , ( ( java.util.Collection<?> < ? > ) TestUtils . getPropertyValue ( org.springframework.integration.redis.util.RedisLockRegistry , STRING , java.lang.ThreadLocal .class ) . get ( ) ) . int ( ) ) ; assertNull ( TestUtils . getPropertyValue ( org.springframework.integration.redis.util.RedisLockRegistry , STRING , java.lang.ThreadLocal .class ) . get ( ) ) ; for ( int int = NUMBER ; int < NUMBER ; int ++ ) { java.util.concurrent.locks.Lock java.util.concurrent.locks.Lock = org.springframework.integration.redis.util.RedisLockRegistry . obtain ( STRING + int ) ; assertNotNull ( TestUtils . getPropertyValue ( java.util.concurrent.locks.Lock , STRING , java.lang.Thread .class ) ) ; java.util.concurrent.locks.Lock . void ( ) ; } assertNull ( TestUtils . getPropertyValue ( org.springframework.integration.redis.util.RedisLockRegistry , STRING , java.lang.ThreadLocal .class ) . get ( ) ) ; }  <METHOD_END>
<METHOD_START> @ Test @ RedisAvailable public void void ( ) java.lang.Exception { RedisConnectionFactory org.springframework.integration.redis.util.RedisConnectionFactory = this . getConnectionFactoryForTest ( ) ; final RedisLockRegistry org.springframework.integration.redis.util.RedisLockRegistry = new RedisLockRegistry ( org.springframework.integration.redis.util.RedisConnectionFactory , this . java.lang.String , NUMBER ) ; java.util.concurrent.locks.Lock java.util.concurrent.locks.Lock = org.springframework.integration.redis.util.RedisLockRegistry . obtain ( STRING ) ; java.util.concurrent.locks.Lock . void ( ) ; java.lang.Long java.lang.Long = java.lang.Long ( org.springframework.integration.redis.util.RedisLockRegistry , STRING ) ; java.util.concurrent.Future<java.lang.Object> < java.lang.Object > java.util.concurrent.Future<java.lang.Object> = java.util.concurrent.Executors . java.util.concurrent.ExecutorService ( ) . java.util.concurrent.Future<java.lang.Object> ( ( ) { java.util.concurrent.locks.Lock java.util.concurrent.locks.Lock = org.springframework.integration.redis.util.RedisLockRegistry . obtain ( STRING ) ; assertFalse ( java.util.concurrent.locks.Lock . boolean ( ) ) ; return null ; } ) ; java.util.concurrent.Future<java.lang.Object> . java.lang.Object ( ) ; assertEquals ( java.lang.Long , java.lang.Long ( org.springframework.integration.redis.util.RedisLockRegistry , STRING ) ) ; java.util.concurrent.locks.Lock . void ( ) ; }  <METHOD_END>
<METHOD_START> private java.lang.Long java.lang.Long ( RedisLockRegistry org.springframework.integration.redis.util.RedisLockRegistry , java.lang.String java.lang.String ) { RedisTemplate < java.lang.String , ? > org.springframework.integration.redis.util.RedisTemplate<java.lang.String,?> = this . org.springframework.integration.redis.util.RedisTemplate<java.lang.String,?> ( ) ; java.lang.String java.lang.String = TestUtils . getPropertyValue ( org.springframework.integration.redis.util.RedisLockRegistry , STRING , java.lang.String .class ) ; return org.springframework.integration.redis.util.RedisTemplate<java.lang.String,> . getExpire ( java.lang.String + STRING + java.lang.String ) ; }  <METHOD_END>
<METHOD_START> private void void ( java.lang.String java.lang.String ) throws java.lang.Exception { RedisTemplate < java.lang.String , ? > org.springframework.integration.redis.util.RedisTemplate<java.lang.String,?> = this . org.springframework.integration.redis.util.RedisTemplate<java.lang.String,?> ( ) ; int int = NUMBER ; while ( int ++ < NUMBER && org.springframework.integration.redis.util.RedisTemplate<java.lang.String,> . keys ( this . java.lang.String + STRING + java.lang.String ) . size ( ) > NUMBER ) { java.lang.Thread . void ( NUMBER ) ; } assertTrue ( java.lang.String + STRING , int < NUMBER ) ; }  <METHOD_END>
